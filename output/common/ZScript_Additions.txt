		


 /@@@@@@@@  /@@@@@@                      /@@             /@@                        /@@ /@@   /@@
|_____ @@  /@@__  @@                    |__/            | @@                      /@@@@| @@  | @@
     /@@/ | @@  \__/  /@@@@@@@  /@@@@@@  /@@  /@@@@@@  /@@@@@@         /@@    /@@|_  @@| @@  | @@
    /@@/  |  @@@@@@  /@@_____/ /@@__  @@| @@ /@@__  @@|_  @@_/        |  @@  /@@/  | @@| @@@@@@@@
   /@@/    \____  @@| @@      | @@  \__/| @@| @@  \ @@  | @@           \  @@/@@/   | @@|_____  @@
  /@@/     /@@  \ @@| @@      | @@      | @@| @@  | @@  | @@ /@@        \  @@@/    | @@      | @@
 /@@@@@@@@|  @@@@@@/|  @@@@@@@| @@      | @@| @@@@@@@/  |  @@@@/         \  @/    /@@@@@@    | @@
|________/ \______/  \_______/|__/      |__/| @@____/    \___/            \_/    |______/    |__/
                                            | @@                                                 
                                            | @@                                                 
                                            |__/                                                 


The following documents the changes, and expansions to the ZScript language in ZQuest/ZC 
	versions 2.54, and 2.55. 
	
Document for: 2.55, Alpha 78
Document Revision: 20th July, 2020


 __           _   _                 
/ _\ ___  ___| |_(_) ___  _ __  ___ 
\ \ / _ \/ __| __| |/ _ \| '_ \/ __|
_\ \  __/ (__| |_| | (_) | | | \__ \
\__/\___|\___|\__|_|\___/|_| |_|___/
                                    
1. Syntax
2. Namespaces
3. Global Pointers
4. Datatypes
5. Typedef
6. Custom Datatypes & Enum
7. Arrays
8. Strings
9. New Features
10. Bugfixes
11. Script Types
12. Compiler
13. New Instructions
14. System and Script Timing and Execution Order

////////////////////////////////////////////////////
/// ZSCRIPT PARSER AND LEXER ///////////////////////
////////////////////////////////////////////////////

  _________             __                 
 /   _____/__.__. _____/  |______  ___  ___
 \_____  <   |  |/    \   __\__  \ \  \/  /
 /        \___  |   |  \  |  / __ \_>    < 
/_______  / ____|___|  /__| (____  /__/\_ \
        \/\/         \/          \/      \/

									// Syntax

////////////
// Tokens //
////////////

The ZScript parser supports the following standard and alternative tokens:

//Operational
+		:	Addition
-		: 	Subtraction
*		:	Multiplication
/		:	Division
++		: 	Increment (Pre, or Post)
--		: 	Decrement (Pre, or Post)

//Assignment
=		: 	Assign
:=		: 	Assign (alternative)
+=		: 	Add-Assign
-=		: 	Subtract-Assign
*=		: 	Multiply-Assign
/=		:	Divide-Assign

//Relational
<		:	Less-Than
>		:	Greater-Than
<=		:	Less-Than-or-Equal
>=		:	More-Than-or-Equal
==		: 	Equal
!=		:	Not-Equal
equals		: 	Equivalent to 	==
not_equal 	:	Equivalent to 	!=
~~		:	Approximately Equal
	
	
Approximately Equal
	Compares if two values are apprxiately equal within aset margin of error.
	The default margin is 0.0100
	You can set a custom margin with:
	#option APPROX_EQUAL_MARGIN <float>
	

//Logical
!		: 	Not
||		:	Logical OR
&&		:	Logical AND
^^		:	Logical XOR
and 		: 	Equivalent to 	&&
xor		: 	Equivalent to 	^^
or 		: 	Equivalent to 	||
not 		: 	Equivalent to 	!
not_eq 		:	Equivalent to 	!=
appx_eq 	:	Equivalent to 	~~
appx_equal 	:	Equivalent to 	~~

//Resolution
.		:	Script Name Scope Resolution
::		:	Namespace Scope Resolution
..		:	Namespace Scope Resolution (alt)

//Bitwise
&		: 	Bitwise AND
~		: 	Bitwise NOT
|		: 	Bitwise OR
^		: 	Bitwise XOR
|=		:	Bitwise OR-Assign
&=		:	Bitwise AND-Assign
^=		:	Bitwise XOR-Assign
bitand 		: 	Equivalent to 	&
bitor 		: 	Equivalent to 	|
bitxor 		: 	Equivalent to 	^
compl		: 	Equivalent to	~
bitnot		: 	Equivalent to	~
or_eq 		: 	Equivalent to 	|=
or_equal 	: 	Equivalent to 	|=
xor_eq 		: 	Equivalent to 	^=
xor_equal 	: 	Equivalent to 	^=
and_eq 		: 	Equivalent to 	&=
and_equal 	: 	Equivalent to 	&=
~=		:	Equivalent to &= ~
bitnot_eq	:	Equivalent to &= ~
bitnot_equal	:	Equivalent to &= ~

Notes: Xor abd Logical Xor alternative Tokens
	C lacks logical xor (^^), and thus the alternate token 
	for bitwise xor (^) is 'xor', HOWEVER, all other bitwise 
	alternative tokens are prefixed with 'bit:
		e.g., 'bitand', 'bitor'
		...but the logical operator alternative tokens 
	for logical AND and logical OR (&&, ||) have no prefix:
		i.e. 'and', 'or'.
	Thus, for the sake of **linguistic uniformity**, I changed
	our alternative tokens for bitwise and logical xor.
	
	Now, logical xor (^^) uses 'xor' as an alternative token, and
	bitwise xor (^) uses 'bitxor'.
	
	WHile this differs from C, I feel that this change makes
	the alternative tokens more uniform, and easier to remember.
		-ZoriaRPG ( 28th October, 2019 )
	
	
______                                                                  
 \      \ _____    _____   ____   _________________    ____  ____   ______
 /   |   \\__  \  /     \_/ __ \ /  ___/\____ \__  \ _/ ___\/ __ \ /  ___/
/    |    \/ __ \|  Y Y  \  ___/ \___ \ |  |_> > __ \\  \__\  ___/ \___ \ 
\____|__  (____  /__|_|  /\___  >____  >|   __(____  /\___  >___  >____  >
        \/     \/      \/     \/     \/ |__|       \/     \/    \/     \/ 

									// Namespaces
	
///////////////
// Namespace //
///////////////

ZScript now supports C-style namespaces.

Declaration examples:

namespace foo
{
	int x(){return 16;}
}

namespace bar
{
	int y(){return 32;}
	namespace foobar
	{
		int z(){ return 64;}
	}
}

namespace doh
{
	int xyz(){return 128;}
}

Access examples:

foo::x();
bar::y();
bar::foobar::z();


/////////////////////
// Using Namespace //
/////////////////////

You may invoke the 'using' token to bring the contents of a namespaces
into the current scope, thus ignoring the requirement for scope-resolution
(::) until the end of that scope.

You may also invoke 'using' as 'always using' to make that namespace global; this cannot be undone.

The following scopes are valid:

file
namespace
script
function

Using the above namespaces as examples:
	[example--

	//buffer
	always using namespace doh;
	//now in scope in all files, functions, and scripts
	//never falls out of scope
	//cannot be undone

	///file 1
	using namespace foo;

	//we can now ignore scope resolution for namespace foo
	x(); //now equivalent to foo::x();
	//end of file; namespace falls out of scope.

	//file 2
	using namespace bar::foobar;
	z(); //now equivalent to bar:foobar::z();
	//end of file; namespace falls out of scope.

	//function
	void main()
	{
		using namespace bar;
		y();
	} //namespace falls out of scope

	ffc script f
	{
		using namespace foo; //whole script
		void run()
		{
			using namespace bar; //only in run()
			int v = x();
			int w = y();
		}
		void n()
		{
			int r = y(); //illegal
		}
	}
	
	--end example]
	
Ambigious identifier access is an error that can occur with 'using'.
	[example--
	void foo(){}
	namespace bar
	{
		void foo(){}
	}
	
	void example()
	{
		using namespace bar;
		foo(); //Illegal; which 'foo()' are you trying to call?
	}
	--end example]
	
In this case, you can select which identifier to reference using scope resolution.
	[example--
	void example2()
	{
		using namespace bar;
		bar::foo(); //Calls 'foo()' within namespace 'bar'
		::foo(); //Calls 'foo()' that is not in a namespace
	}
	--end example]
Another example:
	[example--
	namespace bar
	{
		void foo(){}
	}
	namespace foo
	{
		using namespace bar;
		void foo(){}
		void example3()
		{
			foo(); //This is LEGAL.
		}
	}
	--end example]
	In this example, 'foo::foo()' will be called. 'using' namespaces only apply if
	there is no local match. In this case, since 'example3()' is in 'namespace foo',
	functions also in 'namespace foo' are considered local, and prioritiezed over 'using'.
	

  ________.__        ___.          .__    __________      .__        __                       
 /  _____/|  |   ____\_ |__ _____  |  |   \______   \____ |__| _____/  |_  ___________  ______
/   \  ___|  |  /  _ \| __ \\__  \ |  |    |     ___/  _ \|  |/    \   __\/ __ \_  __ \/  ___/
\    \_\  \  |_(  <_> ) \_\ \/ __ \|  |__  |    |  (  <_> )  |   |  \  | \  ___/|  | \/\___ \ 
 \______  /____/\____/|___  (____  /____/  |____|   \____/|__|___|  /__|  \___  >__|  /____  >
        \/                \/     \/                               \/          \/           \/ 

									// Global Pointers
//////////////////
// New Pointers //
//////////////////

	Hero->
	Player->
	
		These are synonymous with the old Link-> pointer, which is now deprecated but retained
		for compatibility purposes. 
	
	Graphics->
		Used for graphical functions.

	Audio->
		Used for sound and music functions.

	Input->
		Used to read and write buttons, and keyboard keys; as well as control states.

	Text->
		Used to get information on fonts, or to display text.

	FileSystem->
		Used to get information on the user filesystem, such as fileexists(), pathexists().
	
	Module->
		Use to read values or strings used by the current module.


________          __          __                                
\______ \ _____ _/  |______ _/  |_ ___.__.______   ____   ______
 |    |  \\__  \\   __\__  \\   __<   |  |\____ \_/ __ \ /  ___/
 |    `   \/ __ \|  |  / __ \|  |  \___  ||  |_> >  ___/ \___ \ 
/_______  (____  /__| (____  /__|  / ____||   __/ \___  >____  >
        \/     \/          \/      \/     |__|        \/     \/ 

									// Datatypes

///////////////////////
/// Basic Datatypes ///
///////////////////////
The following are the current, supported BASIC datatypes in ZScript:

TYPE		LEGAL RANGE
float 		-214748.3648, 214748.3647
int		-214748, 214748
	The basic numeral datatype. Both float and int are identical.
	The different tokens exist purely for local semantics and both 
		resolve to the same type, including for the purpose of
		matching function signatures.
	The legal range depends on a compiler flag. Older versions of ZScript had
		a maximum legal range of -214747.9999, 214747.9999.
	The current version of the ZScript spec expands this to -214748.3648, 214748.3647.
	
bool	false, true
	A general boolean datatype. Internally, true is '1' and false is 0..
	Older versions of ZScript used 0.001 as 'true. The user can
		use this old value set with a compiler flag, should the user
		require it for older scripts.
	When typecasting to bool, any value that is non-zero will
		evaluate as 'true', and values of EXACTLY zero will evaluate as 'false'.
		
char32		-214748, 214748
	Similar to the C type 'char', but 32 bits wide.
	A datatype specifically for individual characters, or for strings.
	String literals are typed as char32.
	This datatype can be used to narrow function signature matching for use of
		SINGLECHAR or STRING as function inputs.
	When doing signature matches, a SINGLECHAR or a STRING LITERAL will
		match FIRST to char32.
		
		Thus:
			void foo(char32 a)
			{
				TraceS(a);
			}
			void foo(int a)
			{
				Trace(a);
			}
			
			foo("str\n"); 	//Will call: foo(char32)
			foo(16);	//Will call: foo(int);

untyped : A special datatype that can be cast to and from any other type.
	This has no distinct type of its own.
	
	Example:
		untyped ptrs[4];
		ffc f = Screen->LoadFFC(2);
		npc n = Screen->CreateNPC(16);
		lweapon l = Screen->CreateLWeapon(LW_SCRIPT);
		bitmap bitty = Game->CreateBitmap(160,240);
		
		ptrs[0] = f;
		ptrs[1] = n;
		ptrs[2] = l;
		ptrs[3] = bitty;
		
		//These now contain the raw literal value of the pointers to those objects.
		
		bool a = true;
		untyped b = a; //b == 1
		int c = b; //c == 1


///////////////////////
// Complex Datatypes //
///////////////////////

	ffc:
		Used to create a pointer to one of the 32 freeform combo objects on the current
		screen, and to access its members. You cannot create ffcs.
		The ffc datatype is the 'this' pointer for ffc scripts.
		
	npc: 
		Used to create a pointer to an npc object. 
		You may either load a current (valid) npc on the current screen to the pointer, or create
		a new npc on the screen using this pointer.
		The maximum number of npc objects is defined in std.zh, but you may have multiple pointers
		directed at a single object in memory.
		Use this to access npc varibles, arrays, and functions. 
		The npc datatype is the 'this' pointer for npc scripts.
		
	eweapon:
	lweapon:
		Used to create a pointer to a weapon object. 
		Use eweapon for enemy weapons, and lweapon for player weapons.
		You may either load a current (valid) weapon on the current screen to the pointer, or create
		a new weapon on the screen using this pointer.
		The maximum number of weapon objects (per type) is defined in std.zh, but you may have multiple pointers
		directed at a single object in memory.
		Use this to access lweapon and eweaopon varibles, arrays, and functions. 
		The eweapon datatype is the 'this' pointer for eweapon scripts.
		The lweapon datatype is the 'this' pointer for lweapon scripts.
		Note that while eweapon and lweapon share most members, that some members are unique
		to one or the other, and that these script types are not 1:1 interchangeable.
		
	itemsprite: 
		Used to create a pointer to an itemsprite object. 
		You may either load a current (valid) itemsprite on the current screen to the pointer, or create
		a new itemsprite on the screen using this pointer.
		The maximum number of itemsprite objects is defined in std.zh, but you may have multiple pointers
		directed at a single object in memory.
		Use this to access itemsprite varibles, arrays, and functions.
		NOTE: In previous versions, this type was simply called "item".
	
	itemdata:
		Used to access the Item Editor values.
		You may load item IDs 0 to 255 to a pointer, and edit the values in the Item Editor
		for that item, or read its editor values for other use.
		The itemdata datatype is the 'this' pointer for itemdata (formerly item) scripts.
	
	bitmap:
		Used to create user bitmaps, similar to the old 2.50 Render Target bitmaps,
		but with custom sizing.
		
		Bitmap objects have their own drawing functions, and you may save/load them to/from
		files by script.
		
		There are a maximum of 250 user bitmaps at any one time.
	
	npcdata: 
		Used to access the Enemy/NPC Editor values.
		You may load NPC IDs 0 to 255 to a pointer, and edit the values in the Enemy Editor
		for that npc, or read its editor values for other use.

	combodata:
		Used to access the Combo Editor values.
		You may load Combo IDs 0 to 65279 to a pointer, and edit the values in the Combo Editor
		for that combo, or read its editor values for other use.
		The combodata datatype is the 'this' pointer for combodata (T/B/A) scripts.

	spritedata:
		Used to access the Weapon Sprite Editor values.
		You may load Combo IDs 0 to 255 to a pointer, and edit the values in the Weapon Sprite 
		Editor for that sprite, or read its editor values for other use.

	mapdata: 
		Used to access all data contained on MAPS (mapscreens).
		You may load a mapscreen by referencing the map, and the screen; or load
		tempscreen or scrolling screen layers to a pointer, and edit the values for that screen;
		or read its values for other use.

	dmapdata : 
		Used to access all all DMap Editor data.
		You may load a DMap IDs 0 to 511 to a pointer, and edit the values for that DMap;
		or read its editor values for other use.
		The dmapdata datatype is the 'this' pointer for dmapdata scripts.

	messagedata :
		Used to access all String Editor data.
		You may load a Message String IDs 1 to 65535 to a pointer, and edit the values for
		that message string; or read its editor values for other use.

	shopdata :
		Used to access all Item Shop Editor and Info Shop Editor data.
		You may load a Shop Type IDs 0 to 255, or Info Shop IDs 0 to 255, to a pointer, 
		and edit the values for that shop; or read its editor values for other use.
		
	dropsetdata :
		Used to access all Item Dropset Editor data.
		You may load a Item Dropset Type IDs 0 to 255, to a pointer, and edit the values for 
		the dropset; or read its editor values for other use.
		
	file :
		Object type for accessing files on the system. All files accessed must exist in "[zc root]/Files/[questname]/".
		These files can contain either text, or raw binary number data, based on which functions you use.
	
	//Planned/Incomplete
	warpringdata : t/b/a
		(Planned) Access to all Warpring Editor data.
	doorsetdata : t/b/a
		(Planned) Access to all Doorset Editor data
	misccolorsdata : t/b/a
		(Planned) Access to all Misc Colours dialogue data.
	rgbdata : t/b/a
		(Planned) DATATYPE for colour triplets as red,green,blue in one integer value.
		Because ZScript will interpret the value as 'float' inside the script, this datatype
		allows operating on a value as a true integer.
	palette : t/b/a
		(Planned) OBJECT TYPE, for loading and using USER PALETTES.
		This is similar to how user bitmaps work, and may also include a save/load format similar
		to ZPL, so that palettes created by script can be saved, then imported into other quests.
	zcmididata : t/b/a
		(Planned) OBJECT TYPE for working with MIDIs, both in-quest, and as external files.
	palcycledata : t/b/a
		(Planned) Access to all Palette Cycle data.
	gamedata : t/b/a
		(Planned) Access to all global game data (game->, in source)
	cheatsdata : t/b/a
		(Planned) Access to cheat code information.
	subscreendata: t/b/a
	

///////////////////////
/// Type Specifiers ///
///////////////////////

const TYPE

If you declare a type constant, one of two things occurs:
	If the ASSIGNED VALUE is also constant at compile time, then the value of the constant is converted to
	a literal during compilation.
	
	e.g.
	const int A = 5; 
	const int B = A; //A is constant at compile time
	int arr[B]; //B is sized to 5 during compilation.
	
	Such a declaration uses no stack space/registers.
	
If the type is NOT constant at compile time, the declaration is treated as a normal variable/array of its type,
	however, its value cannot be modified during runtime.
	
	e.g.
	const int hpcap = Link->MaxHP; //not constant at compile time, but the value of hpcap
		is read-only.
	const char32[]="A String"; //not constant at compile time (true const string isn't available, nor is const array).
		You cannot modify this during runtime.
	void foo(const bool a, const int b)
	{
		a = false; //illegal to write to a
		b = 64; //cannot write to b
	}
	
	This can be useful if you wish to pass params without the risk of code modifying them, especially
	when passing a pointer by reference.

This type specifier can be applied to ALL datatypes, including enum-specified types.


___________                        .___      _____ 
\__    ___/__.__.______   ____   __| _/_____/ ____\
  |    | <   |  |\____ \_/ __ \ / __ |/ __ \   __\ 
  |    |  \___  ||  |_> >  ___// /_/ \  ___/|  |   
  |____|  / ____||   __/ \___  >____ |\___  >__|   
          \/     |__|        \/     \/    \/       
	  
									// Typedef

/////////////
// Typedef //
/////////////

	You can now define your own types using typedef using normal C syntax:

	typedef old_type new_type;

	[example--
		typedef ffc object; //Allows you to declare object vars that are typed to ffc. 		

		typedef const int DEFINE;
		//Allows you to use the token DEFINE to declare constant ints. 
		
	--end example]
	
	
////////////////////
// Script Typedef //
////////////////////

	 You may also typedef script tokens, creating your own types that resolve into existing script types.

	e.g. script typedef hero villain;
	
	You may now declare the script type 'villain script', that resolves into the normal 'hero script' type.



_________                 __                   ________          __          __                                
\_   ___ \ __ __  _______/  |_  ____   _____   \______ \ _____ _/  |______ _/  |_ ___.__.______   ____   ______
/    \  \/|  |  \/  ___/\   __\/  _ \ /     \   |    |  \\__  \\   __\__  \\   __<   |  |\____ \_/ __ \ /  ___/
\     \___|  |  /\___ \  |  | (  <_> )  Y Y  \  |    `   \/ __ \|  |  / __ \|  |  \___  ||  |_> >  ___/ \___ \ 
 \______  /____//____  > |__|  \____/|__|_|  / /_______  (____  /__| (____  /__|  / ____||   __/ \___  >____  >
        \/           \/                    \/          \/     \/          \/      \/     |__|        \/     \/ 

									// Custom Datatypes	
									// Enum
//////////////////////
// Enumerated Lists //
//////////////////////

You can now define enumerated lists of constant values using the
standard C-style syntax of:

	enum { A, B, C, D = 10, E, F, G = 100, H, I = B };

	In this declaration, A == 0, B == 1, C == 2, D == 10, 
		E == 11, F == 12, G == 100, H == 101, and I == 1
		
		
You can also define a C style enumerated list with an identifier. 
This act defines a pseudo-datatype, with assignable values limited to
the values in the enumerated list.

	enum actiontype { none, walk, attack };
	
	Now, you can declare 'actiontype' as a datatype.
	
	actiontype act;
	
	If you wish to assign a value to it, the value must be validated
	from the enumeration:
		act = walk; //Legal
		act = 7; //Error
		
	You can explicit cast values to these types to circumnavigate the
	restrictions.
		act = <actiontype>7; //this is legal. 
		
	[example--
	
		void foo(actiontype action)
		{
			actiontype newaction = action; 
		}
	
	--end example]
	You can only pass legal values in the actiontype enum to the parameter of this function.
	
	You can further declare functions to return an enum type:
	
	[example--
	
		actiontype walking()
		{
			return walk;
		}
		
	--end example]
	
	
	You can declare enums inside namespaces, and scripts, and then dereference them as any
	other namespace or script scoped component.
	
	[example--
	
		namespace myns
		{
			enum sizeflag { szNone, szSmall, szMedium, szLarge = 4 };
			enum othertype { otA, otB, otC, otD, otE, otF, otG, otH, otI, otJ };
		};
		
		myns::othertype getFlag(myns::sizeflag sz, actiontype act)
		{
			switch(act)
			{
				case none:				
				case walk:
				{
					switch(sz)
					{
						case myns::szNone: return myns::otA;  // Need to dereference the constant, as it 
						case myns::szSmall: return myns::otC; // is part of an enum, inside a namespace.
						case myns::szMedium: return myns::otD;
						case myns::szLarge: return myns::otI;
					}
				}
				case attack:
				{
					switch(sz)
					{
						case myns::szNone: return myns::otA;
						case myns::szSmall: return myns::otE;
						case myns::szMedium: return myns::otG;
						case myns::szLarge: return myns::otH;
					}
				}
				default: return myns::otA;	
			}
		}
	
	--end example]
	
	Because these count as specific types, like int, itemdata, and npc, you can use them as overloads 
	in function signatures, and as long as you always pass the enum constants, you will guarantee a match.
	
	[example--
	
		int myoverloads(int a, npc b, eweapon c);
		myns::othertype myoverloads(actiontype a, npc b, eweapon c);
		
		//If you call:
		
		othertype(walk, n, e);
			//This will use 'myns::othertype myoverloads(actiontype a, npc b, eweapon c)'
			
		//If you instead call:
		
		othertype(1, n, e);
			//This will use 'myoverloads(int a, npc b, eweapon c)'
		
	--end example]
	
	Thus, enum types allow you very precise control over function overloads.
	
	Last, you can use script-scoping, instead of namespace-scoping, if you wish:
	
	[example--
	
		untyped script fakestruct
		{
			enum fktype { seNone, seA, seB, seC };
			enum fkflag { sfNone, sfA, sfB, sfC = 4 }; 
		}
		
		int getfakestructflag(fakestruct.fkflag flag)
		{
			int r = <int>flag; //cast to int
			return r;
		}
		
		//Convert a flag to its type ID
		fakestruct.fktype flagtype(fakestruct.fkflag flag)
		{
			switch(flag)
			{
				case fakestruct.sfNone: return fakestruct.seNone; 
				case fakestruct.sfA: return fakestruct.seA; 
				case fakestruct.sfB: return fakestruct.seB; 
				case fakestruct.sfC: return fakestruct.seC; 
			}
		}
	
	--end example]
	
	

   _____                                    
  /  _  \___________________  ___.__. ______
 /  /_\  \_  __ \_  __ \__  \<   |  |/  ___/
/    |    \  | \/|  | \// __ \\___  |\___ \ 
\____|__  /__|   |__|  (____  / ____/____  >
        \/                  \/\/         \/ 

									// Arrays

////////////////////////////////////
// Array Declaration Improvements //
////////////////////////////////////

	Arrays now support being declared with any constant expression.:

	[example--

		int arr[10*4]; 
		//This is now the same as int arr[40];
		
	--end example]

	Nesting array calls should now work properly. (e.g. arrA[ arrB[ arrC[ arrD[4] ] ] ] )

	Further, you may now use constants in array declarations:

	[example--

		const int sARR_MAX = 20;
		int arr[sARR_MAX];
		
	--end example]


/////////////////////	
// Datatype Arrays //
/////////////////////

It is legal to create an array of any legal datatype, including complex datatypes.
You may specify an explicit array size, or use an array initialiser to set its size implicitely.

Formats
TYPE IDENTIFIER[SIZE];
TYPE IDENTIFIER[SIZE] = { INITILISERS };

	SIZE may be any constant expression.

TYPE IDENTIFIER[] = { INITIALISERS };
TYPE IDENTIFIER[A,B]; //Size is A*B
TYPE IDENTIFIER[A,B] = { INITILISERS }; //Size is A*B

char32 arrays may be initialised with a string:

char32 IDENTIFIER[SIZE] = "string"; //Explicit size.
char32 IDENTIFIER[] = "string"; //Sized implicitely to number of characters +1 for NULL termination.

	Explicitely-sized string arrays must be sized to at least the length + 1 to include a NULL terminator.


  _________ __         .__                      
 /   _____//  |________|__| ____    ____  ______
 \_____  \\   __\_  __ \  |/    \  / ___\/  ___/
 /        \|  |  |  | \/  |   |  \/ /_/  >___ \ 
/_______  /|__|  |__|  |__|___|  /\___  /____  >
        \/                     \//_____/     \/ 

									// Strings

/////////////////////
// String Literals //
/////////////////////

	You may now use C-style string literals at any non-global scope.

	[example--

		TraceS("Trace this string.");
		
	--end example]


	You may use standard C-style escape characters in string literals:

	- \a\b\f\n\r\t\v for the standard values,
	- \" for quotes
	- You can escape a newline to make it not appear in the string

	Additionally, adjacent strings are merged by the compiler.

	[example--

		TraceS("This is a string"
			" on two lines");
		
	--end example]
	

///////////////////////////////////////
// Single Character Escape Sequences //
///////////////////////////////////////

You may now use escape sequences in a SINGLECHAR type:
	char32 tab = '\t';
	
	Valid Escape Characters
	\a     		Alert (Beep, Bell) (added in C89)[1]
	\b    		Backspace
	\f     		Formfeed Page Break
	\n     		Newline (Line Feed); see notes below
	\r     		Carriage Return
	\t     		Horizontal Tab
	\v     		Vertical Tab
	\\     		Backslash
	\'     		Single quotation mark
	\"     		Double quotation mark
	\?     		Question mark (used to avoid trigraphs) 
	\x0 to \xFF   	Normal ANSI characters, as hex value. 
	

	
///////////////////////////////
/// Expanded Array Literals ///
///////////////////////////////

	Array Literals of the following form may be used in lots of places,
	not just array variable declarations.

	{0, 1, 2}
	(int[]){0, 1, 2}
	(int[3]){}
	(int[3]){4}

	[example--
	
		RunFFCScript(script_no, (int[8]){arg1, arg2, arg3});
		
	--end example]
	
	If no type is specified, the array will default to 'untyped'.


	

 _______                  ___________            __                               
 \      \   ______  _  __ \_   _____/___ _____ _/  |_ __ _________   ____   ______
 /   |   \_/ __ \ \/ \/ /  |    __)/ __ \\__  \\   __\  |  \_  __ \_/ __ \ /  ___/
/    |    \  ___/\     /   |     \\  ___/ / __ \|  | |  |  /|  | \/\  ___/ \___ \ 
\____|__  /\___  >\/\_/    \___  / \___  >____  /__| |____/ |__|    \___  >____  >
        \/     \/              \/      \/     \/                        \/     \/ 

									// New Features

/////////////////////////
// Ternary Expressions //
/////////////////////////

You may now use C-style ternary expressions:

	int x = Rand(6,8);
	int y = x > 7 ? 1 : 0;
	
	Assigns, and operations inside ternary blocks must be in parens:
		bool V = true;
		int b;
		int a = V ? ( b =  5 ) ? ( b = 4 );
		
		int c = V ? ( b -= 2 ) ? 0; 
		
		int y; int z; 
		int x = (y += 10) ? (z = 5) : (a -= 2);
		
	In all of these cases, parens are mandatory. 
	
	Further, compound ternary expressions should be placed in parens:
		int a = (V ? 1 : 0) ? 5 : 6
		
	The default, is to evaluate in a linear sequence.
			
	Thus, 
		bool ? int : int ? bool : int
	...would evaluate as: 
		bool ? int : (int ? bool : int)
	
	Using parens to define your order of operations and scope, is prudent. 


///////////////////////////
// Variable Declarations //
///////////////////////////

You can now declare, and initialise variables on one line, as in C.
	Format:
	TYPE (identifier | identifier ASSIGN NUMBER) comma [repeating] SEMICOLON
	Examples:
		int a, b, c = 9, h = 16, f = c+h;
		float n = 1.04, m = 6.03;
		
		These are equivalent to:
		int a; int b; int c = 9; int h = 16; int f = c+h;
		float n = 1.04; float m = 6.03;


///////////////////
// Explicit Cast //
///////////////////

You may now explicitly cast a value, using a type in angle braces.

	ffc f = Screen->LoadFFC(15);
	int x = <int>f;

	f = <ffc>2;


///////////////////////////
/// Arrow from Function ///
///////////////////////////

You may now use the arrow (->) operator on functions of datatypes/pointers, including
cases where you are not using the base function in an assign.
	Examples:
	int x = Screen->LoadNPCByUID(this->ParentUID)->X;
	int sfx = Game->LoadItemData(16)->UseSound;
	int ilvl = Game->LoadItemData(Screen->LoadLWeapon(1)->Parent)->Level;
	
	Previously, you were required to declare a variable and make an assign
		in multiple stages.#
		e.g., this: 
		int ilvl = Game->LoadItemData(Screen->LoadLWeapon(1)->Parent)->Level;
	
		...used to require:
		
		lweapon l = Screen->LoadLWeapon(1);
		itemdata id = Game->LoadItemData(l->Parent);
		int lvl = id->Level;
		
		You can now skip these useless declarations, unless you have a 
		reason or desire to cache the data in a variable. This saves stack space, 
		and, in some circumstances, may improve performance; however repeated
		use of the same variables may benefit from caching the values in a register.
		
		
////////////////////
// Comment Blocks //
////////////////////

	The ZScript language now supports C-Style comment blocks using the traditional syntax of:

	[example--

		/* 
			COMMENT BLOCK
			
		*/
		
	--end example]


/////////////////////
// Global Pointers //
/////////////////////

	You may now declare any datatype, including arrays for any datatype at a global scope.
	*	Data saved to these may become invalid and require manual cleansing by the user!
	*	Only the value of a pointer is saved, not the struct data associated with that pointer.


////////////
// Unless //
////////////

	This statement runs the code block attached to it if its statement would evaluate false
	in an if statement.
	Aside from the obvious semantical enhancement over 'if(!expression)', the advantage of 
	this, is that 'unless(expression)' is faster (in ASM instructions) than 'if(!expression)'.

	Example: 
		int x = 6; int y;
		unless(x==6)
		{
			y = 1;
		}
	
	In this example, the code block would never run, because x == 6. 
	This is the opposite of 'if', and supports 'else unless' and 'else'
	blocks following the unless statement.
	
	
////////////
// Repeat //
////////////

Repeats a command a given number of times.
The value passed to repeat(const int v) must be constant at compile time.

Example:
	const int N = 10;
	int x;
	repeat(N) { ++x; }
	
This is similar to a for loop, but it produces faster ZASM, because the number
of iterations is known at compile-time.


/////////////////////
// Until, do-until //
/////////////////////

	ZScript now supports the Pascal-style token 'until'. 
	This functions as an inverted 'while' statement.
	Aside from the obvious semantical enhancement over 'while(!expression)', the advantage of 
	this, is that 'until(expression)' is faster (in ASM instructions) than 'while(!expression)'.
	
	Examples:
	
		until(x > 7) { DoSomething(); }
		
		do
		{
			Something();
		} until ( x > 7 );



/////////////////
// Switch-Case //
/////////////////

	ZScript now supports C-style switch statements. Case values must be numeric literals,
	ranges, or constant expressions. Each case should end in a break instruction, or else
	fallthrough can be expected to occur. You may provide a default case.

	[example-- 

		const int SOME_CONST = 11;

		switch(var)
		{
			case 1:
			{
				DoSomething(); 
				break
			}
			case SOME_CONST:
			{
				DoSomethingElse();
				break:
			}
			case SOME_CONST+(10*2)
			{
				DoOther();
				break;
			}
			default:
			{
				DoDefault();
				break;
			}
		}

	--end example]
	
	
	 _    __      __              ____                       
	| |  / /___ _/ /_  _____     / __ \____ _____  ____ ____ 
	| | / / __ `/ / / / / _ \   / /_/ / __ `/ __ \/ __ `/ _ \
	| |/ / /_/ / / /_/ /  __/  / _, _/ /_/ / / / / /_/ /  __/
	|___/\__,_/_/\__,_/\___/  /_/ |_|\__,_/_/ /_/\__, /\___/ 
	                                            /____/       
						    
	You may use a VALUE RANGE in a case statement. 
	
	Value ranges take the form of one number, three dots and another number.
	
	The numbers in this range may have decimal places, and you may use constants
		as the upper and lower bounds of a range.
		
	If the switch value is >= [left range value] and is <= [right range value]
		then that case will execute.
		
	The left value of a range must be smaller than the right:
		1...3
		This is a range of values >= 1.0000 and <= 3.0000
		
		3...1
		This is invalid and will generate an error. 
		
	If these values are identical, it will generate a warning; a normal
		case should be used instead of a value range in such a case.
	
	[example-- 
	
		float a = 1.5;
		const float B = 1.0;
		const float C = 2.5;
		switch(a)
		{
			case B...2.4: DoFirst(); break;
			case C...3: DoSecond(); break;
		}
	--end example]

	As the value of 'a' at this time is 1.5000, it fallswithin the range of the
	first case (B...2.4) and DoFirst() will execute.
	
	  _________ __         .__                      
	 /   _____//  |________|__| ____    ____  ______
	 \_____  \\   __\_  __ \  |/    \  / ___\/  ___/
	 /        \|  |  |  | \/  |   |  \/ /_/  >___ \ 
	/_______  /|__|  |__|  |__|___|  /\___  /____  >
	        \/                     \//_____/     \/ 
	
	You may use switch-case on STRING LITERALS.
	Note: You may use EITHER string literals, OR numeric values, but NOT BOTH.
	
	[example--
		char32 tmp[] = "Test";
		switch(tmp)
		{
			case "foo":
				DoSomething();
				break;
			case "bar":
				DoSomethingElse();
				break;
			case "Test":
				DoThirdThing();
				break;
			default:
				DoDefaultThing();
		}
	--end example]
	
	This will match the string against each literal, looking for an identical string.
	By default, this matches case-sensitively; though if the option 'STRING_SWITCH_CASE_INSENSITIVE'
		is nonzero, it will match case-insensitively.
		
	String literal switches and numeric switches cannot be mixed.
	[example--
		switch(foo)
		{
			case 1:
				DoSomething();
				break;
			case "foo":
				DoSomethingElse();
				break;
		}
	--end example]
	This code will produce a compile error, and is not allowed.
	
///////////////////
/// Logical Xor ///
///////////////////

ZScript now supports logical xor operations using the following tokens:
	^^
	logicalxor
	
	[example--
		if ( a ^^ b ) return true;
		if ( c logicalxor d ) return true;
	--end example]
	
If you chain logical xor operations, they are handled in a linear sequence
for their order of operations.
	[example--
		if ( a ^^ b ^^ c ^^ d )
		becomes
		if ( ( a ^^ b ) ^^ c ) ^^ d ) )
	--end example]
	
	It is prudent therefore, to properly specify order of operations for this operation.


///////////////
// NOT Token //
///////////////

You may now use the Not (!) token on any datatype, as in C++.
Example:
	ffc f;
	if ( !f ) f = Screen->LoadFFC(3);
	
	bitmap b;
	if ( !b ) b = Game->CreateBitmap(16,16);
	else b->Create(0, 16, 16);
	
This allows checking if a pointer is initialised, easily. 


///////////////////
// Short Circuit //
///////////////////

Fixed short-circuiting. Logical AND and Logical OR now short-circuit as in C,
based on a compiler flag.

If short-circuiting is enabled, the following occurs:

	if ( a && b ) 
		//if 'a' is false, 'b' is skipped.
	if ( a || b )
		//if 'a' is true, 'b' is skipped. 


/////////////////////
// Constant Assert //
/////////////////////

You may now make constant assertions to create custom compile errors.

	[example--
		const int COMBO = 0;
		//
		CONST_ASSERT(COMBO > 0);
	--end example]
	This would cause the compile error:
		"Assert failed!"
	on the line of the assert.
	
You may also include a custom message to be printed with the error.

	[example--
		const int COMBO = 0;
		//
		CONST_ASSERT(COMBO > 0, "COMBO must be > 0!");
	--end example]
	This would cause the compile error:
		"Assert failed! COMBO must be > 0!"
	on the line of the assert.

This can be useful to prevent yourself from making mistakes, or for scripts you share
to ensure that others using your script don't make mistakes when setting constants.

/////////////////////////
// Conditional Include //
/////////////////////////

You may now conditionally include a file.

	[example--
	const bool USE_TANGO = true;
	
	#includeif(USE_TANGO, "tango.zh")
	--end example]
	
If the constant expression evaluates to true, the file will be imported.
Otherwise, it will be skipped.

//////////////////////
// Include Checking //
//////////////////////

You may now check if a file is included.

	[example--
	if(IS_INCLUDED("tango.zh"))
	{
		//Show a tango message
	}
	else Screen->Message(5);
	--end example]

This is considered a constant expression.


__________              _____.__                      
\______   \__ __  _____/ ____\__|__  ___ ____   ______
 |    |  _/  |  \/ ___\   __\|  \  \/  // __ \ /  ___/
 |    |   \  |  / /_/  >  |  |  |>    <\  ___/ \___ \ 
 |______  /____/\___  /|__|  |__/__/\_ \\___  >____  >
        \/     /_____/                \/    \/     \/ 

									// Bugfixes
	
///////////////////////
// Constant Division //
///////////////////////

Fixed a bug where division of a constant would result in truncation that did not occur in 2.50.x
Fixed issues with division by an integer, where values would be truncated.
Added #option TRUNCATE_DIVISION_BY_LITERAL_BUG as a compiler flag to enable the old, 2.50.x behaviour
Fixed scope resolution for identifiers and variables when used across
	imported files.
	Example:

		//buffer

		import "bar.zs"
		void foo()
		{
			scrid.bar();
		}
		////////////////////end of buffer
		
		//bar.zs
		
		ffc script scrid
		{
			void run(){}
			voud bar(){ Trace(1); }
		}
	
	This worked in 2.50.x, but broke at some point in 2.55, and the
	correct behaviour has been restored. 
		
Script errors will now give line and column references prior to the
	error type.
		
	Old:
		Error S007: Variable X can't have type VOID.
			@ LINE 4 COLUMNS 1-11
		
	New: 
		LINE 4 @ COLUMNS 1-11 - ERROR S007: Variable X can't have type VOID.
Syntax errors have yet to be updated.
		
Fixed some issues where compiler errors improperly carried over. 

Fixed import directive pathing with backslashes:
	Importing in zscript with a path such as scripts\scriptfile.z used to work, in prior versions. 
	As of 2.55, it reads \ as an escape character, and parses the file path improperly. 
	This has now been corrected, so that you may use / or \ as a valid path token, however, / is the better option.


//////////////
// Waitdraw //
//////////////

The Waitdraw() instruction defers further execution of a script (pausing it) until 
	draws to the screen have been rendered for the present frame.
	
The following script types now support Waitdraw():
ffc, screendata, eweapon, itemsprite, itemdata.
You may disable Waitdraw support (for compatibility reasons) for ffc scripts, 
	and itemdata scripts in the ZScript Quest Settings Dialogue.
	
Waitdraw support for npc, and lweapon scripts remains t/b/a.



  _________            .__        __    ___________                            
 /   _____/ ___________|__|______/  |_  \__    ___/__.__.______   ____   ______
 \_____  \_/ ___\_  __ \  \____ \   __\   |    | <   |  |\____ \_/ __ \ /  ___/
 /        \  \___|  | \/  |  |_> >  |     |    |  \___  ||  |_> >  ___/ \___ \ 
/_______  /\___  >__|  |__|   __/|__|     |____|  / ____||   __/ \___  >____  >
        \/     \/         |__|                    \/     |__|        \/     \/ 

 									// Script Types

///////////////////
/// FFC Scripts ///
///////////////////

TOKEN(s):		ffc script
POINTER: 		ffc
InitD:			Yes, [8]
InitD Labels:		No
InitA:			Yes, [2]
Multiple Frames:	Yes
Waitdraw Support:	Yes, depends on QR

* FFC Scripts are the absolute, pure origin og ZScript. Originally called FFScript, and designed 
* to be attached to 'FreeForm Combos' in ZQuest 2.11, FFC scripts still serve this subtle, yet powerful
* purpose to this day.

* The 'this' pointer for ffc scripts is ffc (ri->ffcref).
* You can assign this script type to each of the 32 ffcs on every mapscreen via the menus
* 	Screen>>>Edit FFC>>Script (tab).
*
* In order to run its script, not only must you set the script ID, but the FFC MUST use a combo ID
*	greater than zero. Combo ID 0 cannot run scripts initially, although an already-running
* 	ffc script can write this->Data = 0without the script exiting,
*
* FFC scripts can run for multiple frames, and in addition to the eight standard D[] registers,
*	they have two A[] (address) registers, however the use of A registers is exclusive to ZASM
*	(assembly code) scripts, and there is no benefit to using them in the ZScript C++ style
*	language.
*
*	The purpose of these A registers is to allow ASM-level access to the D-registers of other FFC 
*		scripts running on the same screen.
* In past versions of ZQuest, FFC scripts did not have support for the Waitdraw instruction.
* As of 2.55, Alpha 26, FFCs can use Waitdraw() properly.
* A QR governs this capability: Legacy quests will disable FFC Waitdraw support on quest loading
* 	in ZC Player, and when you load the old quest into the ZQ Editor,
(	New quests created in 2.55 have Waitdraw() support enabled by default.
*	You may enable Waitdraw support in legacy quests by toggling the ZScript setting:'No FFC Waitdraw'.
*	When this setting is enabled, FFC scripts that call Waitdraw() behave as 2.11->2.53 FFC scripts 
* 		that call Waitdraw().



//////////////////////
/// Global Scripts ///
//////////////////////

TOKEN(s):		global script
POINTER: 		n/a
InitD:			No
InitD Labels:		No
InitA:			No
Multiple Frames:	Yes, based on slot.
Waitdraw Support:	Yes, based on slot.

* Global scripts run without context to a specific pointer or datatype.
* There are six, fixed slota; of which you may directly assign scripts
* to five. 
* 
* Slot assignment during compilation to the ~Init Slot (1) is automatic.
* 
* Global scripts do not have InitD args, and parameters listed within the 
* braces of the normal run(...) function are initialised to NULL (0).
* 
* Global scripts are executed automatically when their conditions are valid, 
* based on the script slot to which the user assigns them.

//////////////////////////
// Slot (1) : Game Init //
//////////////////////////

*	SLOT NAME: '~Init'
*
* 	This script runs FOR ONE FRAME, on the first play of a quest.
* 	It is used to initialise global arrays, and the user can create additional
* 	context for it by creating a script named 'global script Init'. 
* 	
* 	During post-compilation slot assignment, any global script with the
* 	EXACT IDENTIFIER 'Init' will be assigned to this slot.
* 
* 	Manual slot assignment to ~Init is possible for ASM script imports,
* 	but doing this may have unintended side-effects.
* 	
* 	Any instructions within the body of the run() function of the script
* 	will execute during game initialisation, but only if the player has not
* 	saved the game.

///////////////////////
// Slot (2) : Active //
///////////////////////

*	SLOT NAME: 'Active'
*
* 	This script can run for multiple frames, and runs during the normal action of the game.
* 	
* 	The typical purpose of this script slot is to tailor the game engine to your needs, and 
* 	the body of its run() function serves as the ZScript equivalent to a main() loop in C.
* 
* 	Generally, the body of this script is an infinite loop, ending in a Waitframe(), although
* 	it may consist of a conditional loop or series of loops, each with instructions to process
* 	during different stages of your game.
* 
* 	Normally, if the player is still playing the quest, then this script is running:
* 		It automatically terminates if you issue a Quit() instruction, if it runs out of scope, 
* 		or under one of the following conditions:
* 	
* 		The player HP falls below '1'. 
* 			Under this circumstance, the script runs for ONE additional frame to allow
* 			your scripts to restore the player HP.
* 			Failing to revive the player will exit this script, and the Hero Scrit Death Slot
* 				will run, followed by the Global Exit Slot (3).
* 				!!VERIFY TIMING
* 		The player triggers the F6 menu.
* 		Any script calls Game->Continue(), or Game->End().
* 
* 	The global active script can run for multiple frames, and supports the Waitdraw() command.

//////////////////////////
// Slot (3) : Game Exit //
//////////////////////////

*	SLOT NAME: 'onExit'
*
* 	This script runs FOR ONE FRAME, after the player dies, or otherwise after the 
* 	game action ends via calling the game over menu.
* 
* 	The purpose of this script slot is to modify global variables or array values prior to 
* 	writing the game save, such as the number of times the polayer has saved his adventure.

///////////////////////////////
// Slot (4) : Load from Save //
///////////////////////////////

*	SLOT NAME: 'onSaveLoad'
*
* 	This script runs FOR ONE FRAME, on every load of a quest from the file select 
* 	screen, AFTER the player has saved the game at least one time.
* 
* 	This script does not run when continuing a game with F6>>>Contunue from the game over
* 	menu, nor when continuing a game with the Game->Continue() ZScript command.
* 
* 	The purpose of this script slot is to reinitialise any user-created conditions, such as re-init
* 	of user bitmaps, re-priming global pointers, or otherwie ensuring that your global or internal
* 	values are correct before the game resumes from a file where values to these variables / pointers
* 	may now be stale, but were saved to the .sav file.

//////////////////////////
// Slot (5) Game Launch //
//////////////////////////

* 	SLOT NAME: 'onLaunch'
*
* 	This script slot runs for MULTIPLE FRAMES, on every load of a quest from the file select 
* 	screen, whether the quest has been previously played, or not. 
* 
* 	This script does not run when continuing a game with F6>>>Contunue from the game over
* 	menu, nor when continuing a game with the Game->Continue() ZScript command.
* 
*	It is similar to slots (1) and (4), and can take the place of either, unless you have timing-specific 
* 	issues that require two scripts to execute.
* 
* 	This script runs after global slot (1) and after Hero script slot (1) on a virgin save slot, 
* 	or directly after global slot (4) if the game has previously been saved.
* 
* 	The purpose of this script slot is to reinitialise any user-created conditions, such as re-init
* 	of user bitmaps, re-priming global pointers, or otherwise ensuring that your global or internal
* 	values are correct before the game resumes from a file where values to these variables / pointers
* 	may now be stale, but were saved to the .sav file.
*
*	This script will run until either you exit the game via a command such as 'Game->End()', or you exit the script.
*	Exiting the script without invoking a command such as 'Game->End()' will proceed to the opening wipe.

/////////////////////////////////////////
// Slot (6) :  Continue Game from Menu //
/////////////////////////////////////////

*	 SLOT NAME: 'onContGame'
*
*	 This script runs FOR ONE FRAME, when the user resumes/reloads an already-running
*	 game either via F6>>>Contunue, or Game->ShowContinueScreen(), from the game over menu, 
*	 or by continuing a game with the Game->Continue() and similar ZScript commands.
* 
*	 This script does not run when loading a game from the file select screen.
* 
*	 The purpose of this script slot is similar to that of slots (2), (4) and (5), but it may also 
*	 be useful in setting minor conditions, such as the player health/magic.
* 
*	 This script slot runs prior to the opening wipe.

/////////////////////
// Slot (7) : Menu //
/////////////////////

*	SLOT NAME: 'onF6Menu'
*
*	This script runs for multiple frames, whenever the player presses F6 or selects the system menu option
*	'Game>>End Game' to display the save screen menu, or runs the 'Game->ShowContinueScreen()' ZScript command,
*	(but not when the player dies; see Hero Slot (3) 'onDeath' for that application.)
*
*	If the compatibility rule 'Old (Instant) F6 Menu' in 'Quest->Rules->Backwards Compatibility' is enabled,
*	this script slot will never be executed.
*
*	The purpose of this script slot is to permit making a drop-in, scripted  replacement for the standard 
*	Continue/Save/Retry menu screen.
*
*	During the execution of this script, all script draws will occur above a static image of the screen as it was
*	before the script began. All engine action, save for this script, and input polling, will be suspended for the duration
*	of the script.
*
*	This script will run until either you exit the game via a command such as 'Game->End()', or you exit the script.
*	Exiting the script without invoking a command such as 'Game->End()' will then open the standard system F6 menu,
*	unless the quest rule 'Skip Continue Screen' in 'Quest->Rules->Other' is active. If the player does not chooses
*	to exit via the standard continue screen, or it is skipped via the aforementioned rule, gameplay will resume
*	exactly where it left off.

//////////////////////
// Slot (8) :  Save //
//////////////////////

*	 SLOT NAME: 'onSave'
*
*	 This script runs FOR ONE FRAME, when the game saves the save data.
*	 This occurs either from F6>>>Save (or GameOver>>>Save), when saving via a Save Point combo type,
*	 as well as from the ZScript commands 'Game->Save()', 'Game->SaveAndQuit()', and 'Game->SaveAndContinue()'.
*	 
*	 This runs AFTER the 'onExit' script, in any condition that would cause both to run.
*	 
*	 The main purpose of this script is to allow saving of custom script data that would NOT be saved to the
*	 save file; such as ZScript files, bitmap images, or SRAM.

   
////////////////////
/// Hero Scripts ///
////////////////////

TOKEN(s):		hero script, player script; link script (deprecated)
POINTER: 		Hero, Player, Link
InitD:			No
InitD Labels:		No
InitA:			No
Multiple Frames:	Yes, based on slot.
Waitdraw Support:	Yes, based on slot.

* You can now compile and assign scripts to the Hero.
* The 'this' pointer is identical to `Hero`, ex. `this->X` `this->Y` `this->HP`
* When you compile this script type, you can assign it to one of the following slots,
* 	which determines when it runs, and how often it runs.
* Hero scripts are executed automatically when their conditions are valid, 
* 	based on the script slot to which the user assigns them.

/////////////////////
// Slot (1) : Init //
/////////////////////

*	SLOT NAME: 'Init'
*
* 	This script runs FOR ONE FRAME at the start whenever the player sprite is initialised, 
*	both at the start of a game, and via F6>>>Continue (or Game->Continue()).
*	
*	It allows you to set up initial values for the player, BEFORE the opening wipe, such as his 
*	Invisibility state, or his screen position.
* 	You can give the player  equipment, and other effects at this time.
*
*	These effects take place BEFORE the engine writes to Screen->EntryX, and Screen->EntryY, 
*	so if you give the player sprite custom starting coordinates by script, reading those values 
*	from the Screen pointer, should give you accurate data.
*

///////////////////////
// Slot (2) : Active //
///////////////////////

*	SLOT NAME: 'Active'
*
*	This script slot runs after (1), and also after the global script (2; active).
*
* 	This script can run for multiple frames, and runs during the normal action of the game.
* 	
* 	The typical purpose of this script slot is to control the player sprite in ways that 
*	extend beyond the normal internal engine mechanics, such as scaling the sprite with the
* 	Z-Axis of the player, or using scripted tiles and animations for diagonal walking.
*
* 	Generally, the body of this script is an infinite loop, ending in a Waitframe(), although
* 	it may consist of a conditional loop or series of loops, each with instructions to process
* 	during different stages of your game.

*	This script can run for multiple frames, until either it runs out of, scope, 
*	you call Quit() inside the script body, or the player presses F6 to open the standard
*	SAVE/CONTINUE/RETRY menu.
*
* 	You may use Waitdraw() in this script type. 
*	
*	If Hero dies, this script halts, and hero script (3), 'onDeath' runs.
*	If Hero wins the game, this script halts, and hero script (4), 'onWin' runs.
*

//////////////////////
// Slot (3) : Death //
//////////////////////

*	SLOT NAME: 'onDeath'
*
*	This script runs when Hero DIES. 
*	It runs BEFORE the GLOBAL EXIT script, and after Hero is DEAD, with no chance of revival.
*		^ If you need to revive the player, such as with a Faerie in a Bottle, use the
*		^ Hero Active script slot for that effect.
*	The script will run before the engine's death animation, unless the quest rule
*	'Hero OnDeath script runs AFTER engine death animation' under 'ZScript->Quest Script Settings' is selected, in which case
*	it will run immediately following this animation.
*
*	This script can run for multiple frames, and is intended to permit you to construct your
*	own Game Over sequences.
*
*	During the execution of this script, all script draws will occur above a static image of the screen as it was
*	before the script began. All engine action, save for this script, and input polling, will be suspended for the duration
*	of the script.
*
*	This script will run until either you exit the game via a command such as 'Game->End()', or you exit the script.
*	Exiting the script without invoking a command such as 'Game->End()' will continue the player's death where it left off.
*	If the script is set to run prior to the engine death animation, exiting via a command such as 'Game->End()' will
*	skip the engine's death animation.

///////////////////////
// Slot (4) : Ending //
///////////////////////

*	SLOT NAME: 'onWin'
*
*	This script runs if the player WINS THE GAME (e.g. via Combo Flag 15).
*	It can run for more than one frame, and it is intended to permit you to make your own
*	Game Ending scenes, or credits scroll.
*
*	You can disable the internal credits scroll, or you can permit that to run normally,
*	after your own credits sequence via the command Game->SkipCredits.


////////////////////
/// DMap Scripts ///
////////////////////
 
TOKEN(s):		dmapdata script
POINTER: 		dmapdata
InitD:			Yes, [8] each (active, scripted subscreen)
InitD Labels:		Yes, [8] each (active, scripted subscreen)
InitA:			No
Multiple Frames:	Yes
Waitdraw Support:	Yes

* You can now compile and assign scripts to DMaps.
* The 'this' pointer for dmapdata scripts is dmapdata (ri->dmapsref).
*
* This script can run for multiple frames, and it runs after the GLOBAL ACTIVE script.
* You may use Waitdraw() in this script type. 
* 
* There are three script slots in the DMap Editor:
*	Active
*		This script runs whenever the player is on the DMap.
*		It has eight InitD args, and eight InitD strings.
*		If the player warps while this script is running, then the engine 
*		will load the DMap Active script from the destination DMap (if any).
*			If using a scripted DMap Active Subscreen script, you have
*			the option that this script continues to run while the scripted
*			subscreen is open.
*	Scripted Subscreen (Active)
*		This script runs, if assigned, when the player presses the
*		START button, IN PLACE OF THE NORMAL ACTIVE SUBSCREEN for this DMap.
*		This script type hasd eight InitD args and eight InitD strings.
*		InitD with this script type is shared with the DMap Passive Subscreen Script Slot.
*		If the player warps while this is running, then the engie will
*		load the Scripted Subscreen (Active) DMap script from the destination DMap (if any).
*		If the destination DMap lacks a Scripted Subscreen (Active) DMap script,
*		then the virtual subscreen will terminate.
*	Scripted Subscreen (Passive)
*		If assigned, this script runs whenever the player is on the DMap.
*		Its purpose is to permit creating a scripted passive subscreen.
*		This script shares its InitD args and its InitD strings with the Scripted
*		Subscreen (Active) DMap slot script.
*		If the player warps while this script is running, then the engine
*		will load the Scripted Subscreen (Passive) script from the destination
*		DMap (if any).
*			If using a scripted DMap Subscreen (Active) script, then you
*			further have the option that this script continues to run while
*			the scripted active subscreen is open.
*
*
*
* DMap scripts run only on DMaps where they are set to run.
* Warping to a DMap with a dmap script will start that script.
*
* You can assign this script to a DMap in the DMAPS EDITOR dialogue. 
*	To do this, open the DMAPS EDITOR, and select the 'Scripts' tab.
*
* You may assign scripts to DMaps from other scripts, on an initialised dmapdata pointer,
* via dmapdata->Script and dmapdata->SubscreenScript[2], where the indices are:
*
*	DMD_SUBSCREEN_ACTIVE 	= 0;
*	DMD_SUBSCREEN_PASSIVE 	= 1;
*
* DMap Active Scripts have eight InitD[] args, in the DMAP EDITOR for this script type.
* 	You may assign values to these in the DMAP EDITOR, and you may label the fields
* 	for these InitD values in the DMAP EDITOR.
* 	You may also read or write to them by script with dmapdata->InitD[] (or this->InitD[])
*
* DMap Subscreen Scripts have eight InitD[] args, in the DMAP EDITOR for this script type.
*	You may assign values to these in the DMAP EDITOR, and you may label the fields
* 	for these InitD values in the DMAP EDITOR.
* 	Both subscreen script types shjare the InitD values and labels, per DMap.
* 	You may also read from, or write to them by script with dmapdata->SubscreenInitD[].
* 
* Trying to modify the script while it is running with this->Script, is untested.


//////////////////////
/// Screen Scripts ///
//////////////////////

TOKEN(s):		screendata script
POINTER: 		Screen
InitD:			Yes, [8]
InitD Labels:		No
InitA:			No
Multiple Frames:	Yes
Waitdraw Support:	Yes

* You can now compile and assign scripts to individual screens.
* The 'this' pointer for screendata scripts is identical to 'Screen->'.
*
* This script can run for multiple frames, and it runs before ffcs.
* You can enable the tick box 'Run on Screen Init'. if this is enabled, ther script runs as soon as the screen
* starts to scroll into view.
*
* Screen scripts run only on screens where they are set to run.
* Warping to a screen with a screen script will start that script.
*
* You can assign this script to a screen in the SCREEN SCRIPT EDITOR dialogue. 
*	To do this, access the Screen menu, and select the entry 'Script'.
*
* You may assign scripts to screens from other scripts, via Screen->Script, or mapdata->Script
* 	on an initialised mapdata pointer.
*
* Screen Scripts have eight InitD[] args, in the SCREEN SCRIPT EDITOR for this script type.
* 	You may assign values to these in the SCREEN SCRIPT EDITOR, but you may not label the fields
* 	for these InitD values in the SCREEN SCRIPT EDITOR.
* 	You may also read or write to them by script with Screen->InitD[] (or mapdata->InitD[], or this->InitD[]).
*
* Trying to modify the script while it is running with this->Script, is untested.


///////////////////
/// NPC Scripts ///
///////////////////

TOKEN(s):		npc script
POINTER: 		npc
InitD:			Yes, [8]
InitD Labels:		Yes, [8]
InitA:			No
Multiple Frames:	Yes
Waitdraw Support:	No

* You can now compile and assign scripts to npcs. 
* The 'this' pointer for npc scripts is npc (ri->guyref).
* You can assign this script type to enemies in the ENEMY EDITOR:
* 	To do this, select the 'Scripts' tab, and then select the 'Action Script' tab. 
* You may assign scripts to enemies from other scripts, via npc->Script.
*
* You can read, or write to the ENEMY EDITOR data for the script ID, with npcdata->Script
* 	on an initialised npcdata pointer.
*
* Enemies have eight InitD[] args, in the ENEMY EDITOR for this script type.
* 	You may assign values to these in the ENEMY EDITOR, and you may label the fields
* 	for these InitD values in the ENEMY EDITOR.
* 	You may also read or write to them by script with npc->InitD[] (or this->InitD[])
* 	or npcdata->InitD[]. 
* Trying to modify the script while it is running with this->Script, is untested.
* Use of these on Room Guys is untested, but should be feasible. 


///////////////////////
/// EWeapon Scripts ///
///////////////////////

TOKEN(s):		eweapon script
POINTER: 		eweapon
InitD:			Yes, [8]
InitD Labels:		Yes, [8]
InitA:			No
Multiple Frames:	Yes
Waitdraw Support:	No

* You can now compile and assign scripts to eweapons.
* The 'this' pointer for npc scripts is eweapon (ri->ewpn).
* You can assign this script type to the weapon generated by an npc in the ENEMY EDITOR.
* 	To do this, select the 'Scripts' tab, and then select the 'Weapon Script' tab. 
* You may assign scripts to eweapons from other scripts, via eweapon->Script, 
* 	on an initialised eweapon pointer.
*
* You can read, or write to the ENEMY EDITOR data for the script ID, with npcdata->WeaponScript.
*
* Enemy Weapons have eight InitD[] args, in the ENEMY EDITOR for this script type.
* 	You may assign values to these in the ENEMY EDITOR, and you may label the fields
* 	for these InitD values in the ENEMY EDITOR.
* 	You may also read or write to them by script with eweapon->InitD[] (or this->InitD[])
* 	or npcdata->WeaponInitD[]. 
* Trying to modify the script while it is running with this->Script, is untested.


///////////////////////
/// LWeapon Scripts ///
///////////////////////

TOKEN(s):		lweapon script
POINTER: 		lweapon
InitD:			Yes, [8]
InitD Labels:		Yes, [8]
InitA:			No
Multiple Frames:	Yes
Waitdraw Support:	No

* You can now compile and assign scripts to lweapons.
* The 'this' pointer for npc scripts is lweapon (ri->lwpn).
* You can assign this script type to the weapon generated by an item in the ITEM EDITOR.
* 	To do this, select the 'Scripts' tab, and then select the 'Weapon Script' tab (W.Script).
* You may assign scripts to lweapons from other scripts, via lweapon->Script
* 	on an initialised lweapon pointer.
*
* You can read, or write to the ITEM EDITOR data for the script ID, with itemdata->WeaponScript.
*
* Link Weapons have eight InitD[] args, in the ITEM EDITOR for this script type.
* 	You may assign values to these in the ITEM EDITOR, and you may label the fields
* 	for these InitD values in the ITEM EDITOR.
* 	You may also read or write to them by script with lweapon->InitD[] (or this->InitD[])
* 	or itemdata->WeaponInitD[]. 
* Trying to modify the script while it is running with this->Script, is untested.


//////////////////////////
/// itemsprite Scripts ///
//////////////////////////

TOKEN(s):		itemsprite script
POINTER: 		itemsprite
InitD:			Yes, [8]
InitD Labels:		Yes, [8]
InitA:			No
Multiple Frames:	Yes
Waitdraw Support:	Yes

* You can now compile and assign scripts to items that appear on the screen.
* The 'this' pointer for itemsprite scripts is itemsprite (ri->itemsref).
*
* This script can run for multiple frames. It automatically ends if the itemsprite becomes invalid.
*
* You can assign this script to an item in the ITEM EDITOR dialogue. 
*	To do this, open the ITEM EDITOR, and select the 'Scripts' tab.
*       Use the SPRITE SCRIPT lister to set this script type. 
*
* itemsprite Scripts have eight InitD[] args, in the ITEM EDITOR for this script type.
* 	You may assign values to these in the ITEM EDITOR, and you may label the fields
* 	for these InitD values in the ITEM EDITOR.
* 	You may also read or write to them by script with itemsprite->InitD[] (or this->InitD[])
*
* Trying to modify the script while it is running with this->Script, is untested.

t/b/a
Itemdata Script, FFC Script


////////////////////////
/// Itemdata Scripts ///
////////////////////////

TOKEN(s):		itemdata script
POINTER: 		itemdata
InitD:			Yes, [8]
InitD Labels:		Yes, [8]
InitA:			Yes, [2]
Multiple Frames:	Yes, depends on QR or item flag
Waitdraw Support:	Yes, depends on QR

It is now possible to permit itemdata scripts to run for more than one frame.
	To do this, you must enable the Quest Rule, 'Item Scripts Continue to Run', 
	in Quest->Rules->Scripts.
	
	This rule is disabled by default, and disabled for all legacy quests, for compatibility
	reasons.

NOTE: In previous versions, this type was simply called "item script".


/////////////////////
/// Combo Scripts ///
/////////////////////

TOKEN(s):		combodata script
POINTER: 		combodata
InitD:			Yes, [2]
InitD Labels:		No
InitA:			No
Multiple Frames:	Yes
Waitdraw Support:	t/b/a


* Each combo position, on every layer, is capable of running a script. You can set the permitted layers in the
* menu: ZScript >>> Quest Specific Settings >>> Scripts.
* combodata Scripts have two InitD[] args, in the COMBO EDITOR for this script type.
* 	You may also read or write to them by script with combodata->InitD[] (or this->InitD[])
* Each combo in the Combo Editor may have one script, and twi InitD values, set on the 'Script' tab.
* Combo scripts, and only combo scripts, may call <combodata>this-> Pos(), PosX(), and PosY() to obtain
* coordinates for a combo running a script.


/////////////////////////
/// Subscreen Scripts ///
/////////////////////////

NOT IMPLEMENTED!

TOKEN(s):		subscreendata script
POINTER: 		subscreendata
InitD:			Yes, [8]
InitD Labels:		No
InitA:			No
Multiple Frames:	Yes
Waitdraw Support:	Undecided

To be added in a future spec. Will run on subscreens, set in the Subscreen Editor via a script subscreen object.



_________                       .__.__                
\_   ___ \  ____   _____ ______ |__|  |   ___________ 
/    \  \/ /  _ \ /     \\____ \|  |  | _/ __ \_  __ \
\     \___(  <_> )  Y Y  \  |_> >  |  |_\  ___/|  | \/
 \______  /\____/|__|_|  /   __/|__|____/\___  >__|   
        \/             \/|__|                \/       

									// Compiler

///////////////////////////
/// Compiler Directives ///
///////////////////////////

	There's a new compile_error directive that ignores the next compiler error/warning of the 
	specified number, that you can use to suppress warnings or halts. 

	Syntax:
	#ignore error(error_number) {error_generating_code}
	#ignore warning(error_number) {error_generating_code}
	catch(error_number) {error_generating_code}
	

//////////////////////
// import, #include //
//////////////////////

The import directive now checks include paths. 
Order and Priority: It first checks an absolute path, then relative to the ZQ binaries,
	then include paths. 
	
The new directive, #include, checks include paths first, then absolute, then relative to the ZQ binaries. 
	

///////////////////
// Header Guards //
///////////////////

The default behaviour for importing duplicate headers / files is now to issue a warning, and ignore the
duplicate import directive. 

You can toggle this behaviour as follows:
	#option HEADER_GUARD warn
		Enables protection, and issues warnings on duplication.
		This is the default.
	#option HEADER_GUARD on
		Enables protection, but issues no warnings.
	#option HEADER_GUARD error
		Halts on finding a duplication.
	#option HEADER_GUARD off
		Halts, and does not give data, as 2.50.
		
If this option is set to anything other than 'off', then the compiler will detail the location of the
original import, and the location of the duplicate, per instance of duplication. 

This option is set in the config files, and not per-quest.
	

///////////////////////////
// Compiler Option Flags //
///////////////////////////

There are now compiler flags that you may enable, or disable, to
emulate old bugs, or to toggle certain actions.

To use these, call the #option directive, followed by the flag macro, and (on | off | error | warn | inherit | default).
	#option LOGGING off
	
	Flag types:
		on : This enables the option.
		off: This disables the option.
		error: Used for certain options.
		warn: Used for certain options.
		inherit: This causes the option to inherit from its last state (e.g., from an importing file). 
		default: Use the default ZQuest value for this option. (Set in 'ZScript->Compiler Settings')
	
	MACROS
	
	NO_LOGGING
		Off by default.
		Valid values: 'on', 'off', 'inherit', 'default'
		If set 'on', then all calls to Trace() type functions will be ignored. 
	
	TRUNCATE_DIVISION_BY_LITERAL_BUG
		Off by default, however on by default for quests made prior to 2.55.
		Valid values: 'on', 'off', 'inherit', 'default'
		Enable this to force scripts to comply to the 2.50.x
			bug, where division by a literal resulted in truncation.
		
	SHORT_CIRCUIT
		On by default, however off by default for quests made prior to 2.55.
		Valid values: 'on', 'off', 'inherit', 'default'
		Enable short-circuiting; see section 'Short Circuiting' above
		
	BOOL_TRUE_RETURN_DECIMAL
		Off by default, however on by default for quests made prior to 2.55.
		Valid values: 'on', 'off', 'inherit', 'default'
		If on, the boolean value 'true' will be represented as '0.0001' instead of '1'.
			This may be necessary for compatibility with some scripts.
			
	HEADER_GUARD
		Warn by default.
		Valid values: 'on', 'off', 'error', 'warn', 'inherit', 'default'
		If on, duplicate import statements will be totally ignored.
		If off, duplicate imports will be processed, as in 2.50.x
		If error, duplicate imports will throw a compiler error.
		If warn, duplicate imports will be ignored, though will throw a compiler warning.
		
	NO_ERROR_HALT
		Off by default.
		Valid values: 'on', 'off', 'inherit', 'default'
		If on, compilation will continue even when a compiler error has been thrown.
			The script will still fail to compile, though it will issue all reachable errors before failing, instead of only the first one it encounters.
		If off, compilation will halt on the first encountered error, as in previous versions.
		
	TRUE_INT_SIZE
		On by default, however off by default for quests made prior to 2.55.
		Valid values: 'on', 'off', 'inherit', 'default'
		If on, the range of int/float constants will be expanded to '-214748,214748' and '-214748.3648,214748.3647' respectively.
		If off, the range will remain '-214747,214747' and '-214747.9999,214747.9999', as in previous versions.
		
	FORCE_INLINE
		Currently unused, pending full implementation of 'inline'
		
	BINARY_32BIT
		Off by default.
		Valid values: 'on', 'off', 'inherit', 'default'
		If on, binary operations and literals will use the true 32-bit values of a number, rather than the ZScript values.
			This means that '1b' == '0.0001' instead of '1'.
			This allows 32 separate bits to be used, which can be usedful for flagsets.
		If off, binary will behave as it did previously.
		This option is FORCED to 'off' for 'std.zh', as it would break a number of functions.
		Be cautious when using this option.
		
	APPROX_EQUAL_MARGIN <float>
		Sets the margin of error for the ~~ (approximately equal) operator.
		The defailt margin of error is 0.0100, so (1.090 ~~ 1.080) == true.
		Set to a foating point value to use a new error margin for ~~.
	
	STRING_SWITCH_CASE_INSENSITIVE
		Off by default.
		Valid values: 'on', 'off', 'inherit', 'default'
		If on, switch-case on string literals will be case-insensitive.
		Else, they will be case-sensitive.
		
Files default to inheriting the option state of the file that imported them. For the buffer, this will use the defaults.
You may force an option to its' default value by setting it to 'default'
The default values can be modified in ZQuest, under 'ZScript->Compiler Settings'.

Note: 	You can use any constant expression, or constant value that is one to represent 'on',
	and any constant expression, or constant value that is zero to represent 'off'.
	For options which only take 'on' or 'off', any other value is treated as 'on'.
	You can use any constant expression, or constant value that is two to represent 'error',
	and any constant expression, or constant value that is three to represent 'warn'.
	The options 'inherit', and 'default' are specific, and not bound to any literal value. 
	Thus, you cannot create macros for them, or otherwise trigger them with constant expressions.

/////////////////////////////
//       Annotations       //
/////////////////////////////

Annotations allow for metadata to be set in specific circumstances.

An annotation is specified as follows:
	@Key("Value")
Annotations can be listed together to use multiple on the same target, as follows:
	@Key("Value"), @Key2("Value2")

Presently, annotations are only allowed on scripts.

	[example--
		
		@Author("Venrob") //This sets the 'Author' metadata of 'script foo' to read 'Venrob'
		ffc script foo
		{
			void run()
			{
				TraceS("Test");
			}
		}
		
	--end example]

Available annotations:

	@Author -
		Valid on: Scripts
		Function: Sets the author name metadata field

/////////////////////////////
///  Registration System  ///
/////////////////////////////

	A new registration handler has been added to the parser.
	Now, global references do NOT need to be placed in order.
	
	[example--
	
		const int A = B;
		const int B = 10;
		const int C = B;
	
	--end example]
	
	Both 'A' and 'C' will be equal to '10'.
	Previously, a compiler error 'Variable B has not been declared' would occur,
	as 'B' would not have been processed by the time it is needed.
	The registration system ensures that everything is registered beforehand, removing this issue.


//////////////////////////////////
/// Mechanical and AST Changes ///
//////////////////////////////////

	Assignment is now an expression instead of a statement. You can theoretically assign 
	inside of a statement now.
	
	[example--
		
		ffc script foo
		{
			void run()
			{
				int x = 0;
				while( (x+=2) < 20 ) Waitframe();
			}
		}
		
	--end example]

	Constants are now treated as normal (unassignable) variables up through type checking. 
	If at that point the constant's value is known, it is stripped out of the AST and its 
	value is saved to the symbol table, similar to how it worked before.

	If the constant's value is not known at compile time, it is instead treated as a normal, 
	unassignable variable by the parser. (It still uses no stack space.)
		In this case, the value is still not considered compile-time constant, and thus cannot
		be used in statements such as 'repeat' and 'case'.

	Constants can now be declared in any scope, not just global scope, and the constant is only
	valid within its scope, so you may now have constants on a per-script, or per-scope basis. 
	
	[example--
	
		ffc script foo
		{
			void run()
			{
				const int X = 10;
				int a = X;
			}
		}
	
	--end example]
	
	You may assign a value to a constant using any constant expression.
	
	[example--
	
		const int A = 5;
		const int B = 10;
		const int C = A*(Pow(B,2));
	
	--end example]




 _______                  .___                 __                        __  .__                      
 \      \   ______  _  __ |   | ____   _______/  |________ __ __   _____/  |_|__| ____   ____   ______
 /   |   \_/ __ \ \/ \/ / |   |/    \ /  ___/\   __\_  __ \  |  \_/ ___\   __\  |/  _ \ /    \ /  ___/
/    |    \  ___/\     /  |   |   |  \\___ \  |  |  |  | \/  |  /\  \___|  | |  (  <_> )   |  \\___ \ 
\____|__  /\___  >\/\_/   |___|___|  /____  > |__|  |__|  |____/  \___  >__| |__|\____/|___|  /____  >
        \/     \/                  \/     \/                          \/                    \/     \/ 

									// New Instructions

//////////////
//  Global  //
//////////////								// Global

int Floor(float n);
 * Truncates n to the nearest integer, rounding downwards.

int Ceiling(float n);
 * Truncates n to the nearest integer, rounding upwards.

int Integer(float n);
 * Truncates n to an integer.

untyped Byte(untyped n);
untyped Int8(untyped n);
 * Clamps and returns 'n' sized to an unsigned byte, with appropriate oberflow.
 
untyped Word(untyped n);
untyped Int16(untyped n);
 * Clamps and returns 'n' sized to an unsigned 16-bit integer, with appropriate overflow.

untyped Short(untyped n);
 * Clamps and returns 'n' sized to a signed 16-bit integer, with appropriate overflow.

untyped SignedByte(untyped n);
 * Clamps and returns 'n' sized to a signed byte, with appropriate overflow.

void SaveSRAM("filename.zcsram", int flags);
void LoadSRAM("filename.zcsram", int flags);
 * Saves or loads the internal datatype dats to a .zcsram file.
 * As of SRAM_VERSION 1, the datatypes (below) are saved.
 * The user can specify which types to save by passing a flagset, 
 * where eaxh ttype ias OR'd together. Pasasing '0' uses all of them:
 * 	TYPE		FLAG
 *	npcdata		0x01
 *	itemdata	0x02
 *	spritedata	0x04
 *	combodata	0x08
 *	dmapdata	0x10
 *	mapdata 	0x20

void SRand(int seed);
 * Sets the current random seed to a given value, input from script. (DOES NOT /10000)

int SRand(); 
 * Generates a random seed, sets it, and returns it.
	
int utol(*string);
 * Converts all uppercase characters in a string to lowercase characters.
 * Returns the pointer to the string.
 * String MUST not be a literal.
 
int ltou(*string);
 * Converts all lowercase characters in a string to uppercase characters.
 * Returns the pointer to the string.
 * String MUST not be a literal.
 
int convcase(*string);
 * Converts all lowercase characters in a string to uppercase characters, and
 * all uppercase characters in a string to lowercase characters.
 * Returns the pointer to the string.
 * String MUST not be a literal.

int ilen(string[]);
 * Returns the number of characters used by a number in the string.
 * Includes the sign, if negative. 

int itoa(int value, dest_string[]);
 * Places value into a string as char. 
 * Returns the number of characters used in the conversion. 

int strcmp(string_a[], string_b[]);
 * Iterates through string_a and string_b until a character is found which is not the same in
 * both strings, and then returns > 0 if the character is larger in str1, and < 0 if it is
 * larger in str2. Returns 0 if the strings are equal.
 * The old string.zh version of this function is still available as:
 * std::string::strcmp(*a, *b).
 
int strncmp(string_a[], string_b[], int num_chars);
 * As strcmp(*a, *b), but compares only the first nth characters, specified as num_chars.
 * The old string.zh version of this function is still available as:
 * std::string::strncmp(*a, *b, int).

int stricmp(string_a[], string_b[]);
 * As strcmp(*a, *b), but case-insensitive.

int strnicmp(string_a[], string_b[], int num_chars);
 * As strncmp(*a, *b, num_chars), but case-insensitive.

int strlen(string[]);
 * Returns the length of a string in characters.
 * The old string.zh version of this function is still available as:
 * std::string::strlen(*a).

void strcpy(string_dest[], string_src[]);
 * Copies string string_src into string_dest.
 * The old string.zh version of this function is still available as:
 * std::string::strcpy(*a,*b).
 
int atoi(string[]);
 * Returns the decimal value of a string consisting of a number.
 * e.g. ("26" would return 26).
 
int strcat(atring_a[], string_b[]);
 * Append the contents of string_b onto string_a.
 * Returns the pointer to string_a.
 
int strchr(string[], int chr);
 * Returns the first index in string that matches 'chr'.

int strrchr(string[], int chr);
 * Reverse of strchr, finding the last instance of a character in a string.
 
int strspn(string[], string_keys[]);
 * Returns the number of characters in a string before a character not contained in
 * 'string_keys' is found
 
int strcspn(string[], string_keys[]);
 * Returns the length of characters in a string before a character contained in
 * 'string_keys' is found

void sprintf(char32[] buf, char32[] format, ...untyped...)
 * Takes a buffer, a format string, and anywhere between 0 and 16 (inclusive) untyped arguments.
 * The untyped arguments will be inserted to the string at points in the format string.
 * Points are specified using '%'. The letter after is used to determine the type of the arg.
 *     "%i" - Integer. Inserts the number as a string, without decimal places.
 *     "%f" - Float. Inserts the number as a string, with decimal places.
 *            If the number does not contain decimal places, ".0" will still appear.
 *     "%d" - Number value. Automatically chooses between "%i" and "%f".
 *     "%s" - String value. Parameter must be a valid ZScript string.
 *     "%p" - Pointer value. Identical to "%i".
 *     "%c" - Character value. Inserts a single character.
 *     "%x" - Hexadecimal, lowercase. Inserts the number, not including decimals,
 *            in hexidecimal. Uses lowercase for letters.
 *     "%X" - Hexadecimal, uppercase. Same as above, but uses uppercase for letters.
 *     "%%" - Inserts a single '%' character, without trying to read it as an argument.
 *     "%" followed by anything other than the above is considered an error. This should never be done.
 * Flags can be used between the '%' and the letter.
 *     "%0#L", where '#' is a number, and 'L' is any letter from 'ifdpxX' (numeric points)
 *           - Requires that the integer portion of the number be at least '#' digits long.
 *             This will fill up to the specified length with '0' characters.
 *             The max number allowed is 10 (ex. "%010d").
 *           Ex. "%02d" given the argument '1' will print '01'.
 *               "%02d" given the argument '11' will print '11'.
 * The resulting string will be placed in the buffer, which is expected to be large enough
 *     to hold the output.

void printf(char32 format[], ...untyped...)
 * Takes a format string, and anywhere between 0 and 16 (inclusive) untyped arguments.
 * Same as 'sprintf', but instead of placing the result in a buffer, will instead
 *     trace the result, as with "TraceS()".
 
int GetSystemTime(int index);
 * Returns the time (Real Time Clock) data from the system on which ZC is running.
 * You may read the following indices: Year, month, day of the month (n/month), day of the week (n/7), 
 * 	hour, minute, second, and day of the year (n/365). 
 * Use the RTC_* constants in std_constants.zh for the index type that you wish to read.

void OverlayTile(int firsttile, int secondtile);		
* Overlay one tile onto another.

int SizeOfArray(untyped[]);
 * SizeOfArray() now returns the size of all datatypes.

void Trace(untyped)
 * The Trace() instruction now supports all datatypes.

untyped Untype(any)
 * Converts the value of any datatype to another, similar to typecasting.
 * Example:
  int x; 
  npc n = Screen->LoadNPC(10);
  x = Untype(n);
  
bool IsValidArray(untyped[]);
 * Returns true if the passed array pointer is valid (usable), false if it is invalid (should not be used).
 

/************************************************************************************************************/


__________      .__        __                    _____                ___.                        
\______   \____ |__| _____/  |_  ___________    /     \   ____   _____\_ |__   ___________  ______
 |     ___/  _ \|  |/    \   __\/ __ \_  __ \  /  \ /  \_/ __ \ /     \| __ \_/ __ \_  __ \/  ___/
 |    |  (  <_> )  |   |  \  | \  ___/|  | \/ /    Y    \  ___/|  Y Y  \ \_\ \  ___/|  | \/\___ \ 
 |____|   \____/|__|___|  /__|  \___  >__|    \____|__  /\___  >__|_|  /___  /\___  >__|  /____  >
                        \/          \/                \/     \/      \/    \/     \/           \/ 

////////////
//  Game  //
////////////								// Game

bool Suspend[susptLAST];
 * Each index represents an aspect of the game engine that you 
 * can suspend or resume by writing to this array.
 * See the enum in std.zh containing suspt* constants
 * for a list that you may use. 
 * Reading from this array will return false if the aspect of the
 * game engine is running; or true if it is suspended.
 * Write elements true to suspend them, or false to resume a 
 * suspended element.

int IncrementQuest();
 * Ends the current quest, incrementing the quest ID by +1, and
 * saves. This works as a normal WIN FLAG. except that the normal
 * ending credits do not appear. Instead, there is a fade out, and
 * the player is returned to the file select, but the file in the 
 * current slot is modified to be the next quest in the MODULE.
 *
 * This is exclusively intended to be used for serialised quests
 * in MODULES and requires the use of QUEST NUMBERS to work.

int MaxNPCs();
 * Returns the maximum number of npc sprites that arw allowed
 * to be on the screen at one time. 
 
void MaxNPCs(int newmax);
 * Sets the maximum number of npc sprites that are allowed to
 * be on the screen at one time. The current legal range is 
 * 1 to 1024.
 
int MaxLWeapons();
 * Returns the maximum number of lweapon sprites that arw allowed
 * to be on the screen at one time. 
 
void MaxLWeapons(int newmax);
 * Sets the maximum number of lweapon sprites that are allowed to
 * be on the screen at one time. The current legal range is 
 * 1 to 1024.
 
int MaxEWeapons();
 * Returns the maximum number of eweapon sprites that arw allowed
 * to be on the screen at one time. 
 
void MaxEWeapons(int newmax);
 * Sets the maximum number of eweapon sprites that are allowed to
 * be on the screen at one time. The current legal range is 
 * 1 to 1024.
 
 int MaxItemsprites();
 * Returns the maximum number of itemsprite sprites that arw allowed
 * to be on the screen at one time. 
 
void MaxItemsprites(int newmax);
 * Sets the maximum number of itemsprite sprites that are allowed to
 * be on the screen at one time. The current legal range is 
 * 1 to 1024.

float Gravity[3];
 * Read or write to the Game's Gravity values.
 * Use the 'GR_' constants to access this array

int Scrolling[5];
 * Read values related to scrolling. READ-ONLY.
 * Use the 'SCROLL_*' constants to access this array
     * SCROLL_DIR: The direction the screen is scrolling. Returns -1 while not scrolling.
     * SCROLL_NX: The x-offset for the new screen. Returns 0 while not scrolling.
     * SCROLL_NY: The y-offset for the new screen. Returns 0 while not scrolling.
     * SCROLL_OX: The x-offset for the old screen. Returns 0 while not scrolling.
     * SCROLL_OY: The y-offset for the old screen. Returns 0 while not scrolling.

int Game->GetNPCScript("name");
 * Returns the slot ID of the npc script 'name'.
 * Returns -1 if there is no match.
 
int Game->GetLWeaponScript("name");
 * Returns the slot ID of the lweapon script 'name'.
 * Returns -1 if there is no match.
 
int Game->GetEWeaponScript("name");
 * Returns the slot ID of the eweapon script 'name'.
 * Returns -1 if there is no match.
 
int Game->GetHeroScript("name");
int Game->GetLinkScript("name");
int Game->GetPlayerScript("name");
 * Returns the slot ID of the hero script 'name'.
 * Returns -1 if there is no match.

int Game->GetDMapScript("name");
 * Returns the slot ID of the dmapdata script 'name'.
 * Returns -1 if there is no match.
 
int Game->GetScreenScript("name");
 * Returns the slot ID of the screendata script 'name'.
 * Returns -1 if there is no match.
 
int Game->GetSubscreenScript("name");
 * Returns the slot ID of the subscreen script 'name'.
 * Returns -1 if there is no match.
 * Thos script type is not implemented at this time.
 
int Game->GetUntypedScript("name");
 * Returns 0; not implemented as this script type has no slot assignment at this time.
 
int Game->GetItemSpriteScript("name");
 * Returns the slot ID of the itemsprite script 'name'.
 * Returns -1 if there is no match.
 
int Game->GetNPC("name");
 * Returns the ID of the npc 'name'.
 * Returns -1 if there is no match.
 
int Game->GetItem("name");
 * Returns the ID of the item 'name'.
 * Returns -1 if there is no match.
 
int Game->GetDMap("name");
 * Returns the ID of the DMap 'name'.
 * Returns -1 if there is no match.
 
int Game->GetCombo("name");
 * Returns the ID of the first combo with label 'name'.
 * Returns -1 if there is no match.
 
bool FFRules[800];
 * An array consisting of all quest rules. 

void Continue();
 * As Game->End(), but this continues the game as if the user had selected the
 * CONTINUE option on the game over screen.

void SaveAndContinue();
 * As Game->Continue(), but also saves the game (after onExit has been executed)

void SaveAndQuit();
 * As Game->End(), but also saves the game (after onExit has been executed)

void ShowContinueScreen();
 * As void ShowSaveScreen(), but it shows the base Save/Retry/Continue screen.

void Reload();
 * Similar to 'Game->End()', but, instead of going back to the title screen,
 *     the same save file will be automatically reloaded; allowing a script to quickly
 *     revert to the prior save, without needing the user to re-select the save file.

bool SkipF6;
 * Disables showing the Continue/Retry/Save menu if the player presses F6.
 * The prompt to exit the game is still shown.

bool SkipCredits;
 * If set true, the credits sequence shown at the end of the game is skipped.

bitmap CreateBitmap(int width, int height);
 * Creates a bitmap with a size of height, width, and returns its pointer.

bitmap LoadBitmapID(int id);
 * Loads one of the six internal bitmaps as a ref to a 'bitmap' typed pointer.

bitmap AllocateBitmap();
 * Initialises a bitmap pointer from the pool of unused bitmap IDs in the system.
 * The current maximum number of user bitmaps is 249. 
 * Returns 0 to the pointer on failure. 

int LItems[512];
 * The size of this array has been corrected to 512, from the prior size of 256.

int LKeys[512];
 * The size of this array has been corrected to 512, from the prior size of 256.

combodata LoadComboData(int id);
 * Loads a Combo Editor table data ref for combo 'id', to a 'combodata' typed pointer.

npcdata LoadNPCData(int id);
 * Loads an Enemy Editor table data ref for NPC 'id', to a 'npcdata' typed pointer.

mapdata LoadMapData(int map, int screen);
 * Loads a screen data ref for screen ID 'screen', of Map ID 'map', to a 'mapdata' typed pointer.

mapdata LoadTempScreen(int layer);
 * Loads a screen data ref for the TEMPORARY data of the layer 'layer'.
 * This can be used to make temporary changes to layers of the current screen, which will not
 *     persist upon leaving the screen.
 * NOTE: All changes to this pointer are lost upon changing screens.

mapdata LoadScrollingScreen(int layer);
 * Loads a screen data ref for the TEMPORARY data of the layer 'layer' used for scrolling.
 * During scrolling, this can be used to change things on the screen you are presently scrolling away from.
 * Not during scrolling, this will point to the last screen you scrolled away from.
 * This pointer will include any temporary changes made while you were on the screen.
 * NOTE: All changes to this pointer are lost upon changing screens.

dmapdata LoadDMapData(int dmap);
 * Loads a dmapdata ref for dmap ID 'dmap' to a 'dmapdata' typed pointer.

dropsetdata LoadDropset(int ID);
 * Loads a dropsetdata ref for dropset number 'ID' to a 'dropset' typed pointer.

spritedata LoadSpriteData(int id);
 * Loads an Weapon Sprite Editor table data ref for sprite 'id', to a 'spritedata' typed pointer.

messagedata LoadMessageData(int id);
 * Loads an String Table Editor table data ref for ZQ Message String 'id', to a 'messagedata' typed pointer.

shopdata LoadShopData(int shop);
 * Loads a Shop Editor table ref for an item shop with an ID of 'id' to a 'shopdata' typed pointer.
	
shopdata LoadInfoShopData(int shop);
 * Loads a Shop Editor table ref for an info shop with an ID of 'id' to a 'shopdata' typed pointer.
 * !! I may make 'infoshopdata' its own type, to prevent conflicts and reduce future shops expansion overhead. -Z

bool TypingMode;
 * If set true, all keyboard presses that would ordinarily perform an in-engine action are suppressed.
 * 	Example: The 'z' key is bound to the 'A Button'; the user presses the 'z' key.
 *	if TypingMode == true, then that keystroke will not cause the engine to register a Button A Press.
 *
 *	Enable this if you wish to create a text prompt using Input->Key[] or Input->ReadKey[].
	
untyped Misc[32];
 * An array of 32 misc values that is always available.
 * Data does not persist between sessions.
 * The Misc[] array now supports all datatypes, and has been expanded to a size of [32].
 * !! Verify that Game->Misc[] is now untyped, to match all other Misc[] arrays. -Z
	
int HighestStringID;
 * Returns the highest valid ID of the strings in the ZQuest String Editor.

int NumMessages;
 * Returns the number of valid strings in the ZQuest String Editor.

int GameOverScreen[12];
 * INCOMPLETE
 * An array of 12 values that affect the visual, and auditory components of the internal
 *	'Game Over' screen, including fonts, colours, sound effects, and cursor tiles.

int GameOverStrings[3]; //
 * INCOMPLETE
 * An array of 3 values that contain the IDs of custom strings for the 'Game Over' screen.
	
int MapCount()				
 * Returns the number of maps used by a quest. 

void PauseSound(int soundid)	
 * Pauses one of the quest's playing sound effects. Use the SFX_ constants in

void ResumeSound(int soundid)
 * Resumes one of the quest's paused sound effects. Use the SFX_ constants in

void EndSound(int soundid)
 * Kills one of the quest's playing sound effects. Use the SFX_ constants in

void GreyscaleOn()
 * Renders the entire display in greyscale.

void GreyscaleOff() 
 * Returns the display rendering to colour. 

int DMapPalette[512]
 * Set or get the Level Palette for each DMap

void SetMessage(int message, int str[])
 * Places string 'str[]' into ZQ Message 'message'.

void SetMapName(int dmap, int str[])
 * Places string 'str[]' into DMap Name for DMap with ID 'dmap'

void SetMapTitle(int dmap, int str[])
 * Places string 'str[]' into DMap Title for DMap with ID 'dmap'

void SetMapIntro(int dmap, int str[])
 * Places string 'str[]' into DMap Intro for DMap with ID 'dmap'

//bool CappedFPS		
//* Check if the game is uncapped. 

int Version;				
 * Returns the version of ZC being used.  

int Build;			
 * Returns the Build ID of the version of ZC being used.  
			
int Beta;				
 * Returns the Beta ID of the version of ZC being used. If the build is not a beta, this returns 0. 

int ZScriptVersion;
 * ZASM command ZSCRIPTVERSION
 * Reads or sets the operating 'last compiled in ZScript Version' value.
 * Writing to this should be limited to editing ASM scripts where it is needed
 * to read and store the correct/current version, and temporarily 
 * modify it during the execution of --that script--, restoring it thereafter.

bool DisableActiveSubscreen;		
 * If set true, the active subscreen will not fall into view when the player presses Start.

int GetPointer(bool *ptr[]);
 * Returns the pointer of a bool array as a float. 

/* The following have been deprecated by other pointer types.

	int GetScreenEnemy(int map, int screen, int enemy_index)			
	* Reads values from enemy lists anywhere in the game. 

	int SetScreenEnemy(int map, int screen, int enemy_index, int enemy_id)			
	* Sets values to enemy lists anywhere in the game.

	int GetScreenDoor(int map, int screen, int index)			
	* Reads value of a door on any screen in the game environment.

	int SetScreenDoor(int map, int screen, int index, int type)			
	* Sets the value of a door on any screen in the game environment.

	void ContinueSound(int sfx); 					
									
	void AdjustSound(int sfx, int pan, bool loop);			
	* Adjusts properties of a sound effect. 

	void PauseMusic()	
	* Pauses the present, playing MIDI or Enhanced Music file. 

	void ResumeMusic()
	* Resumes the present, playing MIDI or Enhanced Music file. 

*/

/************************************************************************************************************/

/////////////////
///  Input->  ///
/////////////////								// Input

int ModifierKeys;
 * Returns the Allegro Keyboard Modifier Flags:
 *	KB_SHIFT_FLAG = 0x0001;
 *	KB_CTRL_FLAG = 0x0002;
 *	KB_ALT_FLAG = 0x0004;
 *	KB_LWIN_FLAG = 0x0008;
 *	KB_RWIN_FLAG = 0x0010;
 *	KB_MENU_FLAG  = 0x0020;
 *	KB_COMMAND_FLAG  = 0x0040;
 *	KB_SCROLOCK_FLAG  = 0x0100;
 *	KB_NUMLOCK_FLAG = 0x0200;
 *	KB_CAPSLOCK_FLAG = 0x0400;
 *	KB_INALTSEQ_FLAG = 0x0800;
 *	KB_ACCENT1_FLAG = 0x1000; 
 *	KB_ACCENT2_FLAG = 0x2000; 
 *	KB_ACCENT3_FLAG = 0x4000; 
 *	KB_ACCENT4_FLAG = 0x8000; 
 * I am unsure what 0x80 is, if anything. It is not listed in Allegro keyboard.h. -Z
 * Might have been reserved for the Apple Right Command key, but never used. 
 
int KeyBindings[14];
 * Returns the key bound to the 14 possible system keys.
 * Use the CB_* constants to access the array, and the KEY_*
 * constants for values. 
 
bool SimulateKeypress[127];
 * Simulates pressing a key on the keyboard, where the key_id
 * is the index of the array. 
 * Input->SimulateKeypress[KEY_A] = true; will attempt to simulate 
 * the user pressing the A key on their keyboard.
 * Writing this false has no effect. 

bool Press[18];
 * An array of boolean values that correspond to whether a control button, or a keyboard
 * 	key bound to a control button, was pressed this frame.
 *	Replaces Link->Press*.
 * Use the CB_* constants to access this array. 

bool Button[18];
 * An array of boolean values that correspond to whether a control button, or a keyboard
 * 	key bound to a control button, was held down this frame.
 *	Replaces Link->Input*.
 * Use the CB_* constants to access this array. 
 
bool Hold[18];
 * An array of boolean values that correspond to whether a control button, or a keyboard
 * 	key bound to a control button, was held down this frame.
 * May be identical to Input->Press[] in some regards.
 * Use the CB_* constants to access this array. 
 
bool DisableButton[18];
 * Setting an index of this to 'true' will prevent the ENGINE from reading that button as pressed/held
 * Scripts will still read the button normally, ignoring this
 * This allows disabling the engine's button, while not disabling the button for scripts.
 * Use the CB_* constants to access this array. 
 
bool KeyRaw[127];
 * Read-Only: An array of boolean values that read as 'true'
 * 	if the corresponding keyboard key was pressed this frame.
 * You can write a key false, but not true. 
 * Use the KEY_* constants to access this array. 
 * Note: This writes directly to allegro's key[] values.
	
bool ReadKey[127] ( should become a function ReadKey()? )
 * As 'KeyRaw[]', except that reading a key with ReadKey[] will ignore further input from that key, 
   until it is released. 
 * Read-only.
 * Use the KEY_* constants to access this array. 
 
bool Key[127];
 * Returns true if a key was down this frame.
 * Functions similarly to 'Input->Button[]', but for keys.
 * Read/Write; this will affect most engine functions as well, though
 *     system keys such as 'Esc', 'F3', 'F4', 'F6', 'F7', 'F8', 'F9'
 *     bypass this, though can be affected via 'KeyRaw[]'
 
bool KeyPress[127];
 * Returns true if a key was pressed this frame.
 * Functions similarly to 'Input->Press[]', but for keys.
 * Read/Write; this will affect most engine functions as well, though
 *     system keys such as 'Esc', 'F3', 'F4', 'F6', 'F7', 'F8', 'F9'
 *     bypass this, though can be affected via 'KeyRaw[]'
 *     Writing this true for 'F3', 'F4', or 'F6' will trigger the button;
 *     though writing false must occur to 'KeyRaw[]'.
 
bool DisableKey[127];
 * Setting an index of this array to 'true' will disable that key for engine input
 * Ex. 'Input->DisableKey[KEY_F6] = true;' will disable the F6 menu from being activated
 * Script key reading, such as 'Input->Key[]', are unaffected.
 * Currently, KEY_F7, KEY_F8, and KEY_F9 cannot be disabled.
 * Use the KEY_* constants to access this array. 
 
bool Joypad[18]; //this is erroneously set up as TYPE_FLOAT in the parser.
 * Similar to Press, except that it only returns presses from a joystick device, not a keyboard.
 * Use the CB_* constants to access this array. 
 
float Mouse[6];
 * An array of boolean values that correspond to whether a mouse button, was clicked this frame,
   plus the x/y components of the mouse.
 *	Replaces mouse variables under Link->.
 * indices: 
 * 	float Mouse[0] Mouse X Position
 * 	float Mouse[1] Mouse Y Position
 * 	float Mouse[2] Mouse Z Position
 * 	bool Mouse[3] Left Button
 * 	bool Mouse[4] Right Button
 * 	bool Mouse[5] Middle Button


//int Type //this is a dummy function in the table.

/************************************************************************************************************/

//////////////											// Module
//  Module  //
//////////////

int GetInt(char32[] "section_id", char32[] "element_id");
 * Returns the value of a specified element of a specified section of the current module.
 * Example: 
 * 	int a = Module->GetInt("METADATA", "version_year");
 
void GetString(char32 buffer[256], char32[] "section_id", char32[] "element_id");
 * Copies a string used by a specified element of a specified section of the current module to 
 * a buffer string. The buffer should be sized to 256.
 * Example:
 * 	char32 buf[256];
 * 	Module->GetString(buf, "METADATA", "author");
 
 void GetItemClass(char32 buffer[256], int itemclass_id);
 * Copies a string used for itemclass ID 'itemclass_id' in the current module to the buffer string.
 * Example:
 * 	char32 buf[256];
 * 	Module->GetItemClass(buf, IC_SWORD);
 
 /************************************************************************************************************/

//////////////////
//  FileSystem  //
//////////////////

bool DirExists(char32[] "filepath");
 * Returns true if the string passed to 'filepath' is a valid directory path,
 *     relative to the current ZC path.
 * If the quest rule "All bitmap-> and FileSystem-> paths relative to quest 'Files' folder" is on,
 *     then this is relative to "[zc root]/Files/[quest name]/"

bool FileExists(char32[] "filepath");
 * Returns true if the string passed to 'filepath' is a valid file path,
 *     relative to the current ZC path.
 * If the quest rule "All bitmap-> and FileSystem-> paths relative to quest 'Files' folder" is on,
 *     then this is relative to "[zc root]/Files/[quest name]/"

bool Remove(char32[] "filepath");
 * Deletes the file pointed to by 'filepath'.
 * Regardless of the quest rule "All bitmap-> and FileSystem-> paths relative to quest 'Files' folder",
 *     this will ALWAYS be relative to "[zc root]/Files/[quest name]/"

/************************************************************************************************************/

////////////////
///   File   ///
////////////////

/*
 * General info:
 * Files opened with 'Open()' or 'Create()', as well as some modes passed to
 *     'OpenMode()', can be Read/Write. In a Read/Write mode, you must call
 *     one of a few certain functions between a read call and a write call.
 *     These functions will list this effect in their description.
 *
 * Writing to files does not write directly to disk, but to a buffer.
 *     It is guaranteed that the contents of this buffer will be written to disk
 *     upon a successful call to 'Flush()', or upon the closing of the file.
 *     Upon exiting the quest, all open files are closed.
 *
 * There is a limit of 256 file pointers. A pointer does not need to have a file
 *     open to count against this limit. Any pointer that returns true from
 *     'isAllocated()' counts against this limit. Calling 'Free()' will deallocate
 *     a pointer, thus no longer counting against this limit. If you open many files
 *     without calling 'Free()', you may run out of pointers, and be unable to open
 *     further files (until you call 'Free()' on some existing pointers).
 *
 * Files are NOT automatically freed if they fall out of scope. You should be sure to
 *     manually call 'Free()' before this happens, or you may lose the pointer, and be
 *     unable to free it later. This could lead to running out of available file pointers.
 *
 * Remember: POSIX filesystems are Case-SenSitive. 
 */

bool Open("filepath");
 * If the file pointer has not been allocated, this function will allocate it.
 * Closes any open file connected to the file pointer.
 * Attempts to open the file at "[zc root]/Files/[questname]/[filepath]"
 * Returns true if successful, false if not.
 * File is opened with mode "rb+" (a read/write binary mode)
 *     If the file does not exist, it will fail.
 * For an equivalent text file mode, use 'OpenMode("filepath", "r+")'

bool Create("filepath");
 * If the file pointer has not been allocated, this function will allocate it.
 * Closes any open file connected to the file pointer.
 * Same as 'Open()', but the file is opened with mode "wb+".
 *     If the file does not exist, it will be created.
 *     If the file DOES exist, all data in the file will be deleted.
 * For an equivalent text file mode, use 'OpenMode("filepath", "w+")'

bool Remove();
 * Deletes the file. This will close it, as with '->Close()', and then delete it from the filesystem.
 * Returns true if successful. The file will be closed even on a failure.

bool OpenMode("filepath", "mode_string");
 * If the file pointer has not been allocated, this function will allocate it.
 * Closes any open file connected to the file pointer.
 * Same as 'Open()', but the file is opened with the specified mode.
 * Valid modes (details taken from http://www.cplusplus.com/reference/cstdio/fopen/):
 *     "r"  | read: Open file for input operations. The file must exist.
 *     "w"  | write: Create an empty file for output operations. If a file
 *            with the same name already exists, its contents are discarded
 *            and the file is treated as a new empty file.
 *     "a"  | append: Open file for output at the end of a file. Output operations
 *            always write data at the end of the file, expanding it. Repositioning
 *            operations ('Seek()', 'Rewind()') are ignored. The file is created if
 *            it does not exist.
 *     "r+" | read/update: Open a file for update (both for input and output). The
 *            file must exist.
 *     "w+" | write/update: Create an empty file and open it for update (both for
 *            input and output). If a file with the same name already exists its
 *            contents are discarded and the file is treated as a new empty file.
 *     "a+" | append/update: Open a file for update (both for input and output)
 *            with all output operations writing data at the end of the file.
 *            Repositioning operations (fseek, fsetpos, rewind) affects the next
 *            input operations, but output operations move the position back to the
 *            end of file. The file is created if it does not exist.
 *
 * The letter "b" can be added to the end of any of these (or before the "+", for update modes)
 *     to specify a binary file mode. Not doing this will specify a text file mode.
 * Text files are files containing sequences of lines of text. Depending on the environment
 *     where the application runs, some special character conversion may occur in input/output
 *     operations in text mode to adapt them to a system-specific text file format. Although
 *     on some environments no conversions occur and both text files and binary files are
 *     treated the same way, using the appropriate mode improves portability.

void Close();
 * Closes any open file connected to the file pointer.
 * This does NOT deallocate the pointer; it is still free to open new files on.

void Free();
 * Closes any open file connected to the file pointer.
 * This will deallocate the file pointer, so that the pointer ID may be re-used.
 * There is a limit to how many file pointers may be allocated at once.
 * See the 'General Information' at the top of this section for more details.

bool isAllocated();
 * Returns true if this file pointer is allocated.
 * This does NOT mean it has a file open; the pointer simply has an ID.

bool isValid();
 * Returns true if this file pointer has a file open.

bool Allocate();
 * Attempts to allocate the file pointer. If it was already allocated, this will re-allocate it;
 *     without deallocating the old pointer! This should not be called on already allocated pointers.
 * Returns true if it can allocate; false otherwise. A false return indicates that the maximum
 *     number of allocated files has been reached.

bool Flush();
 * Flushes the buffer of the file being written to.
 * Writes to a file do not actually write to the file immediately; they instead go to a buffer.
 *     Calling this function will force the buffer to be written to disk.

int ReadString(char32[] buf);
 * Reads a section of characters from the file.
 * Will read either until 'buf' is full, an error occurs, End of File is reached, or a newline
 *     character is reached.
 * If it ends due to reaching a newline character, the newline character will be included at the
 *     end of the string.
 * Returns the length of the string read into 'buf'.

int ReadChars(char32[] buf, int count, int pos);
 * Reads a section of characters from the file.
 * Starts placing characters at 'buf[pos]'.
 *     If 'pos' is negative, starts at 'buf[0]'.
 * If 'count' is 0, does nothing and returns 0.
 * If 'count' is negative, reads until it fills 'buf', an error occurs, or End of File is reached.
 * If 'count' is positive, reads 'count' characters into 'buf'.
 * Will always add a null character at the end of the read characters.
 * Returns the number of characters read, excluding the added null character.

int ReadInts(untyped[] buf, int count, int pos);
 * Reads a section of binary data from the file.
 * Starts placing data at 'buf[pos]'.
 *     If 'pos' is negative, starts at 'buf[0]'.
 * If 'count' is 0, does nothing and returns 0.
 * If 'count' is negative, reads until it fills 'buf', an error occurs, or End of File is reached.
 * If 'count' is positive, reads 'count' characters into 'buf'.
 * The binary data read will be 32b; such that reading '1' will place '0.0001' into buf.
 *     This means that the binary data can contain decimal places.
 * Returns the number of ints read.

int WriteString(char32[] str);
 * Writes the string stored in 'str' to the file.
 * Returns the number of characters successfully written.

int WriteChars(char32[] buf, int count, int pos);
 * Writes characters from 'buf' to file.
 * Starts at 'buf[pos]'.
 *     If 'pos' is negative, starts at 'buf[0]'.
 * If 'count' is 0, does nothing and returns 0.
 * If 'count' is negative, writes from 'buf' until it finds a null character, or reaches the end of 'buf'.
 * If 'count' is positive, writes 'count' characters from buf.
 * Returns the number of characters successfully written.

int WriteInts(untyped[] arr, int count, int pos);
 * Writes 32b binary data from 'arr' to file.
 * The binary data written will be 32b; such that writing '1' will write '10000' to file.
 *     This means that the binary data can contain decimal places; writing '0.0001' will write '1' to file.
 * Starts at 'arr[pos]'.
 *     If 'pos' is negative, starts at 'arr[0]'.
 * If 'count' is 0, does nothing and returns 0.
 * If 'count' is negative, writes from 'arr' until it reaches the end of 'arr'.
 * If 'count' is positive, writes 'count' ints from arr.
 * Returns the number of 32b integers successfully written.

char32 GetChar();
 * Reads and returns the next character in the file.
 * Returns -1 if it fails; check 'EOF' and 'Error' to see why.

char32 PutChar(char32 c);
 * Writes 'c' to file.
 * Returns -1 if it fails; otherwise returns 'c'.

char32 UngetChar(char32 c);
 * Un-reads 'c' to the input stream.
 * Returns -1 if it fails; otherwise returns 'c'.
 * This is a READ operation, not a WRITE operation. The file will not actually be modified;
 *     but further read operations will find this as the next character to be read.
 * Useful if you read a character, then realize you don't want it.

int Pos;
 * Read-only.
 * This represents the current position in the file.
 * In binary modes ('Open()', 'Create()', or 'OpenMode()' including "b"), this is the number
 *     of bytes into the file, / 10000. (i.e. 1 byte in == 0.0001).
 * In text modes ('OpenMode()' not including "b"),
 *     the numerical value may not be meaningful but can still be used to restore the position
 *     to the same position later using 'Seek()' (if there are characters put back using
 *     'UngetChar()' still pending of being read, the behavior is undefined).

bool Seek(int pos, bool from_current);
 * Moves the current position of the file.
 * 'pos' is a 32b value, where '0.0001' represents 1 byte; similar to 'Pos'.
 * If 'from_current' is true, it moves forward from the current position.
 * Otherwise, it moves so that 'Pos' is equal to 'pos'.
 * Using 'from_current'==true in a file open in text mode ('OpenMode()' not
 *     including "b") is undefined.
 * Returns true if successful, false otherwise.
 * If successful, this function has the following side-effects:
 *     All previous calls to 'UngetChar()' are dropped.
 *     The 'EOF' indicator is set to false.
 *     Allows switching between reading and writing on a read/write file.

void Rewind();
 * Rewinds to the beginning of the file.
 * This function has the following side-effects:
 *     All previous calls to 'UngetChar()' are dropped.
 *     The 'EOF' indicator is set to false.
 *     The 'Error' indicator is set to 0.
 *     Allows switching between reading and writing on a read/write file.

bool EOF;
 * Read-Only. Returns true if a read call attempted to read past the end of the file.
 * If true, no further read calls will succeed until the position has been changed;
 *     i.e. 'Seek()' or 'Rewind()'.

int Error;
 * Read-Only. Returns 0 if the file has not enountered an error.
 * If an error was encountered, returns an error code number.

void ClearError();
 * Clears the active EOF and Error indicators.
 * i.e. this writes 'EOF = false;' and 'Error = 0;'.

void GetError(char32[] buf);
 * Stores a string describing the current error into the buffer provided.
 * Stores an empty string if 'Error == 0'.


/************************************************************************************************************/

////////////////
///  Screen  ///
////////////////								// Screen

npc LoadNPCByUID(int uid);
 * Returns an npc pointer to an npc on the screen if its UID matches
 * the input 'uid'.
 * Returns -1 on no match. 
 * If you load npcs by UID, remember to always run an isValid() check on their
 * pointer, prior to performing any actions with it, as UIDs can become stale.
 
 lweapon LoadLWeaponByUID(int uid);
 * Returns an lweapon pointer to an lweapon on the screen if its UID matches
 * the input 'uid'.
 * Returns -1 on no match. 
 * If you load lweapon by UID, remember to always run an isValid() check on their
 * pointer, prior to performing any actions with it, as UIDs can become stale.
 
 eweapon LoadEWeaponByUID(int uid);
 * Returns an eweapon pointer to an eweapon on the screen if its UID matches
 * the input 'uid'.
 * Returns -1 on no match. 
 * If you load lweapon by UID, remember to always run an isValid() check on their
 * pointer, prior to performing any actions with it, as UIDs can become stale.
 
int Script;
 * The screendata script used for the current screen.

untyped InitD[8];
 * The eight D args used by the screendata script for the current screen.

int GetRenderTarget();
 * Returns the present drawing render target ID.
 * Use in conjunction with SetRenderTarget(int) to cache the present RT, 
 * set a new one, draw, then reset it to its prior value.

bool LayerInvisible[7]; 
 * If true, the current layer is invisible.
 * Writing this true for layers 1 through 6 will make those layers invisible.
 
bool ScriptDraws[8];
 * If true, the ZC engine will perform script draws on the given
 * queue layer. 
 * Each queue layer returns true by default. 
 * Writing this false disables script draws targetted to a specific layer queue. 

int Script; 
 * Returns the ID of the script set to the screen, or sets the script that this screen runs.
 
untyped InitD[8];
 * The eight script args for the script that runs on this screen.

bool isSolidLayer(int x, int y, int layer);
 * As 'Screen->isSolid()', but instead of returning true if there is solidity on layers 0, 1, or 2,
 * returns the solidity only for the specified layer.

lweapon CreateLWeaponDx(int type, int baseitem)
 * Create an lweapon with sprites, sounds, and other values set as if it was generated by a specific item.

TriggerSecret(int secret);
 * Triggers a specific secret type on the screen.
 * Might be using the SECCMB_* constants. -Z 30th April, 2019
 
void WavyIn();
 * Replicates the warping screen wave effect (inbound) from a tile warp. 

void WavyOut();		
 * Replicates the warping screen wave effect (outbound) from a tile warp. 

void ZapIn();			
 * Replicates the warping screen zap effect (inbound) from a tile warp. 

void ZapOut();		
 * Replicates the warping screen zap effect (outbound) from a tile warp. 

void OpeningWipe();
 * Replicates the opening wipe screen effect (using the quest rule for its type) from a tile warp.

void ClosingWipe();
 * Replicates the closing wipe screen effect (using the quest rule for its type) from a tile warp.

void OpeningWipe(int shape);
 * Replicates the opening wipe screen effect from a tile warp, in any given shape
 * Use the 'WIPE_' constants in 'std_constants.zh' for 'shape'

void ClosingWipe(int shape);
 * Replicates the closing wipe screen effect from a tile warp, in any given shape
 * Use the 'WIPE_' constants in 'std_constants.zh' for 'shape'


void DrawBitmapEx	( int layer, 
			int bitmap_id, 
			int source_x, int source_y, int source_w, int source_h, 
			int dest_x, int dest_y, int dest_w, int dest_h, 
			float rotation, int cx, int cy, int mode, int lit,  bool mask);

 * As DrawBitmap(), except that it can do more things. 
 * Now supports multiple MODES, OR'd together as a bitmask:
 * const int BITDX_NORMAL = 0;
 * const int BITDX_TRANS = 0x01; //Translucent
 * const int BITDX_PIVOT = 0x02; //THe sprite will rotate at a specific point, instead of its centre.
 * const int BITDX_HFLIP = 0x04; //Horizontal Flip
 * const int BITDX_VFLIP = 0x08; //Vertical Flip.
 * You can also set a pivot point for the rotation, using 'int cx' and 'int cy'
 * If these are non-zero, the rotation anchor point will centre on these coordinates.
 * You may specify a colour to 'int lit' to use a lit mode. 


void FastCombo()
void DrawScreen()
void DrawLayer()
 * These now support Combo CSet values.

void DrawTileCloaked(int layer, int x, int y,
		int tile, int blockw, int blockh,
		int flip);
 * As DrawTile(), but draws with a cloaked effect.

void DrawComboCloaked(int layer, int x, int y,
		int combo, int tilewidth, int tileheight,
		int flip);
 * As DrawCombo(), but draws with a cloaked effect.
 
void DrawString(int layer, 
			int x, int y, 
			int font, int color, int background_color, int format, 
			"string", 
			int opacity,
			int shadow_type, int shadow_color);
 * As DrawString(), but includes a shadow on the text.
 * Use the 'SHD_' constants for 'shadow_type'.

void PutPixels(int layer, int ptr[])
 * Puts multiple pixels to the screen in one function call.
 * PutPixels() expects an array as its arg, with the array in the format of
 * repeating blocks of { x, y, colour, trans }
 *	Example: PutPixels(1, { 25, 10, 5, OP_OPAQUE, 26, 10, 6, OP_OPAQUE } );
 *	This draws two pixels to the screen.
 *	The first is at coordinates x==25, y == 10, colour == 5, and it is opaque.
 *	The second is at coordinates x==25, y==10, colour == 6, and opaque.
	
void DrawTiles(int layer, int ptr[])
 * Similar to FastTile(), but it draws multiple tiles in one call.
 * The arg *ptr[] should be an array with repeating sets of:
 *	{x,y,tile,colour,opacity} 
 *	...per tile that you want to draw.

void DrawCombos(int layer, int ptr[]);
 * Similar to FastCombo, but draws multiple combos in one call.
 * The arg *ptr[] should be an array with repeating sets of: 
 *	{x,y,combo,cset,opacity} 
 *	...per combo that you want to draw.

void Lines(int layer, int ptr[]);
 * Similar to Line(0, but draws multiple lines in one call.
 * The arg *ptr[] should be an array with repeating sets of: 
 *	{ x, y, x2, y2, colour, scale, rx, ry, angle, opacity }
 *	...per line that you want to draw.
	
void Polygon(int layer, int num_points, int vertices[], int colour, int transparency);
	ZASM: POLYGON
 * Draws a polygon to the screen, with a number of points specified as int points,
 * with vertices supplied as an array. 

int Valid;
 * ?

int Guy;
 * The screen guy.

int String;
 * The screen string.

int RoomType;
 * The screen room type.

int Item;
 * The screen item.
 * Note: The NULL value is '0', which is a valid item.
 * 	To determine if there is an item on the screen, if you ever assigned
 * 	item 0 as a valid screen item in your quest, you will also want to read
 * 	HasItem for that screen.

int HasItem; 
 * If not zero, then the item for this screen will be shown.
 * When Link takes the item on a screen, this is set to 0.

int TileWarpType[4];
 * The Tile Warp type for Tile Warps A, B, C, and D; [0], [1], [2], and [3] respectively.
 * See std_constants.zh TWTYPE_* constants for valid types.
	
bool SideWarpOverlay[4];
bool TileWarpOverlay[4];
 * Set or get the overlay state for the warp ID corresponding to the index of this array.

int DoorComboSet;
 * The doorset used by the screen, for NES dungeon doors.
	
int SideWarpReturnSquare[4];
 * The return square (A->D) used by Side Warp[A->D].

int TileWarpReturnSquare[4];	
 * The return square (A->D) used by Tile Warp[A->D].
	
int WarpReturnX[4];
 * The X-component for each of the four 2.50+ (blue) warp return squares.
	
int WarpReturnY[4];
 * The Y-component for each of the four 2.50+ (blue) warp return squares.
	
int WarpReturnC;
 * Stores the information on warp returns, butwise.
 * Deprecated by SideWarpReturnSquare[4] and TileWarpReturnSquare[4].
 * The bits are DDCCBBAADDCCBBAA, where the left section is sidewarp returns, and the right is tilewarp returns.

int StairsX;
 * The X component for where a Stairs secret appears on the screen.
	
int StairsY;
 * The Y component for where a Stairs secret appears on the screen.
	
int ItemX;
 * The X component for the item location on the screen.
	
int ItemY;
 * The Y component for the item location on the screen.

int Palette;
int CSet;
 * ? The screen palette. ?

int TileWarpDMap[4];
 * The destination DMap for each of the four warp types.
	
int TileWarpScreen[4];
 * The destination screen for each of the four warp types.

int Enemy[10];
 * The IDs of the enemies that spawn on the screen.

int EnemyFlags;
 * A flagset for enemies on the screen (E.Flags).
 * Valid values (ORd) together, are:
 *
 *

int Pattern;
 * The enemy 'Spawn Pattern'.
 * Use the PATTERN_* constants in std.zh for the valid values
 
int SideWarpID[4];
 * Returns the sidewarp ID for a given screen edge, as SideWarpID[dir];
 * Returns -1 if there is no sidewarp in that direction.
 * Use the SIDEWARP_* constants in std.zh for the value of this (read return value, or write value).
 * Use the DIR_* constants in std.zh for the index values.

int SideWarpType[4];
 * The Sidewarp type for Sidewarps A, B, C, and D; [0], [1], [2], and [3] respectively.
 * See std_constants.zh SWTYPE_* constants for valid types.

int SideWarpScreen[4];
 * The destination screen for each of the four sidewarps.
	
int SideWarpDMap[4];
 * The destination DMap for each of the four sidewarps.
	
int SideWarpIndex;
 * The warp return IDs. Deprecated by SideWarpID[].

int WarpArrivalX;
 * The X-component for the pre-2.50 (green) arrival square.
	
int WarpArrivalY;
 * The X-component for the pre-2.50 (green) arrival square.
	
int MazePath[4];
 * The four Maze Path directions.

int ExitDir;
 * The Maze Path 'Exit Direction'.

int UnderCombo;
 * The undercombo ID used by the screen.

int UnderCSet;
 * The CSet of the undercombo used by the screen.

int Catchall;
 * The screen 'Catchall' value. 

int CSensitive;
 * The value of Damage Combo Sensitivity for the screen.
	
int NoReset;
 * The No Reset Flagset. Values are ORd together s follows:
 * Secrets		0x
 * Items		0x
 * Special Item		0x
 * Lock Block		0x
 * Boss Lock Block	0x
 * Chest		0x
 * Secrets		0x
 * Locked Chest		0x
 * Boss Locked Chest	0x
 * Door Up [0]		0x
 * Door Down[1]		0x
 * Door Left [2]	0x
 * Door Right [3]	0x

int NoCarry;
 * The No Carry Over Flagset. Values are ORd together s follows:
 * Secrets		0x
 * Items		0x
 * Special Item		0x
 * Lock Block		0x
 * Boss Lock Block	0x
 * Chest		0x
 * Secrets		0x
 * Locked Chest		0x
 * Boss Locked Chest	0x

int LayerMap[7];
 * The Map IDs used by screen layers 1 through 6, represented as [1] through [6].
 * Index [0] does nothing, and trying to access it will report an error to the log.

int LayerScreen[7];
 * The Screen IDs used by screen layers 1 through 6, represented as [1] through [6].
 * Index [0] does nothing, and trying to access it will report an error to the log.

int LayerOpacity[7];
 * The opacity value for each layer used by this screen.
 * Valid layers are 1 through 6, represented as [1] through [6].
 * Index [0] does nothing, and trying to access it will report an error to the log.

int TimedWarpTimer;
 * The timer used by 'Time Warp Tics' in Screen Data->T.Warp

int CarroverMap;
int NextMap;
 * The map to where secrets on the current mapscreen carry over.
 * Corresponds to the Screen Data>>>Screen State Carryover 'Next Map' 
 * selection in the ZQ Editor.
 
int CarryoverSrceen;
int NextScreen;
 * The screen to where secrets on the current mapscreen carry over.
 * Corresponds to the Screen Data>>>Screen State Carryover 'Next Screen' 
 * selection in the ZQ Editor.

int SecretCombo[128];
 * The Combo IDs used by 'Secret Combos' on this screen.
 * See SCR_SEC_* in std_constants.zh for more information.
	
int SecretCSet[128];
 * The CSets used by 'Secret Combos' on this screen.
 * See SCR_SEC_* in std_constants.zh for more information.
	
int SecretFlags[128];
 * The Combo Flags used by 'Secret Combos' on this screen.
 * See SCR_SEC_* in std_constants.zh for more information.
	
int ViewX;
 * Unused at this time. Represents the visible width of the screen.

int ViewY;
 * Unused at this time. Represents the visible height of the screen.

int Width;
 * Unused at this time. Represents the physical;e width of the screen.

int Height;
 * Unused at this time. Represents the physical height of the screen.

int EntryX;
 * The X-coordinate at which Link entered the screen (his last spawn point).
 * If Link is respawned by falling in water, he will appear at this X-component. 

int EntryY;
 * The Y-coordinate at which Link entered the screen (his last spawn point).
 * If Link is respawned by falling in water, he will appear at this Y-component. 

int ScriptEntry;
 * Unused. Originally intended as a way to detect if ffcs should run on loading a screen.

int ScriptOccupancy;
 * Unused. Originally intended as a way to detect if ffcs should run while a screen is active.

int ExitScript;
 * Unused. Originally intended as a way to detect if ffcs should run on leaving a screen.

int OceanSFX;
 * The 'Ambient Sound' under S.Data2. 
 * Rename this to AmbientSFX, or just SFX.

int BossSFX;
 * The Boss Roar sound for this screen.
	
int SecretSFX;
 * The sound that will play on this screen, when secrets are triggered.

int ItemSFX;
 * The sound that will play if Link holds an item over his head on this screen.
	
int MIDI;
 * The MIDI that plays on this screen.

int LensLayer;
 * The layer to which Lens of Truth graphics are drawn.

int ScreenFlags[10];
 * A set of flagsets that contain special data for thiws screen.
 * These represent S.Flags1 and S.Flags2 flags.
 * See std_constants.zh (SFG* for the screen flag froup, 
 *	and SFX* for the screen flag value) for more information. 
	
bool NumFFCs[33];
 * The number of ffcs set up on the current screen.
 * Index [0] is unused, to match internal ZQ Editor FFC numbering.
 * Thus, this returns true/false for indices [1] through [32],
 * which equate to FFC IDs 1 through 32 on the current mapscreen.

/************************************************************************************************************/

/////////////
///  FFC  ///
/////////////									// FFC

int ID;	
 * The screen ref of the ffc. Used primarily for this->ID.

//bool Running; //need to add this to match mapdata. int val

bool Flags[14];
 * Corrected and expanded the array size from [2] to [14].

/************************************************************************************************************/


  _________            .__  __           ________ ___.        __               __          
 /   _____/____________|__|/  |_  ____   \_____  \\_ |__     |__| ____   _____/  |_  ______
 \_____  \\____ \_  __ \  \   __\/ __ \   /   |   \| __ \    |  |/ __ \_/ ___\   __\/  ___/
 /        \  |_> >  | \/  ||  | \  ___/  /    |    \ \_\ \   |  \  ___/\  \___|  |  \___ \ 
/_______  /   __/|__|  |__||__|  \___  > \_______  /___  /\__|  |\___  >\___  >__| /____  >
        \/|__|                       \/          \/    \/\______|    \/     \/          \/ 
The following are the members for sprite objects (Hero, npc, lweapon, eweapon, and itemsprite).

////////////////////
///  Itemsprite  ///
////////////////////

bool Animation;
 * Normally 'true'. If enabled, the item is animated by the ZC engine.
 * Set this false to disable engine animation.
 
int Max();
 * Returns the maximum number of itemsprite sprites (eweapon and lweapon are
 * separate values, and should be read from the appropriate 
 * pointer type) that arw allowed to be on the screen at one time. 

void Max(int newmax);
 * Sets the maximum number of itemsprite sprites (eweapon and lweapon are
 * separate values, and should be read from the appropriate 
 * pointer type) that arw allowed to be on the screen at one time. 
 * The current legal range is 
 * 1 to 1024.
 
 
untyped InitD[8];
 * The 8 D args for the itemsprite.
 * Used as this->InitD[] for itemsprite scripts.

bool Gravity;
 * If set true, the itemsprite will fall in sideview gravity.
 * Itemsprites have gravity set true by default.
`
float Scale;
 * The scale factor for this sprited object. 
 * A scale of 0 and a scale of 1 are identical.
 * Scale values are a multiplier: 1.5 == 50% larger (150%).
 * Negative values are undefined.
 * You can only scale sprites if you disable the Compatibility Quest rule 
 *   'Old (Faster) Sprite Drawing'.
 
float Rotation;
 * The rotation factor for this sprited object, in degrees.
 * You can only rotate sprites if you disable the Compatibility Quest rule 
 *  'Old (Faster) Sprite Drawing'.

int Script;
 * The itemsprite script attached to this itemsprite.

int Family;
int Type;
 * The Family (Item Class) of the itemsprite.

untyped Misc[32];
 * The Misc[] array now supports all datatypes, and has been expanded to a size of [32].

int Pickup;
 * The pick-up type for this itemsprite.
	
int PickupString;
 * If this is > 0, then when Link touches the itemsprite, ZC will display a ZQ String Editor message string
 * equal to its value.
 * The precise behaviour of this is affected by PickupFlags.

int PickupStringFlags;
 * A flagset that determines the behaviour of string display.
 * Values are ORd together, as follows:
 *
 *
 *

int SizeFlags;
 * A flagset that determines how internal engine sizing of items is applied.
 * Values are ORd together, as follows:
 *
 *


float UID;	
 * Each itemsprite created by ZC in in a given session is assigned a unique ID (UID).
 * Returns the UID of an itemsprite.
 * UIDs begin at 00000.0001 and overflow at 217478.3648. 
 *	Note: This allows for 2,147,483,647 unique items, per-session.

int AClock 
 * The clock used for the itemsprite's animation cycle. 

int ScriptTile;
 * If set to 0 or higher, then the itemsprite will be drawn with this tile.
 * The default value for this is -1.

int ScriptFlip;
 * If set to 0, or higher, then the engine will use this Flip state to draw the itemsprite.
 * The default value for this is -1. 

int Falling;
 * The timer indicating how long left the itemsprite will be falling
 * If 0, the itemsprite is not falling
 * Max value of 70, which is the value when you begin falling
 * Read-Write

int FallCombo;
 * The pit combo that the itemsprite is falling into
 * Affects the SFX that will occur on the first frame of falling
 * Read-Write

bool MoveFlags[2];
 * Flags relating to movement.
 * See 'ITEMMV_' constants in std_constants.zh for values
 * [0] == Obeys gravity (see ->Gravity)
 * [1] == Can fall in pitfalls
 * Read-Write

/************************************************************************************************************/	

/////////////////
///  *weapon  ///
/////////////////								// Weapon

int Power; 
 * The damage/power value of te weapo.
 * Identical to *weapon->Damage, but added for uniformity with itemdata.

bool Animation;
 * Normally 'true'. If enabled, the weapon is animated by the ZC engine.
 * Set this false to disable engine animation.

int Max();
 * Returns the maximum number of weapon sprites (eweapon and lweapon are
 * separate values, and should be read from the appropriate 
 * pointer type) that arw allowed to be on the screen at one time. 

void Max(int newmax);
 * Sets the maximum number of weapon sprites (eweapon and lweapon are
 * separate values, and should be read from the appropriate 
 * pointer type) that are allowed to be on the screen at one time. 
 * The current legal range is 
 * 1 to 1024.
 
bool Gravity;
 * If set true, the weapon falls in sideview gravity.
 * Some weapons (e.g. fire, bombs) have this set true by default.

float Scale;
 * The scale factor for this sprited object. 
 * A scale of 0 and a scale of 1 are identical.
 * Scale values are a multiplier: 1.5 == 50% larger (150%).
 * Negative values are undefined.
 * You can only scale sprites if you disable the Compatibility Quest rule 
   'Old (Faster) Sprite Drawing'.
 
float Rotation;
 * The rotation factor for this sprited object, in degrees.
 * You can only rotate sprites if you disable the Compatibility Quest rule 
 *   'Old (Faster) Sprite Drawing'.
   
int Script;
 * The weapon script assigned to this weapon.

untyped InitD[8];
 * The eight InitD values for the weapon script used by this weapon.

int ScriptTile;
 * If set to 0 or higher, then the npc will be drawn with this tile.
 * The default value for this is -1.

int ScriptFlip;
 * If set to 0, or higher, then the engine will use this Flip state to draw the npc.
 * The default value for this is -1. 

int Parent;
npc Parent;
 * The ID of the item, or pointer of the npc (respectively for lweapon, and for eweapon) that created this weapon.
 * Weapons created by script have a default Parent of -1 (lweapon) and <npc>-0.0001 (eweapon). 
	
int Level;
 * LWeapons: The Level value associated with the weapon. 
 * EWeapons: The first bit (Level&1) is used to set a 'boss/unblockable'
 * state. If this bit is 1, then the weapon is a boss weapon.
 * Otherwise it is a normal weapon, blocked by standard shield flags.

float UID;
 * Each weapon created by ZC in in a given session is assigned a unique ID (UID).
 * Returns the UID of a weapon.
 * UIDs begin at 00000.0001 and overflow at 217478.3648. 
 *	Note: This allows for 2,147,483,647 unique weapons, per-session.


untyped Misc[32];		
 * Expanded from a size of [16] to [32]. An array of 32 miscellaneous variables for you to use as you please.
 * The Misc[] array now supports all datatypes, and has been expanded to a size of [32].

int Falling;
 * The timer indicating how long left the weapon will be falling
 * If 0, the weapon is not falling
 * Max value of 70, which is the value when you begin falling
 * Read-Write

int FallCombo;
 * The pit combo that the weapon is falling into
 * Affects the SFX that will occur on the first frame of falling
 * Read-Write

bool MoveFlags[2];
 * Flags relating to movement.
 * See 'WPNMV_' constants in std_constants.zh for values
 * [0] == Obeys gravity (see ->Gravity)
 * [1] == Can fall in pitfalls
 * Read-Write

///////////////////////////
///  EWeapon  Specific  ///
///////////////////////////							// EWeapon

int ParentUID;
 * Returns the UID of the NPC that controls this eweapon.
 * Useful in weapon scripts, using Screen->LoadNPCBYUID(this->ParentUID).
 * Returns 0 is there is no npc controlling the weapon.
 * Remember that UIDs become stale if the npc is destroyed!

///////////////////////////
///  LWeapon  Specific  ///
///////////////////////////							// LWeapon

int Special;
 * The special info for the lweapon.
 * Used by wind lweapons, instead of Level, to determine their effects. 

int Weapon;
 * The UseWeapon property for this weapon. 
 * If set to a value greater than 0, all collisions with npcs
 * will use this as if it was the weapon's ID for calculating
 * the defence value for it. 
 * e.g., if a LW_MAGIC weapon is set to a Weapon of LW_BRANG, when it
 * collides with an npc, the npc will use Defence[LW_BRANG] to resolve 
 * its effects.
 *
 * Some weapons will also trigger map flags, and screen combos as
 * if the natural weapon was the value set as ->Weapon.,
 * e.g. If you set a LW_BRANG weapon to a ->Weapon of LW_SWORD,
 * it will cut bushes. 

int Defence;
int Defense;
 * The default defence value for this weapon.
 * If set greater than 0, then when this weapon collides with an npc,
 * if that npc has its Defence[n] value set to NONE for this weapon's type,
 * it will resolve using this Defence value (e.g. Stun). 

int Range;
 * NEEDS TO BE REIMPLEMENTED
 * The range of boomerang and hookshot lweapons in pixels; and arrow lweapons in frames.

int AClock 
 * The clock used for the itemsprite's animation cycle. 

/************************************************************************************************************/		

/////////////
///  NPC  ///
/////////////	
								// NPC

int Dropset;
 * Alias for npc->ItemSet. 
 * Read or write the item dropset used by the npc.

int Random;
 * Corresponds to the Enemy Editor Random Rate value.

bool Animation;
 * Normally 'true'. If enabled, the npc is animated by the ZC engine.
 * Set this false to disable engine animation.

int Max();
 * Returns the maximum number of npc sprites (eweapon and lweapon are
 * separate values, and should be read from the appropriate 
 * pointer type) that arw allowed to be on the screen at one time. 

void Max(int newmax);
 * Sets the maximum number of npc sprites (eweapon and lweapon are
 * separate values, and should be read from the appropriate 
 * pointer type) that arw allowed to be on the screen at one time. 
 * The current legal range is 
 * 1 to 1024.
 
bool Submerged();
 * Returns if the npc is submerged (in the ground, in the water, or in a wall).
 * Returns true if the npc is FULLY submerged.
 * Returns false as soon as the npc is even partly submerged, and
 * continues to return true until that npc is fully-submerged. 

bool Gravity;
 * If set true, the npc will fall in sideview gravity.
 * Some npcs have this set true by default, others are false by default,
 * based on the npc family.

bool NoSlide;
 * 'false' by default.
 * If this is set to 'true', the npc will ignore engine knockback.

bool NoScriptKnockback;
 * 'false' by default.
 * If this is set to 'true', the npc will ignore script knockback via 'npc->Knockback()'

int SlideSpeed;
 * 4 by default
 * The number of pixels per frame this NPC will move during ENGINE knockback
 * Range: 0 to 255

float Scale;
 * The scale factor for this sprited object. 
 * A scale of 0 and a scale of 1 are identical.
 * Scale values are a multiplier: 1.5 == 50% larger (150%).
 * Negative values are undefined.
 * You can only scale sprites if you disable the Compatibility Quest rule 
 *  'Old (Faster) Sprite Drawing'.
 
float Rotation;
 * The rotation factor for this sprited object, in degrees.
 * You can only rotate sprites if you disable the Compatibility Quest rule 
 *   'Old (Faster) Sprite Drawing'.

bool isDead();
 * Returns if the NPC is dead, or dying

bool CanSlide();
 * Unimplemented
	
int Slide();
 * Run Engine knockback (Only does anything if a knockback is in-progress)
 * This is automatically called for most engine enemy types
 * Calling this from enemy types such as 'Other' will allow them to recieve knockback
 * This is called as a part of scripted walking functions, such as 'ConstantWalk()', automatically.
 * Return: 0 if no knockback occurred, 1 if scripted knockback ('->Knockback()') occurred, 2 if engine knockback occurred.

bool Knockback(int time, int dir, int speed);
 * Attempt to knock an enemy back.
 * 'time' is the number of frames to knock back.
 * 'speed' is how many pixels per frame the npc will move.
 * Returns true if it was successful, or false if it fails.
 * Will fail if:
 *     The enemy cannot move in that direction
 *     The enemy is already mid-knockback
 *     The enemy is dead
 *     'bool npc->NoKnockback;' was set true for this enemy

void Remove(); 
 * Instantly DELETES an npc. No items will be dropped, no sound will play; the npc is simply DELETED OUTRIGHT.
 * This will immediately invalidate the npc pointer, as well as update 'Screen->NumNPCs()', and change the indexes for 'Screen->LoadNPC()'
 * If called from an NPC script on the NPC running the script, immediately terminates the script.

void StopBGSFX();
 * Stops the background sounds that the npc is generating.
	
void Attack();
 * Causes the npc to attack with its weapon.
	
void NewDir(int arr[]);
 * The npc chooses a new direction.
 * Uses an array literal for its args:
 * 	{ int rate, int homing, int special }

void NewDir8(int arr[]);
 * As NewDir(), but 8-directions.
 * 	{int rate, int homing, int special}
 *	{int rate, int homing, int special, int dx1, int dy1, int dx2, int dy2}

void ConstantWalk(int arr[]);
 * Causes the npc to walk.
 * Uses an array literal for its args.
 * Pass NULL as the pointer to run without args, or use:
 * 	{int rate, int homing, int special}

void ConstantWalk8(int arr[]);
 * As ConstantWalk(), but 8-directions.
 * 	{int rate, int homing, int special}

void VariableWalk(int arr[]);
 * Causes the npc to walk and occasionally change speed.
 * 	{int rate, int homing, int special}

void VariableWalk8(int arr[]);
 * As VariableWalk(), but 8-directions.
 * 	{int rate, int homing, int newclk, int special}
 * 	{int rate, int homing, int newclk, int special, int dx1, int dy1, int dx2, int dy2}

void HaltingWalk(int arr[]);
 * Causes an enemy to walk, and occasionally halt.
 * 	{int rate, int homing, int special, int hrate, int haltcnt}

void HaltingWalk8(int arr[]);
 * As HaltingWalk(), but 8-directions.
 * 	{int newrate, int newhoming, int newclk, int special, int newhrate, int haltcnt}
    
void FloatingWalk(int arr[]);
 * Causes an enemy to move, ignoring solidity on the screen.

bool LinkInRange(int dist_in_pixels);
 * Returns true if Link is within 'range' pixels of the enemy.

bool CanMove(int array[]);
 * Returns true if the npc can move in a given direction.
 * Uses an array literal for varying args.
 * Overloaded for a number of options:
 * 	{int dir}: Dir only, should use the default step distance.
 * 	{int dir, int special} 
 * 	{int ndir, int step, int special} 
 * 	{int ndir,int step,int special,int dx1,int dy1,int dx2,int dy2}

bool SimulateHit(int array[]); 
 * Simulates hitting the npc with a weapon, another sprite, or an arbitrary set of 
 * values passed as an overloaded array literal.
 * Returns true if that object would hit the npc. 
 * 	{TYPE, pointer} : Specify the type, such as PTR_TYPE_LWEAPON, then pass an object pointer.
 * 	{int tx, int ty, int tz, int txsz, int tysz, int tzsz} : Arbitrary values.
	
int LinedUp(int range, bool dir8);
 * Checks if enemy is lined up with Link.
 * If so, returns direction Link is at as compared to enemy.
 * Returns -1 if not lined up. Range is inclusive.
 
npc Create(int array[]); 
 * Similar to Screen->CreateNPC(), except:
 * (1) It uses an arry literal for its args, with varying size.
 * (2) You can either create an npc only by its ID, or you can do
 * 	that and set its spawn coordinates at the same time.
 * (3) It works based on an existing pointer, such as:
 * 	npc n; n->Create{args});
 * 	{ int id } 
 * 	{ int id, int x, int y }
	
void BreathAttack(bool seeklink);
 * Fires the breath weapon set to the enemy.

bool Collision(int obj_type, untyped obj_pointer);
 * Returns if either an object is colliding with the npc, or if an arbitrary set of 
 * coordinates would collide.
 * Valid Object Types:
 *obj_type_lweapon, obj_type_eweapon, obj_type_npc, obj_type_link, obj_type_ffc, obj_type_combo_pos, obj_type_item
 *** Not fully implemented!

	
int Family;
int Type;
 * The Family (Enemy Class) of the npc.

int Script; 
 * The npc action script used by this enemy.

untyped InitD[8];
 * The eight InitD args used by the npc action script for this enemy.

int ScriptTile;
 * If set to 0 or higher, then the npc will be drawn with this tile.
 * The default value for this is -1.

int ScriptFlip;
 * If set to 0, or higher, then the engine will use this Flip state to draw the npc.
 * The default value for this is -1. 
                                                        
untyped Attributes[32];
 * Expanded to size [32], and made datatype-insensitive.

int WeaponSprite;
 * The sprite (Quest->Graphics->Sprites->Weapons) used to draw the weapon fired by the npc.

bool Shield[5];
 * The shield status of the enemy.
 * [0] through [3] correspond to DIR* constants (wherein DIR_UP represents FRONT, and DIR_DOWN represents BACK)
 * [4] corresponds to 'Shield can be broken'.


bool Core;
 * This returns true if the NPC is the core segment of a segmented engine enemy.

**************************************************************

untyped HitBy[10];
 * Stores the ID/UIDs of objects that hurt the npc this frame.
 * Indices:

 * The first four indices are for the *screen index* of objects:

 * Description		Index	Status
 * HIT_BY_NPC 		[0] 	Not used at this time. 
 * HIT_BY_EWEAPON 	[1] 	Not used at this time. 
 * HIT_BY_LWEAPON 	[2]	In use by the engine.
 * HIT_BY_FFC 		[3] 	Not used at this time. 

 * The next four, are for the FFCore 'script' UIDs of objects:

 * Description		Index	Status
 * HIT_BY_NPC_UID 	[4] 	Not used at this time. 
 * HIT_BY_EWEAPON_UID 	[5] 	Not used at this time. 
 * HIT_BY_LWEAPON_UID 	[6]	In use by the engine.
 * HIT_BY_FFC_UID 	[7] 	Not used at this time. 

 * The last two, are reserved for special damage-object types. 

 * Description		Index	Status
 * HIT_BY_COMBO 	[8]	Not used at this time. 
 * HIT_BY_MAPFLAG 	[9] 	Not used at this time. 

 * These indices are uniform across all HitBy[] array members, for any datatype with that member. 

 * Some lweapons, notably some melee weapons such as swords (but not sword beams), and boomerangs
 * are not yet implemented in this mechanic. 

**************************************************************

int Defense[42];
int Defense[MAX_DEFENSE];		
 * Expanded to a size of 42 to cover new defense categories.

untyped Misc[32];		
 * Expanded from a size of [16] to [32]. An array of 32 miscellaneous variables for you to use as you please.
 * The Misc[] array now supports all datatypes, and has been expanded to a size of [32].

float UID;
 * Each npc created by ZC in in a given session is assigned a unique ID (UID).
 * Returns the UID of an npc.
 * UIDs begin at 00000.0001 and overflow at 217478.3648. 
 *	Note: This allows for 2,147,483,647 unique npcs, per-session.

int InvFrames;				
 * Returns the number of remaining invincibility frames if the enemy is invincible, otherwise 0. 

int Invincible;			
 * Returns if the enemy is invincible, because of ( superman variable ). 

bool HasItem;				
 * Returns if the enemy is holding the screen item.

bool Ringleader;			
 * Returns if the enemy is a 'ringleader'.

int ItemSet;
int Dropset;
 * The Dropset ID that this enemy will drop from when killed

/* The following commands are valid, but do not yet have in-engine use, */

int Frozen;
 * Returns the number of frames for which the npc remains frozen

int FrozenTile;
 * Unimplemented at this time.
 
int FrozenCSet;
 * Unimplemented at this time.
 
int npcscript;
 * The script ID used by this NPC.

untyped InitD[8];
 * InitialD for the npc script.

untyped IntiA[2];
 * InitialA for the npc script.

int Movement[32];
 * NPC Movement patterns, and args.

int WeaponPattern[32];
 * NPC weapon movement patterns and args.

int FireSound;
 * The sound that plays when the npc fires a weapon.

int Falling;
 * The timer indicating how long left the npc will be falling
 * If 0, the npc is not falling
 * Max value of 70, which is the value when you begin falling
 * Read-Write

int FallCombo;
 * The pit combo that the npc is falling into
 * Affects the SFX that will occur on the first frame of falling
 * Read-Write

bool MoveFlags[3];
 * Flags relating to movement.
 * See 'NPCMV_' constants in std_constants.zh for values
 * [0] == Obeys gravity (see ->Gravity)
 * [1] == Can fall in pitfalls
 * [2] == Can walk over pitfalls
 * Read-Write

/************************************************************************************************************/

//////////////
///  Hero  ///
//////////////									// Hero // Player

int Steps[8];
 * The number of pixels that the player moves in a frame, based on
 * his present coordinates. The movement is taken from his x and y:
 * as: 
 * x_move_in_pixels = Hero->Step[Hero->X&7]
 * y_move_in_pixels = Hero->Step[Hero->Y&7]
 * The default values are: { 1, 1, 2, 1, 1, 2, 1, 1 };
 * You can double his speed by doubling these values, or adjust it slightly as needed.
 * NOTE: This only affects 4-way movement, and has no effect
 *       if the quest rule 'New Hero Movement' is enabled.

int Step;
 * The steprate that the player moves at. This functions similarly to "npc->Step" and such;
 * a step rate of '100' means that you move '1 pixel per frame'. The default step rate is
 * '150', moving at '1.5 pixels per frame'.
 * NOTE: This affects BOTH 4-way and 8-way movement, but ONLY
 *       if the quest rule "New Hero Movement" is enabled.

bool Animation;
 * Normally 'true'. If enabled, the player sprite is animated by the ZC engine.
 * Set this false to disable engine animation.

bool NoStepForward;
 * If set true, the player will not take two steps into NES dungeon rooms.
 * This value is reset to false, every time that the hero sprite is initialised,
 * and thus, should be written ideally in the hero init script.
 * !! Future versions may change when this is cleared.

bool Gravity;
 * If set true (the default), the hero falls in sideview gravity.

bool Climbing;
 * Returns as 'true' when the hero is climbing a sideview ladder
 * Setting to 'false' will let go of the ladder, and setting 'true' will grab the ladder
 * While 'true', gravity does not affect the hero

int JumpCount;
 * Returns the number of times the hero has jumped in mid-air since last landing.
 * If this is positive, it will be reset to 0 the next frame the hero is on the ground.
 * Used by Roc's Feather items to determine how many extra jumps the hero has left

float Scale;
 * The scale factor for this sprited object. 
 * A scale of 0 and a scale of 1 are identical.
 * Scale values are a multiplier: 1.5 == 50% larger (150%).
 * Negative values are undefined.
 * You can only scale sprites if you disable the Compatibility Quest rule 
   'Old (Faster) Sprite Drawing'.
 
float Rotation;
 * The rotation factor for this sprited object, in degrees.
 * You can only rotate sprites if you disable the Compatibility Quest rule 
   'Old (Faster) Sprite Drawing'.

bool Item[256];
 * Reading from, or writing to this array no longer causes lag.

untyped Misc[32];		
 * Expanded from a size of [16] to [32]. An array of 32 miscellaneous variables for you to use as you please.
 * The Misc[] array now supports all datatypes, and has been expanded to a size of [32].

**************************************************************

untyped HitBy[10];
 * Stores the ID/UIDs of objects that hurt the Link this frame.

 * Indices:

 * The first four indices are for the *screen index* of objects:

 * Description		Index	Status
 * HIT_BY_NPC 		[0] 	In use by the engine. 
 * HIT_BY_EWEAPON 	[1] 	In use by the engine.
 * HIT_BY_LWEAPON 	[2]	Not used at this time.
 * HIT_BY_FFC 		[3] 	Not used at this time. 

 * The next four, are for the FFCore 'script' UIDs of objects:

 * Description		Index	Status
 * HIT_BY_NPC_UID 	[4] 	Not used at this time. 
 * HIT_BY_EWEAPON_UID 	[5] 	Not used at this time. 
 * HIT_BY_LWEAPON_UID 	[6]	Not used at this time.
 * HIT_BY_LWEAPON_UID 	[6]	Not used at this time.
 * HIT_BY_FFC_UID 	[7] 	Not used at this time. 

 * The last two, are reserved for special damage-object types. 

 * Description		Index	Status
 * HIT_BY_COMBO 	[8]	Not used at this time. 
 * HIT_BY_MAPFLAG 	[9] 	Not used at this time. 

 * These indices are uniform across all HitBy[] array members, for any datatype with that member. 

 * Some lweapons, notably some melee weapons such as swords (but not sword beams), and boomerangs
 * are not yet implemented in this mechanic. 

**************************************************************

int HealthBeep; 
 * The timer for the health beep sound, if it is not constant.
 * Setting this to -2 suspends system control over stopping the sound,
 * and setting this to -4 suspends system control over both stopping, 
 * and starting it.
 * The normal operating range used by the system is 70 to -1, where -1
 * wraps around to zero internally. 

int Stun;
 * Returns the number of frames for which Link will; remain stunned.
 * Writing to this causes Link to be stunned for 'n' frames.
 * This decrements once per frame.

int Pushing;
 * Returns the number of frames that Link has been pushing against a solid object.

int Defense[]; 
 * Unused at this time.

int ScriptTile;
 * If this is > 0, then Link will be drawn using this tile ID.
 * The specific tile is drawn. This is not an offset, nor OTile.

int ScriptFlip;
 * If this is > 0, then Link's tile will be drawn using this flip value.

bool DisableItem[256];
 * An array of 256 values that represents whether items are disabled on the current DMap.

int InvFrames;				 
 * This returns how long Link will remain invincible, 0 if not invincible. Can be set. 

bool InvFlicker;			
 * If set false, Link will neither flash, nor flicker when invincible. 

int HurtSound;				
 * The sound that plays when Link is injured. By default this is '16', but you may change it at any time.  

int Eaten;				
 * It returns 0 if Link is not eaten, otherwise it returns the duration of him being eaten.

int Equipment;				
 * Link->Equipment is now read-write, and needs testing.

int ItemA;				
 * Contains the item IDs of what is currently equiped to Link's A button.

int ItemB;				
 * Contains the item IDs of what is currently equiped to Link's B button.

int SetItemSlot(int itm_id, int button, int force);				
 * This allows you to set Link's button items without binary operation with options for forcing them.

int UsingItem;			
 * Returns the ID of an item used when Link uses an item. Returns -1 if Link is not using an item this frame. 

int UsingItemA;		
 * Returns the ID of an item used when Link uses an item on button A. Returns -1 if Link is not using an item this frame. 

int UsingItemB;	
 * Returns the ID of an item used when Link uses an item on button B. Returns -1 if Link is not using an item this frame. 

bool Diagonal;	
 * This corresponds to whether 'Diagonal Movement' is enabled, or not. 

bool BigHitbox;		
 * This corresponds to whether 'Big Hitbox' is enabled, or not. 
	
int Attack; 

/* The following have not been ported from 2.future to Canonical ZC:

	int Animation;				
	* Link's Animation style, as set in Quest->Graphics->Sprites->Link
						
	int WalkASpeed;				
	* Link's Walking Animation speed as set in Quest->Graphics->Sprites->Link

	int SwimASpeed;				
	* Link's Swiming Animation speed as set in Quest->Graphics->Sprites->Link

	int HitHeight;				
	* link's Hitbox height in pixels starting from his 0x,0y (upper-left) corner, going down. 
			
	int HitWidth;				
	* Link's Hitbox width in pixels starting from his x0,y0 (upper-left) corner, going right. 

	int HitXOffset;				
	* The X offset of Link's hitbox, or collision rectangle.
		
	int HitYOffset;				
	* The Y offset of Link's hitbox, or collision rectangle.

	int Extend;			
	* Sets the extend value for all of Link's various actions.
*/

void WarpEx(int ptr[])

* Similar to Link->Warp, but with more options. This takes an array, or
  an array literal as its arguments. 
  
  Valid array params are:
	Link->WarpEx({type,dmap,screen,x,y,effect,sound,flags})
	and
	Link->WarpEx({type,dmap,screen,x,y,effect,sound,flags,forcedir}

	type:
		Warp types are:
			wtIWARP: Acts like a tile warp.
			wtExit: An entrance/exit warp.
			wtSCROLL: A scrolling warp.
			wtNONE: A cancel warp. 
			
	dmap:
		The Destination DMap
		
	screen: 
		The Destination Screen
		
	x, y:
		Either raw pixel coordinates, or a warp return square ID.
		
			Link->WarpEx() Coordinates Versus Warp Return Square:
				If 'x' and 'y' are both > -1, then they are raw coordinates as always.
				If 'x' < 0, THEN 'y' is the warp return square type, using positive integers.

				This allows using the warp return constants in std.zh, and it prevents a 
				possible ID clash from both values trying to establish the square ID. 

	effect:
		Warp Effects are:
		warpEffectNONE: No visual effect.
		warpEffectZap: Zap Effects
		warpEffectWave: Wave Effects
		warpEffectInstant: Black screen.
		warpEffectOpen: Calls the opening wipe.

	sound:
		You may play a special sound (e.g. Magic Mirror) during the warp.

	flags:
		Warp Flags are:
		warpFlagKILLSCRIPTDRAWS: Don't kill script drawing during the warp.
		warpFlagKILLSOUNDS: Don't kill playing sounds during the warp.
		warpFlagKILLMUSIC: Don't kill playing music during the warp.

		Their values are:
		warpFlagKILLSCRIPTDRAWS 0x01
		warpFlagKILLSOUNDS 0x02
		warpFlagKILLMUSIC 0x04

		Add them together to calculate a flag.

	forcedir:
		You can either accept the engine's setting for what Link's Dir should be
		after warping him, or force a dir.

int PitPullDir;
 * Returns the direction that the Hero is being pulled in by a pit
 * Read-only

int PitPullTimer;
 * A timer related to pits pulling the hero
 * The pit will only pull the hero on frames where 'PitPullTimer % PitSensitivity == 0'
 * The Pit Sensitivity is an attribyte on the pit combo
 * Read-Write

int Falling;
 * The timer indicating how long left the Hero will be falling
 * If 0, the Hero is not falling
 * Max value of 70, which is the value when you begin falling
 * Writing 'Hero->Action = LA_FALLING' is identical to setting this to 70.
 * Read-Write

int FallCombo;
 * The pit combo that the Hero is falling into
 * If non-zero, this combo's attributes will affect things such as if the Hero will warp,
 *     and how much damage they will take upon finishing falling.
 * If ==0, the Hero will take 1/4 heart of damage, and not warp
 * Writing 'Hero->Action = LA_FALLING' will overwrite this value
 * Writing to '->Falling' will overwrite this value
 * Read-Write

bool MoveFlags[2];
 * Flags relating to movement.
 * See 'HEROMV_' constants in std_constants.zh for values
 * [0] == Obeys gravity (see ->Gravity)
 * [1] == Can fall in pitfalls
 * Read-Write

/************************************************************************************************************/

________          __             _________ __                        __          
\______ \ _____ _/  |______     /   _____//  |________ __ __   _____/  |_  ______
 |    |  \\__  \\   __\__  \    \_____  \\   __\_  __ \  |  \_/ ___\   __\/  ___/
 |    `   \/ __ \|  |  / __ \_  /        \|  |  |  | \/  |  /\  \___|  |  \___ \ 
/_______  (____  /__| (____  / /_______  /|__|  |__|  |____/  \___  >__| /____  >
        \/     \/          \/          \/                         \/          \/ 
The following are the members of data struct pointers (combo, sprite, item, npc, message, game, cheat, warpring, shop, map, and dmap data).

//////////////////
///  itemdata  ///
//////////////////								// Itemdata

int ID;		
 * Returns the item number of the item in question.

bool EquipmentItem;
 * Identical to bool Keep, but with more logical naming.

int Damage;
 * The damage produced by weapons generated from tis item.
 * Identical to itemdata->Power, provided for uniformity it weapons.

void RunScript(int mode);
 * Runs the script assigned to this item at any arbitrary time.
 * Mode Settings:
 * 0 : SCRIPT_MODE_END 
 * 	THIS TERMINATES THE RUNNING SCRIPT.
 * 1: SCRIPT_MODE_NORMAL
 * 	Runs the script either once, or perpetually, based on the ZScript Rule.
 * 2: SCRIPT_MODE_PERPETUAL
 * 	Runs the script perpetually, even if the QR if off. 

int Family;
int Type;
 * The Family (Item Class) of the item.

int WeaponScript;
 * The weapon action script assigned to this item.

int WeaponInitD[8];
 * The eight InitD args used by the weapon script for this item.

int Modifier;	
 * The Link Tile Modifier

int Tile;	
 * The tile used by the item.

int CSet;	
 * The CSet of the tile used by the item.
	
int Flash;		
 * The Flash value for the CSet
	
int AFrames;		
 * The number of animation frames in the item's tile animation. 

int ASpeed;		
 * The speed of the item's animation.
	
int Delay;	
 * The Delay value, before the animation begins. 

int Script;		
 * The Action Script for the item.

int PScript;	
 * The Pickup Script for the item.

int MinHearts;		
 * The minimum number of hearts required to pick up the item.

untyped Attributes[10] 
 * An array of ten integers that correspond to the ten <Misc> text entries on the item editor Data tab.
 * Now datatype-insensitive.

int Sprites[10]
 * An array of ten integers that correspond to the ten sprite pulldowns on the item editor Action tab.

bool Flags[16]
 * An array of 16 boolean flags that correspond to the 16 flag tickboxes on the item editor Flags tab.

bool Combine;	
 * Corresponds to 'Upgrade when collected twice'.
	
bool Downgrade;	
 * Corresponds to the 'Remove When Used' option on the Action tab of the item editor. 
	
bool KeepOld;
 * Corresponds to 'Keep Lower Level Items' on the Pickup tab of the item editor. 
 
bool Validate;
 * Corresponds to 'Only Validate Cost' on the Action tab of the item editor
	
bool RupeeCost;	
 * Corresponds to the 'Use Rupees Instead of Magic' option on the item editor 'Action' tab.
 * Deprecated by CostCounter.
	
bool Edible;	
 * Corresponds to the 'Can be Eaten by Enemies' box on the Pickup tab of the item editor. 
	
bool GainLower;	
 * Corresponds to the 'Gain All Lower Level Items' box on the Pickup tab of the item editor. 

untyped InitD[8];
 * The eight D* args used by both item scripts. Accepts all datatypes.

int Family;
 * The item class.

int Level;
 * The item's Level.

int Power; 
 * The amount of damage generated by the primary weapon for this item, if any.

int Amount;
int Max; 
int MaxIncrement;
int Keep;
int Counter; //should be renamed to IncreaseCounter

int MagicCostTimer;
int CostTimer;
 * The number of frames between counter decrements, when using an item with a perpetual 
 * 	upkeep cost, such as Boots and Cane items.

int UseSound;
 * The sound that will play when the item is used.

int Pickup; 
 * The Pickup type for this item See IP_* in std_constants.zh.
	
int PickupFlags;
 * A flagset used by the Item Editor UI to determine special conditions for item pick-up.
 * Values are ORd together:
 *
 *

int PickupString;
 * The ZQ String Editor (message) string that will appear when Link collects this item.
 * Note: The exact nature of hw frequently the string will be shown per game session can be
 *	modified using 'int PickupStringFlags'.

int PickupStringFlags;
 * A flagset that determines how frequently the PickupString for an item is displayed per game session.
 * You may set the string to always show, only show once per game session, or other intervals
 * using the following flagset (values are ORd together):
 *
 *
 *

int MagicCost;
int Cost;
 * The cost of the item, in units. Whenever the item is used, this value is decremented from 
 * 	the counter supplied to 'CostCounter'. 
 * If the item runs for more than one frame, this amount will be decremented every n frames,
 * 	where n is the value of 'CostTimer'.

int CostCounter;
 * The counter to use when decrementing the item cost. The default is 'CR_MAGIC'.
 * Some item classes (e.g. Bombs) reduce a counter, whether this is set or not.
 * In the case that this is set on such an uitem, it acts as a secobdary cost.

int DrawXOffset;
 * The horizontal draw offset of the item. 
 * Note: SizeFlags[??] must be enabled for this to function.
	
int DrawYOffset;
 * The vertical draw offset of the item. 
 * Note: SizeFlags[??] must be enabled for this to function.

int HitXOffset;
 * The horizontal hitbox offset of the item. 
 * Note: SizeFlags[??] must be enabled for this to function.

int HitYOffset;
 * The vertical hitbox offset of the item. 
 * Note: SizeFlags[??] must be enabled for this to function.

int HitWidth;
 * The hitbox width (X component), in pixels, for the enemy.
 * Note: SizeFlags[??] must be enabled for this to function.

int HitHeight;
 * The hitbox height (Y component), in pixels, for the enemy. 
 * Note: SizeFlags[??] must be enabled for this to function.

int TileWidth;
 * The drawn width (X component) of the item in increments of one tile.
 * Note: SizeFlags[??] must be enabled for this to function.
	
int TileHeight;
 * The drawn height (Y component) of the item in increments of one tile.
 * Note: SizeFlags[??] must be enabled for this to function.

int Weapon;
 * The weapon type that this weapon mimics for the purpose of 
 * calculating the defence outcome when the weapon strikes an enemy,
 * and for determining what combos and secrets it can trigger. 
 * Set to -1 to disable and use the real weapon type/ID.

int Defense;
int Defence;
 * The default defence resolution (e.g. OHKO) that the weapon uses
* when it strikes an enemy. If this is set to anythin gother than -1,
* and the enemy had a defence resolution of 'None', then this default
* defence resolution is used in place of 'None'. 

untyped WeaponInitD[8];
 * An array of the eight D[] args used by the script attached to this weapon.
 
untyped WeaponMisc[32];
 * An array the 32 Misc[] values used by the weapon. 
 * This may be only partially implemented. 
 
int WeaponScript;
 * The weapon script attached to this weapon, when the item generates it.
 
int WeapomnHitXOffset
 * The default HitXOffset used by this weapon when the item generates it.
 
int WeaponHitYOffset;
 * The default HitYOffset used by this weapon when the item generates it.
 
int WeaponHitHeight;
 * The default HitHeight used by this weapon when the item generates it.
 
int WeaponHitWidth;
 * The default HitWidth used by this weapon when the item generates it.
 
int WeaponHitZHeight;
 * The default HitZHeight used by this weapon when the item generates it.
 
int WeaponDrawXOffset; 
 * The default DrawXOffset used by this weapon when the item generates it.
 
int WeaponDrawYOffset;
 * The default DrawYOffset used by this weapon when the item generates it.
 
int WeaponDrawZOffset;
 * The default DrawZOffset used by this weapon when the item generates it.

int OverrideFlags;
int SizeFlags;
 * A flagset that determines which Item Editor 'Size' tab attribute values are applied to the
 * item, overriding engine defaults.
 
int WeaponOverrideFlags;
 * A flagset that determines which Item Editor 'Size' tab attribute values are applied to the
 * weapon generated by this item, overriding engine defaults. 

void GetName(int buffer[]);
 * Loads the item's name into 'buffer'.
 
//! NOT IMPLEMENTED, or NOT FULLY-IMPLEMENTED. 
 
int Range;
 * The distance that the weapon is allowed to travel. 
 * See weapon->Distance;
 * Not implemented at this time.
 
int Duration;
 * The duration of the weapon.
 * See weapon->Duration.
 * Not implemented at this time.
 
int Duplicates;
 * The number of extra weapons that this weapon creates.
 * Not implemented at this time.
 
int DrawLayer; 
 * The layer used to draw the weapon to the screen.
 * Not implemented at this time.
 
int CollectFlags;
 * The items (in CSV format, using a SCV list ID) that the weapon created
 * by this item, collects on contact.
 * Not implemented at this time.

t/b/a
itemdata GetItem(name[]);

/************************************************************************************************************/

/////////////////////
///  messagedata  ///
/////////////////////								// Messagedata

void Set(int buffer[]);
 * Assigns the ZString buffer[] to the messagedata pointer's string.

void Get(int buffer[]);
 * Copies the string value from the messagedata pointer, to the array buffer[].


int buffer_str[80];

int Next;
 * Next message in list.

int Tile;
 * The tile for the background

int CSet;
 * The CSet for the background

int Font;
 * The message font

int X;
 * The messagebox X position

int Y;
 * The messagebox Y position

int Width;
 * The messagebox Width

int Height;
 * The messagebox Height

int Sound;
 * The text advancing SFX

int ListPosition;
 * The position in the list

int VSpace;
 * The space vertically between lines, in pixels

int HSpace;
 * The space horizontally between characters, in pixels

bool Flag[7];
 * A set of flags
 * MSGFLAG_WRAP         - If the text wraps around the bounding box
 * MSGFLAG_CONT         - If the message is the continuation of a previous one
 * MSGFLAG_CENTER       - Reserved
 * MSGFLAG_RIGHT        - Reserved
 * MSGFLAG_FULLTILE     - If the background tile should be treated as the UL of a tile block,
 *                        instead of the UL of a 2x2 adjustable frame
 * MSGFLAG_TRANS_BG     - If the background should be translucent
 * MSGFLAG_TRANS_FG     - If the text should be translucent

int PortraitTile;
 * The upper-left corner tile of the portrait.
 * If 0, no portrait will be displayed.

int PortraitCSet;
 * The CSet of the portrait

int PortraitX;
 * The X position of the portrait

int PortraitY;
 * The Y position of the portrait

int PortraitTileWidth;
 * The Tile Width of the portrait.
 * If 0, no portrait will be displayed.
 * Max value 16

int PortraitTileHeight;
 * The Tile Width of the portrait.
 * If 0, no portrait will be displayed.
 * Max value 14

int TextWidth;
 * Returns the width, in pixels, of the message.
 * This uses the font and text as set in the 'Strings' editor,
 * 	and ignores both trailing spaces and line breaks.
 * Read-Only

int TextHeight;
 * Returns the height, in pixels, of the message.
 * This uses the font as set in the 'Strings' editor, and ignores line breaks.
 * Read-Only
	
//////////////////
///  dmapdata  ///
//////////////////								// DMapdata

	1.	Sideview Gravity on All Screens (uses Dmaps[].sideview, new var.
	2.	Layer 3 is Background on All Screens (uses DMaps[].flgs&dmfLAYER3BG)
	3.	Layer 2 is Background on All Screens (uses DMaps[].flgs&dmfLAYER2BG
	
int ID;
 * Read-only. 
 * This returns the DMap ID for a given dmapdata pointer.

int Map;
 * The game map used by the dmap.
 
int Level;
 * The Level ID of the DMap.
 
int Offset;
 * The DMap offset.
 
int Compass;
 * The screen where the compass marker appears in the minimap.
 
int Palette;
 * The level palette used by the dmap. 
 * Equivalent to Game->LevelPalette[this->ID].
 
int MIDI;
 * The MIDI ID used by the DMap.
 
int Continue;
 * The screen on which the player spawns on the DMap.
 
int Type;
 * The DMap type. Legal types are:
 * 0: NES Dungeon
 * 1: NES Overworld
 * 2: Interior
 * 3: BS Overworld
 
int MusicTrack;
 * The enhanced musiic tracker file track ID.
 
int ActiveSubscreen;
 * The active subscreen ID.
 
int PassiveSubscreen;
 * The passive subscreen ID.
 
int Grid[8];
 * The rooms displayed either when the player has the map item,
 * or when visiting rooms, marked in the DMap editor.
 * See the functions in dmapgrid.zh to access these values.
 
int MiniMapTile[2];
 * The first tile ID used by passive subscreen minimap tile block.
 * Index [0] is the small minimap without the map item, and [1] is the minimap with the map item.
 
int MiniMapCSet[2];
 * The CSet used by the passive subscreen minimap tiles.
 * Index [0] is the small minimap without the map item, and [1] is the minimap with the map item.
 
int MapTile[2];
 * The first tile ID used by active subscreen dungeon map tile block.
 * Index [0] is the map without the map item, and [1] is the map with the map item.
 
int MapCSet[2];
 * The CSet used by the active subscreen dungeon map tiles.
 * Index [0] is the map without the map item, and [1] is the map with the map item.
 
int DisabledItems[256];
 * The items that are disabled on the active subscreen for this DMap.
 
int Flags;
 * The flags used by the DMap. These are OR'd together. 
 * The values are:
 * #define dmfCAVES			0x0001
 * #define dmf3STAIR			0x0002
 * #define dmfWHIRLWIND			0x0004
 * #define dmfGUYCAVES			0x0008
 * #define dmfNOCOMPASS			0x0010
 * #define dmfWAVY 			0x0020
 * #define dmfWHIRLWINDRET		0x0040
 * #define dmfALWAYSMSG   		0x0080
 * #define dmfVIEWMAP       		0x0100
 * #define dmfDMAPMAP         		0x0200
 * #define dmfMINIMAPCOLORFIX 		0x0400
 * #define dmfSCRIPT1 			0x0800
 * #define dmfSCRIPT2 			0x1000
 * #define dmfSCRIPT3 			0x2000
 * #define dmfSCRIPT4 			0x4000
 * #define dmfSCRIPT5 			0x8000
 
bool Sideview;
 * If true, all screens on the DMap are treated as sideview
 * UNLESS the screen flag Toggle Sideview is enabled.
 * If calse, all screens on the DMap are treated as overhead
 * UNLESS the screen flag Toggle Sideview is enabled.
 
int Script;
 * The standard DMap Active Script ID.

untyped InitD[8];
 * The eight script args for the dmapdata active script that runs 
 * on this DMap. 

int ASubScript;
 * The 'Active Subscreen' script slot ID
int PSubScript;
 * The 'Pctive Subscreen' script slot ID

untyped SubInitD[8];
 * The eight script args shared by the active/passive subscreen
 * script slots on this DMap.
	
void SetName(char32 buffer[]);
 * Copies the contents of the client array 'buffer' over the original 
 * DMap name. 
 * UNIMPLEMENTED at this time.
 
void GetName(char32 buffer[]);
 * Copies the name of the DMap into a client string 'buffer'.
 * UNIMPLEMENTED at this time.

void SetTitle(char32 buffer[]);
 * Copies the contents of the client array 'buffer' over the original 
 * DMap title. 
 * UNIMPLEMENTED at this time.
 
void GetTitle(char32 buffer[]);
 * Copies the title of the DMap into a client string 'buffer'.
 * UNIMPLEMENTED at this time.
 
void SetIntro(char32 buffer[]);
 * Copies the contents of the client array 'buffer' over the original 
 * DMap intro text. 
 * UNIMPLEMENTED at this time.
 
void GetIntro(char32 buffer[]);
 * Copies the intro text of the DMap into a client string 'buffer'.
 * UNIMPLEMENTED at this time.

void SetMusic(char32 "filename"); 
 * Sets the enhanced music used by the DMap to a specified filename.
 * UNIMPLEMENTED at this time.
 
void GetMusic(char2 buffer[]);
 * Copies the filename of the DMap enhanced music into a client string 'buffer'.
 * UNIMPLEMENTED at this time.


//////////////////
///  shopdata  ///
//////////////////								// Shopdata

int Type;
 * Returns the shop type for the current shopdata pointer where:
 * 0: Invalid
 * 1: Item Shhop
 * 2: Info Shop
 * This is read-only and solely based on the internal value of the pointer.
 
int Price[3];
 * Valid for both item and innformation shop types.
 * The trhree prices for items or information in the shop. 
 * [0] is leftmost, [1] is middle, [2] is rightmost.
 
int String[3];
 * Valid for both item and innformation shop types.
 * For info shops, these are the IDs of the three hint strings that you can buy.
 * For item shops, these are the IDs of the three strings displayed when you buy an item.
 * [0] is leftmost, [1] is middle, [2] is rightmost.

int Item[3];
 * Valid ONLY for item shop types.
 * The IDs of the items sold by the shop.
 * [0] is leftmost, [1] is middle, [2] is rightmost.
 
bool HasItem[3];
 * Valid ONLY for item shop types.
 * Enables the sale of items in each of the three positions.
 * [0] is leftmost, [1] is middle, [2] is rightmost.
 
Note: The message displayed when entering a shop is Screen->String, or mapdata->String.

/////////////////
///  mapdata  ///
/////////////////								// Mapdata

int Map;
 * Returns the map that this mapdata points to
 * Read-Only

int Screen;
 * Returns the screen that this mapdata points to
 * Read-Only

bool LayerInvisible[7];
 * If true, the current layer is invisible.
 * Writing this true for layers 1 through 6 will make those layers invisible.
 
bool ScriptDraws[8];
 * If true, the ZC engine will perform script draws ont he given
 * queue layer. 
 * Each queue layer returns true by default. 
 * Writing this false disables script draws targetted to a specific layer queue. 

int Script; 
 * Returns the ID of the script set to the mapscreen, or sets the script that this mapscreen runs.
 
untyped InitD[8];
 * The eight script args for the script that runs on this mapscreen.

bool isSolid(int x, int y);
 * As Screen->isSolid(int x, int y), for any mapscreen.

bool isSolidLayer(int x, int y, int layer);
 * As Screen->isSolidLayer(int x, int y, int layer), for any mapscreen.

int Valid;
 * ?

int Guy;
 * The screen guy.

int String;
 * The screen string.

int RoomType;
 * The screen room type.

int Item; 
 * The screen item.
 * Note: The NULL value is '0', which is a valid item.
 * 	To determine if there is an item on the screen, if you ever assigned
 * 	item 0 as a valid screen item in your quest, you will also want to read
 * 	HasItem for that screen.

int HasItem;
 * If not zero, then the item for this screen will be shown.
 * When Link takes the item on a screen, this is set to 0.

int TileWarpType[4];
 * The Tile Warp type for Tile Warps A, B, C, and D; [0], [1], [2], and [3] respectively.
 * See std_constants.zh TWTYPE_* constants for valid types.
	
bool SideWarpOverlay[4];
bool TileWarpOverlay[4];
 * Set or get the overlay state for the warp ID corresponding to the index of this array.

int DoorComboSet;
 * The doorset used by the screen, for NES dungeon doors.

int SideWarpReturnSquare[4];
 * The return square (A->D) used by Side Warp[A->D].

int TileWarpReturnSquare[4];	
 * The return square (A->D) used by Tile Warp[A->D].

int WarpReturnX[4];
 * The X-component for each of the four 2.50+ (blue) warp return squares.
	
int WarpReturnY[4];
 * The Y-component for each of the four 2.50+ (blue) warp return squares.
	
int WarpReturnC;
 * Stores the information on warp returns, butwise.
 * Deprecated by SideWarpReturnSquare[4] and TileWarpReturnSquare[4].
 * The bits are DDCCBBAADDCCBBAA, where the left section is sidewarp returns, and the right is tilewarp returns.

int StairsX;
 * The X component for where a Stairs secret appears on the screen.
	
int StairsY;
 * The Y component for where a Stairs secret appears on the screen.
	
int ItemX;
 * The X component for the item location on the screen.
	
int ItemY;
 * The Y component for the item location on the screen.

int Palette;
int CSet;
 * ? The screen palette. ?

int Door[4];
 * The door state for the screen. See D_* constants for direction and door type.
	
int TileWarpDMap[4];
 * The destination DMap for each of the four warp types.
	
int TileWarpScreen[4];
 * The destination screen for each of the four warp types.

int Enemy[10];
 * The IDs of the enemies that spawn on the screen.

int EnemyFlags;
 * A flagset for enemies on the screen (E.Flags).
 * Valid values (ORd) together, are:
 *
 *

int Pattern;
 * This enemy 'Spawn Pattern'.
 * Use the PATTERN_* constants in std.zh for the valid values

int SideWarpID[4];
 * Returns the sidewarp ID for a given screen edge, as SideWarpID[dir];
 * Returns -1 if there is no sidewarp in that direction.
 * Use the SIDEWARP_* constants in std.zh for the value of this (read return value, or write value).
 * Use the DIR_* constants in std.zh for the index values.

int SideWarpType[4];
 * The Sidewarp type for Sidewarps A, B, C, and D; [0], [1], [2], and [3] respectively.
 * See std_constants.zh SWTYPE_* constants for valid types.
	
int SideWarpScreen[4];
 * The destination screen for each of the four sidewarps.
	
int SideWarpDMap[4];
 * The destination DMap for each of the four sidewarps.
	
int SideWarpIndex;
 * The warp return IDs. Deprecated by SideWarpID[].

int WarpArrivalX;
 * The X-component for the pre-2.50 (green) arrival square.
	
int WarpArrivalY;
 * The X-component for the pre-2.50 (green) arrival square.
	
int MazePath[4]; 
 * The four Maze Path directions.

int ExitDir;
 * The Maze Path 'Exit Direction'.

int UnderCombo;
 * The undercombo ID used by the screen.

int UnderCSet;
 * The CSet of the undercombo used by the screen.

int Catchall;
 * The screen 'Catchall' value. 

int CSensitive;
 * The value of Damage Combo Sensitivity for the screen.
	
int NoReset;
 * The No Reset Flagset. Values are ORd together s follows:
 * Secrets		0x
 * Items		0x
 * Special Item		0x
 * Lock Block		0x
 * Boss Lock Block	0x
 * Chest		0x
 * Secrets		0x
 * Locked Chest		0x
 * Boss Locked Chest	0x
 * Door Up [0]		0x
 * Door Down[1]		0x
 * Door Left [2]	0x
 * Door Right [3]	0x

int NoCarry;
 * The No Carry Over Flagset. Values are ORd together s follows:
 * Secrets		0x
 * Items		0x
 * Special Item		0x
 * Lock Block		0x
 * Boss Lock Block	0x
 * Chest		0x
 * Secrets		0x
 * Locked Chest		0x
 * Boss Locked Chest	0x

int LayerMap[7];
 * The Map IDs used by screen layers 1 through 6, represented as [1] through [6].
 * Index [0] does nothing, and trying to access it will report an error to the log.

int LayerScreen[7];
 * The Screen IDs used by screen layers 1 through 6, represented as [1] through [6].
 * Index [0] does nothing, and trying to access it will report an error to the log.

int LayerOpacity[7];
 * The opacity value for each layer used by this screen.
 * Valid layers are 1 through 6, represented as [1] through [6].
 * Index [0] does nothing, and trying to access it will report an error to the log.

int TimedWarpTimer;
 * The timer used by 'Time Warp Tics' in Screen Data->T.Warp

int CarroverMap;
int NextMap;
 * The map to where secrets on the current mapscreen carry over.
 * Corresponds to the Screen Data>>>Screen State Carryover 'Next Map' 
 * selection in the ZQ Editor.
 
int CarryoverSrceen;
int NextScreen;
 * The screen to where secrets on the current mapscreen carry over.
 * Corresponds to the Screen Data>>>Screen State Carryover 'Next Screen' 
 * selection in the ZQ Editor.

int SecretCombo[128];
 * The Combo IDs used by 'Secret Combos' on this screen.
 * See SCR_SEC_* in std_constants.zh for more information.
	
int SecretCSet[128];
 * The CSets used by 'Secret Combos' on this screen.
 * See SCR_SEC_* in std_constants.zh for more information.
	
int SecretFlags[128];
 * The Combo Flags used by 'Secret Combos' on this screen.
 * See SCR_SEC_* in std_constants.zh for more information.
	
int ViewX;
 * Unused at this time. Represents the visible width of the screen.

int ViewY;
 * Unused at this time. Represents the visible height of the screen.

int Width;
 * Unused at this time. Represents the physical;e width of the screen.

int Height;
 * Unused at this time. Represents the physical height of the screen.

int EntryX;
 * The X-coordinate at which Link entered the screen (his last spawn point).
 * If Link is respawned by falling in water, he will appear at this X-component. 

int EntryY;
 * The Y-coordinate at which Link entered the screen (his last spawn point).
 * If Link is respawned by falling in water, he will appear at this Y-component. 

int ScriptEntry;
 * Unused. Originally intended as a way to detect if ffcs should run on loading a screen.

int ScriptOccupancy;
 * Unused. Originally intended as a way to detect if ffcs should run while a screen is active.

int ExitScript;
 * Unused. Originally intended as a way to detect if ffcs should run on leaving a screen.

int OceanSFX;
 * The 'Ambient Sound' under S.Data2. 
 * Rename this to AmbientSFX, or just SFX.

int BossSFX;
 * The Boss Roar sound for this screen.
	
int SecretSFX;
 * The sound that will play on this screen, when secrets are triggered.

int ItemSFX;
 * The sound that will play if Link holds an item over his head on this screen.
	
int MIDI;
 * The MIDI that plays on this screen.

int LensLayer;
 * The layer to which Lens of Truth graphics are drawn.

int Flags[10];
 * A set of flagsets that contain special data for thiws screen.
 * These represent S.Flags1 and S.Flags2 flags.
 * See std_constants.zh (SFG* for the screen flag froup, 
 *	and SFX* for the screen flag value) for more information. 
	
int D[8];
 * Improperly implemented. Was meant to relate as Screen->D, except that
 * 	Screen->D is not bound to layermap.

int ComboD[176];
 * The IDs of each of the 176 combos used on the screen.

int ComboC[176];
 * The CSets of each of the 176 combos used on the screen.

int ComboF[176];
 * The placed (map) flags for each of the 176 combo positions used by this screen.

int ComboS[176];
 * The inherent flags of each of the 176 combos used on the screen.

int State[32];
 * The screen states used by this screen. Identical to Screen->State[], but for mapdata screens.

int EFlags[3];
 * The Screen Data E.Flags flagsets. 
 * Values are:
 *

int NumFFCs[33];
 * The number of ffcs set up on the current screen.
 * Index [0] is unused, to match internal ZQ Editor FFC numbering.
 * Thus, this returns true/false for indices [1] through [32],
 * which equate to FFC IDs 1 through 32 on the current mapscreen.

int FFCEffectWidth[32];
 * The EffectWidth variable for each of the 32 ffcs on the screen.
 * See ffc->EffectWidth for more details. 
		
int FFCEffectHeight[32];
 * The EffectHeight variable for each of the 32 ffcs on the screen.
 * See ffc->EffectHeight for more details. 
	
int FFCTileWidth[32];
 * The TileWidth variable for each of the 32 ffcs on the screen.
 * See ffc->TilwWidth for more details. 
	
int FFCTileHeight[32];
 * The TileHeighr variable for each of the 32 ffcs on the screen.
 * See ffc->TilwHeight for more details. 

int FFCData[32];
 * The Data (combo ID) variable for each of the 32 ffcs on the screen.
 * See ffc->Data for more details. 
	
int FFCCSet[32];
 * The CSet variable for each of the 32 ffcs on the screen.
 * See ffc->CSet for more details. 
	
int FFCDelay[32];
 * The Delay variable for each of the 32 ffcs on the screen.
 * See ffc->Delay for more details. 
	
int FFCX[32];
 * The X variable for each of the 32 ffcs on the screen.
 * See ffc->X for more details. 
	
int FFCY[32];
 * The Y variable for each of the 32 ffcs on the screen.
 * See ffc->Y for more details. 
	
int FFCVx[32];
 * The Vx variable for each of the 32 ffcs on the screen.
 * See ffc->Vx for more details. 
	
int FFCVy[32];
 * The Vy variable for each of the 32 ffcs on the screen.
 * See ffc->Vy for more details. 
	
int FFCAx[32];
 * The Ax variable for each of the 32 ffcs on the screen.
 * See ffc->Ax for more details. 
	
int FFCAy[32];
 * The Vy variable for each of the 32 ffcs on the screen.
 * See ffc->Vy for more details. 
	
int FFCFlags[32];
 * The Flags variable for each of the 32 ffcs on the screen.
 * See ffc->Flags for more details. 
	
int FFCLink[32];
 * The Link variable for each of the 32 ffcs on the screen.
 * See ffc->Link for more details. 
	
int FFCScript[32];
 * The Script variable for each of the 32 ffcs on the screen.
 * See ffc->Script for more details. 
	
bool FFCRunning[32];
 * Returns true if the specified ffc is running a script?
 * May be used to pause/resume ffc script execution?
 * This needs to be cloned over to ffc->Running -Z

 //Functions
int GetFFCInitD(int ffc_index, int n);
 * Returns the value of InitD[n] for the ffc on the screen with an ID of ffc_index.
 * This needs to be converted to the type 'untyped' to comply
 * 	with the change of float ffc->InitD[] to untyped ffc->InitD[]
 * 	Note: Expressed as a function due to lack of 2D arrays in ZScript. 
 * 	With 2D arrays, this would simply be FFCInitD[32][8].

void SetFFCInitD(int ffc_index, int n, float value);
 * Sets the value of InitD[n] for the ffc on the screen with an ID of ffc_index.
 * 'int value' needs to be converted to the type 'untyped' to comply
 * 	with the change of float ffc->InitD[] to untyped ffc->InitD[]
 * 	Note: Expressed as a function due to lack of 2D arrays in ZScript. 
 * 	With 2D arrays, this would simply be FFCInitD[32][8].


int GetFFCInitA(int ffc_index, int n);
 * Returns the value of InitA[n] for the ffc on the screen with an ID of ffc_index.
 * 	Note: Expressed as a function due to lack of 2D arrays in ZScript. 
 * 	With 2D arrays, this would simply be FFCInitA[32][2].


void SetFFCInitA(int ffc_index, int init_a, float value);
 * Sets the value of InitA[n] for the ffc on the screen with an ID of ffc_index.
 * 	Note: Expressed as a function due to lack of 2D arrays in ZScript. 
 * 	With 2D arrays, this would simply be FFCInitA[32][2].


///////////////////
///  combodata  ///
///////////////////								// Combodata

int Pos();
 * Returns the combo screen index of a combo from a combodata script, from the 'this->'
 * pointer as 'this->Pos()'.
 * Using this from any other combodata variable is illegal and undefined.

int PosX();
int X;
 * Returns the X-coordinate of a combo from a combodata script, from the 'this->'
 * pointer as 'this->PosX()'.
 * Using this from any other combodata variable is illegal and undefined.
 * If used as 'this->X', it is read-only.

int PosY();
int Y;
 * Returns the Y-coordinate of a combo from a combodata script, from the 'this->'
 * pointer as 'this->PosY()'.
 * Using this from any other combodata variable is illegal and undefined.
 * If used as 'this->Y', it is read-only.

int Script;
 * The combodata script used by this combo.

untyped InitD[2];
 * The two InitD args used by the combodata script for this combo.

int ID;
 * Returns the combo ID associated with the current combodata pointer.

int Type; 
 * The 'type' of the combo, in the Combo Editor. 
 * Setting this changes the combo type variables. ?

int OriginalTile; 
 * The original tile of the combo's animation. Writing to this will cause the combo
 * 	to shift to the new animation immediately.
 * Writing this variable is undefined if the quest rule 'New Combo Animation' is off.
 
int Tile; 
 * The tile ID used by the current animation frame of the combo.
 * Writing to this will cause the tile you write to display for at least 1 frame.
 * Writing this variable is undefined if the quest rule 'New Combo Animation' is off.
 
int Frame;
 * The frame of the combo's animation that is presently showing. Writing to this will skip in the animation.
 * Using this variable is undefined if the quest rule 'New Combo Animation' is off.

int AClk;
 * The clock used for the combo's animation cycle.

int ASpeed;
 * The animation speed of the combo. 
 
int Flip; 
 * The flip settings for the combo tile.
	
int Walk;
 * The walkability flags value. 
 * Walk flags are OR'd together using values of:
 *	
 *	

int CSet; 
* The CSet values for the combo.
 * 	How is CSet2 stored?

int Foo; 
 * Unused.

int Frames; 
 * The number of frames of animation.

int NextData;
 * 

int NextCSet; 
 *

int NextTimer; 
 *

int Flag; 
 * The inherent flag bound to the combo.

int SkipAnim; //needs to be renamed to SkipAnimX
 * Corresponds to 'A.SkipX' in the Combo Editor.

int SkipAnimY; 
 * Corresponds to 'A.SkipX' in the Combo Editor.

int AnimFlags;
 * This contains flag data for the Combo Editor settings:
 *	0x	Refresh Animation on Room Entry
 * 	0x 	Refresh Animation When Cycled To

int Expansion[6]; 
 * Reserved for future use by the Combo Editor.
	
int Attributes[4]; 
 * Corresponds to Attributes[0] through Attributes[3] on the 'Attributes 2'
 * 	tab in the Combo Editor.
 * Min value FLOAT_MIN, max value FLOAT_MAX.
 
 int Attribytes[4]; 
 * Corresponds to Attribytes[0] through Attribytes[3] on the 'Attributes 1'
 * 	tab in the Combo Editor.
 * Min value BYTE_MIN, max value BYTE_MAX.

int UserFlags;
 * Corresponds to the 'Misc Flags' on the Attributes tab of the Combo Editor.
 * These values are ORd together.

int TriggerFlags[3]; 
 * Corresponds to the flags on the 'Triggered By' tabs of the Combo Editor
 * 	where the indices and flag values are:
 *	
 *	

int TriggerLevel; 
 * Corresponds to the 'Minimum Level' field on the 'Triggered By (1)' tab of 
 *	the Combo Editor.

/* Combo Types
*	These values contain data that is used by ZC to determine the Combo Type.
*	Using combodata in ZScript, it is possible to define wholly new types
*	by combining sets of these values.
*/

int BlockNPC; 
int BlockHole; 
int BlockTrigger; 
int BlockWeapon[32];
int ConveyorSpeedX; 
int ConveyorSpeedY; 
int SpawnNPC; 
int SpawnNPCWhen; 
int SpawnNPCChange;
int DirChange; 
int DistanceChangeTiles; 
int DiveItem; 
int Dock; 
int Fairy; 
int FFCAttributeChange; 
int DecorationTile; 
int DecorationType; 
int Hookshot;
int Ladder; 
int LockBlock; 
int LockBlockChange; 
int Mirror; 
int DamageAmount; 
int DamageDelay;
int DamageType; 
int MagicAmount; 
int MagicDelay; 
int MagicType; 
int NoPushBlocks;
int Overhead; 
int PlaceNPC; 
int PushDir; 
int PushDelay; 
int PushHeavy; 
int Pushed; 
int Raft;
int ResetRoom; 
int SavePoint; 
int FreezeScreen; 
int SecretCombo; 
int Singular (self-only);
int SlowWalk; 
int Statue; 
int Step; 
int StepChange; 
int Strike[32]; 
int StrikeRemnants;
int StrikeRemnantsType; 
int StrikeChange; 
int StrikeItem; 
int TouchItem;	
int TouchStairs; 
int TriggerType; 
int TriggerSensitivity; 
int Warp; 
int WarpSensitivity;
int WarpDirect; 
int WarpLocation; 
int Water; 
int Whistle; 
int WinGame; 
int BlockWeaponLevel;

// t/b/a
//void GetLabel() / GetName()
//void SetLabel / SetName()
//combodata GetCombo(int label[])
//int Game->GetCombo(int name[])

	triggerflags[3]
	combodata->Attributes[] and Screen->GetComboAttribute(pos, indx) / SetComboAttribute(pos, indx)
	combodata->Flags and Screen->ComboFlags[pos] -- Maybe ComboMisc[pos] to avoid confusion?
	Combo QR rules will become ComboMisc[] ! 

	
/////////////////
///  npcdata  ///
/////////////////								// NPCData

/*
The npcdata datatype allows the user to load and manipulate Enemy Editor
data, and to r/w that information.

Like itemdata, this persists only until the quest exits.

To use npcdata, you must declare an npcdata typed pointer, then load a npc ID
to that pointer. 

npcdata nd = Game->LoadNPCData(1); // Load enemy ID 1 to the pointer 'nd'.

From here, you may access the member functions, and variables as normal:

nd->HP = 32;

*/

void GetName(int ptr[]);
 * Puts the text of the Enemy Name field into string 'ptr'.

void GetInitDLabel(int ptr[], int d_index);
 * Puts the text of the InitD label 'd_index' into string 'ptr'.

bool MatchInitDLabel("label", int d_index);
 * Compares string 'label' to the text of the InitD label field 'd_index'.
 * Returns true if they match.
 * Should be slightly faster than strcmp().

int Family;
int Type;
 * The Family (Enemy Class) of the npc.

int Script; 
 * The npc action script used by this enemy.

untyped InitD[8];
 * The eight InitD args used by the npc action script for this enemy.

int WeaponScript;
 * The weapon action script assigned to this enemy.

untyped WeaponInitD[8];
 * The eight InitD args assigned to the weapon script used by this enemy.

int Tile;
 * The base tile used by the enemy.

int Flags, 
int Flags2, 

int Width;
 * The 'width' (W) of base tile used by the enemy.

int Height;
 * The 'height' (H) of base tile used by the enemy.

int STile;
 * The base 'special' tile used by the enemy.

int SWidth;
 * The 'width' (W) of base 'special' tile used by the enemy.

int SHeight;
 * The 'height' (H) of base 'special' tile used by the enemy.

int ExTile;
 * The base EXPANDED ('New') tile used by the enemy.

int ExWidth;
 * The 'width' (W) of base EXPANDED ('New') tile used by the enemy.

int ExHeight;
 * The 'height' (H) of base EXPANDED ('New') tile used by the enemy.

int HP;
 * The enemy's base hit points.

int Family;
 * The 'Type' of the enemy.

int CSet, 
 * Thge CSet used to render the enemy.

int Anim;
 * The 'O.Anim' used by the enemy.

int ExAnim;
 * The 'E.Anim' used by the enemy.

int Framerate;
 * The 'O.Anim' animation framerate used by the enemy.

int ExFramerate;
 * The 'E.Anim' animation framerate used by the enemy.

int TouchDamage;
 * The amount of contact damage that the enemy causes when it collides with Link.

int WeaponDamage;
 * The power of the weapons fired by the enemy.

int Weapon;
 * The weapon type used by the enemy.

int Random;
 * The 'random rate' of the enemy.

int Haltrate;
 * The 'turn frequency' used by the enemy during its movement phase.

int Step;
 * The enem's step speed.

int Homing;
 * The homing factor of the enemy. Greater values home more keenly on Link. 

int Hunger;
 * The 'hunger' value of the enemy. 
 * Higher values make it more likely that the enemy is attracted to Bait.
 * Valid only for NPCT_WALKING enemies.

int Dropset;
 * The dropset used by the enemy.

int BGSFX;
 * The Ambient sound that the enemy emits.

int DeathSFX;
 * The sound that is played when the enemy dies.

int HitSFX;
 * The sound that is played when the enemy is hit by an lweapon.

int DrawXOffset;
 * The horizontal draw offset of the enemy. 
 * Note: SizeFlag[??] must be enabled for this to function.
	
int DrawYOffset;
 * The vertical draw offset of the enemy. 
 * Note: SizeFlag[??] must be enabled for this to function.
	
int DrawZOffset;
 * The depth draw offset of the enemy. 
 * Note: SizeFlag[??] must be enabled for this to function.
	
int HitXOffset;
 * The horizontal hitbox offset of the enemy. 
 * Note: SizeFlag[??] must be enabled for this to function.

int HitYOffset;
 * The vertical hitbox offset of the enemy. 
 * Note: SizeFlag[??] must be enabled for this to function.

int HitWidth;
 * The hitbox width (X component), in pixels, for the enemy.
 * Note: SizeFlag[??] must be enabled for this to function.

int HitHeight;
 * The hitbox height (Y component), in pixels, for the enemy. 
 * Note: SizeFlag[??] must be enabled for this to function.

int HitZHeight;
 * The hitbox height (Z component), in pixels, for the enemy. 
 * Note: SizeFlag[??] must be enabled for this to function.
	
int TileWidth;
 * The drawn width (X component) of the enemy in increments of one tile.
 * Note: SizeFlag[??] must be enabled for this to function.
	
int TileHeight;
 * The drawn height (Y component) of the enemy in increments of one tile.
 * Note: SizeFlag[??] must be enabled for this to function.
	
int WeaponSprite;
 * The sprite used to draw the enemy weapon.

int Defense[42];
 * The defense categories for the enemy.

int SizeFlag[2];
 * A set of flags that determine if the values for the Enemy Editor 'Size' tab
 * 	are rendered by the engine.

int Attributes[32];
 * The 'Misc. Attributes' of the enemy; now 32 of these; and datatype-insensitive.

bool Shield[5];
 * The shield status of the enemy.
 * [0] through [3] correspond to DIR* constants (wherein DIR_UP represents FRONT, and DIR_DOWN represents BACK)
 * [4] corresponds to 'Shield can be broken'.

int FrozenTile;
 * The base tile used to draw the enemy, when the enemy is frozen solid. //Not yet implemented in-engine.

int FrozenCSet;
 * The CSet value used to render the enemy, when the enemy is frozen solid. //Not yet implemented in-engine.

t/b/a
//int Movement[32]
//* The Movement Pattern values used by the enemy.
//int WeaponMovement[32]
//* The Weapon Movement Pattern values used by the enemy.

//FireSFX
//* The sound played when the enemy uses its weapon.



////////////////////
///  spritedata  ///
////////////////////								// Spritedata

/*
The spritedata datatype allows the user to load and manipulate weapon sprite struct
data, and to r/w that information.

Like itemdata, this persists only until the quest exits.

To use spritedata, you must declare a spritedata typed pointer, then load a sprite ID
to that pointer. 

spritedata sd = Game->LoadSpriteData(1); // Load weapon sprite 1 to the pointer 'sd'.

From here, you may access the member functions, and variables as normal:

sd->Tile = 600;

*/

int Tile;
 * The tile used by the weapon sprite.

int Misc;
 * The Misc Type. (or is this Type?)

int CSet;
 * The CSet used by the sprite.

int Frames;
 * The number of frames in the animation cycle.

int Speed;
 * The speed of the animation cycle.

int Type;
 * The Misc Type. (or is this Misc?)

//Where are Flash, and Flags?! -Z

/////////////////////
///  dropsetdata  ///
/////////////////////								// Dropsetdata

int Choose();
 * Returns a random item ID from the dropset
 * Returns -1 if 'nothing' is chosen.

int Items[10];
 * The item IDs stored in the dropset

int Chances[10];
 * The chances of each item stored in the dropset
 * These are not direct percentages, but weights.

int NothingChance;
 * The chance of nothing being dropped
 * This is not a percentage, but a weighted value

/* The following are planned, but yet to be implemented
	itemsprite Create(int x, int y);
	itemsprite Create(int x, int y, int z);
	 * Creates a random item from the dropset at the given coordinates
	 * Returns NULL if 'nothing' is chosen, as no item is created.

	void GetName(char[] buf);
	 * Loads the name of the dropset into the buffer

	void SetName(char[] buf);
	 * Sets the name of the dropset from the buffer
*/

t/b/a

//////////////////
///  ponddata  ///
//////////////////								// Ponddata

t/b/a

//////////////////
///  warpring  ///
//////////////////								// Warpringdata

t/b/a

/////////////////
///  doorset  ///
/////////////////								// Doorsetdata

t/b/a

////////////////////
///  misccolors  ///
////////////////////								// Miscdata

t/b/a

/////////////////
///  rgbdata  ///
/////////////////								// RGBata

t/b/a

/////////////////
///  palette  ///
/////////////////								// Palettedata

t/b/a

////////////////
///  zcmidi  ///
////////////////								// MIDI

t/b/a

//////////////////
///  palcycle  ///
//////////////////								// Palcycledata

t/b/a

//////////////////
///  gamedata  ///
//////////////////								// Gamedata

t/b/a

////////////////
///  cheats  ///
////////////////								// Cheatdata

t/b/a

  ________                    .__    .__                  ____      _________                        .___
 /  _____/___________  ______ |  |__ |__| ____   ______  /  _ \    /   _____/ ____  __ __  ____    __| _/
/   \  __\_  __ \__  \ \____ \|  |  \|  |/ ___\ /  ___/  >  _ </\  \_____  \ /  _ \|  |  \/    \  / __ | 
\    \_\  \  | \// __ \|  |_> >   Y  \  \  \___ \___ \  /  <_\ \/  /        (  <_> )  |  /   |  \/ /_/ | 
 \______  /__|  (____  /   __/|___|  /__|\___  >____  > \_____\ \ /_______  /\____/|____/|___|  /\____ | 
        \/           \/|__|        \/        \/     \/         \/         \/                  \/      \/ 
Commands for graphics, sound, text, and bitmap objects.

////////////////////
///  Graphics->  ///
////////////////////								// Graphics

int GetPixel(bitmap b, int x, int y);
 * Returns the palette index value for a pixel on a bitmap, at coordinates x, y on that bitmap.
 * The value is expressed as float at this time. 

int NumDraws();
 * Returns the number of script draws that have been executed during the current frame.
 
int MaxDraws();
 * Returns the maximum number of script draws per frame that you can execute in the current build.
 
void Monochrome(int mode);
 * Sets the entire display to monochrome output, using a hue mode that you may select, and either distributed,
 * or uniform colour distribution.
 * This respects the current DMap (level) palette, and it affects the entire main game palette. 

void MonochromeHue(int red, int green, int blue, bool distributed);
 * Sets the entire display to monochrome output, using either distributed using a uniform mode, or
 * a differential mode selected from `bool distributed`, using a hue based on the values that you supply
 * as `red`, `green`, and `blue`. 
 * This respects the current DMap (level) palette, and it affects the entire main game palette. 

void Tint(int red, int green, blue);
 * Tints the entire display with a palette shift using the values that you supply as `red`, `green`, and `blue`.
 * This respects the current DMap (level) palette, and it affects the entire main game palette. 

void ClearTint();
 * Clears all tints, and monochrome/greyscale states back to the original game palette, and normalises it for
   the given DMap palette. 

void Wavy(bool wavyin); 
 * Creates a wavy visual effect, identical to 'Wavy' Warp effects.
 * There are two styles, 'WavyIn', and 'WavyOut'. Select from these using parameter 1. 

void Zap(bool zapin);
 * Creates a wavy visual effect, identical to 'Zap' Warp effects.
 * There are two styles, 'ZapIn', and 'ZapOut'. Select from these using parameter 1. 

void Greyscale(bool enable);
 * Converts the game to monochrome greyscale, or reverts from greyscale to colour.
 * This is useful for simulating 'Gameboy' style displays.
	
int IsBlankTile[214500];
 * Returns 1 is the tile supplied as an index is blank, 0 is it is not blank.
 * Returns -1 if the user passed an invalid tile ID to the index.

/////////////////
///  Audio->  ///
/////////////////								// Audio

void PlayOgg(int filename[]);
 * Similar to PlayEnhancedMusic(), but only for OGG files.
 * Supports seeking, and other special instructions.

int GetOggPos();
 * Returns the current seek position of an OGG started with PlayOgg, in ms.

void SetOggPos(int new_pos);
 * Sets the play position for an OGG started with PlayOgg(), in ms.
 
void SetOggSpeed(int newspeed);
 * Sets the playback speed of an OGG started with PlayOgg();
 

void PlaySound(int soundid);	ZASM Instruction: 
					PLAYSOUNDR
					PLAYSOUNDV
	/**
	* Plays one of the quest's sound effects. Use the SFX_ constants in
	* std.zh as values of soundid.
	*/ Example Use: !#!
	
void EndSound(int soundid);
 * If sfx_id is playing, calling this immediately stops that sound.

void PauseSound(int soundid);
 * If sfx_id is playing, calling this pauses it, halting it from playing, in
 * a manner that you may later resume it from the point at which it was paused.
 * See also: Audio->ResumeSound(int sfx_id) and Audio->ContinueSound(int sfx_id).

void ResumeSound(int soundid); 
 * Resumes a sound effect with an ID of sfx_id, that has been paused.

void ContinueSound(int soundid);
 * Resumes a sound effect with an ID of sfx_id, that has been paused.

void AdjustMusicVolume(int percent); 
 * Adjusts the volume of all MIDI, DIGI, and Enhanced Music.
 * The parameter 'int percent' is the percentage of its present volume.
 * To double the volume, you would pass '200' to parameter 1; to reduce it by half, you
 *	would pass '50' to parameter 1.

void AdjustSFXVolume(int percent);
 * Adjusts the volume of all Soune Effects (WAV).
 * The parameter 'int percent' is the percentage of its present volume.
 * To double the volume, you would pass '200' to parameter 1; to reduce it by half, you
 *	would pass '50' to parameter 1.

void AdjustSound(int, int, bool)

void PauseCurMIDI();
 * Pauses the current MIDI in a manner that permits resuming it.
 * Note: This does not affect Enhanced Music playback.
 * See also: Audio->ResumeCurMIDI().

void ResumeCurMIDI();
 * Resumes MIDI playback, if it has been paused.
 * Note: This does not affect Enhanced Music playback.
 * See also: Audio->PauseCurMIDI().

void PlayMIDI(int MIDIid);	ZASM Instruction: 
					PLAYMIDIR
					PLAYMIDIV
	/**
	* Changes the current screen MIDI to MIDIid.
	* Will revert to the DMap (or screen) MIDI upon leaving the screen.
	*/ Example Use: !#!

bool PlayEnhancedMusic(int filename[], int track);
		
					ZASM Instruction: 
					PLAYENHMUSIC
	/**
	* Play the specified enhanced music if it's available. If the music
	* cannot be played, the current music will continue. The music will
	* revert to normal upon leaving the screen.
	* Returns true if the music file was loaded successfully.
	* The filename cannot be more than 255 characters. If the music format
	* does not support multiple tracks, the track argument will be ignored.
	*/ Example Use: 
	
		int music[]="myfile.mp3"; // Make a string with the filename of the music to play.
		if ( !Game->PlayEnhancedMusic(music, 1) ) Game->PlayMIDI(midi_id);
		
		// Plays the enhanced music file 'myfle.mp3', track 1. 
		// If the file is mssing, the game will instead play 
		// the midi specified as midi_id.

int PanStyle;
 * Set or get the audio panning. See PAN_* constants in std_constants.zh for valid values.

//int Volume[4]
 * Deprecated; raw access to the UI audio controls. (Now unsupported officially.)

////////////////
///  Text->  ///
////////////////								// Text

int FontHeight(int font);
int StringHeight(char32 ptr, int font);
int CharHeight(char32 chr, int font);
 * Returns the height, in pixels, of the given font.

int StringWidth(char32 ptr, int font);
 * Returns the width, in pixels, of the string pointed to by 'ptr', in the given font.
 * This is the width as DrawString() will draw it, so some special characters such as '\n'
 * 	may not be fully accurate, as DrawString() does not draw these properly.

int CharWidth(char32 chr, int font);
 * Returns the width, in pixels, of the character 'chr', in the given font.
 * This is the width as DrawString() will draw it, so some special characters such as '\n'
 * 	may not be fully accurate, as DrawString() does not draw these properly.

int MessageWidth(int msg);
 * Returns the width, in pixels, of the internal string at index 'msg'.
 * This uses the font and text as set in the 'Strings' editor,
 * 	and ignores both trailing spaces and line breaks.

int MessageHeight(int msg);
 * Returns the height, in pixels, of the internal string at index 'msg'.
 * This uses the font as set in the 'Strings' editor, and ignores line breaks.


////////////////
///  bitmap  ///
////////////////								// Bitmap

//void DrawPlane(int layer, int rt, int srcX, int srcY, 
//		int srcW, int srcH, int destW, int destH, 
//		int angle, int cx, int cy, int space_z, int horizon, 
//		int scale_x, int scale_y);
void DrawPlane(int layer, bitmap src, int src_x, int src_y, int dest_x,
			int dest_y, int dest_w, int dest_h, int space_z, int horizon, 
			float scale_x, float scale_y, bool mask);
 * Draws a scaled 'Mode 7' style effect, line-by-line, where each raster is scaled down toward 
 * a horizon point.
 
int Width;
 * Returns the width of the bitmap, in pixels. 
 * READ-ONLY. Bitmaps cannot be resized by writing to this. 
 
int Height;
 * Returns the height of the bitmap, in pixels. 
 * READ-ONLY. Bitmaps cannot be resized by writing to this. 

void Free();
 * If the bitmap is allocated, frees the bitmap.
 *     This means that this bitmap ID is able to be returned by subsequent
 *     calls to 'Game->AllocateBitmap()' and such.
 * Note: The bitmap will remain allocated until script draws are next cleared.
 *       This generally occurs at the end of each frame, unless 'Game->Suspend[]'
 *       is used to prevent it.
 * Once the bitmap is freed, any image data on it is deleted.

bool isValid();
 * Returns true if the bitmap points to a valid bitmap
 * A bitmap is valid when it has been created, and can be written to
 * A bitmap returned from `Game->AllocateBitmap()` is NOT valid, until it is created.
 
bool isAllocated();
 * Returns true if the bitmap points to an allocated bitmap
 * A bitmap which has not been allocated should not be used, and should be allocated with `Game->AllocateBitmap()` or created with `Game->CreateBitmap()`
 * A bitmap which has been allocated, but is not valid, cannot be written to; however, it can be used with `bitmap->Create()` or `bitmap->Read()`
 
float GetPixel(int x, int y);
 * Returns the palette index value of a pixel on the current bitmap pointer.

void Create(int layer, int width, int height);
 * Creates a bitmap on a bitmap pointer, with a size of height, width.
 * Destroys any existing bitmap on that pointer before creating a new one.
 * You can use this on an initialized bitmap pointer; either one allocated with 'Game->AllocateBitmap()', or
 *     a bitmap pointer that has a valid bitmap on it.
 * You can ALSO use this on an uninitialised pointer, and it will attempt to initialize it.
 *     The layer arg will be ignored when this is used on an uninitialised pointer.
 * Note: The 'layer' arg in this function is exclusively for ordering. 
 *       This WILL NOT clear a specific 'layer' of a bitmap. 
 *       Layers in ZC are only an expression of drawing order/sequence!
 
void Clear(int layer);
 * Clears the bitmap to colour 0. 
 * Note: The 'layer' arg in this function is exclusively for ordering. 
 *       This WILL NOT write out a specific 'layer' of a bitmap.
 *        Layers in ZC are only an expression of drawing order/sequence!
 
void ClearToColor(int layer, int color);
 * Clears the bitmap to the chosen color.
 * Note: The 'layer' arg in this function is exclusively for ordering. 
 *       This WILL NOT write out a specific 'layer' of a bitmap.
 *        Layers in ZC are only an expression of drawing order/sequence!
 
void Read(int layer, "filename");
 * Reads a valid graphic file into a bitmap pointer.
 * If used on an uninitialised pointer, it will first attempt to allocate it.
 *     If it fails to allocate the pointer, it will not attempt the read operation.
 * If the filename provided is invalid (e.g., the file is missing), the pointer
 * will be initialised with a blank bitmap at a size of 256x176.
 * If the quest rule "All bitmap-> and FileSystem-> paths relative to quest 'Files' folder" is on,
 *     then this will read a file relative to "[zc root]/Files/[quest name]/" instead of relative
 *     to "[zc root]".
 * Read() will fail if:
 *	The file is corrupt:
		PNG, JPEG, or other 'compressed' formats may abort if the file is corrupt.
 * 		Formats such as .BMP or .TGA may read up until missing data, as they are linear.
 * 	The file is missing.
 * 	The filename is incorrect. Remember that POSIX filesystems are Case-SenSitive. 
 
void Write(int layer, "filename", bool allow_overwrite);
 * Writes a bitmap out as a graphic file.
 * This supports the following formats/extensions:
 *     .png, .gif, .pcx, .tgx, and .bmp. 
 * The provided filename string MUST include one of these extensions, as this
 *     both sets the output filetype, and validates the write.
 * Any other extension, or a lack of a valid extension will result in
 *     logging an error and failing to write the file.
 * Will not replace an existing file unless allow_overwrite is true.
 * Will fail on an uninitialised pointer.
 * Will create any missing directories on the path.
 * Note: The 'layer' arg in this function is exclusively for ordering. 
 *       This WILL NOT write out a specific 'layer' of a bitmap.
 *        Layers in ZC are only an expression of drawing order/sequence!
 * If the quest rule "All bitmap-> and FileSystem-> paths relative to quest 'Files' folder" is on,
 *     then this will write a file relative to "[zc root]/Files/[quest name]/" instead of relative
 *     to "[zc root]".
 * Remember that POSIX filesystems are Case-SenSitive. 

void Blit	
	( 
		int layer, 
		bitmap target, 
		int source_x, int source_y, int source_w, int source_h, 
		int dest_x, int dest_y, int dest_w, int dest_h, 
		float rotation, int cx, int cy, int mode, int lit,  bool mask
	);
			
 * BLITS THE BITMAP ON POINTER 'b' TO A TARGET BITMAP. 
 * As DrawBitmapEx(), except that it draws FROM an initialised bitmap pointer,
 * TO a target bitmap, which may be a user-created bitmap, or it may be the screen.
 * To draw to the screen, or to one of the old system bitmaps, use the RT_* value from std_constants.zh
 *	as the argument to 'bitmap target'.
 * To draw to a user created bitmap, pass its pointer to 'bitmap target'.

void RevBlit 
void BlitTo 
	( 
		int layer, 
		bitmap source, 
		int source_x, int source_y, int source_w, int source_h, 
		int dest_x, int dest_y, int dest_w, int dest_h, 
		float rotation, int cx, int cy, int mode, int lit,  bool mask
	);
			
 * BLITS ANOTHER BITMAP TO THE POINTER 'b'.
 * As DrawBitmapEx(), except that it draws TO an initialised bitmap pointer,
 * FROM a source bitmap, which may be a user-created bitmap, or it may be the screen.
 * To draw to the screen, or to one of the old system bitmaps, use the RT_* value from std_constants.zh
 *	as the argument to 'bitmap source'.
 * To draw from a user created bitmap, pass its pointer to 'bitmap source.

void Rectangle(int layer, 
			int x, int y, int x2, int y2, 
			int color, float scale, 
			int rx, int ry, int rangle, 
			bool fill, int opacity		);
 * Identical to Screen->Rectangle(), but it draws to a target bitmap.

void Circle(int layer, 
		int x, int y, int radius, 
		int color, float scale, 
		int rx, int ry, int rangle, 
		bool fill, int opacity	);
 * Identical to Screen->Circle(), but it draws to a target bitmap.

void Arc(int layer, 
		int x, int y, int radius, int startangle, int endangle, 
		int color, float scale, 
		int rx, int ry, int rangle, 
		bool closed, bool fill, int opacity	);
 * Identical to Screen->Arc(), but it draws to a target bitmap.

void Ellipse(int layer, 
		int x, int y, int xradius, int yradius, 
		int color, float scale, 
		int rx, int ry, int rangle, 
		bool fill, int opacity);
 * Identical to Screen->Ellipse(), but it draws to a target bitmap.

void Line(int layer, int x, int y, int x2, int y2, 
		int color, float scale, 
		int rx, int ry, int rangle, 
		int opacity);
 * Identical to Screen->Line(), but it draws to a target bitmap.

void Spline(int layer, 
		int x1, int y1, int x2, int y2, #
		int x3, int y3,int x4, int y4, 
		int color, int opacity);
 * Identical to Screen->Spline(), but it draws to a target bitmap.

void PutPixel(int layer, int x, int y, 
		int color, 
		int rx, int ry, int rangle, 
		int opacity);
 * Identical to Screen->PutPixel(), but it draws to a target bitmap.

void DrawCharacter(int layer, int x, int y, 
			int font, int color, int background_color, 
			int width, int height, 'char', 
			int opacity );
 * Identical to Screen->DrawCharacter(), but it draws to a target bitmap.

void DrawInteger(int layer, int x, int y, 
			int font, int color, int background_color, 
			int width, int height, int number, int number_decimal_places, 
			int opacity);
 * Identical to Screen->DrawInteger(), but it draws to a target bitmap.

void DrawTile(int layer, int x, int y, 
		int tile, int blockw, int blockh, 
		int cset, int xscale, int yscale, 
		int rx, int ry, int rangle, 
		int flip, 
		bool transparency, int opacity);
 * Identical to Screen->DrawTile(), but it draws to a target bitmap.

void DrawTileCloaked(int layer, int x, int y,
		int tile, int blockw, int blockh,
		int flip);
 * Identical to Screen->DrawTileCloaked(), but it draws to a target bitmap.

void DrawComboCloaked(int layer, int x, int y,
		int combo, int tilewidth, int tileheight,
		int flip);
 * Identical to Screen->DrawComboCloaked(), but it draws to a target bitmap.

void DrawComboint layer, int x, int y, 
		int combo, int w, int h, 
		int cset, int xscale, int yscale, 
		int rx, int ry, int rangle, 
		int frame, int flip, 
		bool transparency, int opacity);
 * Identical to Screen->DrawCombo(), but it draws to a target bitmap.

void DrawString(int layer, 
			int x, int y, 
			int font, int color, int background_color, int format, 
			"string", 
			int opacity );
 * Identical to Screen->DrawString(), but it draws to a target bitmap.
 
void DrawString(int layer, 
			int x, int y, 
			int font, int color, int background_color, int format, 
			"string", 
			int opacity,
			int shadow_type, int shadow_color);
 * Identical to Screen->DrawString(), but it draws to a target bitmap.

void DrawLayer(int layer, 
			int source_map, int source_screen, int source_layer, 
			int x, int y, float rotation, int opacity);
 * Identical to Screen->DrawLayer(), but it draws to a target bitmap.

Quad( int layer, 
	int x1, int y1, int x2, int y2, 
	int x3, int y3, int x4, int y4,
	int w, int h, int cset, int flip, 
	int texture, int render_mode, bitmap render_source)
 * Identical to Screen->Quad(), but it draws to a target bitmap, and you can specify a bitmap as your texture.
 * Pass the bitmap pointer that you want to use to 'bitmap render_source'.
 * If you do not wish to use a bitmap as a texture, pass NULL to the arg 'bitmap render_source'.
 * Use PT_TEXTURE or a similar polytype, to render your bitmap as a texture.
 * For bitmap textures, specify the exact height and width of the texture as args 'w' and 'h'.
 * If rendering a bitmap as a texture, the 'h' and 'w' args need not be a power of 2. 
 * If `bitmap render_source` != NULL, then it will use this as the texture, instead of a tile or combo.
 * If the pointer supplied to render_source is invalid (contains no data), then
 * this function will default to using a tile. 

void Triangle	( int layer, 
			int x1, int y1, int x2, 
			int y2, int x3, int y3,
			int w, int h, int cset, 
			int flip, int texture, 
			int render_mode, bitmap render_source);
			
 * Identical to Screen->Triangle(), but it draws to a target bitmap, and you can specify a bitmap as your texture.
 * Pass the bitmap pointer that you want to use to 'bitmap render_source'.
 * If you do not wish to use a bitmap as a texture, pass NULL to the arg 'bitmap render_source'.
 * Use PT_TEXTURE or a similar polytype, to render your bitmap as a texture. 
 * For bitmap textures, specify the exact height and width of the texture as args 'w' and 'h'.
 * If rendering a bitmap as a texture, the 'h' and 'w' args need not be a power of 2. 
 * If `bitmap render_source` != NULL, then it will use this as the texture, instead of a tile or combo.
 * If the pointer supplied to render_source is invalid (contains no data), then
 * this function will default to using a tile. 

void Quad3D( int layer, 
			int pos[12], int uv[8], int cset[4], int size[2], 
			int flip, int texture, int polytype, bitmap render_source );
 * Identical to Screen->Quad(), but it draws to a target bitmap, and you can specify a bitmap as your texture.
 * Pass the bitmap pointer that you want to use to 'bitmap render_source'.
 * If you do not wish to use a bitmap as a texture, pass NULL to the arg 'bitmap render_source'.
 * Use PT_TEXTURE or a similar polytype, to render your bitmap as a texture. 
 * For bitmap textures, specify the exact height and width of the texture as args 'w' and 'h'.
 * If rendering a bitmap as a texture, the 'h' and 'w' args need not be a power of 2. 
 * If `bitmap render_source` != NULL, then it will use this as the texture, instead of a tile or combo.
 * If the pointer supplied to render_source is invalid (contains no data), then
 * this function will default to using a tile.

void Triangle3D( int layer, 
			int pos[9], int uv[6], int csets[3], int size[2], 
			int flip, int tile, int polytype, bitmap render_source);
			
 * Identical to Screen->Triangle(), but it draws to a target bitmap, and you can specify a bitmap as your texture.
 * Pass the bitmap pointer that you want to use to 'bitmap render_source'.
 * If you do not wish to use a bitmap as a texture, pass NULL to the arg 'bitmap render_source'.
 * Use PT_TEXTURE or a similar polytype, to render your bitmap as a texture. 
 * For bitmap textures, specify the exact height and width of the texture as args 'w' and 'h'.
 * If rendering a bitmap as a texture, the 'h' and 'w' args need not be a power of 2. 
 * If `bitmap render_source` != NULL, then it will use this as the texture, instead of a tile or combo.
 * If the pointer supplied to render_source is invalid (contains no data), then
 * this function will default to using a tile.

void FastTile(int layer, int x, int y, 
		int tile, int cset, 
		int opacity );
 * Identical to Screen->FastTile(), but it draws to a target bitmap.

void FastCombo(int layer, int x, int y, 
		int combo, int cset, 
		int opacity );
 * Identical to Screen->FastCombo(), but it draws to a target bitmap.

void Polygon(int layer, int num_points, int vertices[], int colour, int transparency);
	ZASM: POLYGON
 * Draws a polygon to the bitmap, with a number of points specified as int points,
 * with vertices supplied as an array. 
 
 
void DrawScreen	(int layer, 
			int map, int source_screen, 
			int x, int y, float rotation);
			
 * Draws an entire screen from screen on map on the specified layer of the bitmap at (x,y).
 * If rotation is not zero, it(the entire screen) will rotate about its center.

void DrawScreenSolid	(int layer, 
			int map, int source_screen, 
			int x, int y, float rotation);
			
 * Draws the solidity mask entire screen from screen on map on the specified layer of the bitmap at (x,y) in colour index 1.
 * If rotation is not zero, it(the entire screen) will rotate about its center.

void DrawScreenSolidity	(int layer, 
			int map, int source_screen, 
			int x, int y, float rotation);
			
 * Draws the solidity value for each combo position of an entire screen from screen on map on 
 * the specified layer of the bitmap at (x,y).
 * Each combo position will be drawn in the palette index equal to its value as ComboS[].
 * If rotation is not zero, it(the entire screen) will rotate about its center.
 
void DrawScreenComboTypes	(int layer, 
			int map, int source_screen, 
			int x, int y, float rotation);
			
 * Draws the combo type value for each combo position of an entire screen from screen on map on 
 * the specified layer of the bitmap at (x,y).
 * Each combo position will be drawn in the palette index equal to its value as ComboT[].
 * If rotation is not zero, it(the entire screen) will rotate about its center.

void DrawScreenComboFlags	(int layer, 
			int map, int source_screen, 
			int x, int y, float rotation);
			
 * Draws the combo flag value for each combo position of an entire screen from screen on map on 
 * the specified layer of the bitmap at (x,y).
 * Each combo position will be drawn in the palette index equal to its value as ComboF[].
 * If rotation is not zero, it(the entire screen) will rotate about its center.

void DrawScreenComboIFlags	(int layer, 
			int map, int source_screen, 
			int x, int y, float rotation);
			
 * Draws the combo inh.flag value for each combo position of an entire screen from screen on map on 
 * the specified layer of the bitmap at (x,y).
 * Each combo position will be drawn in the palette index equal to its value as ComboI[].
 * If rotation is not zero, it(the entire screen) will rotate about its center.


	
// Destroy()
// All screen drawing instructions.
// Resize?
// int Depth (read-only)
// Transform() 
// RenderTo(target, mode, args[])
// RenderFrom(target, mode, args[])



________        ___.                       .__                
\______ \   ____\_ |__  __ __  ____   ____ |__| ____    ____  
 |    |  \_/ __ \| __ \|  |  \/ ___\ / ___\|  |/    \  / ___\ 
 |    `   \  ___/| \_\ \  |  / /_/  > /_/  >  |   |  \/ /_/  >
/_______  /\___  >___  /____/\___  /\___  /|__|___|  /\___  / 
        \/     \/    \/     /_____//_____/         \//_____/  
Functions for debugging, and raw access to the internal ZASM stack and mechanics. 

/////////////////
///  Debug->  ///
/////////////////								// Debug

untyped NULL;
untyped Null;
untyped Null();
untyped NULL();
 * You may assign this function to any datatype to clear it to NULL.
 * Example:
lweapon l = Screen->LoadLWeapon(16);
l->Dir = DIR_UP;
l = NULL(); // Clear the pointer to NULL.

void Breakpoint(char[] string);
 * If the ZASM debugger is open, this will break execution, and print the given string.
 * Break controls:
 *     'Insert' - break, or step forward if broken
 *     'Shift+Insert' - Step forward until next breakpoint, or start of next script, whichever comes first
 *     'Ctrl+Shift+Insert' - Same as above, but, doesn't print any ZASM until it breaks.
 *     'Alt+Insert' - Step forward until next breakpoint
 *     'Ctrl+Alt+Insert' - Same as above, but, doesn't print any ZASM until it breaks.
 *     'Ctrl+Insert' - Exit the ZASM debugger entirely
 * If the ZASM debugger is not open, this instruction does NOTHING.
 * Passing NULL to this function will not produce an error, instead printing no label
 * In ZASM scripts, passing the 'NUL' register to this instruction will not produce an error, instead printing no label


float D[256];
 * This is the value of the ri->d[] registers. 
 * These vary depending on the function, or the instruction.
 * For variable access, SETTER: ri->d[0] is the value being passed to the variable.
 * For variable access, GETTER: ri->d[0] *MIGHT BE* the value read from ther variable. (Need to verify.)
 * For array access, SETTER: ri->d[0] is the array index, and ri->d[1] is the value.
 * For array access, GETTER: ri->d[0] is the array index. Not sure on the RVal at this time.

 * For functions, ri->d[n] are the args passed to the functions.
 * 	Typically, the order is ri->d[0] for the first parameter, and each additional param is one index higher.
 *	Some functions might pop values in weird ways. 
 *	It should be possible to purely write functions as SETTER and GETTER types, so that their params
 * 	are simply the ri->d[] values, in order. 

 * Script drawing commands use sdci[] (&script_drawing_commands[n1][n2]), which is different.
 * Their params should still be available via ri->d[], but some values, may not. 
 * 	The frirst param for any script drawing instruction is the BITMAP that it uses. 
 * 	For bitmap-> pointer drawing commands, the bitmap ID is ri->bitmapref, set by Game->LoadBitmapID().
 * 	Otherwise, the BITMAP pointer is set by SetRenderTarget(), qand held in sdci[18].
 *	The other params follow, as inputs from the instruction (function params passed to it).
 *	last, the playfield offsets typically follow the function params.
 * 	Of these, on;y the sdci[] values would be available to ri->d[], if nothing eats them beforehand.

GDR[256]
Debug->GetFFCPointer(), SetFFCPointer(), GetItemPointer(), SetItemPointer(), GetItemdataPointer(), SetItemdataPointer()
	GetNPCPointer(), SetNPCPointer(), GetLWeaponPointer(), SetLWeaponPointer(), GetEWeaponPointer(),
	SetEWeaponPointer(), RefFFC, RefItem, RefItemdata, RefLWeapon, RefEWeapon, RefNPC, SP
,



/************************************************************************************************************/
Game->DEBUGGING: These might find their way into namespace Debug-> instead of Game-> in the future. 
/************************************************************************************************************/	

int RefFFC; 				ZASM Instruction:
					REFFFC
	/**
	* Returns the present ffc reference from the stack. FOR DEBUGGING ONLY!
	* THIS WILL BE DISABLED IN RELEASE BUILDS !
	*/ Example Use:
	
/************************************************************************************************************/	

int RefItem; 				ZASM Instruction:
					REFITEM
	/**
	* Returns the present item reference from the stack. FOR DEBUGGING ONLY!
	* THIS WILL BE DISABLED IN RELEASE BUILDS !
	*/ Example Use:
	
/************************************************************************************************************/	

int RefItemdata; 			ZASM Instruction:
					REFIDATA
	/**
	* Returns the present itemdata reference from the stack. FOR DEBUGGING ONLY!
	* THIS WILL BE DISABLED IN RELEASE BUILDS !
	*/ Example Use:
	
/************************************************************************************************************/	

int RefLWeapon; 			ZASM Instruction:
					REFLWPN
	/**
	* Returns the present lweapon reference from the stack. FOR DEBUGGING ONLY!
	* THIS WILL BE DISABLED IN RELEASE BUILDS !
	*/ Example Use:
	
/************************************************************************************************************/	

int RefEWeapon; 			ZASM Instruction:
					REFEWPN
	/**
	* Returns the present eweapon reference from the stack. FOR DEBUGGING ONLY!
	* THIS WILL BE DISABLED IN RELEASE BUILDS !
	*/ Example Use:
	
/************************************************************************************************************/	

int RefNPC; 				ZASM Instruction:
					REFNPC
	/**
	* Returns the present npc reference from the stack. FOR DEBUGGING ONLY!
	* THIS WILL BE DISABLED IN RELEASE BUILDS !
	*/ Example Use:
	
/************************************************************************************************************/	

int SP; 				ZASM Instruction:
					SP
	/**
	* Returns the value of the stack pointer. FOR DEBUGGING ONLY!
	* THIS WILL BE DISABLED IN RELEASE BUILDS !
	*/ Example Use:

**********************************************************************************************************/

SetRenderSource(int target, int x, int y, int w, int h)

/************************************************************************************************************/

//To add:
Game->Freeze(int type) or Game->Suspend() 
datatype->Create(), Load(), Destroy()



   _____            __                    _______           _            
  / ___/__  _______/ /____  ____ ___     /_  __(_)___ ___  (_)___  ____ _
  \__ \/ / / / ___/ __/ _ \/ __ `__ \     / / / / __ `__ \/ / __ \/ __ `/
 ___/ / /_/ (__  ) /_/  __/ / / / / /    / / / / / / / / / / / / / /_/ / 
/____/\__, /____/\__/\___/_/ /_/ /_/    /_/ /_/_/ /_/ /_/_/_/ /_/\__, /  
     /____/                                                     /____/   


2.55 Script Timing
19th December, 2019 for Alpha 48

1. (If firstplay) Global Init; allocate global arrays and variables.
2. (If firstplay) Link Init
3. (If loading from a saved file) Global OnLoadSave
4. Global onLaunch (if not F6 continue)
5. Global Continue Game (if F6 Continue)
6. FFCs by Screen Index (1 to 32)
7. Global Active (prior to Waitdraw)
8. Link Active  (prior to Waitdraw)
9. DMap Active (prior  to Waitdraw)
10. DMap Passive Subscreen
11. Itemsprite Scripts (by screen index)
12. NPC Active (by screen index)
13. EWeapon Active (by screen index)
14. Clear script one-frame conditions: Clears HitBy[]
15. Link.animate() : During this function, global, Link, and DMap scripts are run during screen scrolling)
15a. Global active during scrolling
15b. Link active, during scrolling, waitdraw may apply
15c. DMap Active, during scrolling, waitdraw may apply
15d. DMap Subscreen Passive, during scrolling, waitdraw may apply.
15e. DMap Subscreen Active, is the player pressed the Start button or the script was already running. 
	Running this script executes is its own isolated event loop. 
	If the DMap Subscreen Active script is running:
		(a) DMap Active (if the QR to run it is enabled)
		(b) DMap Subscreen Passive (if the QR to run it is enabled)
		(c) DMap Subscreen Active
		(d) Waitdraw
		(e) DMap Active (after waitdraw, if the QR to run it is enabled)
		(f) DMap Subscreen Passive (after waitdraw, if the QR to run it is enabled)
		(g) DMap Subscreen Active (after waitdraw)
16. Item Collect Scripts
17. Item Action scripts
18. Continual item scripts, after first frame (ordered by item ID)
19. LWeapon scripts (by screen index)
20. WAITDRAW
21. Global Active (after Waitdraw pause)
22. Link Active (after Waitdraw pause)
23. DMap Active (after Waitdraw pause)
24. DMap Subscreen passive (after Waitdraw pause)
25. FFcs after Waitdraw (if rule enabled_
26. Itemdata scripts after Waitdraw (if rule enabled)
27. NPC Scripts after Waitdraw.
29. EWeapon Scripts after Waitdraw.
30. LWeapon Scripts after Waitdraw.
31. Itemsprite Scripts after Waitdraw.
32.0. Global Exit  (if applicable)
32.1. Link Death (if applicable)
32.2.  Link Win (if Applicable)
33. Global F6 Script (if the player pressed F6)
