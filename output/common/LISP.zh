import "std.zh"
import "string.zh"

////////////////////////////////////////////////////////////////
// Characters

const int CHAR_QUOTE = 39; // '
const int CHAR_TAB = 9;
const int CHAR_NEWLINE = 10;

bool Lisp_Char_IsWhitespace(int c) {
  return c == CHAR_TAB || c == CHAR_NEWLINE || c == ' ';}

bool Lisp_Char_IsSymbol(int c) {
  return !Lisp_Char_IsWhitespace(c) && c
    && c != '(' && c != ')' && c != CHAR_QUOTE;}

bool Lisp_Char_IsSymbolStart(int c) {
  return Lisp_Char_IsSymbol(c) && !isNumber(c);}

////////////////////////////////////////////////////////////////
// Strings

// Computes a hash code for a string.  Implementation of djb2. Not sure if
// it'll have problems because it's not a "long".
int Lisp_StringHash(int string_array, int string_offset) {
  int hash = 5381;
  int i = string_offset;
  while (0 != string_array[i]) {
    hash = (hash << 5) + hash + string_array[string_offset + i];
    ++i;}
  return hash;}

// Write a string into an array, returning the new end index.
int Lisp_WriteString(int array, int offset, int string) {
  return Lisp_WriteString(array, offset, string, 0);}
int Lisp_WriteString(int array, int offset, int string, int string_offset) {
  int i;
  for (i = string_offset; string[i] != 0 && i < SizeOfArray(string); ++i) {
    array[offset] = string[i];
    ++offset;}
  return offset;}

////////////////////////////////////////////////////////////////
// Data Types

// Denotes one of the builtin values.
const int LISP_TYPE_BUILTIN = 0x20000;
// Denotes an object in the main memory array.
const int LISP_TYPE_OBJECT  = 0x10000;
// Denotes a symbol.
const int LISP_TYPE_SYMBOL  = 0x08000;

// Pointer Screen Indices.
const int LISP_TYPE_POINTER       = 0x24000;
const int LISP_POINTER_TYPE_MASK  = 0x00300;
const int LISP_POINTER_INDEX_MASK = 0x000FF;
const int LISP_TYPE_NPC           = 0x00000;
const int LISP_TYPE_ITEM          = 0x00100;
const int LISP_TYPE_LWEAPON       = 0x00200;
const int LISP_TYPE_EWEAPON       = 0x00300;

//// These flags are for the memory info array.
// Indicates a cell object.
const int LISP_MEMORY_CELL     = 0x10000;
// For reference counting.
const int LISP_MEMORY_REF_MASK  = 0x0000F;
const int LISP_MEMORY_MAX_REF   = 0x0000F;
// Marks an object as being permanent.
const int LISP_MEMORY_PERMANENT = 0x00010;


// If a given value references an object.
bool Lisp_IsObject(int x) {return x & LISP_TYPE_OBJECT;}

bool Lisp_IsPointer(int x) {return LISP_LINK == x || (x & LISP_TYPE_POINTER) == LISP_TYPE_POINTER;}

// If a given value is a number.
bool Lisp_IsNumber(int x) {
  if (x < 0) {return true;}
  if (Lisp_IsObject(x)) {return false;}
  if (Lisp_IsSymbol(x)) {return false;}
  if (Lisp_IsPointer(x)) {return false;}
  return true;}

////////////////////////////////////////////////////////////////
// Memory

// The size of the memory.
const int LISP_MEMORY_SIZE = 65536;
// Holds flags about the info at the given index.
int Lisp_Memory_Info[65536];
// Holds the actual memory. Object type determines the interpretation.
int Lisp_Memory_A[65536];
int Lisp_Memory_B[65536];
// Last index used in memory.
int Lisp_Memory_LastAddress = -1;

// Return true if the memory address is free.
bool Lisp_Memory_IsFree(int address) {
  if (0 == address) {return false;}
	if (LISP_MEMORY_PERMANENT & Lisp_Memory_Info[address]) {return false;}
  return 0 == (Lisp_Memory_Info[address] & LISP_MEMORY_REF_MASK);}

// Return the number of memory addresses in use.
int Lisp_Memory_InUseCount() {
	int count = 0;
	for (int i = 0; i < LISP_MEMORY_SIZE; ++i) {
		if (!Lisp_Memory_IsFree(i)) {++count;}}
	return count;}

// Increment the ref count for the object. If the object is increased from 0 references
void Lisp_Memory_IncRefCount(int object) {
  if (!Lisp_IsObject(object)) {return;}
  int address = object & ~LISP_TYPE_OBJECT;
  // Don't increment past the max value.
	int refcount = Lisp_Memory_Info[address] & LISP_MEMORY_REF_MASK;
	if (refcount < LISP_MEMORY_MAX_REF) {
		++Lisp_Memory_Info[address];}}

// Decrement the ref count for the object. If the object is reduced
// to 0 references, will also reduce the ref counts of its references.
void Lisp_Memory_DecRefCount(int object) {
	if (!Lisp_IsObject(object)) {return;}
	int address = object & ~LISP_TYPE_OBJECT;
	int refcount = Lisp_Memory_Info[address] & LISP_MEMORY_REF_MASK;
  // If it's at the max value, we don't know how many there are.
	if (LISP_MEMORY_MAX_REF == refcount) {return;}
	// Don't decrement past 0.
	if (refcount > 0) {--Lisp_Memory_Info[address];}}

// Attempt to garbage collect a single object and its references by using
// refcounts.
void Lisp_Memory_GC(int object) {
	while (true) {
		if (!Lisp_IsObject(object)) {return;}
		int address = object & ~LISP_TYPE_OBJECT;
		// Don't gc permanent objects.
		if (LISP_MEMORY_PERMANENT & Lisp_Memory_Info[address]) {return;}
		// Make sure the refcount is 0.
		if ((Lisp_Memory_Info[address] & LISP_MEMORY_REF_MASK) > 0) {return;}

		// If it's a cell.
		if (Lisp_IsCell(object)) {
			// Decrease children's ref counts.
			Lisp_Memory_DecRefCount(Lisp_Memory_A[address]);
			Lisp_Memory_DecRefCount(Lisp_Memory_B[address]);
			// Attempt to GC children. Tail is done in-loop as an optimization for lists.
			Lisp_Memory_GC(Lisp_Memory_A[address]);
			object = Lisp_Memory_B[address];}}}

// List of all permanent objects.
int Lisp_Memory_Permanents[100];
int Lisp_Memory_PermanentCount = 0;

bool Lisp_Memory_Permanent(int object) {
  if (!Lisp_IsObject(object)) {return false;}
	return Lisp_Memory_Info[object & ~LISP_TYPE_OBJECT] & LISP_MEMORY_PERMANENT;}
void Lisp_Memory_Permanent(int object, bool value) {
  if (!Lisp_IsObject(object)) {return;}
	bool current  = Lisp_Memory_Permanent(object);
	if (current == value) {return;}
	if (value) {
		// Mark as permanent.
		Lisp_Memory_Info[object & ~LISP_TYPE_OBJECT] |= LISP_MEMORY_PERMANENT;
		// Add to permanent list.
		Lisp_Memory_Permanents[Lisp_Memory_PermanentCount] = object;
		++Lisp_Memory_PermanentCount;}
	else {
		// Mark as not permanent.
		Lisp_Memory_Info[object & ~LISP_TYPE_OBJECT] &= ~LISP_MEMORY_PERMANENT;
		// Remove from the permanent list.
		int i;
		for (i = 0; i < Lisp_Memory_PermanentCount; ++i) {
			if (object == Lisp_Memory_Permanents[i]) {break;}}
		for (; i < Lisp_Memory_PermanentCount - 1; ++i) {
			Lisp_Memory_Permanents[i] = Lisp_Memory_Permanents[i + 1];}
		--Lisp_Memory_PermanentCount;}}

// Garbage collect (mark & sweep).
void Lisp_Memory_GC() {
	bool mark[65536];
	int queue[65536];

	// Initialize queue with permanents.
	memcpy(queue, 0, Lisp_Memory_Permanents, 0, Lisp_Memory_PermanentCount);
	int queue_size = Lisp_Memory_PermanentCount;

	// Start marking things.
	int queue_index = 0;
	while (queue_index < queue_size) {
		int object = queue[queue_index];
		if (Lisp_IsObject(object)) {
			int mark_index = object & ~LISP_TYPE_OBJECT;
			if (!mark[mark_index]) {
				mark[mark_index] = true;

				if (Lisp_IsCell(object)) {
					int head = Lisp_Cell_Head(object);
					if (head) {
						queue[queue_size] = head;
						++queue_size;}
					int tail = Lisp_Cell_Tail(object);
					if (tail) {
						queue[queue_size] = tail;
						++queue_size;}}}}
		++queue_index;
	}

	// Free everything that doesn't have a mark.
	for (int i = 0; i < LISP_MEMORY_SIZE; ++i)  {
		if (!mark[i] && i < 520) {
			Lisp_Memory_Info[i] &= ~LISP_MEMORY_REF_MASK;}}
}

////////////////////////////////////////////////////////////////
// Cells

// If a given value indicates a cell.
bool Lisp_IsCell(int x) {return LISP_NIL == x || x & LISP_TYPE_OBJECT;}

// Creates a new cell in memory.
int Lisp_Cell() {
  // Advance until we find a free cell.
  int address = (Lisp_Memory_LastAddress + 1) % LISP_MEMORY_SIZE;
  while (!Lisp_Memory_IsFree(address) && address != Lisp_Memory_LastAddress) {
    address = (address + 1) % LISP_MEMORY_SIZE;}

  // If we failed, complain.
  if (Lisp_Memory_LastAddress == address) {
    Lisp_Cell_OutOfMemory();
    return 0;}

  // Save last used address
  Lisp_Memory_LastAddress = address;

  // Initialize that address as being a cell.
  Lisp_Memory_Info[address] = LISP_MEMORY_CELL;

  // Clear the data.
  Lisp_Memory_A[address] = LISP_NIL;
  Lisp_Memory_B[address] = LISP_NIL;

  // Return pointer.
  return LISP_TYPE_OBJECT | address;}
void Lisp_Cell_OutOfMemory() {
  int msg[]="ERROR - Lisp_Cell() - Out of Memory.\n";
  printf(msg);}

// Get the head of a cell.
int Lisp_Cell_Head(int cell) {
  if (cell == LISP_NIL) {return LISP_NIL;}
  if (!Lisp_IsCell(cell)) {
    Lisp_Cell_Head_Error(cell);
    return LISP_NIL;}
  int address = cell & ~LISP_TYPE_OBJECT;
  return Lisp_Memory_A[address];}
void Lisp_Cell_Head_Error(int value) {
  int msg[] = "ERROR: Attempted to get head of <%d>.\n";
  printf(msg, value);}
// Get the tail of a cell.
int Lisp_Cell_Tail(int cell) {
  if (cell == LISP_NIL) {return LISP_NIL;}
  if (!Lisp_IsCell(cell)) {
    Lisp_Cell_Tail_Error(cell);
    return LISP_NIL;}
  int address = cell & ~LISP_TYPE_OBJECT;
  return Lisp_Memory_B[address];}
void Lisp_Cell_Tail_Error(int value) {
  int msg[] = "ERROR: Attempted to get tail of <%d>.\n";
  printf(msg, value);}
// Set the head of a cell. Returns the cell.
int Lisp_Cell_Head(int cell, int value) {
  int address = cell & ~LISP_TYPE_OBJECT;
  Lisp_Memory_IncRefCount(value);
  Lisp_Memory_DecRefCount(Lisp_Memory_A[address]);
  Lisp_Memory_A[address] = value;
  return cell;}
// Set the tail of a cell. Returns the cell.
int Lisp_Cell_Tail(int cell, int value) {
  int address = cell & ~LISP_TYPE_OBJECT;
  Lisp_Memory_IncRefCount(value);
  Lisp_Memory_DecRefCount(Lisp_Memory_B[address]);
  Lisp_Memory_B[address] = value;
  return cell;}

// Convenience method for creating a cell.
int Lisp_Cell(int head, int tail) {
  int cell = Lisp_Cell();
  Lisp_Cell_Head(cell, head);
  Lisp_Cell_Tail(cell, tail);
  return cell;}

// Convenience method for creating a list.
int Lisp_List(int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7,
              int a8, int a9, int aa, int ab, int ac, int ad, int ae, int af) {
  int args[0x10];
  arrayset(args, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, aa, ab, ac, ad, ae, af);
  int head = Lisp_Cell(a0, LISP_NIL);
  int cell = head;
  for (int i = 1; i < 0x10 && args[i] != 0; ++i) {
    int tmp = Lisp_Cell(args[i], LISP_NIL);
    Lisp_Cell_Tail(cell, tmp);
    cell = tmp;}
  return head;}

////////////////////////////////////////////////////////////////
// Symbols

// Holds each symbol string consecutively.
int Lisp_Symbol_Data[214747];
// Next open spot in Lisp_Symbol_Data.
int Lisp_Symbol_NextIndex = 0;
// Index into Lisp_SymbolStrings for a given symbol.
int Lisp_Symbol_Indices[32768];
// Maximum number of symbols.
const int LISP_SYMBOL_COUNT = 0x08000;

bool Lisp_IsSymbol(int symbol) {
  return (symbol & LISP_TYPE_SYMBOL) && (symbol & ~LISP_TYPE_OBJECT);}

// Get the symbol for a given string, creating it if needed.
int Lisp_Symbol_Get(int array) {return Lisp_Symbol_Get(array, 0);}
int Lisp_Symbol_Get(int array, int offset) {
  int symbol; int i;
  int index = Floor(Lisp_StringHash(array, offset)) % LISP_SYMBOL_COUNT;
  if (index < 0) {index += LISP_SYMBOL_COUNT;}
  int end_index = (LISP_SYMBOL_COUNT + index - 1) % LISP_SYMBOL_COUNT;
  while (index != end_index) {
    int string_index = Lisp_Symbol_Indices[index] - 1;
    // If we hit an empty space, the symbol is unknown and we need to make it.
    if (-1 == string_index) {
      // Save the string's start.
      Lisp_Symbol_Indices[index] = Lisp_Symbol_NextIndex + 1;
      // Copy over the string.
      for (i = 0; array[offset + i] != 0; ++i) {
        Lisp_Symbol_Data[Lisp_Symbol_NextIndex + i] = array[offset + i];}
      Lisp_Symbol_Data[Lisp_Symbol_NextIndex + i] = 0;
      Lisp_Symbol_NextIndex += i + 1;
      // Return the symbol.
      return LISP_TYPE_SYMBOL | index;}
    // If we hit a filled space, return if it's the right symbol.
    else if (0 == strcmp(Lisp_Symbol_Data, string_index, array, offset)) {
      return LISP_TYPE_SYMBOL | index;}
    // Advance to the next index.
    index = (index + 1) % LISP_SYMBOL_COUNT;}
  // Failure. OOM.
  return -1;}

////////////////////////////////////////////////////////////////
// Bultin Values

const int LISP_FALSE       = 0x20000;
const int LISP_TRUE        = 0x20001;
const int LISP_ENV         = 0x20002;
const int LISP_FUNCTION    = 0x20003;
const int LISP_MACRO       = 0x20004;
const int LISP_HEAD        = 0x20005;
const int LISP_TAIL        = 0x20006;
const int LISP_LIST        = 0x20007;
const int LISP_ADD         = 0x20008;
const int LISP_SUBTRACT    = 0x20009;
const int LISP_MULTIPLY    = 0x2000A;
const int LISP_DIVIDE      = 0x2000B;
const int LISP_SET         = 0x2000C;
const int LISP_LET         = 0x2000D;
const int LISP_DO          = 0x2000E;
const int LISP_QUOTE       = 0x2000F;
const int LISP_NIL         = 0x20010;
const int LISP_IF          = 0x20011;
const int LISP_CELL        = 0x20012;
const int LISP_WHILE       = 0x20013;
const int LISP_PRINT       = 0x20014;
const int LISP_DEFINE      = 0x20015;
const int LISP_VARARG      = 0x20016;
const int LISP_NOT         = 0x20017;
const int LISP_LT          = 0x20018;
const int LISP_GT          = 0x20019;
const int LISP_EQ          = 0x2001A;
const int LISP_LTE         = 0x2001B;
const int LISP_GTE         = 0x2001C;
const int LISP_NPC         = 0x2001D;
const int LISP_ITEM        = 0x2001E;
const int LISP_LWEAPON     = 0x2001F;
const int LISP_EWEAPON     = 0x20020;
const int LISP_LINK        = 0x20021;
const int LISP_NPC_P       = 0x20022;
const int LISP_ITEM_P      = 0x20023;
const int LISP_LWEAPON_P   = 0x20024;
const int LISP_EWEAPON_P   = 0x20025;
const int LISP_LINK_P      = 0x20026;
const int LISP_VALID       = 0x20027;
const int LISP_X           = 0x20028;
const int LISP_Y           = 0x20029;
const int LISP_Z           = 0x2002A;
const int LISP_WAITDRAW    = 0x2002B;
const int LISP_WAITFRAME   = 0x2002C;
const int LISP_INPUT_START = 0x2002D;
const int LISP_INPUT_MAP   = 0x2002E;
const int LISP_INPUT_UP    = 0x2002F;
const int LISP_INPUT_DOWN  = 0x20030;
const int LISP_INPUT_LEFT  = 0x20031;
const int LISP_INPUT_RIGHT = 0x20032;
const int LISP_INPUT_L     = 0x20033;
const int LISP_INPUT_R     = 0x20034;
const int LISP_INPUT_EX1   = 0x20035;
const int LISP_INPUT_EX2   = 0x20036;
const int LISP_INPUT_EX3   = 0x20037;
const int LISP_INPUT_EX4   = 0x20038;
const int LISP_PRESS_START = 0x20039;
const int LISP_PRESS_MAP   = 0x2003A;
const int LISP_PRESS_UP    = 0x2003B;
const int LISP_PRESS_DOWN  = 0x2003C;
const int LISP_PRESS_LEFT  = 0x2003D;
const int LISP_PRESS_RIGHT = 0x2003E;
const int LISP_PRESS_L     = 0x2003F;
const int LISP_PRESS_R     = 0x20040;
const int LISP_PRESS_EX1   = 0x20041;
const int LISP_PRESS_EX2   = 0x20042;
const int LISP_PRESS_EX3   = 0x20043;
const int LISP_PRESS_EX4   = 0x20044;
const int LISP_DIR         = 0x20045;
const int LISP_HP          = 0x20046;
const int LISP_NPC_COUNT      = 0x20047;
const int LISP_ITEM_COUNT     = 0x20048;
const int LISP_LWEAPON_COUNT  = 0x20049;
const int LISP_EWEAPON_COUNT  = 0x2004A;
const int LISP_CUR_SCREEN     = 0x2004B;
const int LISP_CUR_DSCREEN    = 0x2004C;
const int LISP_CUR_LEVEL      = 0x2004D;
const int LISP_CUR_MAP        = 0x2004E;
const int LISP_CUR_DMAP       = 0x2004F;
const int LISP_SCREEN_CHANGED = 0x20050;
const int LISP_ACTIVE_WAITFRAME = 0x20051;
const int LISP_MEMORY_IN_USE = 0x20052;

bool Lisp_IsBuiltin(int x) {return x & LISP_TYPE_BUILTIN && x < LISP_TYPE_POINTER;}

////////////////////////////////////////////////////////////////
// Standard Symbols

// Report whether or not a symbol matches the given value.
void Lisp_Symbol_Check(int string, int target) {
  int value = Lisp_Symbol_Get(string);
  if (target != value) {Lisp_Symbol_Check_Fail(string, value);}}
void Lisp_Symbol_Check_Fail(int string, int value) {
  int msg[] = "ERROR: Symbol <%s> needs to be value <%d>.\n";
  printf(msg, string, value);}

const int LISP_SYM_FALSE = 43152;
const int LISP_SYM_TRUE = 46093;
const int LISP_SYM_ENV = 49859;
const int LISP_SYM_FUNCTION = 40645;
const int LISP_SYM_MACRO = 39720;
const int LISP_SYM_HEAD = 62296;
const int LISP_SYM_TAIL = 59959;
const int LISP_SYM_LIST = 47170;
const int LISP_SYM_ADD = 46544;
const int LISP_SYM_SUBTRACT = 46546;
const int LISP_SYM_MULTIPLY = 46543;
const int LISP_SYM_DIVIDE = 46548;
const int LISP_SYM_SET = 64806;
const int LISP_SYM_LET = 57183;
const int LISP_SYM_DO = 46973;
const int LISP_SYM_QUOTE = 33651;
const int LISP_SYM_NIL = 59485;
const int LISP_SYM_IF = 47129;
const int LISP_SYM_CELL = 50311;
const int LISP_SYM_WHILE = 65362;
const int LISP_SYM_PRINT = 54460;
const int LISP_SYM_DEFINE = 53246;
const int LISP_SYM_VARARG = 46539;
const int LISP_SYM_NOT = 59691;
const int LISP_SYM_LT = 46561;
const int LISP_SYM_GT = 46563;
const int LISP_SYM_EQ = 46562;
const int LISP_SYM_LTE = 45603;
const int LISP_SYM_GTE = 45669;
const int LISP_SYM_NPC = 59707;
const int LISP_SYM_ITEM = 49173;
const int LISP_SYM_LWEAPON = 40325;
const int LISP_SYM_EWEAPON = 41464;
const int LISP_SYM_LINK = 46996;
const int LISP_SYM_NPC_P = 60550;
const int LISP_SYM_ITEM_P = 46395;
const int LISP_SYM_LWEAPON_P = 42298;
const int LISP_SYM_EWEAPON_P = 34304;
const int LISP_SYM_LINK_P = 44756;
const int LISP_SYM_VALID = 48268;
const int LISP_SYM_X = 46621;
const int LISP_SYM_Y = 46622;
const int LISP_SYM_Z = 46623;
const int LISP_SYM_WAITDRAW    = 33074;
const int LISP_SYM_WAITFRAME   = 46975;
const int LISP_SYM_INPUT_START = 40578;
const int LISP_SYM_INPUT_MAP   = 62184;
const int LISP_SYM_INPUT_UP    = 53687;
const int LISP_SYM_INPUT_DOWN  = 33265;
const int LISP_SYM_INPUT_LEFT  = 47172;
const int LISP_SYM_INPUT_RIGHT = 52469;
const int LISP_SYM_INPUT_L     = 51228;
const int LISP_SYM_INPUT_R     = 51234;
const int LISP_SYM_INPUT_EX1   = 54168;
const int LISP_SYM_INPUT_EX2   = 54169;
const int LISP_SYM_INPUT_EX3   = 54170;
const int LISP_SYM_INPUT_EX4   = 54171;
const int LISP_SYM_PRESS_START = 52024;
const int LISP_SYM_PRESS_MAP   = 51277;
const int LISP_SYM_PRESS_UP    = 50450;
const int LISP_SYM_PRESS_DOWN  = 54889;
const int LISP_SYM_PRESS_LEFT  = 36028;
const int LISP_SYM_PRESS_RIGHT = 63915;
const int LISP_SYM_PRESS_L     = 43468;
const int LISP_SYM_PRESS_R     = 43474;
const int LISP_SYM_PRESS_EX1   = 43261;
const int LISP_SYM_PRESS_EX2   = 43262;
const int LISP_SYM_PRESS_EX3   = 43263;
const int LISP_SYM_PRESS_EX4   = 43264;
const int LISP_SYM_DIR         = 48601;
const int LISP_SYM_HP          = 47106;
const int LISP_SYM_NPC_COUNT     = 63203;
const int LISP_SYM_ITEM_COUNT    = 35825;
const int LISP_SYM_LWEAPON_COUNT = 41457;
const int LISP_SYM_EWEAPON_COUNT = 44517;
const int LISP_SYM_CUR_SCREEN     = 61272;
const int LISP_SYM_CUR_DSCREEN    = 64781;
const int LISP_SYM_CUR_LEVEL      = 57704;
const int LISP_SYM_CUR_MAP        = 60024;
const int LISP_SYM_CUR_DMAP       = 37548;
const int LISP_SYM_SCREEN_CHANGED = 35692;
const int LISP_SYM_ACTIVE_WAITFRAME = 44930;
const int LISP_SYM_MEMORY_IN_USE    = 62240;

// Initialize the standard symbols.
int Lisp_Symbol_Init() {
  int _false[]    = "false";    Lisp_Symbol_Check(_false,    LISP_SYM_FALSE);
  int _true[]     = "true";     Lisp_Symbol_Check(_true,     LISP_SYM_TRUE);
  int env[]       = "env";      Lisp_Symbol_Check(env,       LISP_SYM_ENV);
  int _function[] = "function"; Lisp_Symbol_Check(_function, LISP_SYM_FUNCTION);
  int macro[]     = "macro";    Lisp_Symbol_Check(macro,     LISP_SYM_MACRO);
  int head[]      = "head";     Lisp_Symbol_Check(head,      LISP_SYM_HEAD);
  int tail[]      = "tail";     Lisp_Symbol_Check(tail,      LISP_SYM_TAIL);
  int list[]      = "list";     Lisp_Symbol_Check(list,      LISP_SYM_LIST);
  int add[]       = "+";        Lisp_Symbol_Check(add,       LISP_SYM_ADD);
  int subtract[]  = "-";        Lisp_Symbol_Check(subtract,  LISP_SYM_SUBTRACT);
  int multiply[]  = "*";        Lisp_Symbol_Check(multiply,  LISP_SYM_MULTIPLY);
  int divide[]    = "/";        Lisp_Symbol_Check(divide,    LISP_SYM_DIVIDE);
  int set[]       = "set";      Lisp_Symbol_Check(set,       LISP_SYM_SET);
  int let[]       = "let";      Lisp_Symbol_Check(let,       LISP_SYM_LET);
  int _do[]       = "do";       Lisp_Symbol_Check(_do,       LISP_SYM_DO);
  int quote[]     = "quote";    Lisp_Symbol_Check(quote,     LISP_SYM_QUOTE);
  int nil[]       = "nil";      Lisp_Symbol_Check(nil,       LISP_SYM_NIL);
  int _if[]       = "if";       Lisp_Symbol_Check(_if,       LISP_SYM_IF);
  int cell[]      = "cell";     Lisp_Symbol_Check(cell,      LISP_SYM_CELL);
  int _while[]    = "while";    Lisp_Symbol_Check(_while,    LISP_SYM_WHILE);
  int print[]     = "print";    Lisp_Symbol_Check(print,     LISP_SYM_PRINT);
  int define[]    = "define";   Lisp_Symbol_Check(define,    LISP_SYM_DEFINE);
  int vararg[]    = "&";        Lisp_Symbol_Check(vararg,    LISP_SYM_VARARG);
  int not[]       = "not";      Lisp_Symbol_Check(not,       LISP_SYM_NOT);
  int lt[]        = "<";        Lisp_Symbol_Check(lt,        LISP_SYM_LT);
  int gt[]        = ">";        Lisp_Symbol_Check(gt,        LISP_SYM_GT);
  int eq[]        = "=";        Lisp_Symbol_Check(eq,        LISP_SYM_EQ);
  int lte[]       = "<=";       Lisp_Symbol_Check(lte,       LISP_SYM_LTE);
  int gte[]       = ">=";       Lisp_Symbol_Check(gte,       LISP_SYM_GTE);
  int _npc[]      = "npc";      Lisp_Symbol_Check(_npc,      LISP_SYM_NPC);
  int _item[]     = "item";     Lisp_Symbol_Check(_item,     LISP_SYM_ITEM);
  int _lweapon[]  = "lweapon";  Lisp_Symbol_Check(_lweapon,  LISP_SYM_LWEAPON);
  int _eweapon[]  = "eweapon";  Lisp_Symbol_Check(_eweapon,  LISP_SYM_EWEAPON);
  int _link[]     = "link";     Lisp_Symbol_Check(_link,     LISP_SYM_LINK);
  int npc_p[]     = "npc?";     Lisp_Symbol_Check(npc_p,     LISP_SYM_NPC_P);
  int item_p[]    = "item?";    Lisp_Symbol_Check(item_p,    LISP_SYM_ITEM_P);
  int lweapon_p[] = "lweapon?"; Lisp_Symbol_Check(lweapon_p, LISP_SYM_LWEAPON_P);
  int eweapon_p[] = "eweapon?"; Lisp_Symbol_Check(eweapon_p, LISP_SYM_EWEAPON_P);
  int link_p[]    = "link?";    Lisp_Symbol_Check(link_p,    LISP_SYM_LINK_P);
  int valid[]     = "valid?";   Lisp_Symbol_Check(valid,     LISP_SYM_VALID);
  int x[]         = "x";        Lisp_Symbol_Check(x,         LISP_SYM_X);
  int y[]         = "y";        Lisp_Symbol_Check(y,         LISP_SYM_Y);
  int z[]         = "z";        Lisp_Symbol_Check(z,         LISP_SYM_Z);
  int waitdraw[]    = "waitdraw";    Lisp_Symbol_Check(waitdraw,    LISP_SYM_WAITDRAW);
  int waitframe[]   = "waitframe";   Lisp_Symbol_Check(waitframe,   LISP_SYM_WAITFRAME);
  int input_start[] = "input-start"; Lisp_Symbol_Check(input_start, LISP_SYM_INPUT_START);
  int input_map[]   = "input-map";   Lisp_Symbol_Check(input_map  , LISP_SYM_INPUT_MAP);
  int input_up[]    = "input-up";    Lisp_Symbol_Check(input_up   , LISP_SYM_INPUT_UP);
  int input_down[]  = "input-down";  Lisp_Symbol_Check(input_down , LISP_SYM_INPUT_DOWN);
  int input_left[]  = "input-left";  Lisp_Symbol_Check(input_left , LISP_SYM_INPUT_LEFT);
  int input_right[] = "input-right"; Lisp_Symbol_Check(input_right, LISP_SYM_INPUT_RIGHT);
  int input_l[]     = "input-l";     Lisp_Symbol_Check(input_l    , LISP_SYM_INPUT_L);
  int input_r[]     = "input-r";     Lisp_Symbol_Check(input_r    , LISP_SYM_INPUT_R);
  int input_ex1[]   = "input-ex1";   Lisp_Symbol_Check(input_ex1  , LISP_SYM_INPUT_EX1);
  int input_ex2[]   = "input-ex2";   Lisp_Symbol_Check(input_ex2  , LISP_SYM_INPUT_EX2);
  int input_ex3[]   = "input-ex3";   Lisp_Symbol_Check(input_ex3  , LISP_SYM_INPUT_EX3);
  int input_ex4[]   = "input-ex4";   Lisp_Symbol_Check(input_ex4  , LISP_SYM_INPUT_EX4);
  int press_start[] = "press-start"; Lisp_Symbol_Check(press_start, LISP_SYM_PRESS_START);
  int press_map[]   = "press-map";   Lisp_Symbol_Check(press_map  , LISP_SYM_PRESS_MAP);
  int press_up[]    = "press-up";    Lisp_Symbol_Check(press_up   , LISP_SYM_PRESS_UP);
  int press_down[]  = "press-down";  Lisp_Symbol_Check(press_down , LISP_SYM_PRESS_DOWN);
  int press_left[]  = "press-left";  Lisp_Symbol_Check(press_left , LISP_SYM_PRESS_LEFT);
  int press_right[] = "press-right"; Lisp_Symbol_Check(press_right, LISP_SYM_PRESS_RIGHT);
  int press_l[]     = "press-l";     Lisp_Symbol_Check(press_l    , LISP_SYM_PRESS_L);
  int press_r[]     = "press-r";     Lisp_Symbol_Check(press_r    , LISP_SYM_PRESS_R);
  int press_ex1[]   = "press-ex1";   Lisp_Symbol_Check(press_ex1  , LISP_SYM_PRESS_EX1);
  int press_ex2[]   = "press-ex2";   Lisp_Symbol_Check(press_ex2  , LISP_SYM_PRESS_EX2);
  int press_ex3[]   = "press-ex3";   Lisp_Symbol_Check(press_ex3  , LISP_SYM_PRESS_EX3);
  int press_ex4[]   = "press-ex4";   Lisp_Symbol_Check(press_ex4  , LISP_SYM_PRESS_EX4);
  int dir[]         = "dir";         Lisp_Symbol_Check(dir,         LISP_SYM_DIR);
  int hp[]          = "hp";          Lisp_Symbol_Check(hp,          LISP_SYM_HP);
  int npc_count[]     = "npc-count";     Lisp_Symbol_Check(npc_count,     LISP_SYM_NPC_COUNT);
  int item_count[]    = "item-count";    Lisp_Symbol_Check(item_count,    LISP_SYM_ITEM_COUNT);
  int lweapon_count[] = "lweapon-count"; Lisp_Symbol_Check(lweapon_count, LISP_SYM_LWEAPON_COUNT);
  int eweapon_count[] = "eweapon-count"; Lisp_Symbol_Check(eweapon_count, LISP_SYM_EWEAPON_COUNT);
  int cur_screen[]    = "current-screen";  Lisp_Symbol_Check(cur_screen,  LISP_SYM_CUR_SCREEN);
  int cur_dscreen[]   = "current-dscreen"; Lisp_Symbol_Check(cur_dscreen, LISP_SYM_CUR_DSCREEN);
  int cur_level[]     = "current-level";   Lisp_Symbol_Check(cur_level,   LISP_SYM_CUR_LEVEL);
  int cur_map[]       = "current-map";     Lisp_Symbol_Check(cur_map,     LISP_SYM_CUR_MAP);
  int cur_dmap[]       = "current-dmap";    Lisp_Symbol_Check(cur_dmap,    LISP_SYM_CUR_DMAP);
  int screen_changed[] = "screen-changed";  Lisp_Symbol_Check(screen_changed, LISP_SYM_SCREEN_CHANGED);
  int active_waitframe[]   = "active-waitframe";   Lisp_Symbol_Check(active_waitframe,   LISP_SYM_ACTIVE_WAITFRAME);
	int memory_in_use[] = "memory-in-use"; Lisp_Symbol_Check(memory_in_use, LISP_SYM_MEMORY_IN_USE);
}

////////////////////////////////////////////////////////////////
// Environment

// The default environment to use.
int Lisp_Env_Root;

// Create a new environment.
int Lisp_Env() {return Lisp_Env(LISP_NIL);}
int Lisp_Env(int parent) {return Lisp_Cell(LISP_SYM_ENV, parent);}

// Get an entry in an environment.
// env - the environment to search
// key - the key to look for
// local - if we ignore parent environments
int Lisp_Env_GetEntry(int env, int key) {return Lisp_Env_Get(env, key, false);}
int Lisp_Env_GetEntry(int env, int key, bool local) {
  while (true) {
    // Advance to the next entry.
    env = Lisp_Cell_Tail(env);
    // Quit if we've failed.
    if (LISP_NIL == env) {return LISP_NIL;}

    int cell = Lisp_Cell_Head(env);
    // If we've hit <env> again, it means we've reached a parent environment.
    if (LISP_SYM_ENV == cell) {
      // If we're restricted to local, fail.
      if (local) {return LISP_NIL;}
      // Otherwise skip this element.
      continue;}

    // If we found the key, return the entry.
    if (key == Lisp_Cell_Head(cell)) {return cell;}}}

// This is the actual get call.
int Lisp_Env_Get(int env, int key) {return Lisp_Env_Get(env, key, false);}
int Lisp_Env_Get(int env, int key, bool local) {
  int entry = Lisp_Env_GetEntry(env, key, local);
  if (LISP_NIL == entry) {return LISP_NIL;}
  return Lisp_Cell_Tail(entry);}

// Set an environment value.
// env - the environment to update.
// key - the key to set.
// value - the value to use.
// local - if true, will force a new value in the immediate environment if it
//     doesn't exist. Otherwise it will use a parent entry if available.
void Lisp_Env_Set(int env, int key, int value) {Lisp_Env_Set(env, key, value, false);}
void Lisp_Env_Set(int env, int key, int value, bool local) {
  int entry = Lisp_Env_GetEntry(env, key, local);
  // If there's no existing entry, stick it at the front of the environment.
  if (LISP_NIL == entry) {
    Lisp_Cell_Tail(env, Lisp_Cell(Lisp_Cell(key, value), Lisp_Cell_Tail(env)));}
  // If there is an existing entry, update it.
  else {
    Lisp_Cell_Tail(entry, value);}}

// Create a new default environment.
int Lisp_Env_Default() {
  int env = Lisp_Env();
  Lisp_Env_Set(env, LISP_SYM_FALSE,     LISP_FALSE);
  Lisp_Env_Set(env, LISP_SYM_TRUE,      LISP_TRUE);
  Lisp_Env_Set(env, LISP_SYM_ENV,       LISP_ENV);
  Lisp_Env_Set(env, LISP_SYM_FUNCTION,  LISP_FUNCTION);
  Lisp_Env_Set(env, LISP_SYM_MACRO,     LISP_MACRO);
  Lisp_Env_Set(env, LISP_SYM_HEAD,      LISP_HEAD);
  Lisp_Env_Set(env, LISP_SYM_TAIL,      LISP_TAIL);
  Lisp_Env_Set(env, LISP_SYM_LIST,      LISP_LIST);
  Lisp_Env_Set(env, LISP_SYM_ADD,       LISP_ADD);
  Lisp_Env_Set(env, LISP_SYM_SUBTRACT,  LISP_SUBTRACT);
  Lisp_Env_Set(env, LISP_SYM_MULTIPLY,  LISP_MULTIPLY);
  Lisp_Env_Set(env, LISP_SYM_DIVIDE,    LISP_DIVIDE);
  Lisp_Env_Set(env, LISP_SYM_SET,       LISP_SET);
  Lisp_Env_Set(env, LISP_SYM_LET,       LISP_LET);
  Lisp_Env_Set(env, LISP_SYM_DO,        LISP_DO);
  Lisp_Env_Set(env, LISP_SYM_QUOTE,     LISP_QUOTE);
  Lisp_Env_Set(env, LISP_SYM_NIL,       LISP_NIL);
  Lisp_Env_Set(env, LISP_SYM_IF,        LISP_IF);
  Lisp_Env_Set(env, LISP_SYM_CELL,      LISP_CELL);
  Lisp_Env_Set(env, LISP_SYM_WHILE,     LISP_WHILE);
  Lisp_Env_Set(env, LISP_SYM_PRINT,     LISP_PRINT);
  Lisp_Env_Set(env, LISP_SYM_DEFINE,    LISP_DEFINE);
  Lisp_Env_Set(env, LISP_SYM_VARARG,    LISP_VARARG);
  Lisp_Env_Set(env, LISP_SYM_NOT,       LISP_NOT);
  Lisp_Env_Set(env, LISP_SYM_LT,        LISP_LT);
  Lisp_Env_Set(env, LISP_SYM_GT,        LISP_GT);
  Lisp_Env_Set(env, LISP_SYM_EQ,        LISP_EQ);
  Lisp_Env_Set(env, LISP_SYM_LTE,       LISP_LTE);
  Lisp_Env_Set(env, LISP_SYM_GTE,       LISP_GTE);
  Lisp_Env_Set(env, LISP_SYM_NPC,       LISP_NPC);
  Lisp_Env_Set(env, LISP_SYM_ITEM,      LISP_ITEM);
  Lisp_Env_Set(env, LISP_SYM_LWEAPON,   LISP_LWEAPON);
  Lisp_Env_Set(env, LISP_SYM_EWEAPON,   LISP_EWEAPON);
  Lisp_Env_Set(env, LISP_SYM_LINK,      LISP_LINK);
  Lisp_Env_Set(env, LISP_SYM_NPC_P,     LISP_NPC_P);
  Lisp_Env_Set(env, LISP_SYM_ITEM_P,    LISP_ITEM_P);
  Lisp_Env_Set(env, LISP_SYM_LWEAPON_P, LISP_LWEAPON_P);
  Lisp_Env_Set(env, LISP_SYM_EWEAPON_P, LISP_EWEAPON_P);
  Lisp_Env_Set(env, LISP_SYM_LINK_P,    LISP_LINK_P);
  Lisp_Env_Set(env, LISP_SYM_VALID,     LISP_VALID);
  Lisp_Env_Set(env, LISP_SYM_X,         LISP_X);
  Lisp_Env_Set(env, LISP_SYM_Y,         LISP_Y);
  Lisp_Env_Set(env, LISP_SYM_Z,         LISP_Z);
  Lisp_Env_Set(env, LISP_SYM_WAITDRAW,    LISP_WAITDRAW);
  Lisp_Env_Set(env, LISP_SYM_WAITFRAME,   LISP_WAITFRAME);
  Lisp_Env_Set(env, LISP_SYM_INPUT_START, LISP_INPUT_START);
  Lisp_Env_Set(env, LISP_SYM_INPUT_MAP,   LISP_INPUT_MAP);
  Lisp_Env_Set(env, LISP_SYM_INPUT_UP,    LISP_INPUT_UP);
  Lisp_Env_Set(env, LISP_SYM_INPUT_DOWN,  LISP_INPUT_DOWN);
  Lisp_Env_Set(env, LISP_SYM_INPUT_LEFT,  LISP_INPUT_LEFT);
  Lisp_Env_Set(env, LISP_SYM_INPUT_RIGHT, LISP_INPUT_RIGHT);
  Lisp_Env_Set(env, LISP_SYM_INPUT_L,     LISP_INPUT_L);
  Lisp_Env_Set(env, LISP_SYM_INPUT_R,     LISP_INPUT_R);
  Lisp_Env_Set(env, LISP_SYM_INPUT_EX1,   LISP_INPUT_EX1);
  Lisp_Env_Set(env, LISP_SYM_INPUT_EX2,   LISP_INPUT_EX2);
  Lisp_Env_Set(env, LISP_SYM_INPUT_EX3,   LISP_INPUT_EX3);
  Lisp_Env_Set(env, LISP_SYM_INPUT_EX4,   LISP_INPUT_EX4);
  Lisp_Env_Set(env, LISP_SYM_PRESS_START, LISP_PRESS_START);
  Lisp_Env_Set(env, LISP_SYM_PRESS_MAP,   LISP_PRESS_MAP);
  Lisp_Env_Set(env, LISP_SYM_PRESS_UP,    LISP_PRESS_UP);
  Lisp_Env_Set(env, LISP_SYM_PRESS_DOWN,  LISP_PRESS_DOWN);
  Lisp_Env_Set(env, LISP_SYM_PRESS_LEFT,  LISP_PRESS_LEFT);
  Lisp_Env_Set(env, LISP_SYM_PRESS_RIGHT, LISP_PRESS_RIGHT);
  Lisp_Env_Set(env, LISP_SYM_PRESS_L,     LISP_PRESS_L);
  Lisp_Env_Set(env, LISP_SYM_PRESS_R,     LISP_PRESS_R);
  Lisp_Env_Set(env, LISP_SYM_PRESS_EX1,   LISP_PRESS_EX1);
  Lisp_Env_Set(env, LISP_SYM_PRESS_EX2,   LISP_PRESS_EX2);
  Lisp_Env_Set(env, LISP_SYM_PRESS_EX3,   LISP_PRESS_EX3);
  Lisp_Env_Set(env, LISP_SYM_PRESS_EX4,   LISP_PRESS_EX4);
  Lisp_Env_Set(env, LISP_SYM_DIR,         LISP_DIR);
  Lisp_Env_Set(env, LISP_SYM_HP,          LISP_HP);
  Lisp_Env_Set(env, LISP_SYM_NPC_COUNT,      LISP_NPC_COUNT);
  Lisp_Env_Set(env, LISP_SYM_ITEM_COUNT,     LISP_ITEM_COUNT);
  Lisp_Env_Set(env, LISP_SYM_LWEAPON_COUNT,  LISP_LWEAPON_COUNT);
  Lisp_Env_Set(env, LISP_SYM_EWEAPON_COUNT,  LISP_EWEAPON_COUNT);
  Lisp_Env_Set(env, LISP_SYM_CUR_SCREEN,     LISP_CUR_SCREEN);
  Lisp_Env_Set(env, LISP_SYM_CUR_DSCREEN,    LISP_CUR_DSCREEN);
  Lisp_Env_Set(env, LISP_SYM_CUR_LEVEL,      LISP_CUR_LEVEL);
  Lisp_Env_Set(env, LISP_SYM_CUR_MAP,        LISP_CUR_MAP);
  Lisp_Env_Set(env, LISP_SYM_CUR_DMAP,       LISP_CUR_DMAP);
  Lisp_Env_Set(env, LISP_SYM_SCREEN_CHANGED, LISP_SCREEN_CHANGED);
  Lisp_Env_Set(env, LISP_SYM_ACTIVE_WAITFRAME, LISP_ACTIVE_WAITFRAME);
  Lisp_Env_Set(env, LISP_SYM_MEMORY_IN_USE, LISP_MEMORY_IN_USE);
  return env;}

////////////////////////////////////////////////////////////////
// Lists

// Get the nth value in a list.
int Lisp_List_Nth(int list, int n) {
  while (n > 0) {
    list = Lisp_Cell_Tail(list);
    if (!list) {return LISP_NIL;}
    --n;}
  return Lisp_Cell_Head(list);}

////////////////////////////////////////////////////////////////
// Initalization

void Lisp_Init() {
  Lisp_Symbol_Init();
  Lisp_Env_Root = Lisp_Env_Default();
	Lisp_Memory_Permanent(Lisp_Env_Root, true);
  int source[] = "
(define defmacro
  (macro (name & spec)
    (list 'define name
      (cell 'macro spec))))
(defmacro defn (name & spec)
  (list 'define name
    (cell 'function spec)))
(defmacro when (test & body)
  (list 'if test (cell 'do body) nil))
(defmacro unless (test & body)
  (list 'if test (cell nil body)))
(defn reverse (list)
  (let (result nil)
    (while list
      (set result (cell (head list) result))
      (set list (tail list)))
    result))
(defn nth (list n)
  (while n
    (set list (tail list))
    (- n 1))
  (head list))
(defn map (f list)
  (let (result nil)
    (while list
      (set result (cell (f (head list)) result))
      (set list (tail list)))
    (reverse result)))
(defn range (count)
  (let (result nil)
    (while count
      (set count (- count 1))
      (set result (cell count result)))
    result))

;; Pointers
(defn items ()
  (map item (range (item-count))))
(defn npcs ()
  (map item (range (npc-count))))
(defn lweapons ()
  (map item (range (lweapon-count))))
(defn eweapons ()
  (map item (range (eweapon-count))))
";
  Lisp_Eval(Lisp_Parse(source));
}

////////////////////////////////////////////////////////////////
// Printing

// Write a lisp value into a string. Returns the new last offset.
int Lisp_WriteValue(int array, int offset, int value) {
  int index;

  // Several important builtins.
  if (LISP_FALSE == value) {
    index = Lisp_Symbol_Indices[LISP_SYM_FALSE & ~LISP_TYPE_SYMBOL] - 1;
    offset = Lisp_WriteString(array, offset, Lisp_Symbol_Data, index);}
  else if (LISP_TRUE == value) {
    index = Lisp_Symbol_Indices[LISP_SYM_TRUE & ~LISP_TYPE_SYMBOL] - 1;
    offset = Lisp_WriteString(array, offset, Lisp_Symbol_Data, index);}
  else if (LISP_NIL == value) {
    index = Lisp_Symbol_Indices[LISP_SYM_NIL & ~LISP_TYPE_SYMBOL] - 1;
    offset = Lisp_WriteString(array, offset, Lisp_Symbol_Data, index);}
  else if (LISP_LINK == value) {
    index = Lisp_Symbol_Indices[LISP_SYM_LINK & ~LISP_TYPE_SYMBOL] - 1;
    array[offset] = '[';
    offset = Lisp_WriteString(array, offset + 1, Lisp_Symbol_Data, index);
    array[offset] = ']';
    ++offset;}

  // A list.
  else if (Lisp_IsCell(value)) {
    array[offset] = '(';
    offset += 1;
    while (LISP_NIL != value) {
      offset = Lisp_WriteValue(array, offset, Lisp_Cell_Head(value));
      value = Lisp_Cell_Tail(value);
      // If we reached the end of the list, quit.
      if (LISP_NIL == value) {
        array[offset] = ')';
        offset = offset + 1;
        break;}
      // If we don't end on a null, do the special . form.
      if (!Lisp_IsCell(value)) {
        array[offset] = ' ';
        array[offset + 1] = '.';
        array[offset + 2] = ' ';
        offset = Lisp_WriteValue(array, offset + 3, value);
        array[offset] = ')';
        offset = offset + 1;
        break;}
      array[offset] = ' ';
      ++offset;}}

  // A symbol.
  else if (Lisp_IsSymbol(value)) {
    // Strip symbol marker.
    value = value & ~LISP_TYPE_SYMBOL;
    index = Lisp_Symbol_Indices[value] - 1;
    if (-1 == index) {offset = Lisp_WriteValue_UnknownSymbol(array, offset);}
    else {offset = Lisp_WriteString(array, offset, Lisp_Symbol_Data, index);}}

  else if (Lisp_IsPointer(value)) {
    array[offset] = '['; ++offset;
    int type = LISP_POINTER_TYPE_MASK & value;
    if (LISP_TYPE_NPC == type) {
      index = Lisp_Symbol_Indices[LISP_SYM_NPC & ~LISP_TYPE_SYMBOL] - 1;
      offset = Lisp_WriteString(array, offset, Lisp_Symbol_Data, index);}
    if (LISP_TYPE_ITEM == type) {
      index = Lisp_Symbol_Indices[LISP_SYM_ITEM & ~LISP_TYPE_SYMBOL] - 1;
      offset = Lisp_WriteString(array, offset, Lisp_Symbol_Data, index);}
    if (LISP_TYPE_LWEAPON == type) {
      index = Lisp_Symbol_Indices[LISP_SYM_LWEAPON & ~LISP_TYPE_SYMBOL] - 1;
      offset = Lisp_WriteString(array, offset, Lisp_Symbol_Data, index);}
    if (LISP_TYPE_EWEAPON == type) {
      index = Lisp_Symbol_Indices[LISP_SYM_EWEAPON & ~LISP_TYPE_SYMBOL] - 1;
      offset = Lisp_WriteString(array, offset, Lisp_Symbol_Data, index);}
    array[offset] = ' '; ++offset;
    offset += itoa(array, offset, (LISP_POINTER_INDEX_MASK & value) + 1);
    array[offset] = ']'; ++offset;}

  // 0.
  else if (0 == value) {
    array[offset] = '0';
    offset += 1;}

  // A number.
  else {offset += ftoa(array, offset, value, true);}

  return offset;}

int Lisp_WriteValue_UnknownSymbol(int array, int offset) {
  int msg[] = "unknown-symbol";
  return Lisp_WriteString(array, offset, msg);}

// Create a formatted string.
int Lisp_Format(int target, int format,
                int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7,
                int a8, int a9, int aa, int ab, int ac, int ad, int ae, int af) {
  int args[0x10];
  arrayset(args, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, aa, ab, ac, ad, ae, af);

  int target_i = 0; int format_i = 0; int args_i = 0;
  while (0 != format[format_i] && target_i < SizeOfArray(target) - 1) {
    int c = format[format_i];

    if ('~' == c) {
      ++format_i;
      c = format[format_i];

      if ('~' == c) {
        target[target_i] = '~';
        ++format_i;
        ++target_i;
        continue;}

      if ('%' == c) {
        target[target_i] = 10; // newline
        ++format_i;
        ++target_i;
        continue;}

      if ('D' == c) {
        target_i += itoa(target, target_i, args[args_i]);
        ++format_i;
        ++args_i;
        continue;}

      if ('X' == c) {
        target_i += xtoa(target, target_i, args[args_i], true);
        ++format_i;
        ++args_i;
        continue;}

      if ('A' == c) {
        target_i = Lisp_WriteValue(target, target_i, args[args_i]);
        ++format_i;
        ++args_i;
        continue;}}

    target[target_i] = format[format_i];
    ++target_i;
    ++format_i;}

  target[target_i] = 0;
  return target_i;}

// Trace a long string.
void TraceS_Long(int string) {
  int buffer[0x200];
  int buffer_index = 0;
  int string_index = 0;
  while (string[string_index] != 0) {
    buffer[buffer_index] = string[string_index];
    if (0x1FE == buffer_index) {
      buffer_index = 0;
      TraceS(buffer);}
    ++buffer_index;
    ++string_index;}
  buffer[buffer_index] = 0;
  TraceS(buffer);}

void Lisp_Print(int format,
                int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7,
                int a8, int a9, int aa, int ab, int ac, int ad, int ae, int af) {
  int buffer[0x2000];
  Lisp_Format(buffer, format, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, aa, ab, ac, ad, ae, af);
  TraceS_Long(buffer);}

////////////////////////////////////////////////////////////////

int Lisp_Bool(bool value) {
  if (value) {return LISP_TRUE;}
  return LISP_FALSE;}

bool Lisp_IsTruthy(int value) {
  if (0 == value) {return false;}
  if (LISP_FALSE == value) {return false;}
  if (LISP_NIL == value) {return false;}
  return true;}

int Lisp_Eval(int x) {return Lisp_Eval(Lisp_Env_Root, x);}
int Lisp_Eval(int env, int x) {
  // Symbol
  if (Lisp_IsSymbol(x)) {return Lisp_Env_Get(env, x, false);}

  // Builtin.
  if (Lisp_IsBuiltin(x)) {return x;}

  // List.
  if (Lisp_IsCell(x)) {return Lisp_Eval_List(env, x);}

  // Number.
  if (Lisp_IsNumber(x)) {return x;}

}

// Evaluate a list.
int Lisp_Eval_List(int env, int list) {
  int f = Lisp_Eval(env, Lisp_Cell_Head(list));

  // Check for a function or macro.
  if (Lisp_IsCell(f) && f != LISP_NIL) {
    int g = Lisp_Cell_Head(f);
    if (g == LISP_SYM_FUNCTION) {return Lisp_Eval_Function_Call(env, f, Lisp_Cell_Tail(list));}
    if (g == LISP_SYM_MACRO) {return Lisp_Eval_Macro_Call(env, f, Lisp_Cell_Tail(list));}}

  // Builtin command.
  if (Lisp_IsBuiltin(f)) {
    if (LISP_ENV == f) {return env;}
    if (LISP_FUNCTION == f) {return list;}
    if (LISP_MACRO == f) {return list;}
    list = Lisp_Cell_Tail(list);
    if (LISP_HEAD == f) {return Lisp_Eval_Builtin_Head(env, list);}
    if (LISP_TAIL == f) {return Lisp_Eval_Builtin_Tail(env, list);}
    if (LISP_LIST == f) {return Lisp_Eval_Builtin_List(env, list);}
    if (LISP_ADD == f) {return Lisp_Eval_Builtin_Add(env, list);}
    if (LISP_SUBTRACT == f) {return Lisp_Eval_Builtin_Subtract(env, list);}
    if (LISP_MULTIPLY == f) {return Lisp_Eval_Builtin_Multiply(env, list);}
    if (LISP_DIVIDE == f) {return Lisp_Eval_Builtin_Divide(env, list);}
    if (LISP_SET == f) {return Lisp_Eval_Builtin_Set(env, list);}
    if (LISP_LET == f) {return Lisp_Eval_Builtin_Let(env, list);}
    if (LISP_DO == f) {return Lisp_Eval_Builtin_Do(env, list);}
    if (LISP_QUOTE == f) {return Lisp_Eval_Builtin_Quote(env, list);}
    if (LISP_IF == f) {return Lisp_Eval_Builtin_If(env, list);}
    if (LISP_CELL == f) {return Lisp_Eval_Builtin_Cell(env, list);}
    if (LISP_WHILE == f) {return Lisp_Eval_Builtin_While(env, list);}
    if (LISP_PRINT == f) {return Lisp_Eval_Builtin_Print(env, list);}
    if (LISP_DEFINE == f) {return Lisp_Eval_Builtin_Define(env, list);}
    if (LISP_NOT == f) {return Lisp_Eval_Builtin_Not(env, list);}
    if (LISP_LT == f) {return Lisp_Eval_Builtin_LT(env, list);}
    if (LISP_GT == f) {return Lisp_Eval_Builtin_GT(env, list);}
    if (LISP_EQ == f) {return Lisp_Eval_Builtin_EQ(env, list);}
    if (LISP_LTE == f) {return Lisp_Eval_Builtin_LTE(env, list);}
    if (LISP_GTE == f) {return Lisp_Eval_Builtin_GTE(env, list);}
    if (LISP_NPC == f) {return Lisp_Eval_Builtin_Npc(env, list);}
    if (LISP_ITEM == f) {return Lisp_Eval_Builtin_Item(env, list);}
    if (LISP_LWEAPON == f) {return Lisp_Eval_Builtin_LWeapon(env, list);}
    if (LISP_EWEAPON == f) {return Lisp_Eval_Builtin_EWeapon(env, list);}
    if (LISP_NPC_P == f) {return Lisp_Eval_Builtin_Npc_P(env, list);}
    if (LISP_ITEM_P == f) {return Lisp_Eval_Builtin_Item_P(env, list);}
    if (LISP_LWEAPON_P == f) {return Lisp_Eval_Builtin_LWeapon_P(env, list);}
    if (LISP_EWEAPON_P == f) {return Lisp_Eval_Builtin_EWeapon_P(env, list);}
    if (LISP_VALID == f) {return Lisp_Eval_Builtin_Valid(env, list);}
    if (LISP_X == f) {return Lisp_Eval_Builtin_X(env, list);}
    if (LISP_Y == f) {return Lisp_Eval_Builtin_Y(env, list);}
    if (LISP_Z == f) {return Lisp_Eval_Builtin_Z(env, list);}
    if (LISP_WAITDRAW == f) {return Lisp_Eval_Builtin_Waitdraw(env, list);}
    if (LISP_WAITFRAME == f) {return Lisp_Eval_Builtin_Waitframe(env, list);}
    if (LISP_INPUT_START == f) {return Lisp_Eval_Builtin_Input_Start(env, list);}
    if (LISP_INPUT_MAP == f) {return Lisp_Eval_Builtin_Input_Map(env, list);}
    if (LISP_INPUT_UP == f) {return Lisp_Eval_Builtin_Input_Up(env, list);}
    if (LISP_INPUT_DOWN == f) {return Lisp_Eval_Builtin_Input_Down(env, list);}
    if (LISP_INPUT_LEFT == f) {return Lisp_Eval_Builtin_Input_Left(env, list);}
    if (LISP_INPUT_RIGHT == f) {return Lisp_Eval_Builtin_Input_Right(env, list);}
    if (LISP_INPUT_L == f) {return Lisp_Eval_Builtin_Input_L(env, list);}
    if (LISP_INPUT_R == f) {return Lisp_Eval_Builtin_Input_L(env, list);}
    if (LISP_INPUT_EX1 == f) {return Lisp_Eval_Builtin_Input_Ex1(env, list);}
    if (LISP_INPUT_EX2 == f) {return Lisp_Eval_Builtin_Input_Ex2(env, list);}
    if (LISP_INPUT_EX3 == f) {return Lisp_Eval_Builtin_Input_Ex3(env, list);}
    if (LISP_INPUT_EX4 == f) {return Lisp_Eval_Builtin_Input_Ex4(env, list);}
    if (LISP_PRESS_START == f) {return Lisp_Eval_Builtin_Press_Start(env, list);}
    if (LISP_PRESS_MAP == f) {return Lisp_Eval_Builtin_Press_Map(env, list);}
    if (LISP_PRESS_UP == f) {return Lisp_Eval_Builtin_Press_Up(env, list);}
    if (LISP_PRESS_DOWN == f) {return Lisp_Eval_Builtin_Press_Down(env, list);}
    if (LISP_PRESS_LEFT == f) {return Lisp_Eval_Builtin_Press_Left(env, list);}
    if (LISP_PRESS_RIGHT == f) {return Lisp_Eval_Builtin_Press_Right(env, list);}
    if (LISP_PRESS_L == f) {return Lisp_Eval_Builtin_Press_L(env, list);}
    if (LISP_PRESS_R == f) {return Lisp_Eval_Builtin_Press_L(env, list);}
    if (LISP_PRESS_EX1 == f) {return Lisp_Eval_Builtin_Press_Ex1(env, list);}
    if (LISP_PRESS_EX2 == f) {return Lisp_Eval_Builtin_Press_Ex2(env, list);}
    if (LISP_PRESS_EX3 == f) {return Lisp_Eval_Builtin_Press_Ex3(env, list);}
    if (LISP_PRESS_EX4 == f) {return Lisp_Eval_Builtin_Press_Ex4(env, list);}
    if (LISP_DIR == f) {return Lisp_Eval_Builtin_Dir(env, list);}
    if (LISP_HP == f) {return Lisp_Eval_Builtin_Hp(env, list);}
    if (LISP_NPC_COUNT == f) {return Screen->NumNPCs();}
    if (LISP_ITEM_COUNT == f) {return Screen->NumItems();}
    if (LISP_LWEAPON_COUNT == f) {return Screen->NumLWeapons();}
    if (LISP_EWEAPON_COUNT == f) {return Screen->NumEWeapons();}
		if (LISP_CUR_SCREEN == f) {return Game->GetCurScreen();}
		if (LISP_CUR_DSCREEN == f) {return Game->GetCurDMapScreen();}
		if (LISP_CUR_LEVEL == f) {return Game->GetCurLevel();}
		if (LISP_CUR_MAP == f) {return Game->GetCurMap();}
		if (LISP_CUR_DMAP == f) {return Game->GetCurDMap();}
		if (LISP_SCREEN_CHANGED == f) {return Lisp_State_ScreenChanged;}
    if (LISP_ACTIVE_WAITFRAME == f) {return Lisp_Eval_Builtin_Active_Waitframe(env, list);}
    if (LISP_MEMORY_IN_USE == f) {return Lisp_Memory_InUseCount();}
  }

  Lisp_Eval_List_CannotCall(f);
  return 0;}
void Lisp_Eval_List_CannotCall(int x) {
  int msg[] = "ERROR: Cannot call value ~A.~%";
  Lisp_Print(msg, x);}

void Lisp_Eval_IncorrectArgCount(int f_sym) {
  int msg[] = "ERROR (~A): Illegal argument count.~%";
  Lisp_Print(msg, f_sym);}
void Lisp_Eval_ArgsNotList(int f_sym) {
  int msg[] = "ERROR (~A): Malformed arguments.~%";
  Lisp_Print(msg, f_sym);}

int Lisp_Eval_Builtin_Head(int env, int list) {
  if (LISP_NIL == list) {
    Lisp_Eval_IncorrectArgCount(LISP_SYM_HEAD);
    return LISP_NIL;}
  int value = Lisp_Eval(env, Lisp_Cell_Head(list));
  if (LISP_NIL != Lisp_Cell_Tail(list)) {
    Lisp_Eval_IncorrectArgCount(LISP_SYM_HEAD);
    return LISP_NIL;}
  return Lisp_Cell_Head(value);}

int Lisp_Eval_Builtin_Tail(int env, int list) {
  if (LISP_NIL == list) {
    Lisp_Eval_IncorrectArgCount(LISP_SYM_TAIL);
    return LISP_NIL;}
  int value = Lisp_Eval(env, Lisp_Cell_Head(list));
  if (LISP_NIL != Lisp_Cell_Tail(list)) {
    Lisp_Eval_IncorrectArgCount(LISP_SYM_TAIL);
    return LISP_NIL;}
  return Lisp_Cell_Tail(value);}

int Lisp_Eval_Builtin_List(int env, int list) {
  if (LISP_NIL == list) {return LISP_NIL;}
  int head = LISP_NIL;
  int current = head;
  while (list != LISP_NIL) {
    int tmp = Lisp_Cell(Lisp_Eval(env, Lisp_Cell_Head(list)), LISP_NIL);
    if (LISP_NIL == head) {head = tmp;}
    else {Lisp_Cell_Tail(current, tmp);}
    current = tmp;
    list = Lisp_Cell_Tail(list);
    if (!Lisp_IsCell(list)) {
      Lisp_Eval_ArgsNotList(LISP_SYM_LIST);
      return LISP_NIL;}}
  return head;}

int Lisp_Eval_Builtin_Add(int env, int list) {
  int value = 0;
  while (LISP_NIL != list) {
    if (!Lisp_IsCell(list)) {
      Lisp_Eval_ArgsNotList(LISP_SYM_ADD);
      return LISP_NIL;}
    int head = Lisp_Eval(env, Lisp_Cell_Head(list));
    if (!Lisp_IsNumber(head)) {
      Lisp_Eval_Builtin_Add_NotNumber(head);
      return LISP_NIL;}
    value += head;
    list = Lisp_Cell_Tail(list);}
  return value;}
void Lisp_Eval_Builtin_Add_NotNumber(int value) {
  int msg[] = "ERROR (+): Argument <~A> is not a number.~%";
  Lisp_Print(msg, value);}

int Lisp_Eval_Builtin_Subtract(int env, int list) {
  int value = Lisp_Eval(env, Lisp_Cell_Head(list));
  if (!Lisp_IsNumber(value)) {
    Lisp_Eval_Builtin_Subtract_NotNumber(value);
    return LISP_NIL;}
  list = Lisp_Cell_Tail(list);
  while (LISP_NIL != list) {
    int head = Lisp_Eval(env, Lisp_Cell_Head(list));
    if (!Lisp_IsNumber(head)) {
      Lisp_Eval_Builtin_Subtract_NotNumber(head);
      return LISP_NIL;}
    value -= head;
    list = Lisp_Cell_Tail(list);
    if (!Lisp_IsCell(list)) {
      Lisp_Eval_ArgsNotList(LISP_SYM_SUBTRACT);
      return LISP_NIL;}}
  return value;}
void Lisp_Eval_Builtin_Subtract_NotNumber(int value) {
  int msg[] = "ERROR (-): Argument <~A> is not a number.~%";
  Lisp_Print(msg, value);}

int Lisp_Eval_Builtin_Multiply(int env, int list) {
  int value = 1;
  while (LISP_NIL != list) {
    if (!Lisp_IsCell(list)) {
      Lisp_Eval_ArgsNotList(LISP_SYM_MULTIPLY);
      return LISP_NIL;}
    int head = Lisp_Eval(env, Lisp_Cell_Head(list));
    if (!Lisp_IsNumber(head)) {
      Lisp_Eval_Builtin_Multiply_NotNumber(head);
      return LISP_NIL;}
    value *= head;
    list = Lisp_Cell_Tail(list);}
  return value;}
void Lisp_Eval_Builtin_Multiply_NotNumber(int value) {
  int msg[] = "ERROR (*): Argument <~A> is not a number.~%";
  Lisp_Print(msg, value);}

int Lisp_Eval_Builtin_Divide(int env, int list) {
  int value = Lisp_Eval(env, Lisp_Cell_Head(list));
  if (!Lisp_IsNumber(value)) {
    Lisp_Eval_Builtin_Divide_NotNumber(value);
    return 0;}
  list = Lisp_Cell_Tail(list);
  while (LISP_NIL != list) {
    int head = Lisp_Eval(env, Lisp_Cell_Head(list));
    if (!Lisp_IsNumber(head)) {
      Lisp_Eval_Builtin_Divide_NotNumber(head);
      return LISP_NIL;}
    value /= head;
    list = Lisp_Cell_Tail(list);
    if (!Lisp_IsCell(list)) {
      Lisp_Eval_ArgsNotList(LISP_SYM_DIVIDE);
      return LISP_NIL;}}
  return value;}
void Lisp_Eval_Builtin_Divide_NotNumber(int value) {
  int msg[] = "ERROR (/): Argument <~A> is not a number.~%";
  Lisp_Print(msg, value);}

int Lisp_Eval_Builtin_Set(int env, int list) {
  int key; int value;
  while (LISP_NIL != list) {
    key = Lisp_Cell_Head(list);
    if (!Lisp_IsSymbol(key)) {
      Lisp_Eval_Builtin_Set_NotSymbol(key);
      return LISP_NIL;}
    list = Lisp_Cell_Tail(list);
    value = Lisp_Eval(env, Lisp_Cell_Head(list));
    Lisp_Env_Set(env, key, value);
    list = Lisp_Cell_Tail(list);}
  return value;}
void Lisp_Eval_Builtin_Set_NotSymbol(int key) {
  int msg[] = "ERROR (set): <~A> is not a symbol.~%";
  Lisp_Print(msg);}

int Lisp_Eval_Builtin_Let(int env, int list) {
  int new_env = Lisp_Env(env);
  int bindings = Lisp_Cell_Head(list);
  list = Lisp_Cell_Tail(list);
  while (LISP_NIL != bindings) {
    int key = Lisp_Cell_Head(bindings);
    if (!Lisp_IsSymbol(key)) {
      Lisp_Eval_Builtin_Let_NotSymbol(key);
      return LISP_NIL;}
    bindings = Lisp_Cell_Tail(bindings);
    int value = Lisp_Eval(env, Lisp_Cell_Head(bindings));
    Lisp_Env_Set(new_env, key, value, true);
    bindings = Lisp_Cell_Tail(bindings);}
	int result = Lisp_Eval_Builtin_Do(new_env, list);
	Lisp_Memory_GC(new_env);
  return result;}
void Lisp_Eval_Builtin_Let_NotSymbol(int key) {
  int msg[] = "ERROR (let): <~A> is not a symbol.~%";
  Lisp_Print(msg);}

int Lisp_Eval_Builtin_Do(int env, int list) {
  int result = LISP_NIL;
  while (LISP_NIL != list) {
    result = Lisp_Eval(env, Lisp_Cell_Head(list));
    list = Lisp_Cell_Tail(list);}
  return result;}

int Lisp_Eval_Builtin_Quote(int env, int list) {
  if (LISP_NIL != Lisp_Cell_Tail(list)) {Lisp_Eval_Builtin_Quote_TooManyArgs();}
  return Lisp_Cell_Head(list);}
void Lisp_Eval_Builtin_Quote_TooManyArgs() {
  int msg[] = "ERROR (quote): Too many arguments.~%";
  Lisp_Print(msg);}

int Lisp_Eval_Builtin_If(int env, int list) {
  int test = Lisp_Eval(env, Lisp_Cell_Head(list));
  list = Lisp_Cell_Tail(list);
  if (Lisp_IsTruthy(test)) {
    return Lisp_Eval(env, Lisp_Cell_Head(list));}
  else {
    list = Lisp_Cell_Tail(list);
    return Lisp_Eval_Builtin_Do(env, list);}}

int Lisp_Eval_Builtin_Cell(int env, int list) {
  int head = Lisp_Eval(env, Lisp_Cell_Head(list));
  list = Lisp_Cell_Tail(list);
  int tail = Lisp_Eval(env, Lisp_Cell_Head(list));
  return Lisp_Cell(head, tail);}

int Lisp_Eval_Builtin_While(int env, int list) {
  int result = LISP_NIL;
  int test_code = Lisp_Cell_Head(list);
  list = Lisp_Cell_Tail(list);
  while (Lisp_IsTruthy(Lisp_Eval(env, test_code))) {
    result = Lisp_Eval_Builtin_Do(env, list);}
  return result;}

int Lisp_Eval_Builtin_Print(int env, int list) {
  int result = Lisp_Eval(env, Lisp_Cell_Head(list));
  int msg[] = "~A~%";
  Lisp_Print(msg, result);
  return result;}

int Lisp_Eval_Builtin_Define(int env, int list) {
  int key = Lisp_Cell_Head(list);
  if (!Lisp_IsSymbol(key)) {
    Lisp_Eval_Builtin_Define_NotSymbol(key);
    return LISP_NIL;}
  list = Lisp_Cell_Tail(list);
  int value = Lisp_Eval(env, Lisp_Cell_Head(list));
  Lisp_Env_Set(Lisp_Env_Root, key, value);
  return value;}
void Lisp_Eval_Builtin_Define_NotSymbol(int key) {
  int msg[] = "ERROR (define): <~A> is not a symbol.~%";
  Lisp_Print(msg);}

int Lisp_Eval_Builtin_Not(int env, int list) {
  if (LISP_NIL != Lisp_Cell_Tail(list)) {
    Lisp_Eval_IncorrectArgCount(LISP_SYM_NOT);
    return LISP_NIL;}
  int x = Lisp_Eval(env, Lisp_Cell_Head(list));
  if (Lisp_IsTruthy(x)) {return LISP_FALSE;}
  else {return LISP_TRUE;}}

int Lisp_Eval_Builtin_LT(int env, int list) {
  int previous = Lisp_Eval(env, Lisp_Cell_Head(list));
  list = Lisp_Cell_Tail(list);
  int current = Lisp_Eval(env, Lisp_Cell_Head(list));
  while (LISP_NIL != list) {
    if (previous >= current) {return LISP_FALSE;}
    previous = current;
    list = Lisp_Cell_Tail(list);
    current = Lisp_Eval(env, Lisp_Cell_Head(list));}
  return LISP_TRUE;}

int Lisp_Eval_Builtin_GT(int env, int list) {
  int previous = Lisp_Eval(env, Lisp_Cell_Head(list));
  list = Lisp_Cell_Tail(list);
  int current = Lisp_Eval(env, Lisp_Cell_Head(list));
  while (LISP_NIL != list) {
    if (previous <= current) {return LISP_FALSE;}
    previous = current;
    list = Lisp_Cell_Tail(list);
    current = Lisp_Eval(env, Lisp_Cell_Head(list));}
  return LISP_TRUE;}

int Lisp_Eval_Builtin_EQ(int env, int list) {
  int previous = Lisp_Eval(env, Lisp_Cell_Head(list));
  list = Lisp_Cell_Tail(list);
  int current = Lisp_Eval(env, Lisp_Cell_Head(list));
  while (LISP_NIL != list) {
    if (previous != current) {return LISP_FALSE;}
    previous = current;
    list = Lisp_Cell_Tail(list);
    current = Lisp_Eval(env, Lisp_Cell_Head(list));}
  return LISP_TRUE;}

int Lisp_Eval_Builtin_LTE(int env, int list) {
  int previous = Lisp_Eval(env, Lisp_Cell_Head(list));
  list = Lisp_Cell_Tail(list);
  int current = Lisp_Eval(env, Lisp_Cell_Head(list));
  while (LISP_NIL != list) {
    if (previous > current) {return LISP_FALSE;}
    previous = current;
    list = Lisp_Cell_Tail(list);
    current = Lisp_Eval(env, Lisp_Cell_Head(list));}
  return LISP_TRUE;}

int Lisp_Eval_Builtin_GTE(int env, int list) {
  int previous = Lisp_Eval(env, Lisp_Cell_Head(list));
  list = Lisp_Cell_Tail(list);
  int current = Lisp_Eval(env, Lisp_Cell_Head(list));
  while (LISP_NIL != list) {
    if (previous < current) {return LISP_FALSE;}
    previous = current;
    list = Lisp_Cell_Tail(list);
    current = Lisp_Eval(env, Lisp_Cell_Head(list));}
  return LISP_TRUE;}

int Lisp_Eval_Builtin_Npc(int env, int list) {
  return Lisp_Eval(env, Lisp_Cell_Head(list)) | LISP_TYPE_NPC | LISP_TYPE_POINTER;}
int Lisp_Eval_Builtin_Item(int env, int list) {
  return Lisp_Eval(env, Lisp_Cell_Head(list)) | LISP_TYPE_ITEM | LISP_TYPE_POINTER;}
int Lisp_Eval_Builtin_LWeapon(int env, int list) {
  return Lisp_Eval(env, Lisp_Cell_Head(list)) | LISP_TYPE_LWEAPON | LISP_TYPE_POINTER;}
int Lisp_Eval_Builtin_EWeapon(int env, int list) {
  return Lisp_Eval(env, Lisp_Cell_Head(list)) | LISP_TYPE_EWEAPON | LISP_TYPE_POINTER;}

int Lisp_Eval_Builtin_Npc_P(int env, int list) {
  int x = Lisp_Eval(env, Lisp_Cell_Head(list));
  return Lisp_Bool(x & LISP_TYPE_POINTER && (LISP_POINTER_TYPE_MASK & x) == LISP_TYPE_NPC);}
int Lisp_Eval_Builtin_Item_P(int env, int list) {
  int x = Lisp_Eval(env, Lisp_Cell_Head(list));
  return Lisp_Bool(x & LISP_TYPE_POINTER && (LISP_POINTER_TYPE_MASK & x) == LISP_TYPE_ITEM);}
int Lisp_Eval_Builtin_LWeapon_P(int env, int list) {
  int x = Lisp_Eval(env, Lisp_Cell_Head(list));
  return Lisp_Bool(x & LISP_TYPE_POINTER && (LISP_POINTER_TYPE_MASK & x) == LISP_TYPE_LWEAPON);}
int Lisp_Eval_Builtin_EWeapon_P(int env, int list) {
  int x = Lisp_Eval(env, Lisp_Cell_Head(list));
  return Lisp_Bool(x & LISP_TYPE_POINTER && (LISP_POINTER_TYPE_MASK & x) == LISP_TYPE_EWEAPON);}
int Lisp_Eval_Builtin_Link_P(int env, int list) {
  int x = Lisp_Eval(env, Lisp_Cell_Head(list));
  return Lisp_Bool(x == LISP_LINK);}

int Lisp_Eval_Builtin_Valid(int env, int list) {
  int x = Lisp_Eval(env, Lisp_Cell_Head(list));
  if (LISP_LINK == x) {return LISP_TRUE;}
  if (!(LISP_TYPE_POINTER & x)) {return LISP_FALSE;}
  int type = x & LISP_POINTER_TYPE_MASK;
  int index = (x & LISP_POINTER_INDEX_MASK) + 1;
  if (type == LISP_TYPE_NPC) {
    npc o = Screen->LoadNPC(index);
    return Lisp_Bool(o->isValid());}
  if (type == LISP_TYPE_ITEM) {
    item o = Screen->LoadItem(index);
    return Lisp_Bool(o->isValid());}
  if (type == LISP_TYPE_LWEAPON) {
    lweapon o = Screen->LoadLWeapon(index);
    return Lisp_Bool(o->isValid());}
  if (type == LISP_TYPE_ITEM) {
    eweapon o = Screen->LoadEWeapon(index);
    return Lisp_Bool(o->isValid());}
  return LISP_NIL;}

int Lisp_Eval_NotPointer(int f_sym, int value) {
  int msg[] = "ERROR (~A): ~A is not a pointer.~%";
  Lisp_Print(msg, f_sym, value);}

int Lisp_Eval_NotNumber(int f_sym, int value) {
  int msg[] = "ERROR (~A): ~A is not a number.~%";
  Lisp_Print(msg, f_sym, value);}

int Lisp_Eval_Builtin_X(int env, int list) {
  int pointer = Lisp_Eval(env, Lisp_Cell_Head(list));
  if (!Lisp_IsPointer(pointer)) {
    Lisp_Eval_NotPointer(LISP_SYM_X, pointer);
    return LISP_NIL;}
  list = Lisp_Cell_Tail(list);
  bool set = false;
  int value;
  if (LISP_NIL != list) {
    set = true;
    value = Lisp_Eval(env, Lisp_Cell_Head(list));
    if (!Lisp_IsNumber(value)) {
      Lisp_Eval_NotNumber(LISP_SYM_X, value);
      return LISP_NIL;}}
  if (LISP_LINK == pointer) {
    if (set) {Link->X = value;}
    return Link->X;}
  int type = pointer & LISP_POINTER_TYPE_MASK;
  int index = (pointer & LISP_POINTER_INDEX_MASK) + 1;
  if (LISP_TYPE_NPC == type) {
    npc o = Screen->LoadNPC(index);
    if (set) {o->X = value;}
    return o->X;}
  if (LISP_TYPE_ITEM == type) {
    item o = Screen->LoadItem(index);
    if (set) {o->X = value;}
    return o->X;}
  if (LISP_TYPE_LWEAPON == type) {
    lweapon o = Screen->LoadLWeapon(index);
    if (set) {o->X = value;}
    return o->X;}
  if (LISP_TYPE_EWEAPON == type) {
    eweapon o = Screen->LoadEWeapon(index);
    if (set) {o->X = value;}
    return o->X;}
  return LISP_NIL;}

int Lisp_Eval_Builtin_Y(int env, int list) {
  int pointer = Lisp_Eval(env, Lisp_Cell_Head(list));
  if (!Lisp_IsPointer(pointer)) {
    Lisp_Eval_NotPointer(LISP_SYM_Y, pointer);
    return LISP_NIL;}
  list = Lisp_Cell_Tail(list);
  bool set = false;
  int value;
  if (LISP_NIL != list) {
    set = true;
    value = Lisp_Eval(env, Lisp_Cell_Head(list));
    if (!Lisp_IsNumber(value)) {
      Lisp_Eval_NotNumber(LISP_SYM_Y, value);
      return LISP_NIL;}}
  if (LISP_LINK == pointer) {
    if (set) {Link->Y = value;}
    return Link->Y;}
  int type = pointer & LISP_POINTER_TYPE_MASK;
  int index = (pointer & LISP_POINTER_INDEX_MASK) + 1;
  if (LISP_TYPE_NPC == type) {
    npc o = Screen->LoadNPC(index);
    if (set) {o->Y = value;}
    return o->Y;}
  if (LISP_TYPE_ITEM == type) {
    item o = Screen->LoadItem(index);
    if (set) {o->Y = value;}
    return o->Y;}
  if (LISP_TYPE_LWEAPON == type) {
    lweapon o = Screen->LoadLWeapon(index);
    if (set) {o->Y = value;}
    return o->Y;}
  if (LISP_TYPE_EWEAPON == type) {
    eweapon o = Screen->LoadEWeapon(index);
    if (set) {o->Y = value;}
    return o->Y;}
  return LISP_NIL;}

int Lisp_Eval_Builtin_Z(int env, int list) {
  int pointer = Lisp_Eval(env, Lisp_Cell_Head(list));
  if (!Lisp_IsPointer(pointer)) {
    Lisp_Eval_NotPointer(LISP_SYM_Z, pointer);
    return LISP_NIL;}
  list = Lisp_Cell_Tail(list);
  bool set = false;
  int value;
  if (LISP_NIL != list) {
    set = true;
    value = Lisp_Eval(env, Lisp_Cell_Head(list));
    if (!Lisp_IsNumber(value)) {
      Lisp_Eval_NotNumber(LISP_SYM_Z, value);
      return LISP_NIL;}}
  if (LISP_LINK == pointer) {
    if (set) {Link->Z = value;}
    return Link->Z;}
  int type = pointer & LISP_POINTER_TYPE_MASK;
  int index = (pointer & LISP_POINTER_INDEX_MASK) + 1;
  if (LISP_TYPE_NPC == type) {
    npc o = Screen->LoadNPC(index);
    if (set) {o->Z = value;}
    return o->Z;}
  if (LISP_TYPE_ITEM == type) {
    item o = Screen->LoadItem(index);
    if (set) {o->Z = value;}
    return o->Z;}
  if (LISP_TYPE_LWEAPON == type) {
    lweapon o = Screen->LoadLWeapon(index);
    if (set) {o->Z = value;}
    return o->Z;}
  if (LISP_TYPE_EWEAPON == type) {
    eweapon o = Screen->LoadEWeapon(index);
    if (set) {o->Z = value;}
    return o->Z;}
  return LISP_NIL;}

int Lisp_Eval_Builtin_Waitdraw(int env, int list) {Waitdraw();}
int Lisp_Eval_Builtin_Waitframe(int env, int list) {Waitframe();}

int Lisp_State_ScreenChanged = 0;
int Lisp_State_LastScreen = -1;
int Lisp_Eval_Builtin_Active_Waitframe(int env, int list) {
	Waitframe();
	int screen = (Game->GetCurDMap() << 8) + Game->GetCurDMapScreen();
	Lisp_State_ScreenChanged = Cond(screen != Lisp_State_LastScreen, 1, 0);
	Lisp_State_LastScreen = screen;

	//int msg[] = "Memory: %d\n"; printf(msg, Lisp_Memory_InUseCount());

	if (Lisp_State_ScreenChanged) {
		int memory_start = Lisp_Memory_InUseCount();
		Lisp_Memory_GC();
		int memory_end = Lisp_Memory_InUseCount();
		int msg[] = "Garbage Collection: %d -> %d\n";
		printf(msg, memory_start, memory_end);
	}
}

int Lisp_Eval_Builtin_Input_Start(int env, int list) {
  if (LISP_NIL != list) {
    Link->InputStart = Lisp_IsTruthy(Lisp_Eval(env, Lisp_Cell_Head(list)));}
  return Lisp_Bool(Link->InputStart);}
int Lisp_Eval_Builtin_Input_Map(int env, int list) {
  if (LISP_NIL != list) {
    Link->InputMap = Lisp_IsTruthy(Lisp_Eval(env, Lisp_Cell_Head(list)));}
  return Lisp_Bool(Link->InputMap);}
int Lisp_Eval_Builtin_Input_Up(int env, int list) {
  if (LISP_NIL != list) {
    Link->InputUp = Lisp_IsTruthy(Lisp_Eval(env, Lisp_Cell_Head(list)));}
  return Lisp_Bool(Link->InputUp);}
int Lisp_Eval_Builtin_Input_Down(int env, int list) {
  if (LISP_NIL != list) {
    Link->InputDown = Lisp_IsTruthy(Lisp_Eval(env, Lisp_Cell_Head(list)));}
  return Lisp_Bool(Link->InputDown);}
int Lisp_Eval_Builtin_Input_Left(int env, int list) {
  if (LISP_NIL != list) {
    Link->InputLeft = Lisp_IsTruthy(Lisp_Eval(env, Lisp_Cell_Head(list)));}
  return Lisp_Bool(Link->InputLeft);}
int Lisp_Eval_Builtin_Input_Right(int env, int list) {
  if (LISP_NIL != list) {
    Link->InputRight = Lisp_IsTruthy(Lisp_Eval(env, Lisp_Cell_Head(list)));}
  return Lisp_Bool(Link->InputRight);}
int Lisp_Eval_Builtin_Input_L(int env, int list) {
  if (LISP_NIL != list) {
    Link->InputL = Lisp_IsTruthy(Lisp_Eval(env, Lisp_Cell_Head(list)));}
  return Lisp_Bool(Link->InputL);}
int Lisp_Eval_Builtin_Input_R(int env, int list) {
  if (LISP_NIL != list) {
    Link->InputR = Lisp_IsTruthy(Lisp_Eval(env, Lisp_Cell_Head(list)));}
  return Lisp_Bool(Link->InputR);}
int Lisp_Eval_Builtin_Input_Ex1(int env, int list) {
  if (LISP_NIL != list) {
    Link->InputEx1 = Lisp_IsTruthy(Lisp_Eval(env, Lisp_Cell_Head(list)));}
  return Lisp_Bool(Link->InputEx1);}
int Lisp_Eval_Builtin_Input_Ex2(int env, int list) {
  if (LISP_NIL != list) {
    Link->InputEx2 = Lisp_IsTruthy(Lisp_Eval(env, Lisp_Cell_Head(list)));}
  return Lisp_Bool(Link->InputEx2);}
int Lisp_Eval_Builtin_Input_Ex3(int env, int list) {
  if (LISP_NIL != list) {
    Link->InputEx3 = Lisp_IsTruthy(Lisp_Eval(env, Lisp_Cell_Head(list)));}
  return Lisp_Bool(Link->InputEx3);}
int Lisp_Eval_Builtin_Input_Ex4(int env, int list) {
  if (LISP_NIL != list) {
    Link->InputEx4 = Lisp_IsTruthy(Lisp_Eval(env, Lisp_Cell_Head(list)));}
  return Lisp_Bool(Link->InputEx4);}
int Lisp_Eval_Builtin_Press_Start(int env, int list) {
  if (LISP_NIL != list) {
    Link->PressStart = Lisp_IsTruthy(Lisp_Eval(env, Lisp_Cell_Head(list)));}
  return Lisp_Bool(Link->PressStart);}
int Lisp_Eval_Builtin_Press_Map(int env, int list) {
  if (LISP_NIL != list) {
    Link->PressMap = Lisp_IsTruthy(Lisp_Eval(env, Lisp_Cell_Head(list)));}
  return Lisp_Bool(Link->PressMap);}
int Lisp_Eval_Builtin_Press_Up(int env, int list) {
  if (LISP_NIL != list) {
    Link->PressUp = Lisp_IsTruthy(Lisp_Eval(env, Lisp_Cell_Head(list)));}
  return Lisp_Bool(Link->PressUp);}
int Lisp_Eval_Builtin_Press_Down(int env, int list) {
  if (LISP_NIL != list) {
    Link->PressDown = Lisp_IsTruthy(Lisp_Eval(env, Lisp_Cell_Head(list)));}
  return Lisp_Bool(Link->PressDown);}
int Lisp_Eval_Builtin_Press_Left(int env, int list) {
  if (LISP_NIL != list) {
    Link->PressLeft = Lisp_IsTruthy(Lisp_Eval(env, Lisp_Cell_Head(list)));}
  return Lisp_Bool(Link->PressLeft);}
int Lisp_Eval_Builtin_Press_Right(int env, int list) {
  if (LISP_NIL != list) {
    Link->PressRight = Lisp_IsTruthy(Lisp_Eval(env, Lisp_Cell_Head(list)));}
  return Lisp_Bool(Link->PressRight);}
int Lisp_Eval_Builtin_Press_L(int env, int list) {
  if (LISP_NIL != list) {
    Link->PressL = Lisp_IsTruthy(Lisp_Eval(env, Lisp_Cell_Head(list)));}
  return Lisp_Bool(Link->PressL);}
int Lisp_Eval_Builtin_Press_R(int env, int list) {
  if (LISP_NIL != list) {
    Link->PressR = Lisp_IsTruthy(Lisp_Eval(env, Lisp_Cell_Head(list)));}
  return Lisp_Bool(Link->PressR);}
int Lisp_Eval_Builtin_Press_Ex1(int env, int list) {
  if (LISP_NIL != list) {
    Link->PressEx1 = Lisp_IsTruthy(Lisp_Eval(env, Lisp_Cell_Head(list)));}
  return Lisp_Bool(Link->PressEx1);}
int Lisp_Eval_Builtin_Press_Ex2(int env, int list) {
  if (LISP_NIL != list) {
    Link->PressEx2 = Lisp_IsTruthy(Lisp_Eval(env, Lisp_Cell_Head(list)));}
  return Lisp_Bool(Link->PressEx2);}
int Lisp_Eval_Builtin_Press_Ex3(int env, int list) {
  if (LISP_NIL != list) {
    Link->PressEx3 = Lisp_IsTruthy(Lisp_Eval(env, Lisp_Cell_Head(list)));}
  return Lisp_Bool(Link->PressEx3);}
int Lisp_Eval_Builtin_Press_Ex4(int env, int list) {
  if (LISP_NIL != list) {
    Link->PressEx4 = Lisp_IsTruthy(Lisp_Eval(env, Lisp_Cell_Head(list)));}
  return Lisp_Bool(Link->PressEx4);}

int Lisp_Eval_Builtin_Dir(int env, int list) {
  int pointer = Lisp_Eval(env, Lisp_Cell_Head(list));
  if (!Lisp_IsPointer(pointer)) {
    Lisp_Eval_NotPointer(LISP_SYM_DIR, pointer);
    return LISP_NIL;}
  list = Lisp_Cell_Tail(list);
  bool set = false;
  int value;
  if (LISP_NIL != list) {
    set = true;
    value = Lisp_Eval(env, Lisp_Cell_Head(list));
    if (!Lisp_IsNumber(value)) {
      Lisp_Eval_NotNumber(LISP_SYM_DIR, value);
      return LISP_NIL;}}
  if (LISP_LINK == pointer) {
    if (set) {Link->Dir = value;}
    return Link->Dir;}
  int type = pointer & LISP_POINTER_TYPE_MASK;
  int index = (pointer & LISP_POINTER_INDEX_MASK) + 1;
  if (LISP_TYPE_NPC == type) {
    npc o = Screen->LoadNPC(index);
    if (set) {o->Dir = value;}
    return o->Dir;}
  if (LISP_TYPE_LWEAPON == type) {
    lweapon o = Screen->LoadLWeapon(index);
    if (set) {o->Dir = value;}
    return o->Dir;}
  if (LISP_TYPE_EWEAPON == type) {
    eweapon o = Screen->LoadEWeapon(index);
    if (set) {o->Dir = value;}
    return o->Dir;}
  return LISP_NIL;}

int Lisp_Eval_Builtin_Hp(int env, int list) {
  int pointer = Lisp_Eval(env, Lisp_Cell_Head(list));
  if (!Lisp_IsPointer(pointer)) {
    Lisp_Eval_NotPointer(LISP_SYM_HP, pointer);
    return LISP_NIL;}
  list = Lisp_Cell_Tail(list);
  bool set = false;
  int value;
  if (LISP_NIL != list) {
    set = true;
    value = Lisp_Eval(env, Lisp_Cell_Head(list));
    if (!Lisp_IsNumber(value)) {
      Lisp_Eval_NotNumber(LISP_SYM_HP, value);
      return LISP_NIL;}}
  if (LISP_LINK == pointer) {
    if (set) {Link->HP = value;}
    return Link->HP;}
  int type = pointer & LISP_POINTER_TYPE_MASK;
  int index = (pointer & LISP_POINTER_INDEX_MASK) + 1;
  if (LISP_TYPE_NPC == type) {
    npc o = Screen->LoadNPC(index);
    if (set) {o->HP = value;}
    return o->HP;}
  return LISP_NIL;}

int Lisp_Eval_Function_Call(int env, int f, int args) {
  f = Lisp_Cell_Tail(f);
  int arg_spec = Lisp_Cell_Head(f);
  int f_body = Lisp_Cell_Tail(f);

  int new_env = Lisp_Env(env);
  while (LISP_NIL != arg_spec && LISP_NIL != args) {
    int spec = Lisp_Cell_Head(arg_spec);
    if (LISP_SYM_VARARG == spec) {
      spec = Lisp_Cell_Head(Lisp_Cell_Tail(arg_spec));
      Lisp_Env_Set(new_env, spec, args, true);
      break;}
    int arg = Lisp_Eval(env, Lisp_Cell_Head(args));
    Lisp_Env_Set(new_env, spec, arg, true);
    arg_spec = Lisp_Cell_Tail(arg_spec);
    args = Lisp_Cell_Tail(args);}

	int result = Lisp_Eval_Builtin_Do(new_env, f_body);
	Lisp_Memory_GC(new_env);
  return result;}

int Lisp_Eval_Macro_Call(int env, int macro, int args) {
  int m = Lisp_Cell_Tail(macro);
  int arg_spec = Lisp_Cell_Head(m);
  int m_body = Lisp_Cell_Tail(m);

  int new_env = Lisp_Env(env);
  while (LISP_NIL != arg_spec && LISP_NIL != args) {
    int spec = Lisp_Cell_Head(arg_spec);
    if (LISP_SYM_VARARG == spec) {
      spec = Lisp_Cell_Head(Lisp_Cell_Tail(arg_spec));
      Lisp_Env_Set(new_env, spec, args, true);
      break;}
    int arg = Lisp_Cell_Head(args);
    Lisp_Env_Set(new_env, spec, arg, true);
    arg_spec = Lisp_Cell_Tail(arg_spec);
    args = Lisp_Cell_Tail(args);}

  int expansion = Lisp_Eval_Builtin_Do(new_env, m_body);
  int result = Lisp_Eval(env, expansion);
	Lisp_Memory_GC(new_env);
	Lisp_Memory_GC(expansion);
	return result;}

////////////////////////////////////////////////////////////////
// Parse

int Lisp_Parse_Index = 0;
int Lisp_Parse(int string) {
  int head = Lisp_Cell(LISP_SYM_DO, LISP_NIL);
  int cell = head;
  Lisp_Parse_Index = 0;
  while (0 != string[Lisp_Parse_Index]) {
    int _item = Lisp_Cell(Lisp_Parse_Item(string), LISP_NIL);
    Lisp_Cell_Tail(cell, _item);
    cell = _item;}
  return head;}

void Lisp_Parse_Skip(int string) {
  int last_index = Lisp_Parse_Index - 1;
  while (Lisp_Parse_Index != last_index) {
    last_index = Lisp_Parse_Index;
    if (Lisp_Char_IsWhitespace(string[Lisp_Parse_Index])) {++Lisp_Parse_Index;}
    if (';' == string[Lisp_Parse_Index]) {
      while (CHAR_NEWLINE != string[Lisp_Parse_Index]) {++Lisp_Parse_Index;}
      ++Lisp_Parse_Index;}}}

int Lisp_Parse_Item(int string) {
  Lisp_Parse_Skip(string);

  int result = LISP_NIL;

  if ('(' == string[Lisp_Parse_Index]) {
    result = Lisp_Parse_List(string);}

  else if (Lisp_Char_IsSymbolStart(string[Lisp_Parse_Index])) {
    result = Lisp_Parse_Symbol(string);}

  else if (isNumber(string[Lisp_Parse_Index])) {
    result = Lisp_Parse_Number(string);}

  // quote
  else if (CHAR_QUOTE == string[Lisp_Parse_Index]) {
    ++Lisp_Parse_Index;
    result = Lisp_List(LISP_SYM_QUOTE, Lisp_Parse_Item(string));}

  else {++Lisp_Parse_Index;}

  Lisp_Parse_Skip(string);
  return result;}

int Lisp_Parse_List(int string) {
  ++Lisp_Parse_Index;

  int list = LISP_NIL;
  int cell = LISP_NIL;
  while (')' != string[Lisp_Parse_Index]) {
    if ('.' == string[Lisp_Parse_Index]) {
      Lisp_Parse_Skip(string);
      Lisp_Cell_Tail(cell, Lisp_Parse_Item(string));
      break;}

    int _item = Lisp_Parse_Item(string);
    if (LISP_NIL == list) {
      list = Lisp_Cell(_item, LISP_NIL);
      cell = list;}
    else {
      int swap = Lisp_Cell(_item, LISP_NIL);
      Lisp_Cell_Tail(cell, swap);
      cell = swap;}}
  ++Lisp_Parse_Index;
  return list;}

int Lisp_Parse_Symbol(int string) {
  int buffer[0x100];
  int index = 0;
  while (Lisp_Char_IsSymbol(string[Lisp_Parse_Index])) {
    buffer[index] = string[Lisp_Parse_Index];
    ++index;
    ++Lisp_Parse_Index;}
  return Lisp_Symbol_Get(buffer);}

int Lisp_Parse_Number(int string) {
  int value = 0;

  if (string[Lisp_Parse_Index] == '0' && string[Lisp_Parse_Index + 1] == 'x') {
    Lisp_Parse_Index += 2;
    while (isHex(string[Lisp_Parse_Index])) {
      int c = string[Lisp_Parse_Index];
      value *= 16;
      if (isNumber(c)) {value += c - '0';}
      if ('A' <= c && c <= 'F') {value += 10 + c - 'A';}
      if ('a' <= c && c <= 'f') {value += 10 + c - 'a';}
      ++Lisp_Parse_Index;}
    return value;}

  while (isNumber(string[Lisp_Parse_Index])) {
    value *= 10;
    value += string[Lisp_Parse_Index] - '0';
    ++Lisp_Parse_Index;}

  if ('.' == string[Lisp_Parse_Index]) {
    ++Lisp_Parse_Index;
    for (int mult = 0.1;
         mult >= 0.0001 && isNumber(string[Lisp_Parse_Index]);
         mult *= 0.1) {
      value += mult * (string[Lisp_Parse_Index] - '0');
      ++Lisp_Parse_Index;}}

  return value;}

////////////////////////////////////////////////////////////////
// Varargs

int Lisp_Format(int target, int format,
                int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7,
                int a8, int a9, int aa, int ab, int ac, int ad, int ae) {
  return Lisp_Format(target, format, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, aa, ab, ac, ad, ae, 0);}
int Lisp_Format(int target, int format,
                int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7,
                int a8, int a9, int aa, int ab, int ac, int ad) {
  return Lisp_Format(target, format, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, aa, ab, ac, ad, 0, 0);}
int Lisp_Format(int target, int format,
                int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7,
                int a8, int a9, int aa, int ab, int ac) {
  return Lisp_Format(target, format, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, aa, ab, ac, 0, 0, 0);}
int Lisp_Format(int target, int format,
                int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7,
                int a8, int a9, int aa, int ab) {
  return Lisp_Format(target, format, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, aa, ab, 0, 0, 0, 0);}
int Lisp_Format(int target, int format,
                int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7,
                int a8, int a9, int aa) {
  return Lisp_Format(target, format, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, aa, 0, 0, 0, 0, 0);}
int Lisp_Format(int target, int format,
                int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7,
                int a8, int a9) {
  return Lisp_Format(target, format, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, 0, 0, 0, 0, 0, 0);}
int Lisp_Format(int target, int format,
                int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7,
                int a8) {
  return Lisp_Format(target, format, a0, a1, a2, a3, a4, a5, a6, a7, a8, 0, 0, 0, 0, 0, 0, 0);}
int Lisp_Format(int target, int format,
                int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7) {
  return Lisp_Format(target, format, a0, a1, a2, a3, a4, a5, a6, a7, 0, 0, 0, 0, 0, 0, 0, 0);}
int Lisp_Format(int target, int format,
                int a0, int a1, int a2, int a3, int a4, int a5, int a6) {
  return Lisp_Format(target, format, a0, a1, a2, a3, a4, a5, a6, 0, 0, 0, 0, 0, 0, 0, 0, 0);}
int Lisp_Format(int target, int format,
                int a0, int a1, int a2, int a3, int a4, int a5) {
  return Lisp_Format(target, format, a0, a1, a2, a3, a4, a5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);}
int Lisp_Format(int target, int format,
                int a0, int a1, int a2, int a3, int a4) {
  return Lisp_Format(target, format, a0, a1, a2, a3, a4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);}
int Lisp_Format(int target, int format,
                int a0, int a1, int a2, int a3) {
  return Lisp_Format(target, format, a0, a1, a2, a3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);}
int Lisp_Format(int target, int format,
                int a0, int a1, int a2) {
  return Lisp_Format(target, format, a0, a1, a2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);}
int Lisp_Format(int target, int format,
                int a0, int a1) {
  return Lisp_Format(target, format, a0, a1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);}
int Lisp_Format(int target, int format,
                int a0) {
  return Lisp_Format(target, format, a0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);}
int Lisp_Format(int target, int format) {
  return Lisp_Format(target, format, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);}

void Lisp_Print(int format,
                int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7,
                int a8, int a9, int aa, int ab, int ac, int ad, int ae) {
  Lisp_Print(format, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, aa, ab, ac, ad, ae, 0);}
void Lisp_Print(int format,
                int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7,
                int a8, int a9, int aa, int ab, int ac, int ad) {
  Lisp_Print(format, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, aa, ab, ac, ad, 0, 0);}
void Lisp_Print(int format,
                int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7,
                int a8, int a9, int aa, int ab, int ac) {
  Lisp_Print(format, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, aa, ab, ac, 0, 0, 0);}
void Lisp_Print(int format,
                int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7,
                int a8, int a9, int aa, int ab) {
  Lisp_Print(format, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, aa, ab, 0, 0, 0, 0);}
void Lisp_Print(int format,
                int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7,
                int a8, int a9, int aa) {
  Lisp_Print(format, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, aa, 0, 0, 0, 0, 0);}
void Lisp_Print(int format,
                int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7,
                int a8, int a9) {
  Lisp_Print(format, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, 0, 0, 0, 0, 0, 0);}
void Lisp_Print(int format,
                int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7,
                int a8) {
  Lisp_Print(format, a0, a1, a2, a3, a4, a5, a6, a7, a8, 0, 0, 0, 0, 0, 0, 0);}
void Lisp_Print(int format,
                int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7) {
  Lisp_Print(format, a0, a1, a2, a3, a4, a5, a6, a7, 0, 0, 0, 0, 0, 0, 0, 0);}
void Lisp_Print(int format,
                int a0, int a1, int a2, int a3, int a4, int a5, int a6) {
  Lisp_Print(format, a0, a1, a2, a3, a4, a5, a6, 0, 0, 0, 0, 0, 0, 0, 0, 0);}
void Lisp_Print(int format,
                int a0, int a1, int a2, int a3, int a4, int a5) {
  Lisp_Print(format, a0, a1, a2, a3, a4, a5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);}
void Lisp_Print(int format,
                int a0, int a1, int a2, int a3, int a4) {
  Lisp_Print(format, a0, a1, a2, a3, a4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);}
void Lisp_Print(int format,
                int a0, int a1, int a2, int a3) {
  Lisp_Print(format, a0, a1, a2, a3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);}
void Lisp_Print(int format,
                int a0, int a1, int a2) {
  Lisp_Print(format, a0, a1, a2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);}
void Lisp_Print(int format,
                int a0, int a1) {
  Lisp_Print(format, a0, a1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);}
void Lisp_Print(int format,
                int a0) {
  Lisp_Print(format, a0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);}
void Lisp_Print(int format) {
  Lisp_Print(format, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);}

int Lisp_List(int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7,
              int a8, int a9, int aa, int ab, int ac, int ad, int ae) {
  return Lisp_List(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, aa, ab, ac, ad, ae, 0);}
int Lisp_List(int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7,
              int a8, int a9, int aa, int ab, int ac, int ad) {
  return Lisp_List(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, aa, ab, ac, ad, 0, 0);}
int Lisp_List(int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7,
              int a8, int a9, int aa, int ab, int ac) {
  return Lisp_List(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, aa, ab, ac, 0, 0, 0);}
int Lisp_List(int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7,
              int a8, int a9, int aa, int ab) {
  return Lisp_List(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, aa, ab, 0, 0, 0, 0);}
int Lisp_List(int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7,
              int a8, int a9, int aa) {
  return Lisp_List(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, aa, 0, 0, 0, 0, 0);}
int Lisp_List(int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7,
              int a8, int a9) {
  return Lisp_List(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, 0, 0, 0, 0, 0, 0);}
int Lisp_List(int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7,
              int a8) {
  return Lisp_List(a0, a1, a2, a3, a4, a5, a6, a7, a8, 0, 0, 0, 0, 0, 0, 0);}
int Lisp_List(int a0, int a1, int a2, int a3, int a4, int a5, int a6, int a7) {
  return Lisp_List(a0, a1, a2, a3, a4, a5, a6, a7, 0, 0, 0, 0, 0, 0, 0, 0);}
int Lisp_List(int a0, int a1, int a2, int a3, int a4, int a5, int a6) {
  return Lisp_List(a0, a1, a2, a3, a4, a5, a6, 0, 0, 0, 0, 0, 0, 0, 0, 0);}
int Lisp_List(int a0, int a1, int a2, int a3, int a4, int a5) {
  return Lisp_List(a0, a1, a2, a3, a4, a5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);}
int Lisp_List(int a0, int a1, int a2, int a3, int a4) {
  return Lisp_List(a0, a1, a2, a3, a4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);}
int Lisp_List(int a0, int a1, int a2, int a3) {
  return Lisp_List(a0, a1, a2, a3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);}
int Lisp_List(int a0, int a1, int a2) {
  return Lisp_List(a0, a1, a2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);}
int Lisp_List(int a0, int a1) {
  return Lisp_List(a0, a1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);}
int Lisp_List(int a0) {
  return Lisp_List(a0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);}