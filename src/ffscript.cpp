#ifndef __GTHREAD_HIDE_WIN32API
#define __GTHREAD_HIDE_WIN32API 1
#endif                            //prevent indirectly including windows.h

#include "precompiled.h" //always first
#include "metadata/versionsig.h"

#include <deque>
//#include <algorithm>
#include <string>
#include <sstream>
#include <math.h>
#include <cstdio>
//
#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>
#include <fstream>
//

#include "ffasm.h"
#include "zc_sys.h"
extern byte use_dwm_flush;
#include "zc_math.h"
#include "zc_array.h"
#include "ffscript.h"
#include "zc_subscr.h"
#include <time.h>
//#include "zc_sys.h"
#include "script_drawing.h"
#include "util.h"
#include "ending.h"
using namespace util;
#include <sstream>
using std::ostringstream;

#ifdef _WIN32
#define SCRIPT_FILE_MODE	(_S_IREAD | _S_IWRITE)
#else
	#include <fcntl.h>
	#include <unistd.h>
	#include <iostream>
	#define SCRIPT_FILE_MODE	(S_ISVTX | S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#endif

//Define this register, so it can be treated specially
#define NUL		5
#define MAX_ZC_ARRAY_SIZE 214748

extern zinitdata zinit;
int hangcount = 0;

extern byte monochrome_console;

CScriptDrawingCommands scriptdraws;
FFScript FFCore;
zquestheader ZCheader;
ZModule zcm;
zcmodule moduledata;
script_bitmaps scb;
user_file script_files[MAX_USER_FILES];

FONT *get_zc_font(int index);

static inline bool fileexists(const char *filename) 
{
	std::ifstream ifile(filename);
	if(ifile) return true;
	return false;
}

const char scripttypenames[15][40]=
{
	"none script",
	"Global Script", "FFC Script", "Screen Script", "Hero Script", 
	"Item Script", "LWeapon Script", "NPC Script", 
	"Subscreen Script", "EWeapon Script", "DMap Script", "Itemsprite Script",
	"DMap ActSub Script", "DMap PasSub Script", "Combo Script"
};


int CScriptDrawingCommands::GetCount()
{
	al_trace("current number of draws is: %d\n", count);
	return count;
}
//Advances the game frame without checking 'Quit' variable status.
//Used for making scripts such as Link's onWin and onDeath scripts
//run for multiple frames.

void FFScript::Waitframe(bool allowwavy, bool sfxcleanup)
{
	if(zcmusic!=NULL)
	{
		zcmusic_poll();
	}
	
	while(Paused && !Advance && !Quit)
	{
		// have to call this, otherwise we'll get an infinite loop
		syskeys();
		// to keep fps constant
		updatescr(allowwavy);
		throttleFPS();
		
#ifdef _WIN32
		
		if(use_dwm_flush)
		{
			do_DwmFlush();
		}
		
#endif
		
		// to keep music playing
		if(zcmusic!=NULL)
		{
			zcmusic_poll();
		}
	}
	
	//if(Quit)
	//	return;
	/*
	if(Playing && game->get_time()<MAXTIME)
		game->change_time(1);
	*/
	Advance=false;
	++frame;
	
	syskeys();
	// Someday... maybe install a Turbo button here?
	updatescr(allowwavy);
	throttleFPS();
	
#ifdef _WIN32
	
	if(use_dwm_flush)
	{
		do_DwmFlush();
	}
	
#endif
	
	//textprintf_ex(screen,font,0,72,254,BLACK,"%d %d", lastentrance, lastentrance_dmap);
	if(sfxcleanup)
		sfx_cleanup();
}

mapscr* GetMapscr(long mapref)
{
	switch(mapref)
	{
		case LONG_MAX: return NULL; //shouldn't happen, as error should already have been thrown before calling this func
		case MAPSCR_TEMP0: return FFCore.tempScreens[0]; //Temp layer 0
		case MAPSCR_TEMP1: return FFCore.tempScreens[1]; //Temp layer 1
		case MAPSCR_TEMP2: return FFCore.tempScreens[2]; //Temp layer 2
		case MAPSCR_TEMP3: return FFCore.tempScreens[3]; //Temp layer 3
		case MAPSCR_TEMP4: return FFCore.tempScreens[4]; //Temp layer 4
		case MAPSCR_TEMP5: return FFCore.tempScreens[5]; //Temp layer 5
		case MAPSCR_TEMP6: return FFCore.tempScreens[6]; //Temp layer 6
		case MAPSCR_SCROLL0: return FFCore.ScrollingScreens[0]; //Temp scrolllayer 0
		case MAPSCR_SCROLL1: return FFCore.ScrollingScreens[1]; //Temp scrolllayer 1
		case MAPSCR_SCROLL2: return FFCore.ScrollingScreens[2]; //Temp scrolllayer 2
		case MAPSCR_SCROLL3: return FFCore.ScrollingScreens[3]; //Temp scrolllayer 3
		case MAPSCR_SCROLL4: return FFCore.ScrollingScreens[4]; //Temp scrolllayer 4
		case MAPSCR_SCROLL5: return FFCore.ScrollingScreens[5]; //Temp scrolllayer 5
		case MAPSCR_SCROLL6: return FFCore.ScrollingScreens[6]; //Temp scrolllayer 6
		default:
		{
			if(mapref < 0) return NULL; //Bad negative value
			else return &TheMaps[mapref]; //Standard mapdata
		}
	}
}

long getMap(long ref)
{
	switch(ref)
	{
		case MAPSCR_TEMP0:
			return currmap+1;
		case MAPSCR_TEMP1:
			return FFCore.tempScreens[0]->layermap[0];
		case MAPSCR_TEMP2:
			return FFCore.tempScreens[0]->layermap[1];
		case MAPSCR_TEMP3:
			return FFCore.tempScreens[0]->layermap[2];
		case MAPSCR_TEMP4:
			return FFCore.tempScreens[0]->layermap[3];
		case MAPSCR_TEMP5:
			return FFCore.tempScreens[0]->layermap[4];
		case MAPSCR_TEMP6:
			return FFCore.tempScreens[0]->layermap[5];
		case MAPSCR_SCROLL0:
			return scrolling_map+1;
		case MAPSCR_SCROLL1:
			return FFCore.ScrollingScreens[0]->layermap[0];
		case MAPSCR_SCROLL2:
			return FFCore.ScrollingScreens[0]->layermap[1];
		case MAPSCR_SCROLL3:
			return FFCore.ScrollingScreens[0]->layermap[2];
		case MAPSCR_SCROLL4:
			return FFCore.ScrollingScreens[0]->layermap[3];
		case MAPSCR_SCROLL5:
			return FFCore.ScrollingScreens[0]->layermap[4];
		case MAPSCR_SCROLL6:
			return FFCore.ScrollingScreens[0]->layermap[5];
		default:
			return (ref / MAPSCRS + 1);
	}
}
long getScreen(long ref)
{
	switch(ref)
	{
		case MAPSCR_TEMP0:
			return currscr;
		case MAPSCR_TEMP1:
			return FFCore.tempScreens[0]->layerscreen[0];
		case MAPSCR_TEMP2:
			return FFCore.tempScreens[0]->layerscreen[1];
		case MAPSCR_TEMP3:
			return FFCore.tempScreens[0]->layerscreen[2];
		case MAPSCR_TEMP4:
			return FFCore.tempScreens[0]->layerscreen[3];
		case MAPSCR_TEMP5:
			return FFCore.tempScreens[0]->layerscreen[4];
		case MAPSCR_TEMP6:
			return FFCore.tempScreens[0]->layerscreen[5];
		case MAPSCR_SCROLL0:
			return scrolling_scr;
		case MAPSCR_SCROLL1:
			return FFCore.ScrollingScreens[0]->layerscreen[0];
		case MAPSCR_SCROLL2:
			return FFCore.ScrollingScreens[0]->layerscreen[1];
		case MAPSCR_SCROLL3:
			return FFCore.ScrollingScreens[0]->layerscreen[2];
		case MAPSCR_SCROLL4:
			return FFCore.ScrollingScreens[0]->layerscreen[3];
		case MAPSCR_SCROLL5:
			return FFCore.ScrollingScreens[0]->layerscreen[4];
		case MAPSCR_SCROLL6:
			return FFCore.ScrollingScreens[0]->layerscreen[5];
		default:
			return (ref % MAPSCRS);
	}
}


#ifdef _WIN32
#include "ConsoleLogger.h"
#else
//unix

class CConsoleLogger
{
public:

	// ctor,dtor
	CConsoleLogger();
	virtual ~CConsoleLogger();
	
	// create a logger: starts a pipe+create the child process
	long Create(const char *lpszWindowTitle=NULL,
				int buffer_size_x=-1,int buffer_size_y=-1,
				const char *logger_name=NULL,
				const char *helper_executable=NULL);

	// close everything
	long Close(void);
	
	// output functions
	inline int print(const char *lpszText,int iSize=-1);
	int printf(const char *format,...);
	
	// play with the CRT output functions
	int SetAsDefaultOutput(void);
	static int ResetDefaultOutput(void);

protected:
	char	m_name[64];
	
#ifdef CONSOLE_LOGGER_USING_MS_SDK
	// we'll use this DWORD as VERY fast critical-section . for more info:
	// * "Understand the Impact of Low-Lock Techniques in Multithreaded Apps"
	//		Vance Morrison , MSDN Magazine  October 2005
	// * "Performance-Conscious Thread Synchronization" , Jeffrey Richter , MSDN Magazine  October 2005
	volatile long m_fast_critical_section;

	inline void InitializeCriticalSection(void)
	{  }
	
	inline void DeleteCriticalSection(void)
	{  }

	// our own LOCK function
	inline void EnterCriticalSection(void)
	{}

	// our own UNLOCK function
	inline void LeaveCriticalSection(void)
	{ m_fast_critical_section=0; }
#else
	inline void InitializeCriticalSection(void)
	{  }
	
	inline void DeleteCriticalSection(void)
	{  }

	// our own LOCK function
	inline void EnterCriticalSection(void)
	{ }

	// our own UNLOCK function
	inline void LeaveCriticalSection(void)
	{ }

#endif

	// you can extend this class by overriding the function
	virtual long	AddHeaders(void)
	{ return 0;}

	// the _print() helper function
	virtual int _print(const char *lpszText,int iSize);

	


	// SafeWriteFile : write safely to the pipe
	inline bool SafeWriteFile(
		/*__in*/ long hFile,
		/*__in_bcount(nNumberOfBytesToWrite)*/	long lpBuffer,
		/*__in        */ long nNumberOfBytesToWrite,
		/*__out_opt   */ long lpNumberOfBytesWritten,
		/*__inout_opt */ long lpOverlapped
		)
	{
		return false;
	}

};


class CConsoleLoggerEx : public CConsoleLogger
{
	long	m_dwCurrentAttributes;
	enum enumCommands
	{
		COMMAND_PRINT,
		COMMAND_CPRINT,
		COMMAND_CLEAR_SCREEN,
		COMMAND_COLORED_CLEAR_SCREEN,
		COMMAND_GOTOXY,
		COMMAND_CLEAR_EOL,
		COMMAND_COLORED_CLEAR_EOL
	};
public:
	CConsoleLoggerEx();

	enum enumColors
	{
		COLOR_BLACK=0,
		COLOR_BLUE,
		COLOR_GREEN,
		COLOR_RED,
		COLOR_WHITE,
		COLOR_INTENSITY,
		COLOR_BACKGROUND_BLACK,
		COLOR_BACKGROUND_BLUE,
		COLOR_BACKGROUND_GREEN,
		COLOR_BACKGROUND_RED,
		COLOR_BACKGROUND_WHITE,
		COLOR_BACKGROUND_INTENSITY,
		COLOR_COMMON_LVB_LEADING_BYTE,
		COLOR_COMMON_LVB_TRAILING_BYTE,
		COLOR_COMMON_LVB_GRID_HORIZONTAL,
		COLOR_COMMON_LVB_GRID_LVERTICAL,
		COLOR_COMMON_LVB_GRID_RVERTICAL,
		COLOR_COMMON_LVB_REVERSE_VIDEO,
		COLOR_COMMON_LVB_UNDERSCORE
	};
	
	// Clear screen , use default color (black&white)
	void cls(void);
	
	// Clear screen use specific color
	void cls(word color);

	// Clear till End Of Line , use default color (black&white)
	void clear_eol(void);
	
	// Clear till End Of Line , use specified color
	void clear_eol(word color);
	
	// write string , use specified color
	int cprintf(int attributes,const char *format,...);
	
	// write string , use current color
	int cprintf(const char *format,...);
	
	// goto(x,y)
	void gotoxy(int x,int y);



	word	GetCurrentColor(void)
	{  }
	
	void	SetCurrentColor(word dwColor)
	{ }
	

protected:
	virtual long AddHeaders(void)
	{
		return  0;
	}
	
	virtual int _print(const char *lpszText,int iSize);
	virtual int _cprint(int attributes,const char *lpszText,int iSize);


};
#endif

#ifdef _WIN32
// ConsoleLogger.cpp: implementation of the CConsoleLogger class.
//
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////



// CTOR: reset everything
CConsoleLogger::CConsoleLogger()
{
	InitializeCriticalSection();
	m_name[0]=0;
	m_hPipe = INVALID_HANDLE_VALUE;
}

// DTOR: delete everything
CConsoleLogger::~CConsoleLogger()
{
	DeleteCriticalSection();
	
	// Notice: Because we want the pipe to stay alive until all data is passed,
	//         it's better to avoid closing the pipe here....
	//Close();
}



//////////////////////////////////////////////////////////////////////////
// Create: create a new console (logger) with the following OPTIONAL attributes:
//
// lpszWindowTitle : window title
// buffer_size_x   : width
// buffer_size_y   : height
// logger_name     : pipe name . the default is f(this,time)
// helper_executable: which (and where) is the EXE that will write the pipe's output
//////////////////////////////////////////////////////////////////////////
long CConsoleLogger::Create(const char	*lpszWindowTitle/*=NULL*/,
							int			buffer_size_x/*=-1*/,int buffer_size_y/*=-1*/,
							const char	*logger_name/*=NULL*/,
							const char	*helper_executable/*=NULL*/)
{
	
	// Ensure there's no pipe connected
	if (m_hPipe != INVALID_HANDLE_VALUE)
	{
		DisconnectNamedPipe(m_hPipe);
		CloseHandle(m_hPipe);
		m_hPipe=INVALID_HANDLE_VALUE;
	}
	strcpy(m_name,"\\\\.\\pipe\\");

	
	if (!logger_name)
	{	// no name was give , create name based on the current address+time
		// (you can modify it to use PID , rand() ,...
		unsigned long now = GetTickCount();
		logger_name = m_name+ strlen(m_name);
		sprintf((char*)logger_name,"logger%d_%lu",(int)this,now);
	}
	else
	{	// just use the given name
		strcat(m_name,logger_name);
	}

	
	// Create the pipe
	m_hPipe = CreateNamedPipe( 
		  m_name,					// pipe name 
		  PIPE_ACCESS_OUTBOUND,		// read/write access, we're only writing...
		  PIPE_TYPE_MESSAGE |       // message type pipe 
		  PIPE_READMODE_BYTE|		// message-read mode 
		  PIPE_WAIT,                // blocking mode 
		  1,						// max. instances  
		  32768,						// output buffer size 
		  0,						// input buffer size (we don't read data, so 0 is fine)
		  1,						// client time-out 
		  NULL);                    // no security attribute 
	if (m_hPipe==INVALID_HANDLE_VALUE)
	{	// failure
		MessageBox(NULL,"CreateNamedPipe failed","ConsoleLogger failed",MB_OK);
		return -1;
	}

	// Extra console : create another process , it's role is to display the pipe's output
	STARTUPINFO si;
	PROCESS_INFORMATION pi;
	GetStartupInfo(&si);
	
	char cmdline[MAX_PATH];;
	if (!helper_executable)
		helper_executable=
			( get_config_int("CONSOLE","console_on_top",0) ) 
			? "ZConsole_OnTop.exe"
			: "ZConsole.exe"; //DEFAULT_HELPER_EXE
	sprintf(cmdline,"%s %s",helper_executable,logger_name);
	BOOL bRet = CreateProcess(NULL,cmdline,NULL,NULL,FALSE,CREATE_NEW_CONSOLE,NULL,NULL,&si,&pi);
	if (!bRet)
	{	// on failure - try to get the path from the environment
		char *path = getenv("ConsoleLoggerHelper");
		if (path)
		{
			sprintf(cmdline,"%s %s",path,logger_name);
			bRet = CreateProcess(NULL,cmdline,NULL,NULL,FALSE,CREATE_NEW_CONSOLE,NULL,NULL,&si,&pi);
		}
		if (!bRet)
		{
			MessageBox(NULL,"Helper executable not found","ConsoleLogger failed",MB_OK);
			CloseHandle(m_hPipe);
			m_hPipe = INVALID_HANDLE_VALUE;
			return -1;
		}
	}
	
	
	BOOL bConnected = ConnectNamedPipe(m_hPipe, NULL) ? 
		 TRUE : (GetLastError() == ERROR_PIPE_CONNECTED); 
	if (!bConnected)
	{
		MessageBox(NULL,"ConnectNamedPipe failed","ConsoleLogger failed",MB_OK);
		
		CloseHandle(m_hPipe);
		m_hPipe = INVALID_HANDLE_VALUE;
		return -1;
	}
	
	DWORD cbWritten;

	//////////////////////////////////////////////////////////////////////////
	// In order to easily add new future-features , i've chosen to pass the "extra"
	// parameters just the HTTP protocol - via textual "headers" .
	// the last header should end with NULL
	//////////////////////////////////////////////////////////////////////////
	

	char buffer[128];
	// Send title
	if (!lpszWindowTitle)	lpszWindowTitle=m_name+9;
	sprintf(buffer,"TITLE: %s\r\n",lpszWindowTitle);
	WriteFile(m_hPipe,buffer,strlen(buffer),&cbWritten,NULL);
	if (cbWritten!=strlen(buffer))
	{
		MessageBox(NULL,"WriteFile failed(1)","ConsoleLogger failed",MB_OK);
		DisconnectNamedPipe(m_hPipe);
		CloseHandle(m_hPipe);
		m_hPipe=INVALID_HANDLE_VALUE;
		return -1;
	}

	
	if (buffer_size_x!=-1 && buffer_size_y!=-1)
	{	// Send buffer-size
		sprintf(buffer,"BUFFER-SIZE: %dx%d\r\n",buffer_size_x,buffer_size_y);
		WriteFile(m_hPipe,buffer,strlen(buffer),&cbWritten,NULL);
		if (cbWritten!=strlen(buffer))
		{
			MessageBox(NULL,"WriteFile failed(2)","ConsoleLogger failed",MB_OK);
			DisconnectNamedPipe(m_hPipe);
			CloseHandle(m_hPipe);
			m_hPipe=INVALID_HANDLE_VALUE;
			return -1;
		}
	}

	// Send more headers. you can override the AddHeaders() function to 
	// extend this class
	if (AddHeaders())
	{	
		DisconnectNamedPipe(m_hPipe);
		CloseHandle(m_hPipe);
		m_hPipe=INVALID_HANDLE_VALUE;
		return -1;
	}



	// send NULL as "end of header"
	buffer[0]=0;
	WriteFile(m_hPipe,buffer,1,&cbWritten,NULL);
	if (cbWritten!=1)
	{
		MessageBox(NULL,"WriteFile failed(3)","ConsoleLogger failed",MB_OK);
		DisconnectNamedPipe(m_hPipe);
		CloseHandle(m_hPipe);
		m_hPipe=INVALID_HANDLE_VALUE;
		return -1;
	}
	return 0;
}


// Close and disconnect
long CConsoleLogger::Close(void)
{
	if (m_hPipe==INVALID_HANDLE_VALUE || m_hPipe==NULL)
		return -1;
	else
		return DisconnectNamedPipe( m_hPipe );
}


//////////////////////////////////////////////////////////////////////////
// print: print string lpszText with size iSize
// if iSize==-1 (default) , we'll use strlen(lpszText)
// 
// this is the fastest way to print a simple (not formatted) string
//////////////////////////////////////////////////////////////////////////
inline int CConsoleLogger::print(const char *lpszText,int iSize/*=-1*/)
{
	if (m_hPipe==INVALID_HANDLE_VALUE)
		return -1;
	return _print(lpszText,(iSize==-1) ? strlen(lpszText) : iSize);
}

//////////////////////////////////////////////////////////////////////////
// printf: print a formatted string
//////////////////////////////////////////////////////////////////////////
int CConsoleLogger::printf(const char *format,...)
{
	if (m_hPipe==INVALID_HANDLE_VALUE)
		return -1;

	int ret;
	char tmp[1024];

	va_list argList;
	va_start(argList, format);
	#ifdef WIN32
	 		ret = _vsnprintf(tmp,sizeof(tmp)-1,format,argList);
	#else
	 		ret = vsnprintf(tmp,sizeof(tmp)-1,format,argList);
	#endif
	tmp[ret]=0;


	va_end(argList);


	return _print(tmp,ret);

}



//////////////////////////////////////////////////////////////////////////
// set the default (CRT) printf() to use this logger
//////////////////////////////////////////////////////////////////////////
int CConsoleLogger::SetAsDefaultOutput(void)
{
	int hConHandle = _open_osfhandle(/*lStdHandle*/ (long)m_hPipe, _O_TEXT);
	if (hConHandle==-1)
		return -2;
	FILE *fp = _fdopen( hConHandle, "w" );
	if (!fp)
		return -3;
	*stdout = *fp;
	return setvbuf( stdout, NULL, _IONBF, 0 );
}

///////////////////////////////////////////////////////////////////////////
// Reset the CRT printf() to it's default
//////////////////////////////////////////////////////////////////////////
int CConsoleLogger::ResetDefaultOutput(void)
{
	long lStdHandle = (long)GetStdHandle(STD_OUTPUT_HANDLE);
	if (lStdHandle ==  (long)INVALID_HANDLE_VALUE)
		return -1;
	int hConHandle = _open_osfhandle(lStdHandle, _O_TEXT);
	if (hConHandle==-1)
		return -2;
	FILE *fp = _fdopen( hConHandle, "w" );
	if (!fp)
		return -3;
	*stdout = *fp;
	return setvbuf( stdout, NULL, _IONBF, 0 );
}


//////////////////////////////////////////////////////////////////////////
// _print: print helper
// we use the thread-safe funtion "SafeWriteFile()" to output the data
//////////////////////////////////////////////////////////////////////////
int CConsoleLogger::_print(const char *lpszText,int iSize)
{
	DWORD dwWritten=(DWORD)-1;
	
	return (!SafeWriteFile( m_hPipe,lpszText,iSize,&dwWritten,NULL)
		|| (int)dwWritten!=iSize) ? -1 : (int)dwWritten;
}




//////////////////////////////////////////////////////////////////////////
// Implementation of the derived class: CConsoleLoggerEx
//////////////////////////////////////////////////////////////////////////

// ctor: just set the default color
CConsoleLoggerEx::CConsoleLoggerEx()
{
	m_dwCurrentAttributes = COLOR_WHITE | COLOR_BACKGROUND_BLACK;
}


	
//////////////////////////////////////////////////////////////////////////
// override the _print.
// first output the "command" (which is COMMAND_PRINT) and the size,
// and than output the string itself	
//////////////////////////////////////////////////////////////////////////
int CConsoleLoggerEx::_print(const char *lpszText,int iSize)
{
	DWORD dwWritten=(DWORD)-1;
	// we assume that in iSize < 2^24 , because we're using only 3 bytes of iSize 
	// 32BIT: send DWORD = 4bytes: one byte is the command (COMMAND_PRINT) , and 3 bytes for size
	
	DWORD command_plus_size = (COMMAND_PRINT <<24)| iSize;
	EnterCriticalSection();
	if ( !WriteFile (m_hPipe, &command_plus_size,sizeof(DWORD),&dwWritten,NULL) 
		|| dwWritten != sizeof(DWORD))
	{
		LeaveCriticalSection();
		return -1;
	}
	
	int iRet = (!WriteFile( m_hPipe,lpszText,iSize,&dwWritten,NULL)
		|| (int)dwWritten!=iSize) ? -1 : (int)dwWritten;
	LeaveCriticalSection();
	return iRet;
}

	
//////////////////////////////////////////////////////////////////////////
// cls: clear screen  (just sends the COMMAND_CLEAR_SCREEN)
//////////////////////////////////////////////////////////////////////////
void CConsoleLoggerEx::cls(void)
{
	DWORD dwWritten=(DWORD)-1;
	// we assume that in iSize < 2^24 , because we're using only 3 bytes of iSize 
	// 32BIT: send DWORD = 4bytes: one byte is the command (COMMAND_PRINT) , and 3 bytes for size
	DWORD command = COMMAND_CLEAR_SCREEN<<24;
	SafeWriteFile (m_hPipe, &command,sizeof(DWORD),&dwWritten,NULL);
}	


//////////////////////////////////////////////////////////////////////////
// cls(DWORD) : clear screen with specific color
//////////////////////////////////////////////////////////////////////////
void CConsoleLoggerEx::cls(DWORD color)
{
	DWORD dwWritten=(DWORD)-1;
	// we assume that in iSize < 2^24 , because we're using only 3 bytes of iSize 
	// 32BIT: send DWORD = 4bytes: one byte is the command (COMMAND_PRINT) , and 3 bytes for size
	DWORD command = COMMAND_COLORED_CLEAR_SCREEN<<24;
	EnterCriticalSection();
	WriteFile (m_hPipe, &command,sizeof(DWORD),&dwWritten,NULL);
	WriteFile (m_hPipe, &color,sizeof(DWORD),&dwWritten,NULL);
	LeaveCriticalSection();
}	

//////////////////////////////////////////////////////////////////////////
// clear_eol() : clear till the end of current line
//////////////////////////////////////////////////////////////////////////
void CConsoleLoggerEx::clear_eol(void)
{
	DWORD dwWritten=(DWORD)-1;
	// we assume that in iSize < 2^24 , because we're using only 3 bytes of iSize 
	// 32BIT: send DWORD = 4bytes: one byte is the command (COMMAND_PRINT) , and 3 bytes for size
	DWORD command = COMMAND_CLEAR_EOL<<24;
	SafeWriteFile (m_hPipe, &command,sizeof(DWORD),&dwWritten,NULL);
}	

//////////////////////////////////////////////////////////////////////////
// clear_eol(DWORD) : clear till the end of current line with specific color
//////////////////////////////////////////////////////////////////////////
void CConsoleLoggerEx::clear_eol(DWORD color)
{
	DWORD dwWritten=(DWORD)-1;
	// we assume that in iSize < 2^24 , because we're using only 3 bytes of iSize 
	// 32BIT: send DWORD = 4bytes: one byte is the command (COMMAND_PRINT) , and 3 bytes for size
	DWORD command = COMMAND_COLORED_CLEAR_EOL<<24;
	EnterCriticalSection();
	WriteFile (m_hPipe, &command,sizeof(DWORD),&dwWritten,NULL);
	WriteFile (m_hPipe, &color,sizeof(DWORD),&dwWritten,NULL);
	LeaveCriticalSection();
}	


//////////////////////////////////////////////////////////////////////////
// gotoxy(x,y) : sets the cursor to x,y location
//////////////////////////////////////////////////////////////////////////
void CConsoleLoggerEx::gotoxy(int x,int y)
{
	DWORD dwWritten=(DWORD)-1;
	// we assume that in iSize < 2^24 , because we're using only 3 bytes of iSize 
	// 32BIT: send DWORD = 4bytes: one byte is the command (COMMAND_PRINT) , and 3 bytes for size
	DWORD command = COMMAND_GOTOXY<<24;
	EnterCriticalSection();
	WriteFile (m_hPipe, &command,sizeof(DWORD),&dwWritten,NULL);
	command = (x<<16)  | y;
	WriteFile (m_hPipe, &command,sizeof(DWORD),&dwWritten,NULL);
	LeaveCriticalSection();
}	


//////////////////////////////////////////////////////////////////////////
// cprintf(attr,str,...) : prints a formatted string with the "attributes" color
//////////////////////////////////////////////////////////////////////////
int CConsoleLoggerEx::cprintf(int attributes,const char *format,...)
{
	if (m_hPipe==INVALID_HANDLE_VALUE)
		return -1;

	int ret;
	char tmp[1024];

	va_list argList;
	va_start(argList, format);
	#ifdef WIN32
	 		ret = _vsnprintf(tmp,sizeof(tmp)-1,format,argList);
	#else
	 		ret = vsnprintf(tmp,sizeof(tmp)-1,format,argList);
	#endif
	tmp[ret]=0;


	va_end(argList);

	if ( monochrome_console ) return _cprint(CConsoleLoggerEx::COLOR_BACKGROUND_BLACK | CConsoleLoggerEx::COLOR_WHITE,tmp,ret);
	else	return _cprint(attributes,tmp,ret);

}


//////////////////////////////////////////////////////////////////////////
// cprintf(str,...) : prints a formatted string with current color
//////////////////////////////////////////////////////////////////////////
int CConsoleLoggerEx::cprintf(const char *format,...)
{
	if (m_hPipe==INVALID_HANDLE_VALUE)
		return -1;

	int ret;
	char tmp[1024];

	va_list argList;
	va_start(argList, format);
	#ifdef WIN32
	 		ret = _vsnprintf(tmp,sizeof(tmp)-1,format,argList);
	#else
	 		ret = vsnprintf(tmp,sizeof(tmp)-1,format,argList);
	#endif
	tmp[ret]=0;


	va_end(argList);

	if ( monochrome_console ) return _cprint(CConsoleLoggerEx::COLOR_BACKGROUND_BLACK | CConsoleLoggerEx::COLOR_WHITE,tmp,ret);
	else return _cprint(m_dwCurrentAttributes,tmp,ret);

}


//////////////////////////////////////////////////////////////////////////
// the _cprintf() helper . do the actual output
//////////////////////////////////////////////////////////////////////////
int CConsoleLoggerEx::_cprint(int attributes,const char *lpszText,int iSize)
{
	
	DWORD dwWritten=(DWORD)-1;
	// we assume that in iSize < 2^24 , because we're using only 3 bytes of iSize 
	// 32BIT: send DWORD = 4bytes: one byte is the command (COMMAND_CPRINT) , and 3 bytes for size
	DWORD command_plus_size = (COMMAND_CPRINT <<24)| iSize;
	EnterCriticalSection();
	if ( !WriteFile (m_hPipe, &command_plus_size,sizeof(DWORD),&dwWritten,NULL) 
		|| dwWritten != sizeof(DWORD))
	{
		LeaveCriticalSection();
		return -1;
	}
	
	command_plus_size = attributes;	// reuse of the prev variable
	if ( !WriteFile (m_hPipe, &command_plus_size,sizeof(DWORD),&dwWritten,NULL) 
		|| dwWritten != sizeof(DWORD))
	{
		LeaveCriticalSection();
		return -1;
	}
	
	int iRet = (!WriteFile( m_hPipe,lpszText,iSize,&dwWritten,NULL)
		|| (int)dwWritten!=iSize) ? -1 : (int)dwWritten;
	LeaveCriticalSection();
	return iRet;
}

#else
//Unix


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////



// CTOR: reset everything
CConsoleLogger::CConsoleLogger()
{
}

// DTOR: delete everything
CConsoleLogger::~CConsoleLogger()
{

}



//////////////////////////////////////////////////////////////////////////
// Create: create a new console (logger) with the following OPTIONAL attributes:
//
// lpszWindowTitle : window title
// buffer_size_x   : width
// buffer_size_y   : height
// logger_name     : pipe name . the default is f(this,time)
// helper_executable: which (and where) is the EXE that will write the pipe's output
//////////////////////////////////////////////////////////////////////////
long CConsoleLogger::Create(const char	*lpszWindowTitle/*=NULL*/,
							int			buffer_size_x/*=-1*/,int buffer_size_y/*=-1*/,
							const char	*logger_name/*=NULL*/,
							const char	*helper_executable/*=NULL*/)
{
	return 0;
}


// Close and disconnect
long CConsoleLogger::Close(void)
{
	return 0;
}


//////////////////////////////////////////////////////////////////////////
// print: print string lpszText with size iSize
// if iSize==-1 (default) , we'll use strlen(lpszText)
// 
// this is the fastest way to print a simple (not formatted) string
//////////////////////////////////////////////////////////////////////////
inline int CConsoleLogger::print(const char *lpszText,int iSize/*=-1*/)
{
	return 0;
}

//////////////////////////////////////////////////////////////////////////
// printf: print a formatted string
//////////////////////////////////////////////////////////////////////////
int CConsoleLogger::printf(const char *format,...)
{
	return 0;

}



//////////////////////////////////////////////////////////////////////////
// set the default (CRT) printf() to use this logger
//////////////////////////////////////////////////////////////////////////
int CConsoleLogger::SetAsDefaultOutput(void)
{
	return 0;
}

///////////////////////////////////////////////////////////////////////////
// Reset the CRT printf() to it's default
//////////////////////////////////////////////////////////////////////////
int CConsoleLogger::ResetDefaultOutput(void)
{
	return 0;
}


//////////////////////////////////////////////////////////////////////////
// _print: print helper
// we use the thread-safe funtion "SafeWriteFile()" to output the data
//////////////////////////////////////////////////////////////////////////
int CConsoleLogger::_print(const char *lpszText,int iSize)
{
	return 0;
}




//////////////////////////////////////////////////////////////////////////
// Implementation of the derived class: CConsoleLoggerEx
//////////////////////////////////////////////////////////////////////////

// ctor: just set the default color
CConsoleLoggerEx::CConsoleLoggerEx()
{
}


	
//////////////////////////////////////////////////////////////////////////
// override the _print.
// first output the "command" (which is COMMAND_PRINT) and the size,
// and than output the string itself	
//////////////////////////////////////////////////////////////////////////
int CConsoleLoggerEx::_print(const char *lpszText,int iSize)
{
	return 0;
}

	
//////////////////////////////////////////////////////////////////////////
// cls: clear screen  (just sends the COMMAND_CLEAR_SCREEN)
//////////////////////////////////////////////////////////////////////////
void CConsoleLoggerEx::cls(void)
{

}	


//////////////////////////////////////////////////////////////////////////
// cls(DWORD) : clear screen with specific color
//////////////////////////////////////////////////////////////////////////
void CConsoleLoggerEx::cls(word color)
{

}	

//////////////////////////////////////////////////////////////////////////
// clear_eol() : clear till the end of current line
//////////////////////////////////////////////////////////////////////////
void CConsoleLoggerEx::clear_eol(void)
{

}	

//////////////////////////////////////////////////////////////////////////
// clear_eol(DWORD) : clear till the end of current line with specific color
//////////////////////////////////////////////////////////////////////////
void CConsoleLoggerEx::clear_eol(word color)
{

}	


//////////////////////////////////////////////////////////////////////////
// gotoxy(x,y) : sets the cursor to x,y location
//////////////////////////////////////////////////////////////////////////
void CConsoleLoggerEx::gotoxy(int x,int y)
{

}	


//////////////////////////////////////////////////////////////////////////
// cprintf(attr,str,...) : prints a formatted string with the "attributes" color
//////////////////////////////////////////////////////////////////////////
int CConsoleLoggerEx::cprintf(int attributes,const char *format,...)
{
	return 0;
}


//////////////////////////////////////////////////////////////////////////
// cprintf(str,...) : prints a formatted string with current color
//////////////////////////////////////////////////////////////////////////
int CConsoleLoggerEx::cprintf(const char *format,...)
{
	return 0;
}


//////////////////////////////////////////////////////////////////////////
// the _cprintf() helper . do the actual output
//////////////////////////////////////////////////////////////////////////
int CConsoleLoggerEx::_cprint(int attributes,const char *lpszText,int iSize)
{
	return 0;
}

#endif

//no ifdef here
CConsoleLoggerEx coloured_console;
CConsoleLoggerEx zscript_coloured_console;


const char script_types[14][16]=
{
	"global", "ffc", "screendata", "hero", "item", "lweapon", "npc", "subscreen",
	"eweapon", "dmapdata", "itemsprite", "dmapdata (AS)", "dmapdata (PS)", "combodata"
};
	
	
	
int FFScript::UpperToLower(std::string *s)
{
	if ( s->size() < 1 ) 
	{
		Z_scripterrlog("String passed to UpperToLower() is too small. Size is: %d \n", s->size());
		return 0;
	}
	for ( unsigned int q = 0; q < s->size(); ++q )
	{
		if ( s->at(q) >= 'A' || s->at(q) <= 'Z' )
		{
			s->at(q) += 32;
		}
	}
	return 1;
}

int FFScript::LowerToUpper(std::string *s)
{
	if ( s->size() < 1 ) 
	{
		Z_scripterrlog("String passed to LowerToUpper() is too small. Size is: %d \n", s->size());
		return 0;
	}
	for ( unsigned int q = 0; q < s->size(); ++q )
	{
		if ( s->at(q) >= 'a' || s->at(q) <= 'z' )
		{
			s->at(q) -= 32;
		}
	}
	return 1;
}

int FFScript::ConvertCase(std::string *s)
{
	if ( s->size() < 1 ) 
	{
		Z_scripterrlog("String passed to UpperToLower() is too small. Size is: %d \n", s->size());
		return 0;
	}
	for ( unsigned int q = 0; q < s->size(); ++q )
	{
		if ( s->at(q) >= 'a' || s->at(q) <= 'z' )
		{
			s->at(q) -= 32;
		}
		else if ( s->at(q) >= 'A' || s->at(q) <= 'Z' )
		{
			s->at(q) += 32;
		}
	}
	zprint("FFScript::ConvertCase(std::string s), post-conversion, string is: %s\n", s->c_str());
	return 1;
}

bool FFScript::isNumber(char chr)
{
	if ( chr >= '0' )
	{
		if ( chr <= '9' ) return true;
	}
	return false;
}

int FFScript::ilen(char *p)
{
	int ret = 0; int pos = 0;
	if(p[pos] == '-')
		ret++;
	for(; FFCore.isNumber(p[pos + ret]); ++ret);
	return ret;
}

int FFScript::zc_strlen(char *p)
{
	int count = 0;
 
	while(*p!='\0')
	{
		count++;
		p++;
	}
 
	return count;
}

int FFScript::atox(char *ip_str)
{
	char tmp[2]={'2','\0'};
	int op_val=0, i=0, ip_len = FFCore.zc_strlen(ip_str);

	if(strncmp(ip_str, "0x", 2) == 0)
	{
		ip_str +=2;
		ip_len -=2;
	}

	for(i=0;i<ip_len;i++)
	{
		op_val *= 0x10;
		switch(ip_str[i])
		{
			case 'a':
			op_val += 0xa;
			break;
			case 'b':
			op_val += 0xb;
			break;
			case 'c':
			op_val += 0xc;
			break;
			case 'd':
			op_val += 0xd;
			break;
			case 'e':
			op_val += 0xe;
			break;
			case 'f':
			op_val += 0xf;
			break;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			tmp[0] = ip_str[i];
			op_val += atoi(tmp);
			break;
			default :
			op_val += 0x0;
			break;
		}
	}
	return op_val;
}

char runningItemScripts[256] = {0};
byte itemScriptsWaitdraw[256] = {0};
 
//item *FFCore.temp_ff_item = NULL;
//enemy *FFCore.temp_ff_enemy = NULL;
//weapon *FFCore.temp_ff_lweapon = NULL;
//weapon *FFCore.temp_ff_eweapon = NULL;

//miscQdata *Misc;

#include "zelda.h"
#include "link.h"
//extern int directItem = -1; //Is set if Link is currently using an item directly
//extern int directItemA = -1;
//extern int directItemB = -1;

#include "guys.h"
//enemy enemyclass;
#include "gamedata.h"
#include "zc_init.h"
#include "zsys.h"
#include "title.h"
#include "mem_debug.h"
#include "zscriptversion.h"

#include "pal.h"
#include "zdefs.h"
#include "zq_class.h"
#include "rendertarget.h" //Needed for LoadBitmap

#include "zc_custom.h"
#include "qst.h"

#ifdef _FFDEBUG
#include "ffdebug.h"
#endif

#include "debug.h"

#define zc_max(a,b)  ((a)>(b)?(a):(b))
/*template <typename T>
T zc_max(T a, T b)
{
	return (a > b) ? a : b;
}*/

#define zc_min(a,b)  ((a)<(b)?(a):(b))

#ifdef _MSC_VER
#pragma warning ( disable : 4800 ) //int to bool town. population: lots.
#endif

#define NUMSHOPS 256
#define NUMINFOSHOPS 511

//! New datatype vars for 2.54:

//spritedata sp->member


using std::string;

extern sprite_list particles;
extern LinkClass Link;
extern char *guy_string[];
extern int skipcont;

PALETTE tempgreypal; //Palettes go here. This is used for Greyscale() / Monochrome()
PALETTE userPALETTE[256]; //Palettes go here. This is used for Greyscale() / Monochrome()
PALETTE tempblackpal; //Used for storing the palette while fading to black

FFScript ffengine;

byte FF_rules[512]; //For Migration of Quest Rules, and Scritp Engine Rules
long FF_link_tile;	//Overrides for the tile used when blitting Limk to the bitmap; and a var to hold a script-set action/
byte FF_link_action; //This way, we can make safe replicas of internal Link actions to be set by script. 
	
long FF_screenbounds[4]; //edges of the screen, left, right, top, bottom used for where to scroll. 
long FF_screen_dimensions[4]; //height, width, displaywidth, displayheight
long FF_subscreen_dimensions[4];
long FF_eweapon_removal_bounds[4]; //left, right, top, bottom coordinates for automatic eweapon removal. 
long FF_lweapon_removal_bounds[4]; //left, right, top, bottom coordinates for automatic lweapon removal. 
long FF_clocks[FFSCRIPTCLASS_CLOCKS]; //Will be used for Linkaction, anims, and so forth 
byte ScriptDrawingRules[SCRIPT_DRAWING_RULES];
long FF_UserMidis[NUM_USER_MIDI_OVERRIDES]; //MIDIs to use for Game Over, and similar to override system defaults. 
	
miscQdata *misc;

//We gain some speed by not passing as arguments
long sarg1 = 0;
long sarg2 = 0;
refInfo *ri = NULL;
script_data *curscript = NULL;

static int numInstructions; // Used to detect hangs
static bool scriptCanSave = true;
byte curScriptType;
word curScriptNum;

//Global script data
refInfo globalScriptData[NUMSCRIPTGLOBAL];
refInfo linkScriptData;
refInfo screenScriptData;
refInfo dmapScriptData;
refInfo activeSubscreenScriptData;
refInfo passiveSubscreenScriptData;
word g_doscript = 0xFFFF;
word link_doscript = 1;
word dmap_doscript = 0; //Initialised at 0, intentionally. Zelda.cpp's game_loop() will set it to 1. 
word active_subscreen_doscript = 0;
word passive_subscreen_doscript = 0;
word global_wait = 0;
bool link_waitdraw = false;
bool dmap_waitdraw = false;
bool passive_subscreen_waitdraw = false;
bool active_subscreen_waitdraw = false;
word item_doscript[256] = {0};
word item_collect_doscript[256] = {0};
byte dmapscriptInitialised = 0;
byte activeSubscreenInitialised = 0;
byte passiveSubscreenInitialised = 0;
//Sprite script data
refInfo itemScriptData[256];
refInfo itemCollectScriptData[256];
byte itemscriptInitialised[256]={0};
refInfo npcScriptData[256];
refInfo lweaponScriptData[256]; //should this be lweapon and eweapon, separate stacks?
refInfo eweaponScriptData[256]; //should this be lweapon and eweapon, separate stacks?
refInfo itemactiveScriptData[256];

//char runningItemScripts[256] = {0};

//Combo Scripts
refInfo comboScriptData[176*7];
word combo_doscript[176*7] = {0}; //one bit per layer
byte combo_waitdraw[176] = {0}; //one bit per layer
byte combo_initialised[176*7] = {0}; //one bit per layer
int comboscript_combo_ids[176*7] = {0};
long combo_stack[176*7][MAX_SCRIPT_REGISTERS];

#define COMBOSCRIPT_RUNTYPE_DISABLED 0
#define COMBOSCRIPT_RUNTYPE_RUNNING 1
#define COMBOSCRIPT_RUNTYPE_CLEARING 2

//The stacks
//This is where we need to change the formula. These stacks need to be variable in some manner
//to permit adding additional scripts to them, without manually sizing them in advance. - Z

long(*stack)[MAX_SCRIPT_REGISTERS] = NULL;
long ffc_stack[32][MAX_SCRIPT_REGISTERS];
long global_stack[NUMSCRIPTGLOBAL][MAX_SCRIPT_REGISTERS];
long item_stack[256][MAX_SCRIPT_REGISTERS];
long item_collect_stack[256][MAX_SCRIPT_REGISTERS];
long ffmisc[32][16];
long link_stack[MAX_SCRIPT_REGISTERS];
long dmap_stack[MAX_SCRIPT_REGISTERS];
long active_subscreen_stack[MAX_SCRIPT_REGISTERS];
long passive_subscreen_stack[MAX_SCRIPT_REGISTERS];
long screen_stack[MAX_SCRIPT_REGISTERS];
refInfo ffcScriptData[32];

void clear_ffc_stack(const byte i)
{
	memset(ffc_stack[i], 0, MAX_SCRIPT_REGISTERS * sizeof(long));
}


void clear_global_stack(const byte i)
{
	memset(global_stack[i], 0, sizeof(global_stack[i]));
}

void FFScript::clear_screen_stack()
{
	memset(screen_stack, 0, sizeof(screen_stack));
}

void clear_link_stack()
{
	memset(link_stack, 0, MAX_SCRIPT_REGISTERS * sizeof(long));
}

void clear_dmap_stack()
{
	memset(dmap_stack, 0, MAX_SCRIPT_REGISTERS * sizeof(long));
}

void clear_active_subscreen_stack()
{
	memset(active_subscreen_stack, 0, MAX_SCRIPT_REGISTERS * sizeof(long));
}

void clear_passive_subscreen_stack()
{
	memset(passive_subscreen_stack, 0, MAX_SCRIPT_REGISTERS * sizeof(long));
}


void FFScript::initZScriptDMapScripts()
{
	dmap_doscript = 1;
	dmap_waitdraw = false;
	dmapScriptData.Clear();
	clear_dmap_stack();
	dmapscriptInitialised = 0;
	//
	passive_subscreen_doscript = 1;
	passive_subscreen_waitdraw = false;
	passiveSubscreenScriptData.Clear();
	clear_passive_subscreen_stack();
	passiveSubscreenInitialised = 0;
}

void FFScript::initZScriptActiveSubscreenScript()
{
	active_subscreen_doscript = 1;
	activeSubscreenScriptData.Clear();
	clear_active_subscreen_stack();
	activeSubscreenInitialised = 0;
	active_subscreen_waitdraw = false;
}

void FFScript::initZScriptLinkScripts()
{
	link_doscript = 1;
	link_waitdraw = false;
	linkScriptData.Clear();
	clear_link_stack();
}

void clear_item_stack(int i)
{
	memset(item_stack[i], 0, MAX_SCRIPT_REGISTERS * sizeof(long));
	memset(item_collect_stack[i], 0, MAX_SCRIPT_REGISTERS * sizeof(long));
}

void FFScript::initZScriptItemScripts()
{
	for ( int q = 0; q < 256; q++ )
	{
		if ( (itemsbuf[q].flags&ITEM_FLAG16) && game->item[q] ) item_doscript[q] = 1;
		else item_doscript[q] = 0;
		item_collect_doscript[q] = 0;
		itemScriptData[q].Clear();
		itemCollectScriptData[q].Clear();
		itemscriptInitialised[q] = 0;
		clear_item_stack(q);
	}
}

/*
void FFScript::initZScriptItemScripts()
{
	dmap_doscript = 1;
	dmapScriptData.Clear();
	clear_dmap_stack();
}
*/

//ScriptHelper
class SH
{

///-----------------------------//
//           Errors             //
///-----------------------------//

public:

	enum __Error
	{
		_NoError, //OK!
		_Overflow, //script array too small
		_InvalidPointer, //passed NULL pointer or similar
		_OutOfBounds, //library array out of bounds
		_InvalidSpriteUID //bad npc, ffc, etc.
	};
	
#define INVALIDARRAY localRAM[0]  //localRAM[0] is never used
	
	//only if the player is messing with their pointers...
	static ZScriptArray& InvalidError(const long ptr)
	{
		Z_scripterrlog("Invalid pointer (%i) passed to array (don't change the values of your array pointers)\n", ptr);
		return INVALIDARRAY;
	}
	
	static void write_stack(const unsigned int stackoffset, const long value)
	{
		if(stackoffset == 0)
		{
			Z_scripterrlog("Stack over or underflow, stack pointer = %ld\n", stackoffset);
			return;
		}
		
		(*stack)[stackoffset] = value;
	}
	
	static long read_stack(const unsigned int stackoffset)
	{
		if(stackoffset == 0)
		{
			Z_scripterrlog("Stack over or underflow, stack pointer = %ld\n", stackoffset);
			return -10000;
		}
		
		return (*stack)[stackoffset];
	}
	
	static INLINE long get_arg(long arg, bool v)
	{
		return v ? arg : get_register(arg);
	}
};

///----------------------------//
//           Misc.             //
///----------------------------//

//Miscellaneous Helper
class MiscH : public SH
{
public:

};

byte flagpos;
int ornextflag(bool flag)
{
	int f = (flag?1:0)<<flagpos;
	flagpos++;
	return f;
}

long get_screenflags(mapscr *m, int flagset)
{
	int f=0;
	flagpos = 0;
	
	switch(flagset)
	{
	case 0: // Room Type
		f = ornextflag(m->flags6&1)  | ornextflag(m->flags6&2) | ornextflag(m->flags7&8);
		break;
		
	case 1: // View
		f = ornextflag(m->flags3&8)  | ornextflag(m->flags7&16) | ornextflag(m->flags3&16)
			| ornextflag(m->flags3&64) | ornextflag(m->flags7&2)  | ornextflag(m->flags7&1)
			| ornextflag(m->flags&4);
		break;
		
	case 2: // Secrets
		f = ornextflag(m->flags&1)   | ornextflag(m->flags5&16) | ornextflag(m->flags6&4)
			| ornextflag(m->flags6&32);
		break;
		
	case 3: // Warp
		f = ornextflag(m->flags5&4)  | ornextflag(m->flags5&8)  | ornextflag(m->flags&64)
			| ornextflag(m->flags8&64) | ornextflag(m->flags3&32);
		break;
		
	case 4: // Item
		f = ornextflag(m->flags3&1)  | ornextflag(m->flags7&4);
		break;
		
	case 5: // Combo
		f = ornextflag((m->flags2>>4)&2)| ornextflag(m->flags3&2)| ornextflag(m->flags5&2)
			| ornextflag(m->flags6&64);
		break;
		
	case 6: // Save
		f = ornextflag(m->flags4&64) | ornextflag(m->flags4&128) | ornextflag(m->flags6&8)
			| ornextflag(m->flags6&16);
		break;
		
	case 7: // FFC
		f = ornextflag(m->flags6&128)| ornextflag(m->flags5&128);
		break;
		
	case 8: // Whistle
		f = ornextflag(m->flags&16)  | ornextflag(m->flags7&64)  | ornextflag(m->flags7&128);
		break;
		
	case 9: // Misc
		f = ornextflag(m->flags&32)  | ornextflag(m->flags5&64)  | m->flags8<<2;
		break;
	}
	
	return f*10000;
}

long get_screeneflags(mapscr *m, int flagset)
{
	int f=0;
	flagpos = 0;
	
	switch(flagset)
	{
	case 0:
		f = m->enemyflags&0x1F;
		break;
		
	case 1:
		f = ornextflag(m->enemyflags&32) | ornextflag(m->enemyflags&64) | ornextflag(m->flags3&4)
			| ornextflag(m->enemyflags&128)| ornextflag((m->flags2>>4)&4);
		break;
		
	case 2:
		f = ornextflag(m->flags3&128)    | ornextflag(m->flags&2)       | ornextflag((m->flags2>>4)&8)
			| ornextflag(m->flags4&16);
		break;
	}
	
	return f*10000;
}


///------------------------------------------------//
//           Bounds Checking Functions             //
///------------------------------------------------//

//Bounds Checker
class BC : public SH
{
public:

	static INLINE int checkMapID(const long ID, const char * const str)
	{
		//return checkBounds(ID, 0, map_count-1, str);
		if(ID < 0 || ID > map_count-1)
		{
			Z_scripterrlog("Invalid value (%i) passed to '%s'\n", ID+1, str);
			return _OutOfBounds;
		}
		
		return _NoError;
	}
	
	static INLINE int checkDMapID(const long ID, const char * const str)
	{
		return checkBounds(ID, 0, MAXDMAPS-1, str);
	}
	
	static INLINE int checkComboPos(const long pos, const char * const str)
	{
		return checkBoundsPos(pos, 0, 175, str);
	}
	
	static INLINE int checkTile(const long pos, const char * const str)
	{
		return checkBounds(pos, 0, NEWMAXTILES-1, str);
	}
	
	static INLINE int checkCombo(const long pos, const char * const str)
	{
		return checkBounds(pos, 0, MAXCOMBOS-1, str);
	}
	
	static INLINE int checkMisc(const long a, const char * const str)
	{
		return checkBounds(a, 0, 15, str);
	}
	
	 static INLINE int checkMisc32(const long a, const char * const str)
	{
		return checkBounds(a, 0, 31, str);
	}
	
	static INLINE int checkMessage(const long ID, const char * const str)
	{
		return checkBounds(ID, 0, msg_strings_size-1, str);
	}
	
	static INLINE int checkLayer(const long layer, const char * const str)
	{
		return checkBounds(layer, 0, 6, str);
	}
	
	static INLINE int checkFFC(const long ffc, const char * const str)
	{
		return checkBounds(ffc, 0, MAXFFCS-1, str);
	}
	
	static INLINE int checkGuyIndex(const long index, const char * const str)
	{
		return checkBoundsOneIndexed(index, 0, guys.Count()-1, str);
	}
	
	static INLINE int checkItemIndex(const long index, const char * const str)
	{
		return checkBoundsOneIndexed(index, 0, items.Count()-1, str);
	}
	
	static INLINE int checkEWeaponIndex(const long index, const char * const str)
	{
		return checkBoundsOneIndexed(index, 0, Ewpns.Count()-1, str);
	}
	
	static INLINE int checkLWeaponIndex(const long index, const char * const str)
	{
		return checkBoundsOneIndexed(index, 0, Lwpns.Count()-1, str);
	}
	
	static INLINE int checkGuyID(const long ID, const char * const str)
	{
		//return checkBounds(ID, 0, MAXGUYS-1, str); //Can't create NPC ID 0
		return checkBounds(ID, 1, MAXGUYS-1, str);
	}
	
	static INLINE int checkItemID(const long ID, const char * const str)
	{
		return checkBounds(ID, 0, ITEMCNT-1, str);
	}
	
	static INLINE int checkWeaponID(const long ID, const char * const str)
	{
		return checkBounds(ID, 0, WPNCNT-1, str);
	}
	
	static INLINE int checkWeaponMiscSprite(const long ID, const char * const str)
	{
		return checkBounds(ID, 0, MAXWPNS-1, str);
	}
	
	static INLINE int checkSFXID(const long ID, const char * const str)
	{
		return checkBounds(ID, 0, WAV_COUNT-1, str);
	}
	
	static INLINE int checkBounds(const long n, const long boundlow, const long boundup, const char * const funcvar)
	{
		if(n < boundlow || n > boundup)
		{
			Z_scripterrlog("Invalid value (%i) passed to '%s'\n", n, funcvar);
			return _OutOfBounds;
		}
		
		return _NoError;
	}
	
	static INLINE int checkBoundsPos(const long n, const long boundlow, const long boundup, const char * const funcvar)
	{
		if(n < boundlow || n > boundup)
		{
			Z_scripterrlog("Invalid position [%i] used to read to '%s'\n", n, funcvar);
			return _OutOfBounds;
		}
        
		return _NoError;
	}
	
	static INLINE int checkBoundsOneIndexed(const long n, const long boundlow, const long boundup, const char * const funcvar)
	{
		if(n < boundlow || n > boundup)
		{
			Z_scripterrlog("Invalid value (%i) passed to '%s'\n", n+1, funcvar);
			return _OutOfBounds;
		}
		
		return _NoError;
	}
	
	static INLINE int checkUserArrayIndex(const long index, const dword size)
	{
		if(index < 0 || index >= long(size))
		{
			Z_scripterrlog("Invalid index (%ld) to local array of size %ld\n", index, size);
			return _OutOfBounds;
		}
		
		return _NoError;
	}
};

///------------------------------------------------//
//           Pointer Handling Functions          //
///------------------------------------------------//
//MUST call AND check load functions before trying to use other functions


	

//Guy Helper
class GuyH : public SH
{

public:
	static int loadNPC(const long eid, const char * const funcvar)
	{
		if ( !eid ) 
		{
			//can never be zero?
			Z_scripterrlog("The npc pointer used for %s is NULL or uninitialised.", funcvar);
			return _InvalidSpriteUID;
		}
		tempenemy = (enemy *) guys.getByUID(eid);
		
		if(tempenemy == NULL)
		{
			Z_scripterrlog("Invalid NPC with UID %ld passed to %s\nNPCs on screen have UIDs ", eid, funcvar);
			
			for(word i = 0; i < guys.Count(); i++)
				Z_scripterrlog("%ld ", guys.spr(i)->getUID());
				
			Z_scripterrlog("\n");
			return _InvalidSpriteUID;
		}
		
		return _NoError;
	}
	
	static INLINE enemy *getNPC()
	{
		return tempenemy;
	}
	
	// Currently only used in a context where the enemy is known to be valid,
	// so there's no need to print an error
	static int getNPCIndex(const long eid)
	{
		for(word i = 0; i < guys.Count(); i++)
		{
			if(guys.spr(i)->getUID() == eid)
				return i;
		}
		
		return -1;
	}
	
	static long getNPCDMisc(const byte a)
	{
		switch(a)
		{
			case 0: return tempenemy->dmisc1;
			case 1: return tempenemy->dmisc2;
			case 2: return tempenemy->dmisc3;
			case 3: return tempenemy->dmisc4;
			case 4: return tempenemy->dmisc5;
			case 5: return tempenemy->dmisc6;
			case 6: return tempenemy->dmisc7;
			case 7: return tempenemy->dmisc8;
			case 8: return tempenemy->dmisc9;
			case 9: return tempenemy->dmisc10;
			case 10: return tempenemy->dmisc11;
			case 11: return tempenemy->dmisc12;
			case 12: return tempenemy->dmisc13;
			case 13: return tempenemy->dmisc14;
			case 14: return tempenemy->dmisc15;
			case 15: return tempenemy->dmisc16;
			case 16: return tempenemy->dmisc17;
			case 17: return tempenemy->dmisc18;
			case 18: return tempenemy->dmisc19;
			case 19: return tempenemy->dmisc20;
			case 20: return tempenemy->dmisc21;
			case 21: return tempenemy->dmisc22;
			case 22: return tempenemy->dmisc23;
			case 23: return tempenemy->dmisc24;
			case 24: return tempenemy->dmisc25;
			case 25: return tempenemy->dmisc26;
			case 26: return tempenemy->dmisc27;
			case 27: return tempenemy->dmisc28;
			case 28: return tempenemy->dmisc29;
			case 29: return tempenemy->dmisc30;
			case 30: return tempenemy->dmisc31;
			case 31: return tempenemy->dmisc32;
		}
		
		return 0;
	}
	
	static bool hasLink()
	{
		if(tempenemy->family == eeWALLM)
			return ((eWallM *) tempenemy)->haslink;
			
		if(tempenemy->family == eeWALK)
			return ((eStalfos *) tempenemy)->haslink;
			
		return false;
	}
	
	static long getMFlags()
	{
		flagpos = 5;
		// Must be in the same order as in the Enemy Editor pane
		return (tempenemy->flags&0x1F)
				| ornextflag(tempenemy->flags&(lens_only))
				| ornextflag(tempenemy->flags2&(guy_flashing))
				| ornextflag(tempenemy->flags2&(guy_blinking))
				| ornextflag(tempenemy->flags2&(guy_transparent))
				| ornextflag(tempenemy->flags&(inv_front))
				| ornextflag(tempenemy->flags&(inv_left))
				| ornextflag(tempenemy->flags&(inv_right))
				| ornextflag(tempenemy->flags&(inv_back))
				| ornextflag(tempenemy->flags&(guy_bkshield));
	}
	
	static INLINE void clearTemp()
	{
		tempenemy = NULL;
	}
	
private:

	static enemy *tempenemy;
};

enemy *GuyH::tempenemy = NULL;

//Item Helper
class ItemH : public SH
{

public:
	static int loadItem(const long iid, const char * const funcvar)
	{
		if ( !iid ) 
		{
			//can never be zero?
			Z_scripterrlog("The item pointer used for %s is NULL or uninitialised.", funcvar);
			return _InvalidSpriteUID;
		}
		
		tempitem = (item *) items.getByUID(iid);
		
		if(tempitem == NULL)
		{
			Z_scripterrlog("Invalid item with UID %ld passed to %s\nItems on screen have UIDs ", iid, funcvar);
			
			for(word i = 0; i < items.Count(); i++)
				Z_scripterrlog("%ld ", items.spr(i)->getUID());
				
			Z_scripterrlog("\n");
			return _InvalidSpriteUID;
		}
		
		return _NoError;
	}
	
	static int getItemIndex(const long iid)
	{
		for(word i = 0; i < items.Count(); i++)
		{
			if(items.spr(i)->getUID() == iid)
				return i;
		}
		
		return -1;
	}
	
	static INLINE item* getItem()
	{
		return tempitem;
	}
	
	static INLINE void clearTemp()
	{
		tempitem = NULL;
	}
	
private:

	static item *tempitem;
};

item *ItemH::tempitem = NULL;

//LWeapon Helper
class LwpnH : public SH
{

public:
	

	static defWpnSprite getDefWeaponSprite(weapon *wp)
	{
		switch(wp->id)
		{
			case wNone: return ws_0;
			case wSword: return ws_0;
			case wBeam: return wsBeam;
			case wBrang : return wsBrang;
			case wBomb: return wsBomb;
			case wSBomb: return wsSBomb;
			case wLitBomb: return wsBombblast;
			case wLitSBomb: return wsBombblast;
			case wArrow: return wsArrow;
			case wFire: return wsFire;
			case wWhistle: return wsUnused45;
			case wBait: return wsBait;
			case wWand: return wsWandHandle;
			case wMagic: return wsMagic;
			case wCatching: return wsUnused45;
			case wWind: return wsWind;
			case wRefMagic: return wsRefMagic;
			case wRefFireball: return wsRefFireball;
			case wRefRock: return wsRock;
			case wHammer: return wsHammer;
			case wHookshot: return wsHookshotHead;
			case wHSHandle: return wsHookshotHandle;
			case wHSChain: return wsHookshotChainH;
			case wSSparkle: return wsSilverSparkle;
			case wFSparkle: return wsGoldSparkle;
			case wSmack: return wsHammerSmack;
			case wPhantom: return wsUnused45;
			case wCByrna: return wsByrnaCane;
			case wRefBeam: return wsRefBeam;
			case wStomp: return wsUnused45;
			case lwMax: return wsUnused45;
			case wScript1: 
			case wScript2:
			case wScript3:
			case wScript4:
			case wScript5:
			case wScript6:
			case wScript7:
			case wScript8:
			case wScript9:
			case wScript10: return ws_0;
			case wIce: return wsIce; //new
			case wFlame: return wsEFire2; //new
			//not implemented; t/b/a
			case wSound:
			case wThrowRock: 
			case wPot:
			case wLit:
			case wBombos:
			case wEther:
			case wQuake:
			case wSword180:
			case wSwordLA:  return wsUnused45;
		
			case ewFireball: return wsFireball2;
			case ewArrow: return wsEArrow;
			case ewBrang: return wsBrang;
			case ewSword: return wsEBeam;
			case ewRock: return wsRock;
			case ewMagic: return wsEMagic;
			case ewBomb: return wsEBomb;
			case ewSBomb: return wsESbomb;
			case ewLitBomb: return wsEBombblast;
			case ewLitSBomb: return wsESbombblast;
			case ewFireTrail: return wsEFiretrail;
			case ewFlame: return wsEFire;
			case ewWind: return wsEWind;
			case ewFlame2: return wsEFire2;
			case ewFlame2Trail: return wsEFiretrail2;
			case ewIce: return wsIce;
			case ewFireball2: return wsFireball2;
			default: return wsUnused45;
		}
	};
	
	static int loadWeapon(const long wid, const char * const funcvar)
	{
		if ( !wid ) 
		{
			//can never be zero?
			Z_scripterrlog("The lweapon pointer used for %s is NULL or uninitialised.", funcvar);
			return _InvalidSpriteUID;
		}
		tempweapon = (weapon *) Lwpns.getByUID(wid);
		
		if(tempweapon == NULL)
		{
			Z_scripterrlog("Invalid lweapon with UID %ld passed to %s\nLWeapons on screen have UIDs ", wid, funcvar);
			
			for(word i = 0; i < Lwpns.Count(); i++)
				Z_scripterrlog("%ld ", Lwpns.spr(i)->getUID());
				
			Z_scripterrlog("\n");
			return _InvalidSpriteUID;
		}
		
		return _NoError;
	}
	
	static int getLWeaponIndex(const long lwid)
	{
		for(word i = 0; i < Lwpns.Count(); i++)
		{
			if(Lwpns.spr(i)->getUID() == lwid)
				return i;
		}
		
		return -1;
	}
	
	static INLINE weapon *getWeapon()
	{
		return tempweapon;
	}
	
	static INLINE void clearTemp()
	{
		tempweapon = NULL;
	}
	
private:

	static weapon *tempweapon;
};

weapon *LwpnH::tempweapon = NULL;

//EWeapon Helper
class EwpnH : public SH
{

public:
	
	defWpnSprite getDefWeaponSprite(weapon *wp)
	{
		switch(wp->id)
		{
			case wNone: return ws_0;
			case wSword: return ws_0;
			case wBeam: return wsBeam;
			case wBrang : return wsBrang;
			case wBomb: return wsBomb;
			case wSBomb: return wsSBomb;
			case wLitBomb: return wsBombblast;
			case wLitSBomb: return wsBombblast;
			case wArrow: return wsArrow;
			case wFire: return wsFire;
			case wWhistle: return wsUnused45;
			case wBait: return wsBait;
			case wWand: return wsWandHandle;
			case wMagic: return wsMagic;
			case wCatching: return wsUnused45;
			case wWind: return wsWind;
			case wRefMagic: return wsRefMagic;
			case wRefFireball: return wsRefFireball;
			case wRefRock: return wsRock;
			case wHammer: return wsHammer;
			case wHookshot: return wsHookshotHead;
			case wHSHandle: return wsHookshotHandle;
			case wHSChain: return wsHookshotChainH;
			case wSSparkle: return wsSilverSparkle;
			case wFSparkle: return wsGoldSparkle;
			case wSmack: return wsHammerSmack;
			case wPhantom: return wsUnused45;
			case wCByrna: return wsByrnaCane;
			case wRefBeam: return wsRefBeam;
			case wStomp: return wsUnused45;
			case lwMax: return wsUnused45;
			case wScript1: 
			case wScript2:
			case wScript3:
			case wScript4:
			case wScript5:
			case wScript6:
			case wScript7:
			case wScript8:
			case wScript9:
			case wScript10: return ws_0;
			case wIce: return wsIce; //new
			case wFlame: return wsEFire2; //new
			//not implemented; t/b/a
			case wSound:
			case wThrowRock: 
			case wPot:
			case wLit:
			case wBombos:
			case wEther:
			case wQuake:
			case wSword180:
			case wSwordLA:  return wsUnused45;
		
			case ewFireball: return wsFireball2;
			case ewArrow: return wsEArrow;
			case ewBrang: return wsBrang;
			case ewSword: return wsEBeam;
			case ewRock: return wsRock;
			case ewMagic: return wsEMagic;
			case ewBomb: return wsEBomb;
			case ewSBomb: return wsESbomb;
			case ewLitBomb: return wsEBombblast;
			case ewLitSBomb: return wsESbombblast;
			case ewFireTrail: return wsEFiretrail;
			case ewFlame: return wsEFire;
			case ewWind: return wsEWind;
			case ewFlame2: return wsEFire2;
			case ewFlame2Trail: return wsEFiretrail2;
			case ewIce: return wsIce;
			case ewFireball2: return wsFireball2;
			default: return wsUnused45;
		}
	};

	static int loadWeapon(const long wid, const char * const funcvar)
	{
		if ( !wid ) 
		{
			//can never be zero?
			Z_scripterrlog("The eweapon pointer used for %s is NULL or uninitialised.", funcvar);
			return _InvalidSpriteUID;
		}
		tempweapon = (weapon *) Ewpns.getByUID(wid);
		
		if(tempweapon == NULL)
		{
			Z_scripterrlog("Invalid eweapon with UID %ld passed to %s\nEWeapons on screen have UIDs ", wid, funcvar);
			
			for(word i = 0; i < Ewpns.Count(); i++)
				Z_scripterrlog("%ld ", Ewpns.spr(i)->getUID());
				
			Z_scripterrlog("\n");
			return _InvalidSpriteUID;
		}
		
		return _NoError;
	}
	
	static int getEWeaponIndex(const long ewid)
	{
		for(word i = 0; i < Ewpns.Count(); i++)
		{
			if(Ewpns.spr(i)->getUID() == ewid)
				return i;
		}
		
		return -1;
	}
	
	static INLINE weapon *getWeapon()
	{
		return tempweapon;
	}
	
	static INLINE void clearTemp()
	{
		tempweapon = NULL;
	}
	
private:

	static weapon *tempweapon;
};

weapon *EwpnH::tempweapon = NULL;

void clearScriptHelperData()
{
	GuyH::clearTemp();
	ItemH::clearTemp();
	LwpnH::clearTemp();
	EwpnH::clearTemp();
}

///---------------------------------------------//
//           Array Helper Functions           //
///---------------------------------------------//

//Array Helper
class ArrayH : public SH
{
public:

	//Returns a reference to the correct array based on pointer passed
	static ZScriptArray& getArray(const long ptr)
	{
		if(ptr <= 0)
			return InvalidError(ptr);
			
		if(ptr >= NUM_ZSCRIPT_ARRAYS) //Then it's a global
		{
			dword gptr = ptr - NUM_ZSCRIPT_ARRAYS;
			
			if(gptr > game->globalRAM.size())
				return InvalidError(ptr);
				
			return game->globalRAM[gptr];
		}
		else
		{
			if(localRAM[ptr].Size() == 0)
				return InvalidError(ptr);
				
			return localRAM[ptr];
		}
	}
	
	static size_t getSize(const long ptr)
	{
		ZScriptArray& a = getArray(ptr);
		
		if(a == INVALIDARRAY)
			return size_t(-1);
			
		return a.Size();
	}
	
	//Can't you get the std::string and then check its length?
	static int strlen(const long ptr)
	{
		ZScriptArray& a = getArray(ptr);
		
		if(a == INVALIDARRAY)
			return -1;
			
		word count;
		
		for(count = 0; BC::checkUserArrayIndex(count, a.Size()) == _NoError && a[count] != '\0'; count++) ;
		
		return count;
	}
	
	//Returns values of a zscript array as an std::string.
	static void getString(const long ptr, string &str, dword num_chars = ZSCRIPT_MAX_STRING_CHARS, dword offset = 0)
	{
		ZScriptArray& a = getArray(ptr);
		
		if(a == INVALIDARRAY)
		{
			str.clear();
			return;
		}
		
		str.clear();
		
		for(word i = offset; BC::checkUserArrayIndex(i, a.Size()) == _NoError && a[i] != '\0' && num_chars != 0; i++)
		{
			int c = a[i] / 10000;
			if(char(c) != c)
			{
				Z_scripterrlog("Illegal char value (%d) at position [%d] in string pointer %d\n", c, i, ptr);
				Z_scripterrlog("Value of invalid char will overflow.\n");
			}
			str += char(c);
			--num_chars;
		}
	}
	
	//Used for issues where reading the ZScript array floods the console with errors 'Accessing array index [12] size of 12.
	//Happens with Quad3D and some other functions, and I have no clue why. -Z ( 28th April, 2019 )
	//Like getString but for an array of longs instead of chars. *(arrayPtr is not checked for validity)
	static void getValues2(const long ptr, long* arrayPtr, dword num_values, dword offset = 0) //a hack -Z
	{
		ZScriptArray& a = getArray(ptr);
		
		if(a == INVALIDARRAY)
			return;
			
		for(word i = offset; BC::checkUserArrayIndex(i, ArrayH::getSize(ptr)+1) == _NoError && num_values != 0; i++)
		{
			arrayPtr[i] = (a[i] / 10000);
			num_values--;
		}
	}
	
	//Like getString but for an array of longs instead of chars. *(arrayPtr is not checked for validity)
	static void getValues(const long ptr, long* arrayPtr, dword num_values, dword offset = 0)
	{
		ZScriptArray& a = getArray(ptr);
		
		if(a == INVALIDARRAY)
			return;
			
		for(word i = offset; BC::checkUserArrayIndex(i, a.Size()) == _NoError && num_values != 0; i++)
		{
			arrayPtr[i] = (a[i] / 10000);
			num_values--;
		}
	}
	
	//Get element from array
	static INLINE long getElement(const long ptr, const long offset)
	{
		ZScriptArray& a = getArray(ptr);
		
		if(a == INVALIDARRAY)
			return -10000;
			
		if(BC::checkUserArrayIndex(offset, a.Size()) == _NoError)
			return a[offset];
		else
			return -10000;
	}
	
	//Set element in array
	static INLINE void setElement(const long ptr, const long offset, const long value)
	{
		ZScriptArray& a = getArray(ptr);
		
		if(a == INVALIDARRAY)
			return;
			
		if(BC::checkUserArrayIndex(offset, a.Size()) == _NoError)
			a[offset] = value;
	}
	
	//Puts values of a zscript array into a client <type> array. returns 0 on success. Overloaded
	template <typename T>
	static int getArray(const long ptr, T *refArray)
	{
		return getArray(ptr, getArray(ptr).Size(), 0, 0, 0, refArray);
	}
	
	template <typename T>
	static int getArray(const long ptr, const word size, T *refArray)
	{
		return getArray(ptr, size, 0, 0, 0, refArray);
	}
	
	template <typename T>
	static int getArray(const long ptr, const word size, word userOffset, const word userStride, const word refArrayOffset, T *refArray)
	{
		ZScriptArray& a = getArray(ptr);
		
		if(a == INVALIDARRAY)
			return _InvalidPointer;
			
		word j = 0, k = userStride;
		
		for(word i = 0; j < size; i++)
		{
			if(i >= a.Size())
				return _Overflow;
				
			if(userOffset-- > 0)
				continue;
				
			if(k > 0)
				k--;
			else if(BC::checkUserArrayIndex(i, a.Size()) == _NoError)
			{
				refArray[j + refArrayOffset] = T(a[i]);
				k = userStride;
				j++;
			}
		}
		
		return _NoError;
	}
	
	
	static int setArray(const long ptr, const string s2)
	{
		ZScriptArray &a = getArray(ptr);
		
		if(a == INVALIDARRAY)
			return _InvalidPointer;
			
		word i;
		
		for(i = 0; i < s2.size(); i++)
		{
			if(i >= a.Size())
			{
				a.Back() = '\0';
				return _Overflow;
			}
			
			if(BC::checkUserArrayIndex(i, a.Size()) == _NoError)
				a[i] = s2[i] * 10000;
		}
		
		if(BC::checkUserArrayIndex(i, a.Size()) == _NoError)
			a[i] = '\0';
			
		return _NoError;
	}
	
	//Puts values of a client <type> array into a zscript array. returns 0 on success. Overloaded
	template <typename T>
	static int setArray(const long ptr, const word size, T *refArray)
	{
		return setArray(ptr, size, 0, 0, 0, refArray);
	}
	
	template <typename T>
	static int setArray(const long ptr, const word size, word userOffset, const word userStride, const word refArrayOffset, T *refArray)
	{
		ZScriptArray& a = getArray(ptr);
		
		if(a == INVALIDARRAY)
			return _InvalidPointer;
			
		word j = 0, k = userStride;
		
		for(word i = 0; j < size; i++)
		{
			if(i >= a.Size())
				return _Overflow; //Resize?
				
			if(userOffset-- > 0)
				continue;
				
			if(k > 0)
				k--;
			else if(BC::checkUserArrayIndex(i, a.Size()) == _NoError)
			{
				a[i] = long(refArray[j + refArrayOffset]) * 10000;
				k = userStride;
				j++;
			}
		}
		
		return _NoError;
	}
};

// Called to deallocate arrays when a script stops running
void deallocateArray(const long ptrval)
{
	if(ptrval<=0 || ptrval >= NUM_ZSCRIPT_ARRAYS)
		Z_scripterrlog("Script tried to deallocate memory at invalid address %ld\n", ptrval);
	else
	{
		arrayOwner[ptrval].clear();
		
		if(localRAM[ptrval].Size() == 0)
			Z_scripterrlog("Script tried to deallocate memory that was not allocated at address %ld\n", ptrval);
		else
		{
			word size = localRAM[ptrval].Size();
			localRAM[ptrval].Clear();
			
			// If this happens once per frame, it can drown out every other message. -L
			//Z_eventlog("Deallocated local array with address %ld, size %d\n", ptrval, size);
			size = size;
		}
	}
}

void FFScript::deallocateAllArrays(const byte scriptType, const long UID, bool requireAlways)
{
	if(requireAlways && !get_bit(quest_rules, qr_ALWAYS_DEALLOCATE_ARRAYS))
	{
		//Keep 2.50.2 behavior if QR unchecked.
		switch(scriptType)
		{
			case SCRIPT_FFC:
			case SCRIPT_ITEM:
			case SCRIPT_GLOBAL:
				return;
		}
	}
	//Z_eventlog("Attempting array deallocation from %s UID %d\n", script_types[scriptType], UID);
	for(long i = 1; i < NUM_ZSCRIPT_ARRAYS; i++)
	{
		if(arrayOwner[i].scriptType == scriptType && arrayOwner[i].ownerUID==UID)
		{
			deallocateArray(i);
			//Z_eventlog("Deallocated array %d from %s UID %d\n", i, script_types[scriptType], UID);
		}
	}
}

void FFScript::deallocateAllArrays()
{
	//No QR check here- always deallocate on quest exit.
	for(long i = 1; i < NUM_ZSCRIPT_ARRAYS; i++)
	{
		if(localRAM[i].Size() > 0)
		{
			//Z_eventlog("Deallocated array %d from %s UID %d\n", i, script_types[arrayOwner[i].scriptType], arrayOwner[i].ownerUID);
			deallocateArray(i);
		}
	}
}

item *checkItem(long iid)
{
	item *s = (item *)items.getByUID(iid);
	
	if(s == NULL)
	{
		Z_eventlog("Script attempted to reference a nonexistent item!\n");
		Z_eventlog("You were trying to reference an item with UID = %ld; Items on screen are UIDs ", iid);
		
		for(int i=0; i<items.Count(); i++)
		{
			Z_eventlog("%ld ", items.spr(i)->getUID());
		}
		
		Z_eventlog("\n");
		return NULL;
	}
	
	return s;
}

weapon *checkLWpn(long eid, const char *what)
{
	weapon *s = (weapon *)Lwpns.getByUID(eid);
	
	if(s == NULL)
	{
	
		Z_eventlog("Script attempted to reference a nonexistent LWeapon!\n");
		Z_eventlog("You were trying to reference the %s of an LWeapon with UID = %ld; LWeapons on screen are UIDs ", what, eid);
		
		for(int i=0; i<Lwpns.Count(); i++)
		{
			Z_eventlog("%ld ", Lwpns.spr(i)->getUID());
		}
		
		Z_eventlog("\n");
		return NULL;
	}
	
	return s;
}

weapon *checkEWpn(long eid, const char *what)
{
	weapon *s = (weapon *)Ewpns.getByUID(eid);
	
	if(s == NULL)
	{
	
		Z_eventlog("Script attempted to reference a nonexistent EWeapon!\n");
		Z_eventlog("You were trying to reference the %s of an EWeapon with UID = %ld; EWeapons on screen are UIDs ", what, eid);
		
		for(int i=0; i<Ewpns.Count(); i++)
		{
			Z_eventlog("%ld ", Ewpns.spr(i)->getUID());
		}
		
		Z_eventlog("\n");
		return NULL;
	}
	
	return s;
}

user_file *checkFile(long ref, const char *what, bool req_file = false, bool skipError = false)
{
	if(ref > 0 && ref <= MAX_USER_FILES)
	{
		user_file* f = &script_files[ref-1];
		if(f->reserved)
		{
			if(req_file && !f->file)
			{
				if(skipError) return NULL;
				Z_scripterrlog("Script attempted to reference an invalid file!\n");
				Z_scripterrlog("File with UID = %ld does not have an open file connection!\n",ref);
				Z_scripterrlog("Use '->Open()' or '->Create()' to hook to a system file.\n");
				return NULL;
			}
			return f;
		}
	}
	if(skipError) return NULL;
	Z_scripterrlog("Script attempted to reference a nonexistent File!\n");
	Z_scripterrlog("You were trying to reference the '%s' of a File with UID = %ld\n", what, ref);
	return NULL;
}

user_bitmap *checkBitmap(long ref, const char *what, bool req_valid = false, bool skipError = false)
{
	int ind = ref - 10;
	if(ind >= firstUserGeneratedBitmap && ind < MAX_USER_BITMAPS)
	{
		user_bitmap* b = &(scb.script_created_bitmaps[ind]);
		if(b->reserved())
		{
			if(req_valid && !b->u_bmp)
			{
				if(skipError) return NULL;
				Z_scripterrlog("Script attempted to reference an invalid bitmap!\n");
				Z_scripterrlog("Bitmap with UID = %ld does not have a valid memory bitmap!\n",ref);
				Z_scripterrlog("Use '->Create()' to create a memory bitmap.\n");
				return NULL;
			}
			return b;
		}
	}
	else
	{
		switch(ind)
		{
			case rtSCREEN:
			case rtBMP0:
			case rtBMP1:
			case rtBMP2:
			case rtBMP3:
			case rtBMP4:
			case rtBMP5:
			case rtBMP6:
				zprint2("Internal error: 'checkBitmap()' recieved ref pointing to system bitmap!\n");
				zprint2("Please report this as a bug!\n");
				break;
		}
	}
	if(skipError) return NULL;
	Z_scripterrlog("Script attempted to reference a nonexistent bitmap!\n");
	if(what)
		Z_scripterrlog("You were trying to reference the '%s' of a bitmap with UID = %ld\n", what, ref);
	else
		Z_scripterrlog("You were trying to reference with UID = %ld\n", ref);
	return NULL;
}

int get_screen_d(long index1, long index2)
{
	if(index2 < 0 || index2 > 7)
	{
		Z_scripterrlog("You were trying to reference an out-of-bounds array index for a screen's D[] array (%ld); valid indices are from 0 to 7.\n", index1);
		return 0;
	}
	
	return game->screen_d[index1][index2];
}

void set_screen_d(long index1, long index2, int val)
{
	if(index2 < 0 || index2 > 7)
	{
		Z_scripterrlog("You were trying to reference an out-of-bounds array index for a screen's D[] array (%ld); valid indices are from 0 to 7.\n", index1);
		return;
	}
	
	game->screen_d[index1][index2] = val;
}

// If scr is currently being used as a layer, return that layer no.
int whichlayer(long scr)
{
	for(int i = 0; i < 6; i++)
	{
		if(scr == (tmpscr->layermap[i] - 1) * MAPSCRS + tmpscr->layerscreen[i])
			return i;
	}
	
	return -1;
}

sprite *s;


//Forward decl
int do_msgheight(int msg, char const* str);
int do_msgwidth(int msg, char const* str);
//

long get_register(const long arg)
{

	long ret = 0;
	
	//Macros
	
	#define GET_SPRITEDATA_VAR_INT(member, str) \
	{ \
		if(ri->spritesref < 0 || ri->spritesref > (MAXWPNS-1) )    \
		{ \
			ret = -10000; \
			Z_scripterrlog("Invalid Sprite ID passed to spritedata->%s: %d\n", (ri->spritesref*10000), str);\
		} \
		else \
			ret = (wpnsbuf[ri->spritesref].member * 10000); \
	}
	
	switch(arg)
	{
		
		case INCQST:
		{
			//zprint2("Incrementing Quest\n");
			int newqst = 0;
			if ( game->get_quest() < 255 )  //255 is a custom quest
			{
				newqst = (game->get_quest()+1);
			}
			else
			{
				newqst = 1;
			}
			//zprint2("newqst is: %d\n", newqst);
			if ( newqst < 11 ) 
			{
			
				ret = newqst * 10000;
				Quit = qINCQST;
				//ending();
			
			}
			else ret = -10000;
			break;
		}
		//Debug->Null()
		case DONULL: 
			ret = 0;
			break;
		
		//debug ri->d[]
		case DEBUGD:
		{
			int a = ri->d[0] / 10000;
			ret = ri->d[a] * 10000;
			break;
		}
		
		///----------------------------------------------------------------------------------------------------//
		//FFC Variables
		case DATA:
			if(BC::checkFFC(ri->ffcref, "ffc->Data") == SH::_NoError)
				ret = tmpscr->ffdata[ri->ffcref]*10000;
			break;
			
		case FFSCRIPT:
			if(BC::checkFFC(ri->ffcref, "ffc->Script") == SH::_NoError)
				ret = tmpscr->ffscript[ri->ffcref]*10000;
			break;
			
		case FCSET:
			if(BC::checkFFC(ri->ffcref, "ffc->CSet") == SH::_NoError)
				ret = tmpscr->ffcset[ri->ffcref]*10000;
			break;
			
		case DELAY:
			if(BC::checkFFC(ri->ffcref, "ffc->Delay") == SH::_NoError)
				ret = tmpscr->ffdelay[ri->ffcref]*10000;
			break;
			
		case FX:
			if(BC::checkFFC(ri->ffcref, "ffc->X") == SH::_NoError)
				ret = tmpscr->ffx[ri->ffcref];
			break;
			
		case FY:
			if(BC::checkFFC(ri->ffcref, "ffc->Y") == SH::_NoError)
				ret = tmpscr->ffy[ri->ffcref];
			break;
			
		case XD:
			if(BC::checkFFC(ri->ffcref, "ffc->Vx") == SH::_NoError)
				ret = tmpscr->ffxdelta[ri->ffcref];
			break;
			
		case YD:
			if(BC::checkFFC(ri->ffcref, "ffc->Vy") == SH::_NoError)
				ret = tmpscr->ffydelta[ri->ffcref];
			break;
		case FFCID:
			if(BC::checkFFC(ri->ffcref, "ffc->ID") == SH::_NoError)
				ret=(ri->ffcref*10000)+10000;
			break;
			
		case XD2:
			if(BC::checkFFC(ri->ffcref, "ffc->Ax") == SH::_NoError)
				ret = tmpscr->ffxdelta2[ri->ffcref];
			break;
			
		case YD2:
			if(BC::checkFFC(ri->ffcref, "ffc->Ay") == SH::_NoError)
				ret = tmpscr->ffydelta2[ri->ffcref];
			break;
			
		case FFFLAGSD:
			if(BC::checkFFC(ri->ffcref, "ffc->Flags[]") == SH::_NoError)
				ret=((tmpscr->ffflags[ri->ffcref] >> (ri->d[0] / 10000))&1) ? 10000 : 0;
			break;
			
		case FFCWIDTH:
			if(BC::checkFFC(ri->ffcref, "ffc->EffectWidth") == SH::_NoError)
				ret=((tmpscr->ffwidth[ri->ffcref]&0x3F)+1)*10000;
			break;
			
		case FFCHEIGHT:
			if(BC::checkFFC(ri->ffcref, "ffc->EffectHeight") == SH::_NoError)
				ret=((tmpscr->ffheight[ri->ffcref]&0x3F)+1)*10000;
			break;
			
		case FFTWIDTH:
			if(BC::checkFFC(ri->ffcref, "ffc->TileWidth") == SH::_NoError)
				ret=((tmpscr->ffwidth[ri->ffcref]>>6)+1)*10000;
			break;
			
		case FFTHEIGHT:
			if(BC::checkFFC(ri->ffcref, "ffc->TileHeight") == SH::_NoError)
				ret=((tmpscr->ffheight[ri->ffcref]>>6)+1)*10000;
			break;
			
		case FFLINK:
			if(BC::checkFFC(ri->ffcref, "ffc->Link") == SH::_NoError)
				ret=(tmpscr->fflink[ri->ffcref])*10000;
			break;
			
		case FFMISCD:
		{
			int a = ri->d[0] / 10000;
			
			if(BC::checkMisc(a, "ffc->Misc") != SH::_NoError)
				ret = -10000;
			else
			{
				if(BC::checkFFC(ri->ffcref, "ffc->Misc[]") == SH::_NoError)
					ret = ffmisc[ri->ffcref][a];
			}
		}
		break;
		
		case FFINITDD:
		{
			int a = ri->d[0] / 10000;
			
			if(BC::checkBounds(a, 0, 7, "ffc->InitD") != SH::_NoError)
				ret = -10000;
			else
			{
				if(BC::checkFFC(ri->ffcref, "ffc->InitD[]") == SH::_NoError)
				ret = tmpscr->initd[ri->ffcref][a];
			}
		}
		break;
		
		///----------------------------------------------------------------------------------------------------//
		//Link's Variables
		case LINKX:
		{
			if (get_bit(quest_rules,qr_SPRITEXY_IS_FLOAT))
			{
				//double lx = (double)Link.getX();
				//Z_scripterrlog("lx: %f\n", lx);
				
				//ret = lx * 10000;
				//zfix lx = Link.getX();
				//Z_scripterrlog("lx: %d\n", lx);
				ret = Link.getX().getZLong();
			}
			else ret = long(Link.getX()) * 10000;

			break;
		}
			
		case LINKY:
		{
			if (get_bit(quest_rules,qr_SPRITEXY_IS_FLOAT))
			{
				ret = Link.getY().getZLong();
			}
			else ret = long(Link.getY()) * 10000;

			break;
		}    
		case LINKZ:
		{
			if (get_bit(quest_rules,qr_SPRITEXY_IS_FLOAT))
			{
				ret = Link.getZ().getZLong();
			}
			else ret = long(Link.getZ()) * 10000;

			break;
		} 
		case LINKJUMP:
			// -fall/100*10000, but doing it that way screwed up the result
			ret = Link.getFall().getZLong() / -100;
			break;
			
		case LINKDIR:
			ret=(int)(Link.dir)*10000;
			break;
			
		case LINKHITDIR:
			ret=(int)(Link.getHitDir())*10000;
			break;
			
		case LINKHP:
			ret=(int)(game->get_life())*10000;
			break;
		
		case LINKGRAVITY:
			ret = ( (Link.moveflags & FLAG_OBEYS_GRAV) ? 10000 : 0 );
			break;
		
		case HERONOSTEPFORWARD:
			ret = ( (FFCore.nostepforward) ? 10000 : 0 );
			break;
			
		case LINKMP:
			ret=(int)(game->get_magic())*10000;
			break;
			
		case LINKMAXHP:
			ret=(int)(game->get_maxlife())*10000;
			break;
			
		case LINKMAXMP:
			ret=(int)(game->get_maxmagic())*10000;
			break;
			
		case LINKACTION:
		{
			//Z_scripterrlog("The present FFCore action is: %d\n", FFCore.getLinkAction());
			//int act = FFCore.getLinkAction() * 10000;
			ret = FFCore.getLinkAction() * 10000;
			//Z_scripterrlog("The present 'action' return value is: %d\n", act);
			//ret = act;
			//ret=(int)(Link.getAction())*10000;
			break;
		}
		
		case HEROHEALTHBEEP:
		{
			//Z_scripterrlog("The present FFCore action is: %d\n", FFCore.getLinkAction());
			//int act = FFCore.getLinkAction() * 10000;
			ret = heart_beep ? ( heart_beep_timer * 10000 ) : 0;
			//Z_scripterrlog("The present 'action' return value is: %d\n", act);
			//ret = act;
			//ret=(int)(Link.getAction())*10000;
			break;
		}
			
		case LINKHELD:
			ret = (int)(Link.getHeldItem())*10000;
			break;
			
		case LINKITEMD:
			ret = game->item[vbound(ri->d[0]/10000, 0, MAXITEMS-1)] ? 10000 : 0;
			break;
		
		case HEROSTEPS:
			ret = lsteps[vbound(ri->d[0]/10000, 0, 7)] * 10000;
			break;
		
		case HEROSTEPRATE:
			ret = Link.getStepRate() * 10000;
			break;
			
		case LINKEQUIP:
			ret = ((Awpn&0xFF)|((Bwpn&0xFF)<<8))*10000;
			break;
			
		case LINKINVIS:
			ret = (((int)(Link.getDontDraw())) ? 10000 : 0);
			break;
			
		case LINKINVINC:
			ret = (int)(Link.scriptcoldet)*10000;
			break;
		
		case LINKENGINEANIMATE:
			ret = (int)(Link.do_animation)*10000;
			break;
			
		case LINKLADDERX:
			ret=(int)(Link.getLadderX())*10000;
			break;
			
		case LINKLADDERY:
			ret=(int)(Link.getLadderY())*10000;
			break;
			
		case LINKSWORDJINX:
			ret = (int)(Link.getSwordClk())*10000;
			break;
			
		case LINKITEMJINX:
			ret = (int)(Link.getItemClk())*10000;
			break;
			
		case LINKDRUNK:
			ret = (int)(Link.DrunkClock())*10000;
			break;
			
		case LINKMISCD:
			ret = (int)(Link.miscellaneous[vbound(ri->d[0]/10000,0,31)]); //Was this buffed before? -Z
			break;
		
		
		case LINKHITBY:
		{
			int indx = ri->d[0]/10000;
			switch(indx)
			{
				//screen indices of objects
				case 0:
				case 1:
				case 2:
				case 3:
				{
					ret = (int)(Link.gethitLinkUID(indx))* 10000;
					break;
				}
				//uids of objects
				case 5:
				case 6:
				case 7:
				case 8:
				{
					ret = (int)(Link.gethitLinkUID(vbound(ri->d[0]/10000,0,3))); //do not multiply by 10000! UIDs are not *10000!
					break;
					
				}
				default: { al_trace("Invalid index passed to Link->HitBy[%d] /n", indx); ret = -1; break; }
			}
			break;
		}
		case LINKDEFENCE:
			ret = (int)(Link.get_defence(vbound(ri->d[0]/10000,0,255)))* 10000;
			break;
			
			
		case LINKROTATION:
			if ( get_bit(quest_rules, qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"Link->Rotation");
				ret = -1; break;
			}
			ret = (int)(Link.rotation)*10000;
			break;
		
		case LINKSCALE:
		{
			if ( get_bit(quest_rules, qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"Link->Scale");
				ret = -1; break;
			}
			//al_trace("Link's scale is: %d\n", Link.scale);
			ret = (int)(Link.scale*100.0);
			break;
		}
		

		case LINKHXOFS:
			ret = (int)(Link.hxofs)*10000;
			break;
			
		case LINKHYOFS:
			ret = (int)(Link.hyofs)*10000;
			break;
			
		case LINKXOFS:
			ret = (int)(Link.xofs)*10000;
			break;
			
		case LINKYOFS:
			ret = (int)(Link.yofs-playing_field_offset)*10000;
			break;
			
		case LINKZOFS:
			ret = (int)(Link.zofs)*10000;
			break;
			
		case LINKHXSZ:
			ret = (int)(Link.hxsz)*10000;
			break;
			
		case LINKHYSZ:
			ret = (int)(Link.hysz)*10000;
			break;
			
		case LINKHZSZ:
			ret = (int)(Link.hzsz)*10000;
			break;
			
		case LINKTXSZ:
			ret = (int)(Link.txsz)*10000;
			break;
			
		case LINKTYSZ:
			ret = (int)(Link.tysz)*10000;
			break;
			
		case LINKTILE:
			ret = (int)(Link.tile)*10000;
			break;
			
		case LINKFLIP:
			ret = (int)(Link.flip)*10000;
			break;
		
		case LINKINVFRAME:
			ret = (int)Link.getHClk()*10000;
			break;
		
		case LINKCANFLICKER:
			ret= Link.getCanLinkFlicker()?10000:0;
			break;
		case LINKHURTSFX:
			ret = (int)Link.getHurtSFX()*10000;
			break;
		
		/*
		case LINKUSINGITEM:
			ret = (int)Link.getDirectItem()*10000;
			break;
		
		case LINKUSINGITEMA:
			ret = (int)Link.getDirectItemA()*10000;
			break;
		
		case LINKUSINGITEMB:
			ret = (int)Link.getDirectItemB()*10000;
			break;
		*/
			
		case LINKEATEN:
			ret=(int)Link.getEaten()*10000;
			break;
		case LINKPUSH:
			ret=(int)Link.getPushing()*10000;
			break;
		case LINKSTUN:
			ret=(int)Link.StunClock()*10000;
			break;
		case LINKSCRIPTTILE:
			ret=script_link_sprite*10000;
			break;
		
		case HEROSCRIPTCSET:
			ret=script_link_cset*10000;
			break;
		case LINKSCRIPFLIP:
			ret=script_link_flip*10000;
			break;
			
			
		case LINKITEMB:
			//Link->setBButtonItem(vbound((value/10000),0,(MAXITEMS-1)));
			ret = Bwpn*10000;
			break;
		
		case LINKITEMA:
			//Link->setBButtonItem(vbound((value/10000),0,(MAXITEMS-1)));
			ret = Awpn *10000;
			break;
		
		case LINKTILEMOD:
			ret = Link.getTileModifier() * 10000;
			break;
		
		case LINKDIAG:
			ret=Link.getDiagMove()?10000:0;
			break;
		
		case LINKBIGHITBOX:
			ret=Link.getBigHitbox()?10000:0;
			break;
		
		case LINKCLIMBING:
			ret = Link.getOnSideviewLadder()?10000:0;
			break;
			
		case HEROJUMPCOUNT:
			ret = Link.extra_jump_count * 10000;
			break;
		
		case HEROPULLDIR:
			ret = Link.pit_pulldir * 10000;
			break;
		
		case HEROPULLCLK:
			ret = Link.pit_pullclk * 10000;
			break;
		
		case HEROFALLCLK:
			ret = Link.fallclk * 10000;
			break;
		
		case HEROFALLCMB:
			ret = Link.fallCombo * 10000;
			break;
		
		case HEROMOVEFLAGS:
		{
			int indx = ri->d[0]/10000;
			if(BC::checkBounds(indx, 0, 1, "Hero->MoveFlags[]") != SH::_NoError)
				ret = 0; //false
			else
			{
				//All bits, in order, of a single byte; just use bitwise
				ret = (Link.moveflags & (1<<indx)) ? 10000 : 0;
			}
			break;
		}
		
		///----------------------------------------------------------------------------------------------------//
		//Input States
		case INPUTSTART:
			ret=control_state[6]?10000:0;
			break;
			
		case INPUTMAP:
			ret=control_state[9]?10000:0;
			break;
			
		case INPUTUP:
			ret=control_state[0]?10000:0;
			break;
			
		case INPUTDOWN:
			ret=control_state[1]?10000:0;
			break;
			
		case INPUTLEFT:
			ret=control_state[2]?10000:0;
			break;
			
		case INPUTRIGHT:
			ret=control_state[3]?10000:0;
			break;
			
		case INPUTA:
			ret=control_state[4]?10000:0;
			break;
			
		case INPUTB:
			ret=control_state[5]?10000:0;
			break;
			
		case INPUTL:
			ret=control_state[7]?10000:0;
			break;
			
		case INPUTR:
			ret=control_state[8]?10000:0;
			break;
			
		case INPUTEX1:
			ret=control_state[10]?10000:0;
			break;
			
		case INPUTEX2:
			ret=control_state[11]?10000:0;
			break;
			
		case INPUTEX3:
			ret=control_state[12]?10000:0;
			break;
			
		case INPUTEX4:
			ret=control_state[13]?10000:0;
			break;
			
		case INPUTAXISUP:
			ret=control_state[14]?10000:0;
			break;
			
		case INPUTAXISDOWN:
			ret=control_state[15]?10000:0;
			break;
			
		case INPUTAXISLEFT:
			ret=control_state[16]?10000:0;
			break;
			
		case INPUTAXISRIGHT:
			ret=control_state[17]?10000:0;
			break;
			
		case INPUTMOUSEX:
		{
			int leftOffset=(resx/2)-(128*screen_scale);
			ret=((gui_mouse_x()-leftOffset)/screen_scale)*10000;
			break;
		}
		
		case INPUTMOUSEY:
		{
			int mousequakeoffset = 56+((int)(sin((double)(--quakeclk*2-frame))*4));
			int tempoffset = (quakeclk > 0) ? mousequakeoffset : playing_field_offset;
			int topOffset=(resy/2)-((112-tempoffset)*screen_scale);
			ret=((gui_mouse_y()-topOffset)/screen_scale)*10000;
			break;
		}
		
		case INPUTMOUSEZ:
			ret=(gui_mouse_z())*10000;
			break;
			
		case INPUTMOUSEB:
			ret=(gui_mouse_b())*10000;
			break;
		
		case INPUTPRESSSTART:
			ret=button_press[6]?10000:0;
			break;
			
		case INPUTPRESSMAP:
			ret=button_press[9]?10000:0;
			break;
			
		case INPUTPRESSUP:
			ret=button_press[0]?10000:0;
			break;
			
		case INPUTPRESSDOWN:
			ret=button_press[1]?10000:0;
			break;
			
		case INPUTPRESSLEFT:
			ret=button_press[2]?10000:0;
			break;
			
		case INPUTPRESSRIGHT:
			ret=button_press[3]?10000:0;
			break;
			
		case INPUTPRESSA:
			ret=button_press[4]?10000:0;
			break;
			
		case INPUTPRESSB:
			ret=button_press[5]?10000:0;
			break;
			
		case INPUTPRESSL:
			ret=button_press[7]?10000:0;
			break;
			
		case INPUTPRESSR:
			ret=button_press[8]?10000:0;
			break;
			
		case INPUTPRESSEX1:
			ret=button_press[10]?10000:0;
			break;
			
		case INPUTPRESSEX2:
			ret=button_press[11]?10000:0;
			break;
			
		case INPUTPRESSEX3:
			ret=button_press[12]?10000:0;
			break;
			
		case INPUTPRESSEX4:
			ret=button_press[13]?10000:0;
			break;
			
		case INPUTPRESSAXISUP:
			ret=button_press[14]?10000:0;
			break;
			
		case INPUTPRESSAXISDOWN:
			ret=button_press[15]?10000:0;
			break;
			
		case INPUTPRESSAXISLEFT:
			ret=button_press[16]?10000:0;
			break;
			
		case INPUTPRESSAXISRIGHT:
			ret=button_press[17]?10000:0;
			break;
			
		case FFRULE:
			// DUkey, DDkey, DLkey, DRkey, Akey, Bkey, Skey, Lkey, Rkey, Pkey, Exkey1, Exkey2, Exkey3, Exkey4 };
		{
			//Read-only
			int ruleid = vbound((ri->d[0]/10000),0,qr_MAX);
			ret = get_bit(quest_rules,ruleid)?10000:0;
		}
		break;
		
		case BUTTONPRESS:
			// DUkey, DDkey, DLkey, DRkey, Akey, Bkey, Skey, Lkey, Rkey, Pkey, Exkey1, Exkey2, Exkey3, Exkey4 };
		{
			//Read-only
			int button = vbound((ri->d[0]/10000),0,17);
			ret = button_press[button]?10000:0;
		}
		break;

		case BUTTONINPUT:
		{
			//Read-only
			int button = vbound((ri->d[0]/10000),0,17);
			ret=control_state[button]?10000:0;
		}
		break;

		case BUTTONHELD:
		{
			//Read-only
			int button = vbound((ri->d[0]/10000),0,17);
			ret = button_hold[button]?10000:0;
		}
		break;

		case RAWKEY:
		{	//Game->KeyPressed[], read-only
			//if ( !keypressed() ) break; //Don;t return values set by setting Link->Input/Press
			//hmm...no, this won;t return properly for modifier keys. 
			int keyid = ri->d[0]/10000;
			//key = vbound(key,0,n);
			bool pressed = key[keyid] != 0;
			ret = pressed?10000:0;
		}
		break;
		
		case KEYINPUT:
		{
			ret = KeyInput[ri->d[0]/10000] ? 10000 : 0;
			break;
		}
		case KEYPRESS:
		{
			ret = KeyPress[ri->d[0]/10000] ? 10000 : 0;
			break;
		}
		
		case KEYMODIFIERS:
		{
			ret = (key_shifts*10000);
			break;
		}
		
		case KEYBINDINGS:
		{
			int keyid = ri->d[0]/10000;
			switch(keyid)
			{
				case 0: ret = DUkey * 10000; break;
				case 1: ret = DDkey * 10000; break; 
				case 2: ret = DLkey * 10000; break;
				case 3: ret = DRkey * 10000; break;
				case 4: ret = Akey * 10000; break;
				case 5: ret = Bkey * 10000; break;
				case 6: ret = Skey * 10000; break;
				case 7: ret = Lkey * 10000; break;
				case 8: ret = Rkey * 10000; break;
				case 9: ret = Pkey * 10000; /*map*/ break; 
				case 10: ret = Exkey1 * 10000; break;
				case 11: ret = Exkey2 * 10000; break;
				case 12: ret = Exkey3 * 10000; break;
				case 13: ret = Exkey4 * 10000; break;
				
				default: { Z_scripterrlog("Invalid index [%d] passed to Input->KeyBindings[]\n", keyid); ret = 0; break; }
			}
			break;
		}

		case READKEY:
		{
			//Game->ReadKey(int key), also clears it. 
			int keyid = ri->d[0]/10000;
			bool pressed = zc_readkey(keyid, true);
			ret = pressed?10000:0;
		}
		break;
		
		case DISABLEKEY:
		{
			//Input->DisableKey(int key)
			int keyid = ri->d[0]/10000;
			ret = disabledKeys[keyid]?10000:0;
			break;
		}
		
		case DISABLEBUTTON:
		{
			//Input->DisableButton(int cb)
			int cbid = ri->d[0]/10000;
			ret = disable_control[cbid]?10000:0;
			break;
		}

		case JOYPADPRESS:
		{
			//Checks if a press is from the joypad, not keyboard. 
			int button = ri->d[0]/10000;
			ret = joybtn(button)?10000:0;
		}
		break;
		
		case MOUSEARR:
		{	
			int indx = (ri->d[0]/10000);
			int rv;
			switch (indx)
			{
				case 0: //MouseX
				{
					int leftOffset=(resx/2)-(128*screen_scale);
					rv=((gui_mouse_x()-leftOffset)/screen_scale)*10000;
					break;	
				}
				case 1: //MouseY
				{
					int mousequakeoffset = 56+((int)(sin((double)(--quakeclk*2-frame))*4));
					int tempoffset = (quakeclk > 0) ? mousequakeoffset : playing_field_offset;
					int topOffset=(resy/2)-((112-tempoffset)*screen_scale);
					rv=((gui_mouse_y()-topOffset)/screen_scale)*10000;
					break;
				}
				case 2: //MouseZ
				{
					rv=(gui_mouse_z())*10000;
					break;
				}
				case 3: //Left Click
				{
					rv=((gui_mouse_b()&0x1))*10000;
					break;
				}
				case 4: //Right Click
				{
					rv=((gui_mouse_b()&0x2))*10000;
					break;
				}
				case 5: //Middle Click
				{
					rv=((gui_mouse_b()&0x4))*10000;
					break;
				}
				default:
				{
					Z_scripterrlog("Invalid index passed to Input->Mouse[]: %d\n", indx);
					rv = -10000;
					break;
				}
			}
				
			//bool pressed = key[keyid] != 0;
			//ret = pressed?10000:0;
			ret = rv;
		}
		break;
			
		///----------------------------------------------------------------------------------------------------//
		//Item Variables
		case ITEMSCALE:
			if ( get_bit(quest_rules, qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"item->Scale");
				ret = -1; break;
			}
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((int)((item*)(s))->scale)*100.0;
			}
			break;
		
		case ITEMX:
			if(0!=(s=checkItem(ri->itemref)))
			{
				if ( get_bit(quest_rules,qr_SPRITEXY_IS_FLOAT) )
				{
					ret=(((item*)(s))->x).getZLong();    
				}
				else ret=((int)((item*)(s))->x)*10000;
			}
			break;
		
		case ITEMSPRITESCRIPT:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((int)((item*)(s))->script)*10000;
			}
			break;
		
		case ITEMSPRITEINITD:
			if(0!=(s=checkItem(ri->itemref)))
			{
				int a = vbound(ri->d[0]/10000,0,7);
				ret=((int)((item*)(s))->initD[a]);
			}
			break;
		
		case ITEMFAMILY:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((int)((item*)(s))->family)*10000;
			}
			break;
		
		case ITEMLEVEL:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((int)((item*)(s))->lvl)*10000;
			}
			break;
			
		case SPRITEMAXITEM:
		{
			//No bounds check, as this is a universal function and works from NULL pointers!
			ret = items.getMax() * 10000;
			break;
		}
		
		case ITEMSCRIPTUID:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((int)((item*)(s))->script_UID); //Literal, not *10000
			}
			break;
			
		case ITEMY:
			if(0!=(s=checkItem(ri->itemref)))
			{
				if ( get_bit(quest_rules,qr_SPRITEXY_IS_FLOAT) )
				{
					ret=(((item*)(s))->y).getZLong();    
				}
				else 
					ret=((int)((item*)(s))->y)*10000;
			}
			break;
			
		case ITEMZ:
			if(0!=(s=checkItem(ri->itemref)))
			{
				if ( get_bit(quest_rules,qr_SPRITEXY_IS_FLOAT) )
				{
					ret=(((item*)(s))->z).getZLong();    
				}
				else 
					ret=((int)((item*)(s))->z)*10000;
			}
			break;
			
		case ITEMJUMP:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret = ((item*)(s))->fall.getZLong() / -100;
			}
			break;
			
		case ITEMDRAWTYPE:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->drawstyle*10000;
			}
			break;
		  
		case ITEMGRAVITY:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((((item*)(s))->moveflags & FLAG_OBEYS_GRAV) ? 10000 : 0);
			}
			break;
			
		case ITEMID:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->id*10000;
			}
			break;
			
		case ITEMTILE:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->tile*10000;
			}
			break;
			
		case ITEMSCRIPTTILE:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->scripttile*10000;
			}
			break;
			
		case ITEMSCRIPTFLIP:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->scriptflip*10000;
			}
			break;
		
		case ITEMPSTRING:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->pstring*10000;
			}
			break;
		case ITEMPSTRINGFLAGS:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->pickup_string_flags*10000;
			}
			break;
		case ITEMOVERRIDEFLAGS:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->overrideFLAGS*10000;
			}
			break;
			
		case ITEMOTILE:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->o_tile*10000;
			}
			break;
			
		case ITEMCSET:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=(((item*)(s))->o_cset&15)*10000;
			}
			break;
			
		case ITEMFLASHCSET:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=(((item*)(s))->o_cset>>4)*10000;
			}
			break;
			
		case ITEMFRAMES:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->frames*10000;
			}
			break;
			
		case ITEMFRAME:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->aframe*10000;
			}
			break;
		
		case ITEMACLK:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->aclk*10000;
			}
			break;    
		
		case ITEMASPEED:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->o_speed*10000;
			}
			break;
			
		case ITEMDELAY:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->o_delay*10000;
			}
			break;
			
		case ITEMFLIP:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->flip*10000;
			}
			break;
			
		case ITEMFLASH:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->flash*10000;
			}
			break;
			
		case ITEMHXOFS:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=(((item*)(s))->hxofs)*10000;
			}
			break;

		case ITEMROTATION:
			if ( get_bit(quest_rules, qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"item->Rotation");
				ret = -1; break;
			}
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=(((item*)(s))->rotation)*10000;
			}
			break;

		case ITEMHYOFS:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=(((item*)(s))->hyofs)*10000;
			}
			break;
			
		case ITEMXOFS:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((int)(((item*)(s))->xofs))*10000;
			}
			break;
			
		case ITEMYOFS:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((int)(((item*)(s))->yofs-playing_field_offset))*10000;
			}
			break;
			
		case ITEMZOFS:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((int)(((item*)(s))->zofs))*10000;
			}
			break;
			
		case ITEMHXSZ:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=(((item*)(s))->hxsz)*10000;
			}
			break;
			
		case ITEMHYSZ:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=(((item*)(s))->hysz)*10000;
			}
			break;
			
		case ITEMHZSZ:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=(((item*)(s))->hzsz)*10000;
			}
			break;
			
		case ITEMTXSZ:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=(((item*)(s))->txsz)*10000;
			}
			break;
			
		case ITEMTYSZ:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=(((item*)(s))->tysz)*10000;
			}
			break;
			
		case ITEMCOUNT:
			ret=(items.Count())*10000;
			break;
		
		case GETRENDERTARGET:
			ret=(zscriptDrawingRenderTarget->GetCurrentRenderTarget())*10000;
			break;
			
		case ITEMEXTEND:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->extend*10000;
			}
			break;
			
		case ITEMPICKUP:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret=((item*)(s))->pickup*10000;
			}
			break;
			
		case ITEMMISCD:
			if(0!=(s=checkItem(ri->itemref)))
			{
				int a = vbound(ri->d[0]/10000,0,31);
				ret=(((item*)(s))->miscellaneous[a]);
			}
			break;
		
		case ITEMFALLCLK:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret = ((item*)(s))->fallclk * 10000;
			}
			break;
		
		case ITEMFALLCMB:
			if(0!=(s=checkItem(ri->itemref)))
			{
				ret = ((item*)(s))->fallCombo * 10000;
			}
			break;
		
		case ITEMMOVEFLAGS:
		{
			if(0!=(s=checkItem(ri->itemref)))
			{
				int indx = ri->d[0]/10000;
				if(BC::checkBounds(indx, 0, 1, "itemsprite->MoveFlags[]") != SH::_NoError)
					ret = 0; //false
				else
				{
					//All bits, in order, of a single byte; just use bitwise
					ret = (((item*)(s))->moveflags & (1<<indx)) ? 10000 : 0;
				}
			}
			break;
		}
			
		///----------------------------------------------------------------------------------------------------//
		//Itemdata Variables
		
		
		case IDATAUSEWPN:
			ret=(itemsbuf[ri->idata].useweapon)*10000;
			break;
		case IDATAUSEDEF:
			ret=(itemsbuf[ri->idata].usedefence)*10000;
			break;
		case IDATAWRANGE:
			ret=(itemsbuf[ri->idata].weaprange)*10000;
			break;
		case IDATAMAGICTIMER:
			ret=(itemsbuf[ri->idata].magiccosttimer)*10000;
			break;
		case IDATAUSEMVT:
		{
			long a = vbound((ri->d[0] / 10000),0,(ITEM_MOVEMENT_PATTERNS-1));
			ret=(itemsbuf[ri->idata].weap_pattern[a])*10000;
		}
		break;
		
		case IDATADURATION:
			ret=(itemsbuf[ri->idata].weapduration)*10000;
			break;
		
		case IDATADUPLICATES:
			ret=(itemsbuf[ri->idata].duplicates)*10000;
			break;
		case IDATADRAWLAYER:
			ret=(itemsbuf[ri->idata].drawlayer)*10000;
			break;
		case IDATACOLLECTFLAGS:
			ret=(itemsbuf[ri->idata].collectflags)*10000;
			break;
		case IDATAWEAPONSCRIPT:
			ret=(itemsbuf[ri->idata].weaponscript)*10000;
			break;
		case IDATAMISCD:
		{
			int a = vbound((ri->d[0] / 10000),0,31);
			ret=(itemsbuf[ri->idata].wpn_misc_d[a])*10000;
		}
		break;
		case IDATAWPNINITD:
		{
			int a = vbound((ri->d[0] / 10000),0,7);
			ret=(itemsbuf[ri->idata].weap_initiald[a]);
		}
		break;
		case IDATAWEAPHXOFS:
			ret=(itemsbuf[ri->idata].weap_hxofs)*10000;
			break;
		case IDATAWEAPHYOFS:
			ret=(itemsbuf[ri->idata].weap_hyofs)*10000;
			break;
		case IDATAWEAPHXSZ:
			ret=(itemsbuf[ri->idata].weap_hxsz)*10000;
			break;
		case IDATAWEAPHYSZ:
			ret=(itemsbuf[ri->idata].weap_hysz)*10000;
			break;
		case IDATAWEAPHZSZ:
			ret=(itemsbuf[ri->idata].weap_hzsz)*10000;
			break;
		case IDATAWEAPXOFS:
			ret=(itemsbuf[ri->idata].weap_xofs)*10000;
			break;
		case IDATAWEAPYOFS:
			ret=(itemsbuf[ri->idata].weap_yofs)*10000;
			break;
		case IDATAHXOFS:
			ret=(itemsbuf[ri->idata].hxofs)*10000;
			break;
		case IDATAHYOFS:
			ret=(itemsbuf[ri->idata].hyofs)*10000;
			break;
		case IDATAHXSZ:
			ret=(itemsbuf[ri->idata].hxsz)*10000;
			break;
		case IDATAHYSZ:
			ret=(itemsbuf[ri->idata].hysz)*10000;
			break;
		case IDATAHZSZ:
			ret=(itemsbuf[ri->idata].hzsz)*10000;
			break;
		case IDATADXOFS:
			ret=(itemsbuf[ri->idata].xofs)*10000;
			break;
		case IDATADYOFS:
			ret=(itemsbuf[ri->idata].yofs)*10000;
			break;
		case IDATATILEW:
			ret=(itemsbuf[ri->idata].tilew)*10000;
			break;
		case IDATATILEH:
			ret=(itemsbuf[ri->idata].tileh)*10000;
			break;
		case IDATAPICKUP:
			ret=(itemsbuf[ri->idata].pickup)*10000;
			break;
		case IDATAOVERRIDEFL:
			ret=(itemsbuf[ri->idata].overrideFLAGS)*10000;
			break;

		case IDATATILEWWEAP:
			ret=(itemsbuf[ri->idata].weap_tilew)*10000;
			break;
		case IDATATILEHWEAP:
			ret=(itemsbuf[ri->idata].weap_tileh)*10000;
			break;
		case IDATAOVERRIDEFLWEAP:
			ret=(itemsbuf[ri->idata].weapoverrideFLAGS)*10000;
			break;
		
		case IDATAFAMILY:
			ret=(itemsbuf[ri->idata].family)*10000;
			break;
			
		case IDATALEVEL:
			ret=(itemsbuf[ri->idata].fam_type)*10000;
			break;
			
		case IDATAKEEP:
			ret=(itemsbuf[ri->idata].flags & ITEM_GAMEDATA)?10000:0;
			break;
			
		case IDATAAMOUNT:
			ret=(itemsbuf[ri->idata].amount)*10000;
			break;
			
		case IDATASETMAX:
			ret=(itemsbuf[ri->idata].setmax)*10000;
			break;
			
		case IDATAMAX:
			ret=(itemsbuf[ri->idata].max)*10000;
			break;
			
		case IDATACOUNTER:
			ret=(itemsbuf[ri->idata].count)*10000;
			break;
			
		case IDATAUSESOUND:
			ret=(itemsbuf[ri->idata].usesound)*10000;
			break;
			
		case IDATAPOWER:
			ret=(itemsbuf[ri->idata].power)*10000;
			break;
			
		//2.54
		//Get the ID of an item.
		case IDATAID:
			ret=ri->idata*10000;
			break;
		
		//Get the script assigned to an item (active)
		case IDATASCRIPT:
			ret=(itemsbuf[ri->idata].script)*10000;
			break;
		//Get the ->Attributes[] of an item
		case IDATAATTRIB:
		{
			int index = vbound(ri->d[0]/10000,0,9);
			switch(index)
			{
				case 0:
					ret=(itemsbuf[ri->idata].misc1)*10000; break;
				case 1:
					ret=(itemsbuf[ri->idata].misc2)*10000; break;
				case 2:
					ret=(itemsbuf[ri->idata].misc3)*10000; break;
				case 3:
					ret=(itemsbuf[ri->idata].misc4)*10000; break;
				case 4:
					ret=(itemsbuf[ri->idata].misc5)*10000; break;
				case 5:
					ret=(itemsbuf[ri->idata].misc6)*10000; break;
				case 6:
					ret=(itemsbuf[ri->idata].misc7)*10000; break;
				case 7:
					ret=(itemsbuf[ri->idata].misc8)*10000; break;
				case 8:
					ret=(itemsbuf[ri->idata].misc9)*10000; break;
				case 9:
					ret=(itemsbuf[ri->idata].misc10)*10000; break;
				default: 
					ret = -10000; break;
			}
				
			break;
		}
		//Get the ->Sprite[] of an item.
		case IDATASPRITE:
		{
			int index = vbound(ri->d[0]/10000,0,9);
			switch(index)
			{
				case 0:
					ret=(itemsbuf[ri->idata].wpn)*10000; break;
				case 1:
					ret=(itemsbuf[ri->idata].wpn2)*10000; break;
				case 2:
					ret=(itemsbuf[ri->idata].wpn3)*10000; break;
				case 3:
					ret=(itemsbuf[ri->idata].wpn4)*10000; break;
				case 4:
					ret=(itemsbuf[ri->idata].wpn5)*10000; break;
				case 5:
					ret=(itemsbuf[ri->idata].wpn6)*10000; break;
				case 6:
					ret=(itemsbuf[ri->idata].wpn7)*10000; break;
				case 7:
					ret=(itemsbuf[ri->idata].wpn8)*10000; break;
				case 8:
					ret=(itemsbuf[ri->idata].wpn9)*10000; break;
				case 9:
					ret=(itemsbuf[ri->idata].wpn10)*10000; break;
				default: 
					ret = -10000; break;
			}
				
			break;
		}
		//Link TIle modifier
		case IDATALTM:
			ret=(itemsbuf[ri->idata].ltm)*10000;
			break;
		//Pickup script
		case IDATAPSCRIPT:
			ret=(itemsbuf[ri->idata].collect_script)*10000;
			break;
		//Pickup string
		case IDATAPSTRING:
			ret=(itemsbuf[ri->idata].pstring)*10000;
			break;
		//Magic cost
		case IDATAMAGCOST:
			ret=(itemsbuf[ri->idata].magic)*10000;
			break;
		//cost counter ref
		case IDATACOSTCOUNTER:
			ret=(itemsbuf[ri->idata].cost_counter)*10000;
			break;
		//Min Hearts to Pick Up
		case IDATAMINHEARTS:
			ret=(itemsbuf[ri->idata].pickup_hearts)*10000;
			break;
		//Tile used by the item
		case IDATATILE:
			ret=(itemsbuf[ri->idata].tile)*10000;
			break;
		//itemdata->Flash
		case IDATAMISC:
			ret=(itemsbuf[ri->idata].misc)*10000;
			break;
		//->CSet
		case IDATACSET:
			ret=(itemsbuf[ri->idata].csets)*10000;
			break;
		//->A.Frames
		case IDATAFRAMES:
			ret=(itemsbuf[ri->idata].frames)*10000;
			break;
		/*
		case IDATAFRAME:
			ret=(itemsbuf[ri->idata].frame)*10000;
			break;
		*/ 
		//->A.Speed
		case IDATAASPEED:
			ret=(itemsbuf[ri->idata].speed)*10000;
			break;
		//->Delay
		case IDATADELAY:
			ret=(itemsbuf[ri->idata].delay)*10000;
			break;
		// teo of this item upgrades
		case IDATACOMBINE:
			ret=(itemsbuf[ri->idata].flags & ITEM_COMBINE)?10000:0;
			break;
		//Use item, and get the lower level one
		case IDATADOWNGRADE:
			ret=(itemsbuf[ri->idata].flags & ITEM_DOWNGRADE)?10000:0;
			break;
		//Only validate the cost, don't charge it
		case IDATAVALIDATE:
			ret=(itemsbuf[ri->idata].flags & ITEM_VALIDATEONLY)?10000:0;
			break;
		//->Flags[5]
		case IDATAFLAGS:
		{
			int index = vbound(ri->d[0]/10000,0,15);
			switch(index)
			{
				case 0:
					ret=(itemsbuf[ri->idata].flags & ITEM_FLAG1)?10000:0; break;
				case 1:
					ret=(itemsbuf[ri->idata].flags & ITEM_FLAG2)?10000:0; break;
				case 2:
					ret=(itemsbuf[ri->idata].flags & ITEM_FLAG3)?10000:0; break;
				case 3:
					ret=(itemsbuf[ri->idata].flags & ITEM_FLAG4)?10000:0; break;
				case 4:
					ret=(itemsbuf[ri->idata].flags & ITEM_FLAG5)?10000:0; break;
				case 5:
					ret=(itemsbuf[ri->idata].flags & ITEM_FLAG6)?10000:0; break;
				case 6:
					ret=(itemsbuf[ri->idata].flags & ITEM_FLAG7)?10000:0; break;
				case 7:
					ret=(itemsbuf[ri->idata].flags & ITEM_FLAG8)?10000:0; break;
				case 8:
					ret=(itemsbuf[ri->idata].flags & ITEM_FLAG9)?10000:0; break;
				case 9:
					ret=(itemsbuf[ri->idata].flags & ITEM_FLAG10)?10000:0; break;
				case 10:
					ret=(itemsbuf[ri->idata].flags & ITEM_FLAG11)?10000:0; break;
				case 11:
					ret=(itemsbuf[ri->idata].flags & ITEM_FLAG12)?10000:0; break;
				case 12:
					ret=(itemsbuf[ri->idata].flags & ITEM_FLAG13)?10000:0; break;
				case 13:
					ret=(itemsbuf[ri->idata].flags & ITEM_FLAG14)?10000:0; break;
				case 14:
					ret=(itemsbuf[ri->idata].flags & ITEM_FLAG15)?10000:0; break;
				case 15:
					ret=(itemsbuf[ri->idata].flags & ITEM_FLAG16)?10000:0; break;
				
				
				default: 
					ret = 0; break;
			}
				
			break;
		}
			
			//->Keep Old
			case IDATAKEEPOLD:
				ret=(itemsbuf[ri->idata].flags & ITEM_KEEPOLD)?10000:0;
				break;
			//Use rupees instead of magic
			case IDATARUPEECOST:
				ret=(itemsbuf[ri->idata].flags & ITEM_RUPEE_MAGIC)?10000:0;
				break;
			//Can be eaten
			case IDATAEDIBLE:
				ret=(itemsbuf[ri->idata].flags & ITEM_EDIBLE)?10000:0;
				break;
			//Not int he editor, could become flags[6], but I'm reserving this one for other item uses. 
			case IDATAFLAGUNUSED:
				ret=(itemsbuf[ri->idata].flags & ITEM_UNUSED)?10000:0;
				break;
			//Gain lower level items when collected
			case IDATAGAINLOWER:
				ret=(itemsbuf[ri->idata].flags & ITEM_GAINOLD)?10000:0;
				break;
		//Unchanged from master
		case IDATAINITDD:
		{
			int a = ri->d[0] / 10000;
			
			if(BC::checkBounds(a, 0, 7, "itemdata->InitD") != SH::_NoError)
				ret = -10000;
			else
				ret = itemsbuf[ri->idata].initiald[a];
		}
		break;
		
		///----------------------------------------------------------------------------------------------------//
		//NPC Variables

		//Reduces accessing integer members to one line
		#define GET_NPC_VAR_INT(member, str) \
		{ \
			if(GuyH::loadNPC(ri->guyref, str) != SH::_NoError) \
				ret = -10000; \
			else \
				ret = GuyH::getNPC()->member * 10000; \
		}

		case NPCDIR:
			if(GuyH::loadNPC(ri->guyref, "npc->Dir") != SH::_NoError)
				ret = -10000;
			else
				ret = zc_max(GuyH::getNPC()->dir * 10000, 0);
				
			break;
			
		case NPCRATE:
			GET_NPC_VAR_INT(rate, "npc->Rate") break;
			
		case NPCHOMING:
			GET_NPC_VAR_INT(homing, "npc->Homing") break;
			
		case NPCFRAMERATE:
			GET_NPC_VAR_INT(frate, "npc->ASpeed") break;
			
		case NPCHALTRATE:
			GET_NPC_VAR_INT(hrate, "npc->HaltRate") break;
		
		case NPCRANDOM:
			GET_NPC_VAR_INT(rate, "npc->Random") break;
			
		case NPCDRAWTYPE:
			GET_NPC_VAR_INT(drawstyle, "npc->DrawStyle") break;
			
		case NPCHP:
			GET_NPC_VAR_INT(hp, "npc->HP") break;
			
		case NPCCOLLDET:
			GET_NPC_VAR_INT(scriptcoldet, "npc->ColDetection") break;
		
		case NPCENGINEANIMATE:
			GET_NPC_VAR_INT(do_animation, "npc->Animation") break;
			
		case NPCSTUN:
			GET_NPC_VAR_INT(stunclk, "npc->Stun") break;
			
		case NPCHUNGER:
			GET_NPC_VAR_INT(grumble, "npc->Hunger") break;
		
		case NPCWEAPSPRITE:
			GET_NPC_VAR_INT(wpnsprite, "npc->WeaponSprite") break;
			
		case NPCTYPE:
			GET_NPC_VAR_INT(family, "npc->Type") break;
			
		case NPCDP:
			GET_NPC_VAR_INT(dp, "npc->Damage") break;
			
		case NPCWDP:
			GET_NPC_VAR_INT(wdp, "npc->WeaponDamage") break;
			
		case NPCOTILE:
			GET_NPC_VAR_INT(o_tile, "npc->OriginalTile") break;
			
		case NPCTILE:
			GET_NPC_VAR_INT(tile, "npc->Tile") break;
		
		case NPCSCRIPTTILE:
			GET_NPC_VAR_INT(scripttile, "npc->ScriptTile") break;
			
		case NPCSCRIPTFLIP:
			GET_NPC_VAR_INT(scriptflip, "npc->ScriptFlip") break;
			
		case NPCWEAPON:
			GET_NPC_VAR_INT(wpn, "npc->Weapon") break;
			
		case NPCITEMSET:
			GET_NPC_VAR_INT(item_set, "npc->ItemSet") break;
			
		case NPCCSET:
			GET_NPC_VAR_INT(cs, "npc->CSet") break;
			
		case NPCBOSSPAL:
			GET_NPC_VAR_INT(bosspal, "npc->BossPal") break;
			
		case NPCBGSFX:
			GET_NPC_VAR_INT(bgsfx, "npc->SFX") break;
			
		case NPCEXTEND:
			GET_NPC_VAR_INT(extend, "npc->Extend") break;
			
		case NPCHXOFS:
			GET_NPC_VAR_INT(hxofs, "npc->HitXOffset") break;
			
		case NPCHYOFS:
			GET_NPC_VAR_INT(hyofs, "npc->HitYOffset") break;
			
		case NPCHXSZ:
			GET_NPC_VAR_INT(hxsz, "npc->HitWidth") break;
			
		case NPCHYSZ:
			GET_NPC_VAR_INT(hysz, "npc->HitHeight") break;
			
		case NPCHZSZ:
			GET_NPC_VAR_INT(hzsz, "npc->HitZHeight") break;
		
		case NPCROTATION:
			if ( get_bit(quest_rules, qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"npc->Rotation");
				ret = -1; break;
			}
			GET_NPC_VAR_INT(rotation, "npc->Rotation") break;

		case NPCTXSZ:
			GET_NPC_VAR_INT(txsz, "npc->TileWidth") break;
			
		case NPCTYSZ:
			GET_NPC_VAR_INT(tysz, "npc->TileHeight") break;
			
		//And zfix
		#define GET_NPC_VAR_FIX(member, str) \
		{ \
			if(GuyH::loadNPC(ri->guyref, str) != SH::_NoError) \
				ret = -10000; \
			else \
				ret = (long(GuyH::getNPC()->member) * 10000); \
		}

		case NPCX:
		//GET_NPC_VAR_FIX(x, "npc->X") break;     
		{
			if(GuyH::loadNPC(ri->guyref, "X") != SH::_NoError) 
			{
				ret = -10000; 
			}
			else 
			{
				if ( get_bit(quest_rules,qr_SPRITEXY_IS_FLOAT) )
				{
					ret = ((GuyH::getNPC()->x).getZLong()); 
				}
				else
				{
					ret = (long(GuyH::getNPC()->x) * 10000);   
				}
			}
			break;
		}
		
		case SPRITEMAXNPC:
		{
			//No bounds check, as this is a universal function and works from NULL pointers!
			ret = guys.getMax() * 10000;
			break;
		}
		
		case NPCSUBMERGED:
		{
			if(GuyH::loadNPC(ri->guyref, "Submerged()") != SH::_NoError) 
			{
				ret = -10000; 
			}    
			else
			{
				ret = ((GuyH::getNPC()->isSubmerged()) ? 10000 : 0);
				
			}
			break;	
		}
			
			
		case NPCY:
			//GET_NPC_VAR_FIX(y, "npc->Y") break;
		{
			if(GuyH::loadNPC(ri->guyref, "Y") != SH::_NoError) 
			{
				ret = -10000; 
			}
			else 
			{
				if ( get_bit(quest_rules,qr_SPRITEXY_IS_FLOAT) )
				{
					ret = ((GuyH::getNPC()->y).getZLong()); 
				}
				else
				{
					ret = (long(GuyH::getNPC()->y) * 10000);   
				}
			}
			break;
		}
		
			
		case NPCZ:
			//GET_NPC_VAR_FIX(z, "npc->Z") break;
		{
			if(GuyH::loadNPC(ri->guyref, "Z") != SH::_NoError) 
			{
				ret = -10000; 
			}
			else 
			{
				if ( get_bit(quest_rules,qr_SPRITEXY_IS_FLOAT) )
				{
					ret = ((GuyH::getNPC()->z).getZLong()); 
				}
				else
				{
					ret = (long(GuyH::getNPC()->z) * 10000);   
				}
			}
			break;
		}
			
		case NPCXOFS:
			GET_NPC_VAR_FIX(xofs, "npc->DrawXOffset") break;
			
		case NPCYOFS:
			GET_NPC_VAR_FIX(yofs, "npc->DrawYOffset") ret-=playing_field_offset*10000;
			break;
			
		case NPCZOFS:
			GET_NPC_VAR_FIX(zofs, "npc->DrawZOffset") break;
			
			//These variables are all different to the templates (casting for jump and step is slightly non-standard)
		case NPCJUMP:
			if(GuyH::loadNPC(ri->guyref, "npc->Jump") != SH::_NoError)
				ret = -10000;
			else
				ret = GuyH::getNPC()->fall.getZLong() / -100;
				
			break;
		
		
		case NPCSCALE:
			if ( get_bit(quest_rules, qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"npc->Scale");
				ret = -1; break;
			}
			if(GuyH::loadNPC(ri->guyref, "npc->Scale") != SH::_NoError)
				ret = -10000;
			else
				ret = (long(GuyH::getNPC()->scale) * 100.0);
				
			break;
		
		case NPCIMMORTAL:
			if(GuyH::loadNPC(ri->guyref, "npc->Immortal") != SH::_NoError)
				ret = -10000;
			else
				ret = GuyH::getNPC()->immortal ? 10000 : 0;
			break;
		
		case NPCNOSLIDE:
			if(GuyH::loadNPC(ri->guyref, "npc->NoSlide") != SH::_NoError)
				ret = -10000;
			else
				ret = (GuyH::getNPC()->knockbackflags & FLAG_NOSLIDE) ? 10000 : 0;
			break;
		
		case NPCNOSCRIPTKB:
			if(GuyH::loadNPC(ri->guyref, "npc->NoScriptKnockback") != SH::_NoError)
				ret = -10000;
			else
				ret = (GuyH::getNPC()->knockbackflags & FLAG_NOSCRIPTKNOCKBACK) ? 10000 : 0;
			break;
		
		case NPCKNOCKBACKSPEED:
			if(GuyH::loadNPC(ri->guyref, "npc->SlideSpeed") != SH::_NoError)
				ret = -10000;
			else
				ret = GuyH::getNPC()->knockbackSpeed * 10000;
			break;
			
		case NPCSTEP:
			if(GuyH::loadNPC(ri->guyref, "npc->Step") != SH::_NoError)
				ret = -10000;
			else
			{
				if ( get_bit(quest_rules,qr_STEP_IS_FLOAT) )
				{
					ret = ( ( (GuyH::getNPC()->step).getZLong() ) * 100 );
				}
				//old, buggy code replication, round two: Go! -Z
				//else ret = ( ( (GuyH::getNPC()->step) * 100.0 ).getZLong() );
				else 
				{
					double s2 = ( (GuyH::getNPC()->step).getZLong() );
					ret = long(s2*100);
					//ret = long( ( (GuyH::getNPC()->step) * 100.0 )) * 10000;
				}
				//else ret = long(GuyH::getNPC()->step * fix(100.0)) * 10000;
				
				//else 
				//{
					//old, buggy code replication, round THREE: Go! -Z
				//	double tmp = ( (GuyH::getNPC()->step) ) * 1000000.0;
				//	ret = (long)tmp;
				//}
			}
				
			break;
		
		case NPCGRAVITY:
			if(GuyH::loadNPC(ri->guyref, "npc->Gravity") != SH::_NoError)
				ret = -10000;
			else
				ret = ((GuyH::getNPC()->moveflags & FLAG_OBEYS_GRAV) ? 10000 : 0);
				
			break;
		
			
		case NPCID:
			if(GuyH::loadNPC(ri->guyref, "npc->ID") != SH::_NoError)
				ret = -10000;
			else
				ret = (GuyH::getNPC()->id & 0xFFF) * 10000;
				
			break;
		
		case NPCISCORE:
			if(GuyH::loadNPC(ri->guyref, "npc->isCore") != SH::_NoError)
				ret = -10000;
			else
				ret = ((GuyH::getNPC()->isCore) ? 10000 : 0);
				
			break;
		
		case NPCSCRIPTUID:
			if(GuyH::loadNPC(ri->guyref, "npc->ScriptUID") != SH::_NoError)
				ret = -10000;
			else
				ret = ((GuyH::getNPC()->getScriptUID())); //literal, not *10000
				
			break;
		
		case NPCPARENTUID:
			if(GuyH::loadNPC(ri->guyref, "npc->ParentUID") != SH::_NoError)
				ret = -10000;
			else
				ret = ((GuyH::getNPC()->parent_script_UID)); //literal, not *10000
				
			break;
		
		//case EWPNPARENTUID:
			//if(0!=(s=checkEWpn(ri->ewpn, "ScriptUID")))
			//	ret=(((weapon*)(s))->parent_script_UID); //literal, not *10000
				
			
		case NPCMFLAGS:
			if(GuyH::loadNPC(ri->guyref, "npc->MiscFlags") != SH::_NoError)
				ret = -10000;
			else
				ret = GuyH::getMFlags() * 10000;
				
			break;
			
		//Indexed (two checks)
		case NPCDEFENSED:
		{
			int a = ri->d[0] / 10000;
			
			if(GuyH::loadNPC(ri->guyref, "npc->Defense[]") != SH::_NoError ||
					BC::checkBounds(a, 0, (edefLAST255), "npc->Defense[]") != SH::_NoError)
				ret = -10000;
			else
				ret = GuyH::getNPC()->defense[a] * 10000;
		}
		break;
		
		case NPCHITBY:
		{
			int indx = ri->d[0] / 10000;

			if(GuyH::loadNPC(ri->guyref, "npc->HitBy[]") != SH::_NoError )
			{
				ret = -10000; break;
			}
			else
			{
				switch(indx)
				{
					//screen indixes
					case 0:
					case 1:
					case 2:
					case 3:
					case 8:
					case 9:
					case 10:
					case 11:
					case 12:
					case 13:
					case 14:
					case 15:
					{
						ret = GuyH::getNPC()->hitby[indx] * 10000; // * 10000; //do not multiply by 10000! UIDs are not *10000!
						break;
					}
					//UIDs
					case 4:
					case 5:
					case 6:
					case 7:
					{
						ret = GuyH::getNPC()->hitby[indx]; // * 10000; //do not multiply by 10000! UIDs are not *10000!
						break;
					}
					default: { Z_scripterrlog("Invalid index used for npc->HitBy[%d]. /n", indx); ret = -10000; break; }
				}
				break;
			}
		}
		
		//2.fuure compat.
		
		case NPCSCRDEFENSED:
		{
			int a = ri->d[0] / 10000;
			
			if(GuyH::loadNPC(ri->guyref, "npc->ScriptDefense") != SH::_NoError ||
					BC::checkBounds(a, 0, edefSCRIPTDEFS_MAX, "npc->ScriptDefense") != SH::_NoError)
				ret = -10000;
			else
				ret = GuyH::getNPC()->defense[a+edefSCRIPT01] * 10000;
		}
		break;
		
		
		case NPCMISCD:
		{
			int a = ri->d[0] / 10000;
			
			if(GuyH::loadNPC(ri->guyref, "npc->Misc") != SH::_NoError ||
					BC::checkMisc32(a, "npc->Misc") != SH::_NoError)
				ret = -10000;
			else
				ret = GuyH::getNPC()->miscellaneous[a];
		}
		break;
		case NPCINITD:
		{
			int a = ri->d[0] / 10000;
			
			if(GuyH::loadNPC(ri->guyref, "npc->InitD[]") != SH::_NoError )
				ret = -10000;
			else
			{
				//enemy *e = (enemy*)guys.spr(ri->guyref);
				ret = (int)GuyH::getNPC()->initD[a];
			}
		}
		break;
		
		case NPCSCRIPT:
		{
			int a = ri->d[0] / 10000;
			
			if(GuyH::loadNPC(ri->guyref, "npc->Script") != SH::_NoError )
				ret = -10000;
			else
			{
				//enemy *e = (enemy*)guys.spr(ri->guyref);
				ret = (int)GuyH::getNPC()->script * 10000;
			}
		}
		break;
		
		case NPCDD: //Fized the size of this array. There are 15 total attribs, [0] to [14], not [0] to [9]. -Z
		{
			int a = ri->d[0] / 10000;
			
			if(GuyH::loadNPC(ri->guyref, "npc->Attributes") != SH::_NoError ||
					BC::checkBounds(a, 0, ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ? 31 : 15 ), "npc->Attributes") != SH::_NoError)
				ret = -10000;
			else
				ret = GuyH::getNPCDMisc(a) * 10000;
		}
		break;
		
			case NPCINVINC:
			if(GuyH::loadNPC(ri->guyref, "npc->InvFrames") != SH::_NoError)
				ret = -10000;
			else
				ret = (int)GuyH::getNPC()->hclk * 10000;
				
			break;
		
		case NPCHASITEM:
			if(GuyH::loadNPC(ri->guyref, "npc->HasItem") != SH::_NoError)
				ret = 0;
			else
				ret = GuyH::getNPC()->itemguy?10000:0;
				
			break;
		
		case NPCRINGLEAD:
			if(GuyH::loadNPC(ri->guyref, "npc->Ringleader") != SH::_NoError)
				ret = 0;
			else
				ret = GuyH::getNPC()->leader?10000:0;
				
			break;
		
		case NPCSUPERMAN:
			if(GuyH::loadNPC(ri->guyref, "npc->Invincible") != SH::_NoError)
				ret = -10000;
			else
				ret = (int)GuyH::getNPC()->superman * 10000;
				
			break;
		
		case NPCSHIELD:
		{
			int indx = ri->d[0];
			if(GuyH::loadNPC(ri->guyref, "npc->Shield[]") == SH::_NoError)
			{
				switch(indx)
				{
					case 0:
					{
						ret = ((GuyH::getNPC()->flags&inv_front) ? 10000 : 0);
						break;
					}
					case 1:
					{
						ret = ((GuyH::getNPC()->flags&inv_left) ? 10000 : 0);
						break;
					}
					case 2:
					{
						ret = ((GuyH::getNPC()->flags&inv_right) ? 10000 : 0);
						break;
					}
					case 3:
					{
						ret = ((GuyH::getNPC()->flags&inv_back) ? 10000 : 0);
						break;
					}
					case 4: //shield can be broken
					{
						ret = ((GuyH::getNPC()->flags&guy_bkshield) ? 10000 : 0);
						break;
					}
					default:
					{
						Z_scripterrlog("Invalid Array Index passed to npc->Shield[]: %d\n", indx); 
						break;
					}
				}
			}
			else
			{
				ret = -10000;
				break;
			}
		}
		
		case NPCFROZENTILE:
			GET_NPC_VAR_INT(frozentile, "npc->FrozenTile"); break;
		
		case NPCFROZENCSET:
			GET_NPC_VAR_INT(frozencset, "npc->FrozenCSet"); break;
		
		case NPCFROZEN:
			GET_NPC_VAR_INT(frozenclock, "npc->Frozen"); break;
		
		
		case NPCBEHAVIOUR: 
		{
			if(GuyH::loadNPC(ri->guyref, "npc->Behaviour[]") != SH::_NoError) 
			{
				ret = -10000;
				break;
			}
			
			int index = vbound(ri->d[0]/10000,0,4);
			switch(index)
			{
				case 0:
					ret=(GuyH::getNPC()->editorflags & ENEMY_FLAG1)?10000:0; break;
				case 1:
					ret=(GuyH::getNPC()->editorflags & ENEMY_FLAG2)?10000:0; break;
				case 2:
					ret=(GuyH::getNPC()->editorflags & ENEMY_FLAG3)?10000:0; break;
				case 3:
					ret=(GuyH::getNPC()->editorflags & ENEMY_FLAG4)?10000:0; break;
				case 4:
					ret=(GuyH::getNPC()->editorflags & ENEMY_FLAG5)?10000:0; break;
				case 5:
					ret=(GuyH::getNPC()->editorflags & ENEMY_FLAG6)?10000:0; break;
				case 6:
					ret=(GuyH::getNPC()->editorflags & ENEMY_FLAG7)?10000:0; break;
				case 7:
					ret=(GuyH::getNPC()->editorflags & ENEMY_FLAG8)?10000:0; break;
				case 8:
					ret=(GuyH::getNPC()->editorflags & ENEMY_FLAG9)?10000:0; break;
				case 9:
					ret=(GuyH::getNPC()->editorflags & ENEMY_FLAG10)?10000:0; break;
				case 10:
					ret=(GuyH::getNPC()->editorflags & ENEMY_FLAG11)?10000:0; break;
				case 11:
					ret=(GuyH::getNPC()->editorflags & ENEMY_FLAG12)?10000:0; break;
				case 12:
					ret=(GuyH::getNPC()->editorflags & ENEMY_FLAG13)?10000:0; break;
				case 13:
					ret=(GuyH::getNPC()->editorflags & ENEMY_FLAG14)?10000:0; break;
				case 14:
					ret=(GuyH::getNPC()->editorflags & ENEMY_FLAG15)?10000:0; break;
				case 15:
					ret=(GuyH::getNPC()->editorflags & ENEMY_FLAG16)?10000:0; break;
				
				default: 
					ret = 0; break;
			}
				
			break;
		}
		
		case NPCFALLCLK:
			if(GuyH::loadNPC(ri->guyref, "npc->Falling") == SH::_NoError)
			{
				ret = GuyH::getNPC()->fallclk * 10000;
			}
			break;
		
		case NPCFALLCMB:
			if(GuyH::loadNPC(ri->guyref, "npc->FallCombo") == SH::_NoError)
			{
				ret = GuyH::getNPC()->fallCombo * 10000;
			}
			break;
		
		case NPCMOVEFLAGS:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->MoveFlags[]") == SH::_NoError)
			{
				int indx = ri->d[0]/10000;
				if(BC::checkBounds(indx, 0, 2, "npc->MoveFlags[]") != SH::_NoError)
					ret = 0; //false
				else
				{
					//All bits, in order, of a single byte; just use bitwise
					ret = (GuyH::getNPC()->moveflags & (1<<indx)) ? 10000 : 0;
				}
			}
			break;
		}
		
		
		
		///----------------------------------------------------------------------------------------------------//
		//LWeapon Variables
		case LWPNSPECIAL:
			if(0!=(s=checkLWpn(ri->lwpn,"Special")))
				ret=((int)((weapon*)(s))->specialinfo)*10000;
			
				
			break;
			
		case LWPNSCALE:
			if ( get_bit(quest_rules, qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"lweapon->Scale");
				ret = -1; break;
			}
			if(0!=(s=checkLWpn(ri->lwpn,"Scale")))
				ret=((int)((weapon*)(s))->scale)*100.0;
				
			break;
		
		case LWPNX:
			if(0!=(s=checkLWpn(ri->lwpn,"X")))
			{
				if ( get_bit(quest_rules,qr_SPRITEXY_IS_FLOAT) )
				{
					ret=(((weapon*)(s))->x).getZLong();  
				}
				else 
					ret=((int)((weapon*)(s))->x)*10000;
			}
				
			break;
		
		case SPRITEMAXLWPN:
		{
			//No bounds check, as this is a universal function and works from NULL pointers!
			ret = Lwpns.getMax() * 10000;
			break;
		}
	
		case LWPNY:
			if(0!=(s=checkLWpn(ri->lwpn,"Y")))
			{
				if ( get_bit(quest_rules,qr_SPRITEXY_IS_FLOAT) )
				{
					ret=(((weapon*)(s))->y).getZLong();  
				}
				else 
					ret=((int)((weapon*)(s))->y)*10000;
			}
			break;
			
		case LWPNZ:
			if(0!=(s=checkLWpn(ri->lwpn,"Z")))
			{
				if ( get_bit(quest_rules,qr_SPRITEXY_IS_FLOAT) )
				{
					ret=(((weapon*)(s))->z).getZLong();  
				}
				else 
					ret=((int)((weapon*)(s))->z)*10000;
			}
				
			break;
			
		case LWPNJUMP:
			if(0!=(s=checkLWpn(ri->lwpn,"Jump")))
				ret = ((weapon*)(s))->fall.getZLong() / -100;
				
			break;
			
		case LWPNDIR:
			if(0!=(s=checkLWpn(ri->lwpn,"Dir")))
				ret=((weapon*)(s))->dir*10000;
				
			break;
		 
		case LWPNGRAVITY:
			if(0!=(s=checkLWpn(ri->lwpn,"Gravity")))
				ret= (((weapon*)(s))->moveflags & FLAG_OBEYS_GRAV) ? 10000 : 0;
				
			break;
			
		case LWPNSTEP:
			if(0!=(s=checkLWpn(ri->lwpn,"Step")))
			{
				if ( get_bit(quest_rules,qr_STEP_IS_FLOAT) )
				{
					ret=((weapon*)s)->step.getZLong() * 100;
				}
				//old, buggy code replication, round two: Go! -Z
				//else ret = ( ( ( ((weapon*)s)->step ) * 100.0 ).getZLong() );
				
				//else 
				//{
					//old, buggy code replication, round THREE: Go! -Z
				//	double tmp = ( ((weapon*)s)->step.getFloat() ) * 1000000.0;
				//	ret = (int)tmp;
				//}
				
				//old, buggy code replication, round FOUR: Go! -Z
				else ret = (int)((float)((weapon*)s)->step * 1000000.0);
			}
			break;
			
		case LWPNANGLE:
			if(0!=(s=checkLWpn(ri->lwpn,"Angle")))
				ret=(int)(((weapon*)(s))->angle*10000);
				
			break;
			
		case LWPNANGULAR:
			if(0!=(s=checkLWpn(ri->lwpn,"Angular")))
				ret=((weapon*)(s))->angular*10000;
				
			break;
			
		case LWPNBEHIND:
			if(0!=(s=checkLWpn(ri->lwpn,"Behind")))
				ret=((weapon*)(s))->behind*10000;
				
			break;
			
		case LWPNDRAWTYPE:
			if(0!=(s=checkLWpn(ri->lwpn,"DrawStyle")))
				ret=((weapon*)(s))->drawstyle*10000;
				
			break;
			
		case LWPNPOWER:
			if(0!=(s=checkLWpn(ri->lwpn,"Damage")))
				ret=((weapon*)(s))->power*10000;
				
			break;
		/*
		case LWPNRANGE:
			if(0!=(s=checkLWpn(ri->lwpn,"Range")))
				ret=((weapon*)(s))->scriptrange*10000;
				
			break;
		*/        
		case LWPNDEAD:
			if(0!=(s=checkLWpn(ri->lwpn,"DeadState")))
				ret=((weapon*)(s))->dead*10000;
				
			break;
			
		case LWPNID:
			if(0!=(s=checkLWpn(ri->lwpn,"ID")))
				ret=((weapon*)(s))->id*10000;
				
			break;
			
		case LWPNTILE:
			if(0!=(s=checkLWpn(ri->lwpn,"Tile")))
				ret=((weapon*)(s))->tile*10000;
				
			break;
		
		case LWPNSCRIPTTILE:
			if(0!=(s=checkLWpn(ri->lwpn,"ScriptTile")))
				ret=((weapon*)(s))->scripttile*10000;
				
			break;
		
		case LWPNSCRIPTFLIP:
			if(0!=(s=checkLWpn(ri->lwpn,"ScriptFlip")))
				ret=((weapon*)(s))->scriptflip*10000;
				
			break;
			
		case LWPNCSET:
			if(0!=(s=checkLWpn(ri->lwpn,"CSet")))
				ret=((weapon*)(s))->cs*10000;
				
			break;
			
		case LWPNFLASHCSET:
			if(0!=(s=checkLWpn(ri->lwpn,"FlashCSet")))
				ret=(((weapon*)(s))->o_cset>>4)*10000;
				
			break;
			
		case LWPNFRAMES:
			if(0!=(s=checkLWpn(ri->lwpn,"NumFrames")))
				ret=((weapon*)(s))->frames*10000;
				
			break;
			
		case LWPNFRAME:
			if(0!=(s=checkLWpn(ri->lwpn,"Frame")))
				ret=((weapon*)(s))->aframe*10000;
				
			break;
			
		case LWPNASPEED:
			if(0!=(s=checkLWpn(ri->lwpn,"ASpeed")))
				ret=((weapon*)(s))->o_speed*10000;
				
			break;
			
		case LWPNFLASH:
			if(0!=(s=checkLWpn(ri->lwpn,"Flash")))
				ret=((weapon*)(s))->flash*10000;
				
			break;
			
		case LWPNFLIP:
			if(0!=(s=checkLWpn(ri->lwpn,"Flip")))
				ret=((weapon*)(s))->flip*10000;
				
			break;
			
		case LWPNCOUNT:
			ret=Lwpns.Count()*10000;
			break;
			
		case LWPNEXTEND:
			if(0!=(s=checkLWpn(ri->lwpn,"Extend")))
				ret=((weapon*)(s))->extend*10000;
				
			break;
			
		case LWPNOTILE:
			if(0!=(s=checkLWpn(ri->lwpn,"OriginalTile")))
				ret=((weapon*)(s))->o_tile*10000;
				
			break;
			
		case LWPNOCSET:
			if(0!=(s=checkLWpn(ri->lwpn,"OriginalCSet")))
				ret=(((weapon*)(s))->o_cset&15)*10000;
				
			break;
			
		case LWPNHXOFS:
			if(0!=(s=checkLWpn(ri->lwpn,"HitXOffset")))
				ret=(((weapon*)(s))->hxofs)*10000;
				
			break;
			
		case LWPNHYOFS:
			if(0!=(s=checkLWpn(ri->lwpn,"HitYOffset")))
				ret=(((weapon*)(s))->hyofs)*10000;
				
			break;
			
		case LWPNXOFS:
			if(0!=(s=checkLWpn(ri->lwpn,"DrawXOffset")))
				ret=((int)(((weapon*)(s))->xofs))*10000;
				
			break;
			
		case LWPNYOFS:
			if(0!=(s=checkLWpn(ri->lwpn,"DrawYOffset")))
				ret=((int)(((weapon*)(s))->yofs-playing_field_offset))*10000;
				
			break;
			
		case LWPNZOFS:
			if(0!=(s=checkLWpn(ri->lwpn,"DrawZOffset")))
				ret=((int)(((weapon*)(s))->zofs))*10000;
				
			break;
			
		case LWPNHXSZ:
			if(0!=(s=checkLWpn(ri->lwpn,"HitWidth")))
				ret=(((weapon*)(s))->hxsz)*10000;
				
			break;
			
		case LWPNHYSZ:
			if(0!=(s=checkLWpn(ri->lwpn,"HitHeight")))
				ret=(((weapon*)(s))->hysz)*10000;
				
			break;
			
		case LWPNHZSZ:
			if(0!=(s=checkLWpn(ri->lwpn,"HitZHeight")))
				ret=(((weapon*)(s))->hzsz)*10000;
				
			break;
			
		case LWPNTXSZ:
			if(0!=(s=checkLWpn(ri->lwpn,"TileWidth")))
				ret=(((weapon*)(s))->txsz)*10000;
				
			break;
			
		case LWPNTYSZ:
			if(0!=(s=checkLWpn(ri->lwpn,"TileHeight")))
				ret=(((weapon*)(s))->tysz)*10000;
				
			break;
			
		case LWPNMISCD:
			if(0!=(s=checkLWpn(ri->lwpn,"Misc")))
			{
				int a = vbound(ri->d[0]/10000,0,31);
				ret=(((weapon*)(s))->miscellaneous[a]);
			}
			
			break;
			
		case LWPNCOLLDET:
			if(0!=(s=checkLWpn(ri->lwpn,"CollDetection")))
				ret=(((weapon*)(s))->scriptcoldet)*10000;
				
			break;
		
		case LWPNENGINEANIMATE:
			if(0!=(s=checkLWpn(ri->lwpn,"Animation")))
				ret=(((weapon*)(s))->do_animation)*10000;
				
			break;
		
		case LWPNPARENT:
			if(0!=(s=checkLWpn(ri->lwpn,"Parent")))
				ret=(((weapon*)(s))->parentitem)*10000;
				
			break;

		case LWPNLEVEL:
			if(0!=(s=checkLWpn(ri->lwpn,"Level")))
				ret=(((weapon*)(s))->type)*10000;
				
			break;
		
		case LWPNSCRIPT:
			if(0!=(s=checkLWpn(ri->lwpn,"Script")))
				ret=(((weapon*)(s))->weaponscript)*10000;
				
			break;
		
		case LWPNUSEWEAPON:
			if(0!=(s=checkLWpn(ri->lwpn,"Weapon")))
				ret=(((weapon*)(s))->useweapon)*10000;
				
			break;
		
		case LWPNUSEDEFENCE:
			if(0!=(s=checkLWpn(ri->lwpn,"Defense")))
				ret=(((weapon*)(s))->usedefence)*10000;
				
			break;
		
		case LWPNINITD:
		{
			int a = vbound((ri->d[0] / 10000),0,7);
			if(0!=(s=checkLWpn(ri->lwpn,"InitD[]")))
			{
				ret=(((weapon*)(s))->weap_initd[a]);
			}
			break;
		}
		
		case LWEAPONSCRIPTUID:
			if(0!=(s=checkLWpn(ri->lwpn,"ScriptUID")))
				ret=(((weapon*)(s))->script_UID); //literal, not *10000
				
			break;

		case LWPNROTATION:
			if ( get_bit(quest_rules, qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"lweapon->Rotation");
				ret = -1; break;
			}
			if(0!=(s=checkLWpn(ri->lwpn,"Rotation")))
				ret=((weapon*)(s))->rotation*10000;
				
			break;
		
		case LWPNFALLCLK:
			if(0!=(s=checkLWpn(ri->lwpn,"Falling")))
			{
				ret = ((weapon*)(s))->fallclk * 10000;
			}
			break;
		
		case LWPNFALLCMB:
			if(0!=(s=checkLWpn(ri->lwpn,"FallCombo")))
			{
				ret = ((weapon*)(s))->fallCombo * 10000;
			}
			break;
		
		case LWPNMOVEFLAGS:
		{
			if(0!=(s=checkLWpn(ri->lwpn,"MoveFlags[]")))
			{
				int indx = ri->d[0]/10000;
				if(BC::checkBounds(indx, 0, 1, "lweapon->MoveFlags[]") != SH::_NoError)
					ret = 0; //false
				else
				{
					//All bits, in order, of a single byte; just use bitwise
					ret = (((weapon*)(s))->moveflags & (1<<indx)) ? 10000 : 0;
				}
			}
			break;
		}

			
		///----------------------------------------------------------------------------------------------------//
		//EWeapon Variables
		case EWPNSCALE:
			if ( get_bit(quest_rules, qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"eweapon->Scale");
				ret = -1; break;
			}
			if(0!=(s=checkEWpn(ri->ewpn, "Scale")))
				ret=((int)((weapon*)(s))->scale)*100.0;
				
			break;

		case EWPNX:
			if(0!=(s=checkEWpn(ri->ewpn, "X")))
			{
				if ( get_bit(quest_rules,qr_SPRITEXY_IS_FLOAT) )
				{
					ret=(((weapon*)(s))->x).getZLong();
				}
				else 
					ret=((int)((weapon*)(s))->x)*10000;
			}
			break;
			
		case SPRITEMAXEWPN:
		{
			//No bounds check, as this is a universal function and works from NULL pointers!
			ret = Ewpns.getMax() * 10000;
			break;
		}
	
		case EWPNY:
			if(0!=(s=checkEWpn(ri->ewpn, "Y")))
			{
				if ( get_bit(quest_rules,qr_SPRITEXY_IS_FLOAT) )
				{
					ret=(((weapon*)(s))->y).getZLong();
				}
				else 
					 ret=((int)((weapon*)(s))->y)*10000;
			}
			break;
			
		case EWPNZ:
			if(0!=(s=checkEWpn(ri->ewpn, "Z")))
			{
				if ( get_bit(quest_rules,qr_SPRITEXY_IS_FLOAT) )
				{
					ret=(((weapon*)(s))->z).getZLong();
				}
				else 
					ret=((int)((weapon*)(s))->z)*10000;
			}
			break;
			
		case EWPNJUMP:
			if(0!=(s=checkEWpn(ri->ewpn, "Jump")))
				ret = ((weapon*)(s))->fall.getZLong() / -100;
				
			break;
			
		case EWPNDIR:
			if(0!=(s=checkEWpn(ri->ewpn, "Dir")))
				ret=((weapon*)(s))->dir*10000;
				
			break;
			
		case EWPNLEVEL:
			if(0!=(s=checkEWpn(ri->ewpn, "Level")))
				ret=((weapon*)(s))->type*10000;
				
			break;
			
		case EWPNGRAVITY:
			if(0!=(s=checkEWpn(ri->ewpn, "Gravity")))
				ret=((((weapon*)(s))->moveflags & FLAG_OBEYS_GRAV) ? 10000 : 0);
				
			break;
			
		case EWPNSTEP:
			if(0!=(s=checkEWpn(ri->ewpn, "Step")))
			{
				if ( get_bit(quest_rules,qr_STEP_IS_FLOAT) )
				{
					ret=((weapon*)s)->step.getZLong() * 100;
				}
				//old, buggy code replication, round two: Go! -Z
				//else ret = ( ( ( ((weapon*)s)->step ) * 100.0 ).getZLong() );
				//old, buggy code replication, round FOUR: Go! -Z
				else ret = (int)((float)((weapon*)s)->step * 1000000.0);
			}
			//else 
			//{
				//old, buggy code replication, round THREE: Go! -Z
			//	double tmp = ( ((weapon*)s)->step.getFloat() ) * 1000000.0;
			//	ret = long(tmp);
			//}
			break;
			
		case EWPNANGLE:
			if(0!=(s=checkEWpn(ri->ewpn,"Angle")))
				ret=(int)(((weapon*)(s))->angle*10000);
				
			break;
			
		case EWPNANGULAR:
			if(0!=(s=checkEWpn(ri->ewpn,"Angular")))
				ret=((weapon*)(s))->angular*10000;
				
			break;
			
		case EWPNBEHIND:
			if(0!=(s=checkEWpn(ri->ewpn,"Behind")))
				ret=((weapon*)(s))->behind*10000;
				
			break;
			
		case EWPNDRAWTYPE:
			if(0!=(s=checkEWpn(ri->ewpn,"DrawStyle")))
				ret=((weapon*)(s))->drawstyle*10000;
				
			break;
			
		case EWPNPOWER:
			if(0!=(s=checkEWpn(ri->ewpn,"Damage")))
				ret=((weapon*)(s))->power*10000;
				
			break;
			
		case EWPNDEAD:
			if(0!=(s=checkEWpn(ri->ewpn,"DeadState")))
				ret=((weapon*)(s))->dead*10000;
				
			break;
			
		case EWPNID:
			if(0!=(s=checkEWpn(ri->ewpn,"ID")))
				ret=((weapon*)(s))->id*10000;
				
			break;
			
		case EWPNTILE:
			if(0!=(s=checkEWpn(ri->ewpn,"Tile")))
				ret=((weapon*)(s))->tile*10000;
				
			break;
		
		case EWPNSCRIPTTILE:
			if(0!=(s=checkEWpn(ri->ewpn,"ScriptTile")))
				ret=((weapon*)(s))->scripttile*10000;
				
			break;
		
		case EWPNSCRIPTFLIP:
			if(0!=(s=checkEWpn(ri->ewpn,"ScriptFlip")))
				ret=((weapon*)(s))->scriptflip*10000;
				
			break;
			
		case EWPNCSET:
			if(0!=(s=checkEWpn(ri->ewpn,"CSet")))
				ret=((weapon*)(s))->cs*10000;
				
			break;
			
		case EWPNFLASHCSET:
			if(0!=(s=checkEWpn(ri->ewpn,"FlashCSet")))
				ret=(((weapon*)(s))->o_cset>>4)*10000;
				
			break;
			
		case EWPNFRAMES:
			if(0!=(s=checkEWpn(ri->ewpn,"NumFrames")))
				ret=((weapon*)(s))->frames*10000;
				
			break;
			
		case EWPNFRAME:
			if(0!=(s=checkEWpn(ri->ewpn,"Frame")))
				ret=((weapon*)(s))->aframe*10000;
				
			break;
			
		case EWPNASPEED:
			if(0!=(s=checkEWpn(ri->ewpn,"ASpeed")))
				ret=((weapon*)(s))->o_speed*10000;
				
			break;
			
		case EWPNFLASH:
			if(0!=(s=checkEWpn(ri->ewpn,"Flash")))
				ret=((weapon*)(s))->flash*10000;
				
			break;
			
		case EWPNFLIP:
			if(0!=(s=checkEWpn(ri->ewpn,"Flip")))
				ret=((weapon*)(s))->flip*10000;
				
			break;

		case EWPNROTATION:
			if ( get_bit(quest_rules, qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"eweapon->Rotation");
				break;
			}
			if(0!=(s=checkEWpn(ri->ewpn,"Rotation")))
				ret=((weapon*)(s))->rotation*10000;
				
			break;

		case EWPNCOUNT:
			ret=Ewpns.Count()*10000;
			break;
			
		case EWPNEXTEND:
			if(0!=(s=checkEWpn(ri->ewpn,"Extend")))
				ret=((weapon*)(s))->extend*10000;
				
			break;
			
		case EWPNOTILE:
			if(0!=(s=checkEWpn(ri->ewpn,"OriginalTile")))
				ret=((weapon*)(s))->o_tile*10000;
				
			break;
			
		case EWPNOCSET:
			if(0!=(s=checkEWpn(ri->ewpn,"OriginalCSet")))
				ret=(((weapon*)(s))->o_cset&15)*10000;
				
			break;
			
		case EWPNHXOFS:
			if(0!=(s=checkEWpn(ri->ewpn,"HitXOffset")))
				ret=(((weapon*)(s))->hxofs)*10000;
				
			break;
			
		case EWPNHYOFS:
			if(0!=(s=checkEWpn(ri->ewpn,"HitYOffset")))
				ret=(((weapon*)(s))->hyofs)*10000;
				
			break;
			
		case EWPNXOFS:
			if(0!=(s=checkEWpn(ri->ewpn,"DrawXOffset")))
				ret=((int)(((weapon*)(s))->xofs))*10000;
				
			break;
			
		case EWPNYOFS:
			if(0!=(s=checkEWpn(ri->ewpn,"DrawYOffset")))
				ret=((int)(((weapon*)(s))->yofs-playing_field_offset))*10000;
				
			break;
			
		case EWPNZOFS:
			if(0!=(s=checkEWpn(ri->ewpn,"DrawZOffset")))
				ret=((int)(((weapon*)(s))->zofs))*10000;
				
			break;
			
		case EWPNHXSZ:
			if(0!=(s=checkEWpn(ri->ewpn,"HitWidth")))
				ret=(((weapon*)(s))->hxsz)*10000;
				
			break;
			
		case EWPNHYSZ:
			if(0!=(s=checkEWpn(ri->ewpn,"HitHeight")))
				ret=(((weapon*)(s))->hysz)*10000;
				
			break;
			
		case EWPNHZSZ:
			if(0!=(s=checkEWpn(ri->ewpn,"HitZHeight")))
				ret=(((weapon*)(s))->hzsz)*10000;
				
			break;
			
		case EWPNTXSZ:
			if(0!=(s=checkEWpn(ri->ewpn,"TileWidth")))
				ret=(((weapon*)(s))->txsz)*10000;
				
			break;
			
		case EWPNTYSZ:
			if(0!=(s=checkEWpn(ri->ewpn,"TileHeight")))
				ret=(((weapon*)(s))->tysz)*10000;
				
			break;
			
		case EWPNMISCD:
			if(0!=(s=checkEWpn(ri->ewpn,"Misc")))
			{
				int a = vbound(ri->d[0]/10000,0,31);
				ret=(((weapon*)(s))->miscellaneous[a]);
			}
			
			break;
			
		case EWPNCOLLDET:
			if(0!=(s=checkEWpn(ri->ewpn,"CollDetection")))
				ret=(((weapon*)(s))->scriptcoldet)*10000;
				
			break;
		
		case EWPNENGINEANIMATE:
			if(0!=(s=checkEWpn(ri->ewpn,"Animation")))
				ret=(((weapon*)(s))->do_animation)*10000;
				
			break;
		
		case EWPNPARENT:
			if(0!=(s=checkEWpn(ri->ewpn, "Parent")))
				ret= ((get_bit(quest_rules,qr_OLDEWPNPARENT)) ? (((weapon*)(s))->parentid)*10000 : (((weapon*)(s))->parentid));
		
			break;
		
		case EWEAPONSCRIPTUID:
			if(0!=(s=checkEWpn(ri->ewpn, "ScriptUID")))
				ret=(((weapon*)(s))->script_UID); //literal, not *10000
				
			break;
		
		case EWPNPARENTUID:
			if(0!=(s=checkEWpn(ri->ewpn, "ParentUID")))
				ret=(((weapon*)(s))->parent_script_UID); //literal, not *10000
				
			break;
		
		case EWPNSCRIPT:
			if(0!=(s=checkEWpn(ri->ewpn,"Script")))
				ret=(((weapon*)(s))->weaponscript)*10000;
				
			break;
		
		case EWPNINITD:
		{
			int a = vbound((ri->d[0] / 10000),0,7);
			if(0!=(s=checkEWpn(ri->ewpn,"InitD[]")))
			{
				ret=(((weapon*)(s))->weap_initd[a]);
			}
			break;
		}
		
		case EWPNFALLCLK:
			if(0!=(s=checkEWpn(ri->ewpn,"Falling")))
			{
				ret = ((weapon*)(s))->fallclk * 10000;
			}
			break;
		
		case EWPNFALLCMB:
			if(0!=(s=checkEWpn(ri->ewpn,"FallCombo")))
			{
				ret = ((weapon*)(s))->fallCombo * 10000;
			}
			break;
		
		case EWPNMOVEFLAGS:
		{
			if(0!=(s=checkEWpn(ri->ewpn,"MoveFlags[]")))
			{
				int indx = ri->d[0]/10000;
				if(BC::checkBounds(indx, 0, 1, "eweapon->MoveFlags[]") != SH::_NoError)
					ret = 0; //false
				else
				{
					//All bits, in order, of a single byte; just use bitwise
					ret = (((weapon*)(s))->moveflags & (1<<indx)) ? 10000 : 0;
				}
			}
			break;
		}
		
		/*
		case LWEAPONSCRIPTUID:
			if(0!=(s=checkLWpn(ri->lwpn,"ScriptUID")))
				ret=(((weapon*)(s))->getScriptUID()); //literal, not *10000
				
			break;
		case EWEAPONSCRIPTUID:
			if(0!=(s=checkLWpn(ri->ewpn,"ScriptUID")))
				ret=(((weapon*)(s))->getScriptUID()); //literal, not *10000
				
			break;
		*/
			
		///----------------------------------------------------------------------------------------------------//
		//Game Info
		
		
		case GAMESUBSCHEIGHT:
		{
			ret = passive_subscreen_height*10000;    
		}
		break;
		
		case GAMEPLAYFIELDOFS:
			ret = playing_field_offset*10000;
			break;
		
		case PASSSUBOFS:
			ret = passive_subscreen_offset * 10000;
			break;
		
		case GETPIXEL:
			ret=FFCore.do_getpixel();
			break;

		
		case ZELDAVERSION:
			ret = ZC_VERSION; //Do *not* multiply by 10,000!
			break;
		case ZELDABUILD:
			ret = (int)VERSION_BUILD*10000;
			break;
		
		case ZSCRIPTVERSION: 
		{
			ret = (FFCore.quest_format[vLastCompile]) * 10000;
		}
		
		case ZELDABETA:
		{
			if ( (FFCore.quest_format[vLastCompile]) < 13 ) //I don't remember why I did this. 
				//It used to return IS_BETA*10000 here
			{
				int statusvers = 0;
				if ( V_ZC_ALPHA ) statusvers = V_ZC_ALPHA;
				else if ( V_ZC_BETA ) statusvers = V_ZC_BETA;
				else if ( V_ZC_GAMMA ) statusvers = V_ZC_GAMMA;
				else if ( V_ZC_RELEASE ) statusvers = V_ZC_RELEASE;
				ret = statusvers*10000;
			}
			else 
			{
				//and it used to return (int)IS_BETA*10000 here. -Z
				int statusvers = 0;
				if ( V_ZC_ALPHA ) statusvers = V_ZC_ALPHA;
				else if ( V_ZC_BETA ) statusvers = V_ZC_BETA;
				else if ( V_ZC_GAMMA ) statusvers = V_ZC_GAMMA;
				else if ( V_ZC_RELEASE ) statusvers = V_ZC_RELEASE;
				ret = (int)statusvers*10000;
			}
			break;
		}
		case GAMEDEATHS:
			ret=game->get_deaths()*10000;
			break;
			
		case GAMECHEAT:
			ret=game->get_cheat()*10000;
			break;
			
		case GAMETIME:
			ret=game->get_time();
			break;// Can't multiply by 10000 or the maximum result is too big
			
		case GAMETIMEVALID:
			ret=game->get_timevalid()?10000:0;
			break;
			
		case GAMEHASPLAYED:
			ret=game->get_hasplayed()?10000:0;
			break;
		
		case TYPINGMODE:
			ret=FFCore.kb_typing_mode?10000:0;
			break;
		
		case SKIPCREDITS:
			ret=FFCore.skip_ending_credits?10000:0;
			break;
		
		case SKIPF6:
			ret=get_bit(quest_rules,qr_NOCONTINUE)?10000:0;
			break;
			
		case GAMESTANDALONE:
			ret=standalone_mode?10000:0;
			break;
			
		case GAMEGUYCOUNT:
		{
			int mi = (currmap*MAPSCRSNORMAL)+(ri->d[0]/10000);
			ret=game->guys[mi]*10000;
		}
		break;
		
		case GAMECONTSCR:
			ret=game->get_continue_scrn()*10000;
			break;
			
		case GAMECONTDMAP:
			ret=game->get_continue_dmap()*10000;
			break;
			
		case GAMEENTRSCR:
			ret=lastentrance*10000;
			break;
			
		case GAMEENTRDMAP:
			ret=lastentrance_dmap*10000;
			break;
			
		case GAMECOUNTERD:
			ret=game->get_counter((ri->d[0])/10000)*10000;
			break;
			
		case GAMEMCOUNTERD:
			ret=game->get_maxcounter((ri->d[0])/10000)*10000;
			break;
			
		case GAMEDCOUNTERD:
			ret=game->get_dcounter((ri->d[0])/10000)*10000;
			break;
			
		case GAMEGENERICD:
			ret=game->get_generic((ri->d[0])/10000)*10000;
			break;
		
		case GAMEMISC:
		{
			int indx = ri->d[0]/10000;
			if ( indx < 0 || indx > 31 )
			{
				ret = -10000;
				Z_scripterrlog("Invalud index used to access Game->Misc: %d\n", indx);
			}
			else
			{
				ret = QMisc.questmisc[indx]*((get_bit(quest_rules,qr_OLDQUESTMISC)) ? 10000 : 1);
			}
			break;
		}
			
		case GAMEITEMSD:
			ret=(game->item[(ri->d[0])/10000] ? 10000 : 0);
			break;
		case DISABLEDITEM:
			ret = (game->items_off[(ri->d[0])/10000] ? 10000 : 0);
			break;
		case GAMESUSPEND:
		{
			int inx = (ri->d[0])/10000;
			if ( (unsigned) inx > (susptLAST-1) )
			{
				Z_scripterrlog("Invalid array index [%d] passed to Gme->Suspend[]\n");
			}
			ret = (( FFCore.system_suspend[inx] ) ? 10000 : 0);
			break;
		}
		case GAMELITEMSD:
			ret=game->lvlitems[(ri->d[0])/10000]*10000;
			break;
			
		case GAMELKEYSD:
			ret=game->lvlkeys[(ri->d[0])/10000]*10000;
			break;
			
		case GAMEGRAVITY:
		{
			int indx = ri->d[0]/10000;
			if(indx < 0 || indx > 2)
			{
				ret = -10000;
				Z_scripterrlog("Invalid index used to access Game->Gravity[]: %d\n", indx);
			}
			else
			{
				switch(indx)
				{
					case 0: //Gravity Strength
						ret = zinit.gravity * 100;
						break;
					case 1: //Terminal Velocity
						ret = zinit.terminalv * 100;
						break;
					case 2: //Sprite Layer Threshold
						ret = zinit.jump_link_layer_threshold * 10000;
						break;
				}
			}
			break;
		}
		
		case GAMESCROLLING:
		{
			int indx = ri->d[0]/10000;
			if(indx < 0 || indx >= SZ_SCROLLDATA)
			{
				Z_scripterrlog("Invalid index used to access Game->Scrolling[]: %d\n", indx);
			}
			else
			{
				ret = FFCore.ScrollingData[indx] * 10000L;
			}
			break;
		}
		
		
		case SCREENSTATED:
		{
			int mi =(currmap*MAPSCRSNORMAL)+currscr;
			ret=((game->maps[mi]>>((ri->d[0]/10000)))&1)?10000:0;
		}
		break;
		
		case SCREENSTATEDD:
		{
			// Gah! >:(  Screen state is stored in game->maps, which uses 128 screens per map,
			// but the compiler multiplies the map number by 136, so it has to be corrected here.
			// Yeah, the compiler could be fixed, but that wouldn't cover existing quests...
			int mi = ri->d[0] / 10000;
			mi -= 8*((ri->d[0] / 10000) / MAPSCRS);
			
			if(BC::checkMapID(mi>>7, "Game->GetScreenState") == SH::_NoError)
				ret=(game->maps[mi] >> (ri->d[1] / 10000) & 1) ? 10000 : 0;
			else
				ret=0;
				
			break;
		}
		
		case GAMEGUYCOUNTD:
			ret=game->guys[(currmap * MAPSCRSNORMAL) + (ri->d[0] / 10000)]*10000;
			break;
			
		case CURMAP:
			ret=(1+currmap)*10000;
			break;
			
		case CURSCR:
			ret=currscr*10000;
			break;
			
		case ALLOCATEBITMAPR:
			ret=FFCore.do_allocate_bitmap();
			break;
			
		case GETMIDI:
			ret=(currmidi-(ZC_MIDI_COUNT-1))*10000;
			break;
			
		case CURDSCR:
		{
			int di = (get_currscr()-DMaps[get_currdmap()].xoff);
			ret=(DMaps[get_currdmap()].type==dmOVERW ? currscr : di)*10000;
		}
		break;
		
		case GAMEMAXMAPS:
			ret = (map_count)*10000;
			break;
		case GAMENUMMESSAGES:
			ret = (msg_count-1) * 10000; 
			break;
		
		case CURDMAP:
			ret=currdmap*10000;
			break;
			
		case CURLEVEL:
			ret=DMaps[get_currdmap()].level*10000;
			break;
			
		case GAMECLICKFREEZE:
			ret=disableClickToFreeze?0:10000;
			break;
			
		
		case NOACTIVESUBSC:
			ret=Link.stopSubscreenFalling()?10000:0;
			break;
				
		///----------------------------------------------------------------------------------------------------//
		//DMap Information

		#define GET_DMAP_VAR(member, str) \
		{ \
			int ID = ri->d[0] / 10000; \
			if(BC::checkDMapID(ID, str) != SH::_NoError) \
				ret = -10000; \
			else \
				ret = DMaps[ID].member * 10000; \
		}

		case DMAPFLAGSD:
			GET_DMAP_VAR(flags,   "Game->DMapFlags")    break;
			
		case DMAPLEVELD:
			GET_DMAP_VAR(level,   "Game->DMapLevel")    break;
			
		case DMAPCOMPASSD:
			GET_DMAP_VAR(compass, "Game->DMapCompass")  break;
			
		case DMAPCONTINUED:
			GET_DMAP_VAR(cont,    "Game->DMapContinue") break;
		
		case DMAPLEVELPAL:
			GET_DMAP_VAR(color,   "Game->DMapPalette")    break; 
			
		case DMAPOFFSET:
			GET_DMAP_VAR(xoff,    "Game->DMapOffset")   break;
			
		case DMAPMAP:
		{
			int ID = ri->d[0] / 10000;
			
			if(BC::checkDMapID(ID, "Game->DMapMap") != SH::_NoError)
				ret = -10000;
			else
				ret = (DMaps[ID].map+1) * 10000;
				
			break;
		}
		
		case DMAPMIDID:
		{
			int ID = ri->d[0] / 10000;
			
			if(BC::checkDMapID(ID, "Game->DMapMIDI") == SH::_NoError)
			{
				// Based on play_DmapMusic
				switch(DMaps[ID].midi)
				{
				case 2:
					ret = -60000;
					break; // Dungeon
					
				case 3:
					ret = -30000;
					break; // Level 9
					
				case 1:
					ret = -20000;
					break; // Overworld
					
				case 0:
					ret = 0;
					break; // None
					
				default:
					ret = (DMaps[ID].midi - 3) * 10000;
				}
			}
			else
				ret = -10000; // Which is valid, but whatever.
				
			break;
		}
		
		///----------------------------------------------------------------------------------------------------//
		//Screen->ComboX
		#define GET_COMBO_VAR(member, str) \
		{ \
		int pos = ri->d[0] / 10000; \
		if(BC::checkComboPos(pos, str) != SH::_NoError) \
		{ \
		    ret = -10000; \
		} \
		else \
		    ret = tmpscr->member[pos]*10000; \
		}

		case COMBODD:
			GET_COMBO_VAR(data,  "Screen->ComboD[]") break;
			
		case COMBOCD:
			GET_COMBO_VAR(cset,  "Screen->ComboC[]") break;
			
		case COMBOFD:
			GET_COMBO_VAR(sflag, "Screen->ComboF[]") break;
			
		#define GET_COMBO_VAR_BUF(member, str) \
		{ \
		    int pos = ri->d[0] / 10000; \
		    if(BC::checkComboPos(pos, str) != SH::_NoError) \
		    { \
			ret = -10000; \
		    } \
		    else \
			ret = combobuf[tmpscr->data[pos]].member * 10000; \
		}
			
		case COMBOTD:
			GET_COMBO_VAR_BUF(type, "Screen->ComboT[]") break;
			
		case COMBOID:
			GET_COMBO_VAR_BUF(flag, "Screen->ComboI[]") break;
			
		case COMBOSD:
		{
			int pos = ri->d[0] / 10000;
			
			if(BC::checkComboPos(pos, "Screen->ComboS[]") != SH::_NoError)
				ret = -10000;
			else
				ret = (combobuf[tmpscr->data[pos]].walk & 0xF) * 10000;
		}
		break;
		
		///----------------------------------------------------------------------------------------------------//
		//Game->GetComboX
		
		case COMBODDM:
		{
			int pos = (ri->d[0])/10000;
			int sc = (ri->d[2]/10000);
			int m = zc_max((ri->d[1]/10000)-1,0);
			long scr = zc_max(m*MAPSCRS+sc,0);
			int layr = whichlayer(scr);
			
			if(pos >= 0 && pos < 176 && scr >= 0 && sc < MAPSCRS && m < map_count)
			{
				if(scr==(currmap*MAPSCRS+currscr))
					ret=tmpscr->data[pos]*10000;
				else if(layr>-1)
					ret=tmpscr2[layr].data[pos]*10000;
				else ret=TheMaps[scr].data[pos]*10000;
			}
			else
				ret = -10000;
		}
		break;
		
		case COMBOCDM:
		{
			int pos = (ri->d[0])/10000;
			int sc = (ri->d[2]/10000);
			int m = zc_max((ri->d[1]/10000)-1,0);
			long scr = zc_max(m*MAPSCRS+sc,0);
			int layr = whichlayer(scr);
			
			if(pos >= 0 && pos < 176 && scr >= 0 && sc < MAPSCRS && m < map_count)
			{
				if(scr==(currmap*MAPSCRS+currscr))
					ret=tmpscr->cset[pos]*10000;
				else if(layr>-1)
					ret=tmpscr2[layr].cset[pos]*10000;
				else ret=TheMaps[scr].cset[pos]*10000;
			}
			else
				ret = -10000;
		}
		break;
		
		case COMBOFDM:
		{
			int pos = (ri->d[0])/10000;
			int sc = (ri->d[2]/10000);
			int m = zc_max((ri->d[1]/10000)-1,0);
			long scr = zc_max(m*MAPSCRS+sc,0);
			int layr = whichlayer(scr);
			
			if(pos >= 0 && pos < 176 && scr >= 0 && sc < MAPSCRS && m < map_count)
			{
				if(scr==(currmap*MAPSCRS+currscr))
					ret=tmpscr->sflag[pos]*10000;
				else if(layr>-1)
					ret=tmpscr2[layr].sflag[pos]*10000;
				else ret=TheMaps[scr].sflag[pos]*10000;
			}
			else
				ret = -10000;
		}
		break;
		
		case COMBOTDM:
		{
			int pos = (ri->d[0])/10000;
			int sc = (ri->d[2]/10000);
			int m = zc_max((ri->d[1]/10000)-1,0);
			long scr = zc_max(m*MAPSCRS+sc,0);
			int layr = whichlayer(scr);
			
			if(pos >= 0 && pos < 176 && scr >= 0 && sc < MAPSCRS && m < map_count)
			{
				if(scr==(currmap*MAPSCRS+currscr))
					ret=combobuf[tmpscr->data[pos]].type*10000;
				else if(layr>-1)
					ret=combobuf[tmpscr2[layr].data[pos]].type*10000;
				else ret=combobuf[
								 TheMaps[scr].data[pos]].type*10000;
			}
			else
				ret = -10000;
		}
		break;
		
		case COMBOIDM:
		{
			int pos = (ri->d[0])/10000;
			int sc = (ri->d[2]/10000);
			int m = zc_max((ri->d[1]/10000)-1,0);
			long scr = zc_max(m*MAPSCRS+sc,0);
			int layr = whichlayer(scr);
			
			if(pos >= 0 && pos < 176 && scr >= 0 && sc < MAPSCRS && m < map_count)
			{
				if(scr==(currmap*MAPSCRS+currscr))
					ret=combobuf[tmpscr->data[pos]].flag*10000;
				else if(layr>-1)
					ret=combobuf[tmpscr2[layr].data[pos]].flag*10000;
				else ret=combobuf[TheMaps[scr].data[pos]].flag*10000;
			}
			else
				ret = -10000;
		}
		break;
		
		case COMBOSDM:
		{
			int pos = (ri->d[0])/10000;
			int sc = (ri->d[2]/10000);
			int m = zc_max((ri->d[1]/10000)-1,0);
			long scr = zc_max(m*MAPSCRS+sc,0);
			int layr = whichlayer(scr);
			
			if(pos >= 0 && pos < 176 && scr >= 0 && sc < MAPSCRS && m < map_count)
			{
				if(scr==(currmap*MAPSCRS+currscr))
					ret=(combobuf[tmpscr->data[pos]].walk&15)*10000;
				else if(layr>-1)
					ret=(combobuf[tmpscr2[layr].data[pos]].walk&15)*10000;
				else ret=(combobuf[TheMaps[scr].data[pos]].walk&15)*10000;
			}
			else
				ret = -10000;
		}
		break;
		

		
		
		///----------------------------------------------------------------------------------------------------//
		//Screen Information
		
			#define	GET_SCREENDATA_VAR_INT32(member, str) \
		{ \
			ret = (tmpscr->member *10000); \
		} \

		#define	GET_SCREENDATA_VAR_INT16(member, str) \
		{ \
			ret = (tmpscr->member *10000); \
		} \

		#define	GET_SCREENDATA_VAR_BYTE(member, str) \
		{ \
			ret = (tmpscr->member *10000); \
		} \
		
		#define GET_SCREENDATA_VAR_INDEX32(member, str, indexbound) \
		{ \
			int indx = ri->d[0] / 10000; \
			ret = (tmpscr->member[indx] *10000); \
		} \
		
		#define GET_SCREENDATA_VAR_INDEX16(member, str, indexbound) \
		{ \
			int indx = ri->d[0] / 10000; \
			ret = (tmpscr->member[indx] *10000); \
		} \
		
		#define GET_SCREENDATA_BYTE_INDEX(member, str, indexbound) \
		{ \
			int indx = ri->d[0] / 10000; \
			ret = (tmpscr->member[indx] *10000); \
		} \
		
		//byte
		#define GET_SCREENDATA_LAYER_INDEX(member, str, indexbound) \
		{ \
			int indx = ri->d[0] / 10000; \
			if ( FFCore.quest_format[vFFScript] < 11 ) ++indx; \
			if(indx < 1 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to Screen->%s[]: %d\n", str, indx); \
				ret = -10000; \
			} \
			else \
			{ \
				ret = (tmpscr->member[indx-1] *10000); \
			} \
		} \
		
		
		#define GET_SCREENDATA_BOOL_INDEX(member, str, indexbound) \
		{ \
			int indx = ri->d[0] / 10000; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to Screen->%s[]: %d\n", (indx), str); \
				ret = -10000; \
			} \
			else \
			{ \
				ret = (tmpscr->member[indx]?10000:0); \
			} \
		} \
		
		
		#define GET_SCREENDATA_FLAG(member, str, indexbound) \
		{ \
			long flag =  (value/10000);  \
			ret = (tmpscr->member&flag) ? 10000 : 0); \
		} \
		
		case SCREENDATAVALID:		GET_SCREENDATA_VAR_BYTE(valid, "Valid"); break;		//b
		case SCREENDATAGUY: 		GET_SCREENDATA_VAR_BYTE(guy, "Guy"); break;		//b
		case SCREENDATASTRING:		GET_SCREENDATA_VAR_INT32(str, "String"); break;		//w
		case SCREENDATAROOM: 		GET_SCREENDATA_VAR_BYTE(room, "RoomType");	break;		//b
		case SCREENDATAITEM: 		GET_SCREENDATA_VAR_BYTE(item, "Item"); break;		//b
		case SCREENDATAHASITEM: 		GET_SCREENDATA_VAR_BYTE(hasitem, "HasItem"); break;	//b
		case SCREENDATATILEWARPTYPE: 	GET_SCREENDATA_BYTE_INDEX(tilewarptype, "TileWarpType", 3); break;	//b, 4 of these
		//case SCREENDATATILEWARPOVFLAGS: 	GET_SCREENDATA_VAR_BYTE(tilewarpoverlayflags, "TileWarpOverlayFlags"); break;	//b, tilewarpoverlayflags
		case SCREENDATADOORCOMBOSET: 	GET_SCREENDATA_VAR_INT32(door_combo_set, "DoorComboSet"); break;	//w
		case SCREENDATAWARPRETX:	 	GET_SCREENDATA_BYTE_INDEX(warpreturnx, "WarpReturnX", 3); break;	//b, 4 of these
		case SCREENDATAWARPRETY:	 	GET_SCREENDATA_BYTE_INDEX(warpreturny, "WarpReturnY", 3); break;	//b, 4 of these
		case SCREENDATAWARPRETURNC: 	GET_SCREENDATA_VAR_INT32(warpreturnc, "WarpReturnC"); break;	//w
		case SCREENDATASTAIRX: 		GET_SCREENDATA_VAR_BYTE(stairx, "StairsX"); break;	//b
		case SCREENDATASTAIRY: 		GET_SCREENDATA_VAR_BYTE(stairy, "StairsY"); break;	//b
		case SCREENDATAITEMX:		GET_SCREENDATA_VAR_BYTE(itemx, "ItemX"); break; //itemx
		case SCREENDATAITEMY:		GET_SCREENDATA_VAR_BYTE(itemy, "ItemY"); break;	//itemy
		case SCREENDATACOLOUR: 		GET_SCREENDATA_VAR_INT32(color, "CSet"); break;	//w
		case SCREENDATAENEMYFLAGS: 	GET_SCREENDATA_VAR_BYTE(enemyflags, "EnemyFlags");	break;	//b
		case SCREENDATADOOR: 		GET_SCREENDATA_BYTE_INDEX(door, "Door", 3); break;	//b, 4 of these
		case SCREENDATATILEWARPDMAP: 	GET_SCREENDATA_VAR_INDEX32(tilewarpdmap, "TileWarpDMap", 3); break;	//w, 4 of these
		case SCREENDATATILEWARPSCREEN: 	GET_SCREENDATA_BYTE_INDEX(tilewarpscr, "TileWarpScreen", 3); break;	//b, 4 of these
		case SCREENDATAEXITDIR: 		GET_SCREENDATA_VAR_BYTE(exitdir, "ExitDir"); break;	//b
		case SCREENDATAENEMY: 		GET_SCREENDATA_VAR_INDEX32(enemy, "Enemy", 9); break;	//w, 10 of these
		case SCREENDATAPATTERN: 		GET_SCREENDATA_VAR_BYTE(pattern, "Pattern"); break;	//b
		case SCREENDATASIDEWARPTYPE: 	GET_SCREENDATA_BYTE_INDEX(sidewarptype, "SideWarpType", 3); break;	//b, 4 of these
		//case SCREENDATASIDEWARPOVFLAGS: 	GET_SCREENDATA_VAR_BYTE(sidewarpoverlayflags, "SideWarpOverlayFlags"); break;	//b
		case SCREENDATAWARPARRIVALX: 	GET_SCREENDATA_VAR_BYTE(warparrivalx, "WarpArrivalX"); break;	//b
		case SCREENDATAWARPARRIVALY: 	GET_SCREENDATA_VAR_BYTE(warparrivaly, "WarpArrivalY"); break;	//b
		case SCREENDATAPATH: 		GET_SCREENDATA_BYTE_INDEX(path, "MazePath", 3); break;	//b, 4 of these
		case SCREENDATASIDEWARPSC: 	GET_SCREENDATA_BYTE_INDEX(sidewarpscr, "SideWarpScreen", 3); break;	//b, 4 of these
		case SCREENDATASIDEWARPDMAP: 	GET_SCREENDATA_VAR_INDEX32(sidewarpdmap, "SideWarpDMap", 3); break;	//w, 4 of these
		case SCREENDATASIDEWARPINDEX: 	GET_SCREENDATA_VAR_BYTE(sidewarpindex, "SideWarpIndex"); break;	//b
		case SCREENDATAUNDERCOMBO: 	GET_SCREENDATA_VAR_INT32(undercombo, "Undercombo"); break;	//w
		case SCREENDATAUNDERCSET:	 	GET_SCREENDATA_VAR_BYTE(undercset,	"UnderCSet"); break; //b
		case SCREENDATACATCHALL:	 	GET_SCREENDATA_VAR_INT32(catchall,	"Catchall"); break; //W

		case SCREENDATACSENSITIVE: 	GET_SCREENDATA_VAR_BYTE(csensitive, "CSensitive"); break;	//B
		case SCREENDATANORESET: 		GET_SCREENDATA_VAR_INT32(noreset, "NoReset"); break;	//W
		case SCREENDATANOCARRY: 		GET_SCREENDATA_VAR_INT32(nocarry, "NoCarry"); break;	//W
		case SCREENDATALAYERMAP:	 	GET_SCREENDATA_LAYER_INDEX(layermap, "LayerMap", 6); break;	//B, 6 OF THESE
		case SCREENDATALAYERSCREEN: 	GET_SCREENDATA_LAYER_INDEX(layerscreen, "LayerScreen", 6); break;	//B, 6 OF THESE
		case SCREENDATALAYEROPACITY: 	GET_SCREENDATA_LAYER_INDEX(layeropacity, "LayerOpacity", 6); break;	//B, 6 OF THESE
		case SCREENDATALAYERINVIS: 	
		{
			int indx = ri->d[0] / 10000;
			if(indx < 0 || indx > 6 )
			{
				Z_scripterrlog("Invalid Index passed to Screen->LayerInvisible[]: %d\n", indx);
				ret = 0;
			}
			else
			{
				ret = ((tmpscr->hidelayers >> indx) & 1) *10000;
			}
			break;
		}
		case SCREENDATASCRIPTDRAWS: 	
		{
			int indx = ri->d[0] / 10000;
			if(indx < 0 || indx > 7 )
			{
				Z_scripterrlog("Invalid Index passed to Screen->HideScriptLayer[]: %d\n", indx);
				ret = 0;
			}
			else
			{
				ret = ((tmpscr->hidescriptlayers >> indx) & 1) ? 0 : 10000;
			}
			break;
		}
		case SCREENDATATIMEDWARPTICS: 	GET_SCREENDATA_VAR_INT32(timedwarptics, "TimedWarpTimer"); break;	//W
		case SCREENDATANEXTMAP: 		GET_SCREENDATA_VAR_BYTE(nextmap, "NextMap"); break;	//B
		case SCREENDATANEXTSCREEN: 	GET_SCREENDATA_VAR_BYTE(nextscr, "NextScreen"); break;	//B
		case SCREENDATASECRETCOMBO: 	GET_SCREENDATA_VAR_INDEX32(secretcombo, "SecretCombo", 127); break;	//W, 128 OF THESE
		case SCREENDATASECRETCSET: 	GET_SCREENDATA_BYTE_INDEX(secretcset, "SecretCSet", 127); break;	//B, 128 OF THESE
		case SCREENDATASECRETFLAG: 	GET_SCREENDATA_BYTE_INDEX(secretflag, "SecretFlags", 127); break;	//B, 128 OF THESE
		case SCREENDATAVIEWX: 		GET_SCREENDATA_VAR_INT32(viewX, "ViewX"); break;	//W
		case SCREENDATAVIEWY: 		GET_SCREENDATA_VAR_INT32(viewY, "ViewY"); break; //W
		case SCREENDATASCREENWIDTH: 	GET_SCREENDATA_VAR_BYTE(scrWidth, "Width"); break;	//B
		case SCREENDATASCREENHEIGHT: 	GET_SCREENDATA_VAR_BYTE(scrHeight,	"Height"); break;	//B
		case SCREENDATAENTRYX: 		GET_SCREENDATA_VAR_BYTE(entry_x, "EntryX"); break;	//B
		case SCREENDATAENTRYY: 		GET_SCREENDATA_VAR_BYTE(entry_y, "EntryY"); break;	//B
		//case SCREENDATANUMFF: 		GET_SCREENDATA_VAR_INT16(numff, "NumFFCs"); break;	//INT16
		//Number of ffcs that are in use (have valid data
		case SCREENDATANUMFF: 	
		{
			int indx = ri->d[0] / 10000;
			if ( !indx )
			{
				Z_scripterrlog("Invalid Index passed to Screen->NumFFCs[%d].\n Valid indices are 1 through [32].\n", indx);
				ret = 0;
			}
			else if(((unsigned)indx)>32)
			{
				Z_scripterrlog("Invalid Index passed to Screen->NumFFCs[%d].\n Valid indices are 1 through [32].\n", indx);
				ret = 0;
			}
			else
			{
				--indx;
				ret = (((tmpscr->numff) & (1<<indx))) ? 10000 : 0;
				//ret = ((tmpscr->hidescriptlayers >> indx) & 1) ? 0 : 10000;
			}
			break;
		}
			//inita	//INT32, 32 OF THESE, EACH WITH 2
		case SCREENDATAFFINITIALISED: 	GET_SCREENDATA_BOOL_INDEX(initialized, "FFCRunning", 31); break;	//BOOL, 32 OF THESE
		case SCREENDATASCRIPTENTRY: 	GET_SCREENDATA_VAR_INT32(script_entry, "ScriptEntry"); break;	//W
		case SCREENDATASCRIPTOCCUPANCY: 	GET_SCREENDATA_VAR_INT32(script_occupancy,	"ScriptOccupancy");  break;//W
		case SCREENDATASCRIPTEXIT: 	GET_SCREENDATA_VAR_INT32(script_exit, "ExitScript"); break;	//W
		case SCREENDATAOCEANSFX:	 	GET_SCREENDATA_VAR_BYTE(oceansfx, "OceanSFX"); break;	//B
		case SCREENDATABOSSSFX: 		GET_SCREENDATA_VAR_BYTE(bosssfx, "BossSFX"); break;	//B
		case SCREENDATASECRETSFX:	 	GET_SCREENDATA_VAR_BYTE(secretsfx, "SecretSFX"); break;	//B
		case SCREENDATAHOLDUPSFX:	 	GET_SCREENDATA_VAR_BYTE(holdupsfx,	"ItemSFX"); break; //B
		case SCREENDATASCREENMIDI:
		{
			ret = ((tmpscr->screen_midi+(MIDIOFFSET_MAPSCR-MIDIOFFSET_ZSCRIPT)) *10000);
			break;
		}
		case SCREENDATALENSLAYER:	 	GET_SCREENDATA_VAR_BYTE(lens_layer, "LensLayer"); break;	//B, OLD QUESTS ONLY?

		case SCREENSIDEWARPID: 
		{
			int indx = ri->d[0] / 10000;
			
			ret = (((tmpscr->flags2 >> indx) & 1)
				? (tmpscr->sidewarpindex >> (2*indx)) & 3 //Return which warp is set
				: -1 //Returns -1 if no warp is set
				)*10000;
			break;
		}

		case SCREENDATATILEWARPOVFLAGS: 
		{
			int indx = ri->d[0] / 10000;
			if ( ((unsigned)indx) > 3 ) 
			{
				Z_scripterrlog("Invalid index passed to TileWarpOverlayFlags[%d].\n. Valid indices are [0] through [3].\n", indx);
				ret = 0;
			}
			else
			{
				ret = (tmpscr->tilewarpoverlayflags & (1<<indx))?10000:0;
			}
			break;
		}

		case SCREENDATASIDEWARPOVFLAGS: 
		{
			int indx = ri->d[0] / 10000;
			if ( ((unsigned)indx) > 3 ) 
			{
				Z_scripterrlog("Invalid index passed to SideWarpOverlayFlags[%d].\n. Valid indices are [0] through [3].\n", indx);
				ret = 0;
			}
			else
			{
				ret = (tmpscr->sidewarpoverlayflags & (1<<indx))?10000:0;
			}
			break;
		}

		case SCREENDATATWARPRETSQR:
		{
			int indx = ri->d[0] / 10000;
			if ( ((unsigned)indx) > 3)
			{
				ret = -10000;
				Z_scripterrlog("Invalid Array Index passed to Screen->TileWarpReturnSquare[]: %d\n", indx);
				
			}
			else 
			{
				ret = ((tmpscr->warpreturnc>>(indx*2))&3) * 10000;
			}
			break;
		}


		case SCREENDATASWARPRETSQR:
		{
			int indx = ri->d[0] / 10000;
			if ( ((unsigned)indx) > 3)
			{
				ret = -10000;
				Z_scripterrlog("Invalid Array Index passed to Screen->SideWarpReturnSquare[]: %d\n", indx);
				
			}
			else 
			{
				ret = ((tmpscr->warpreturnc>>(8+(indx*2)))&3) * 10000;
			}
			break;
		}

		case SCREENDATAFLAGS: 
		{
			int flagid = (ri->d[0])/10000;
			//bool valtrue = ( value ? 10000 : 0);
			switch(flagid)
			{
				case 0: ret = (tmpscr->flags * 10000); break;
				case 1: ret = (tmpscr->flags2 * 10000); break;
				case 2: ret = (tmpscr->flags3 * 10000); break;
				case 3: ret = (tmpscr->flags4 * 10000); break;
				case 4: ret = (tmpscr->flags5 * 10000); break;
				case 5: ret = (tmpscr->flags6 * 10000); break;
				case 6: ret = (tmpscr->flags7 * 10000); break;
				case 7: ret = (tmpscr->flags8 * 10000); break;
				case 8: ret = (tmpscr->flags9 * 10000); break;
				case 9: ret = (tmpscr->flags10 * 10000); break;
				default:
				{
					Z_scripterrlog("Invalid index passed to mapdata->flags[]: %d\n", flagid); 
					ret = -10000;
					break;
					
				}
			}
			break;
			//GET_SCREENDATA_BYTE_INDEX	//B, 11 OF THESE, flags, flags2-flags10
		}

		case SDD:
		{
			int di = ((get_currdmap())<<7) + get_currscr()-(DMaps[get_currdmap()].type==dmOVERW ? 0 : DMaps[get_currdmap()].xoff);
			ret=FFScript::get_screen_d(di, ri->d[0]/10000);
		}
		break;
		
		case SDDD:
			ret=FFScript::get_screen_d((ri->d[0])/10000 + ((get_currdmap())<<7), ri->d[1] / 10000);
			break;
		
		case LINKOTILE:
			ret=FFCore.getLinkOTile(ri->d[0]/10000, ri->d[1] / 10000);
			break;
			
		case SDDDD:
			ret=FFScript::get_screen_d(ri->d[1] / 10000 + ((ri->d[0]/10000)<<7), ri->d[2] / 10000);
			break;
			
		case SCRDOORD:
			ret=tmpscr->door[ri->d[0]/10000]*10000;
			break;
		
		case SCREENSCRIPT:
			ret=tmpscr->script*10000;
			break;
		
		case SCREENINITD:
			ret = tmpscr->screeninitd[ri->d[0]/10000];
			break;
		
		case MAPDATAINITDARRAY:
		{
			if ( ri->mapsref == LONG_MAX ) 
			{ 
				Z_scripterrlog("Script attempted to use a mapdata->InitD[%d] on a pointer that is uninitialised\n",ri->d[0]/10000); 
				break; 
			} 
			else 
			{ 
				mapscr *m = GetMapscr(ri->mapsref); 
				ret = m->screeninitd[ri->d[0]/10000];
			} 
			break;
		}
		
		case MAPDATALAYERINVIS: 	
		{
			int indx = ri->d[0] / 10000;
			if(indx < 0 || indx > 6 )
			{
				Z_scripterrlog("Invalid Index passed to mapdata->LayerInvisible[]: %d\n", indx);
				ret = 0;
			}
			else
			{
				if ( ri->mapsref == LONG_MAX )
				{
						Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n","LayerInvisible");
						ret = -10000;
				}
				else
				{
					mapscr *m = GetMapscr(ri->mapsref);
					ret = ((m->hidelayers >> indx) & 1) *10000;
				}
			}
			break;
		}
		case MAPDATASCRIPTDRAWS: 	
		{
			int indx = ri->d[0] / 10000;
			if(indx < 0 || indx > 6 )
			{
				Z_scripterrlog("Invalid Index passed to mapdata->DisableScriptDraws[]: %d\n", indx);
				ret = 0;
			}
			else
			{
				if ( ri->mapsref == LONG_MAX )
				{
						Z_scripterrlog("Script attempted to use a mapdata->DisableScriptDraws on a pointer that is uninitialised\n");
						ret = -10000;
				}
				else
				{
					mapscr *m = GetMapscr(ri->mapsref);
					ret = ((m->hidescriptlayers >> indx) & 1) ? 0 : 10000;
				}
			}
			break;
		}
		
		//These use the same method as GetScreenD -Z
		case SCREENWIDTH:
			ret=FFScript::get_screenWidth(&TheMaps[(ri->d[1] / 10000) * MAPSCRS + (ri->d[0]/10000)]);
			break;

		case SCREENHEIGHT:
			ret=FFScript::get_screenHeight(&TheMaps[(ri->d[1] / 10000) * MAPSCRS + (ri->d[0]/10000)]);
			break;

		case SCREENVIEWX:
			ret=get_screenViewX(&TheMaps[(ri->d[1] / 10000) * MAPSCRS + (ri->d[0]/10000)]);
			break;

		case SCREENVIEWY:
			ret=get_screenViewY(&TheMaps[(ri->d[1] / 10000) * MAPSCRS + (ri->d[0]/10000)]);
			break;

		case SCREENGUY:
			ret=get_screenGuy(&TheMaps[(ri->d[1] / 10000) * MAPSCRS + (ri->d[0]/10000)]);
			break;

		case SCREENSTRING:
			ret=get_screenString(&TheMaps[(ri->d[1] / 10000) * MAPSCRS + (ri->d[0]/10000)]);
			break;

		case SCREENROOM:
			ret=get_screenRoomtype(&TheMaps[(ri->d[1] / 10000) * MAPSCRS + (ri->d[0]/10000)]);
			break;

		case SCREENENTX:
			ret=get_screenEntryX(&TheMaps[(ri->d[1] / 10000) * MAPSCRS + (ri->d[0]/10000)]);
			break;

		case SCREENENTY:
			ret=get_screenEntryY(&TheMaps[(ri->d[1] / 10000) * MAPSCRS + (ri->d[0]/10000)]);
			break;

		case SCREENITEM:
			ret=get_screenitem(&TheMaps[(ri->d[1] / 10000) * MAPSCRS + (ri->d[0]/10000)]);
			break;

		case SCREENUNDCMB:
			ret=get_screenundercombo(&TheMaps[(ri->d[1] / 10000) * MAPSCRS + (ri->d[0]/10000)]);
			break;

		case SCREENUNDCST:
			ret=get_screenundercset(&TheMaps[(ri->d[1] / 10000) * MAPSCRS + (ri->d[0]/10000)]);
			break;

		case SCREENCATCH:
			ret=get_screenatchall(&TheMaps[(ri->d[1] / 10000) * MAPSCRS + (ri->d[0]/10000)]);
			break;
	 
			
		case LIT:
			ret= darkroom ? 0 : 10000;
			break;
			
		case WAVY:
			ret = wavy*10000;
			break;
			
		case QUAKE:
			ret = quakeclk*10000;
			break;
			
		case SCREENFLAGSD:
			ret = get_screenflags(tmpscr,vbound(ri->d[0] / 10000,0,9));
			break;
			
		case SCREENEFLAGSD:
			ret = get_screeneflags(tmpscr,vbound(ri->d[0] / 10000,0,2));
			break;
			
		case NPCCOUNT:
			ret = guys.Count()*10000;
			break;
			
		case ROOMDATA:
			ret = tmpscr->catchall*10000;
			break;
			
		case ROOMTYPE:
			ret = tmpscr->room*10000;
			break;
			
		case PUSHBLOCKX:
			ret = blockmoving ? int(mblock2.x)*10000 : -10000;
			break;
			
		case PUSHBLOCKY:
			ret = blockmoving ? int(mblock2.y)*10000 : -10000;
			break;
			
		case PUSHBLOCKCOMBO:
			ret = mblock2.bcombo*10000;
			break;
			
		case PUSHBLOCKCSET:
			ret = mblock2.cs*10000;
			break;
			
		case UNDERCOMBO:
			ret = tmpscr->undercombo*10000;
			break;
			
		case UNDERCSET:
			ret = tmpscr->undercset*10000;
			break;
		
		//Creates an lweapon using an iemdata struct values to generate its properties.
		//Useful in conjunction with the new weapon editor. 
		case CREATELWPNDX:
		{
			//Z_message("Trying to get Link->SetExtend().\n");
			long ID = (ri->d[0] / 10000);
			int itemid = (ri->d[1]/10000);
			itemid = vbound(itemid,0,(MAXITEMS-1));
			
			//Z_scripterrlog("GetLinkExtend rid->[2] is (%i), trying to use for '%s'\n", ri->d[2], "ri->d[2]");
			//Z_scripterrlog("GetLinkExtend rid->[1] is (%i), trying to use for '%s'\n", state, "state");
			//Z_scripterrlog("GetLinkExtend rid->[0] is (%i), trying to use for '%s'\n", dir, "dir");
			if ( Lwpns.Count() < 256 )
			{
				
				Lwpns.add
				(
					new weapon
					(
						(zfix)0, /*X*/
						(zfix)0, /*Y*/
						(zfix)0, /*Z*/
						ID,	 /*id*/
						0,	 /*type*/
						0,	 /*power*/
						0,	 /*dir*/
						-1,	 /*Parentid*/
						Link.getUID(), /*prntid*/
						false,	 /*isdummy*/
						1,	 /*script_gen*/
						1,  /*islwpn*/
						(ID==wWind?1:0)  /*special*/
					)
				);
				ri->lwpn = Lwpns.spr(Lwpns.Count() - 1)->getUID();
				
				weapon *w = (weapon*)Lwpns.spr(Lwpns.Count()-1); //last created
				w->LOADGFX(FFCore.getDefWeaponSprite(ID));
				w->ScriptGenerated = 1;
				w->isLWeapon = 1;
				if(ID == wWind) w->specialinfo = 1;
				//weapon *w = (weapon*)Lwpns.spr(Lwpns.Count()-1); //last created
				//w->LOADGFX(FFCore.getDefWeaponSprite(ID)); //not needed here because this has access to wpn->prent
			}
			else
			{
				Z_scripterrlog("Tried to create too many LWeapons on the screen. The current LWeapon count is: %d\n", Lwpns.Count());
				ri->lwpn = LONG_MAX;
			}
			
			/* Z_scripterrlog("CreateLWeaponDx ri->d[0] is (%i), trying to use for '%s'\n", ID, "ID");
			Z_scripterrlog("CreateLWeaponDx ri->d[1] is (%i), trying to use for '%s'\n", itemid, "itemid");
			Z_scripterrlog("CreateLWeaponDx ri->lwpn is (%i), trying to use for '%s'\n", ri->lwpn, "ri->lwpn"); */
			
			ret = ri->lwpn; 
		}
		break;
		
		/*
		//Screen->CollisionDx(int enemy_index, int lweapon_type, int power, int x, int y, int weapon_dir, int parent_item);
		//Handles collision between an npc at screen index 'enemy_index', and an arbitrary lweapon that may or may not exist.
		//Does damage, and returns true a value collision is valid. Returns a different value otherwise. 
		
		// take damage or ignore it
		// -1: damage (if any) dealt
		// 1: blocked
		// 0: weapon passes through unhindered
		// 2: heal enemy? -ZoriaRPG
		
		//THis function should automatically check for shields blocking the weapon, and calculate enemy defences.
		//In theory, scritped swords, and other melee weapons could use this, as coudl any weapon, and it may simplify
		//collision routines. 
		case COLLISIONDX:
		{
			//Z_message("Trying to get Link->SetExtend().\n");
			int index = (ri->d[0] / 10000);
			long lweapon_type = (ri->d[1] / 10000);
			int power = (ri->d[2]/10000);
			
			int wpnx = ri->4[3]/10000, wpny = ri->d[4]/10000;
			int dir = ri->d[5]/10000;
			int parentitem = (ri->d[6]/10000);
			lweapon_type = vbound(lweapon_type,0,40); //Are we at 40, or higher now>
			parentitem = vbound(itemid,0,255);
			
			//Log the stack events:
			Z_scripterrlog("CollisionDx ri->d[0] is (%i), trying to use for '%s'\n", index, "index");
			Z_scripterrlog("CollisionDx ri->d[1] is (%i), trying to use for '%s'\n", lweapon_type, "lweapon_type");
			Z_scripterrlog("CollisionDx ri->d[2] is (%i), trying to use for '%s'\n", power, "power");
			Z_scripterrlog("CollisionDx ri->d[3] is (%i), trying to use for '%s'\n", wpnx, "wpnx");
			Z_scripterrlog("CollisionDx ri->d[4] is (%i), trying to use for '%s'\n", wpny, "wpny");
			Z_scripterrlog("CollisionDx ri->d[5] is (%i), trying to use for '%s'\n", dir, "dir");
			Z_scripterrlog("CollisionDx ri->d[0] is (%i), trying to use for '%s'\n", parentitem, "parentitem");
			
			weapon *w = new weapon((zfix)wpnx,(zfix)wpny,(zfix)0,lweapon_type,0,power,dir,parentitem,-1,false);
			int retval = ((enemy*)guys.spr(index))->takehit(w); 
				//TakeHit, as I recall, applies damage and returns the hit status. Gold.
			delete w;
			ret = retval;
		}
		break;
		
		*/
		case DEBUGREFFFC:
		{
			int r = -1;
			if ( ri->ffcref ) r = ri->ffcref;
				ret = r * 10000;
			break;
		}
			
		case DEBUGREFITEM:
		{
			int r = -1;
			if ( ri->itemref ) r = ri->itemref;
				ret = r * 10000;
			break;
		}
			
		case DEBUGREFITEMDATA:
		{
			int r = -1;
			if ( ri->idata ) r = ri->idata;
				ret = r * 10000;
			break;
		}
			
		case DEBUGREFLWEAPON:
		{
			int r = -1;
			if ( ri->lwpn ) r = ri->lwpn;
				ret = r * 10000;
			break;
		}
			
		case DEBUGREFEWEAPON:
		{
			int r = -1;
			if ( ri->ewpn ) r = ri->ewpn;
				ret = r * 10000;
			break;
		}
			
		case DEBUGREFNPC:
		{
			int r = -1;
			if ( ri->guyref ) r = ri->guyref;
				ret = r * 10000;
			break;
		}    
			
		case DEBUGSP:
		{
			ret = SH::read_stack(ri->sp) * 10000;
			break;
		}   
		case DEBUGGDR:
		{
			int a = vbound(ri->d[0]/10000,0,15);
			int r = -1;
			if ( game->global_d[a] ) r = game->global_d[a];
				ret = r * 10000;
			break;
		}
		
		///----------------------------------------------------------------------------------------------------//
		//New Datatype Variables
			
		///----------------------------------------------------------------------------------------------------//
		//spritedata sp-> Variables
			
		case SPRITEDATATILE: GET_SPRITEDATA_VAR_INT(newtile, "Tile") break;
		case SPRITEDATAMISC: GET_SPRITEDATA_VAR_INT(misc, "Misc") break;
		case SPRITEDATACSETS: GET_SPRITEDATA_VAR_INT(csets, "CSet") break;
		case SPRITEDATAFRAMES: GET_SPRITEDATA_VAR_INT(frames, "Frames") break;
		case SPRITEDATASPEED: GET_SPRITEDATA_VAR_INT(speed, "Speed") break;
		case SPRITEDATATYPE: GET_SPRITEDATA_VAR_INT(type, "Type") break;
		
		///----------------------------------------------------------------------------------------------------//
		//mapdata m-> variables
		#define	GET_MAPDATA_VAR_INT32(member, str) \
		{ \
			if ( ri->mapsref == LONG_MAX ) \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n",str); \
				ret = -10000; \
			} \
			else \
			{ \
				mapscr *m = GetMapscr(ri->mapsref); \
				ret = (m->member *10000); \
			} \
		} \

		#define	GET_MAPDATA_VAR_INT16(member, str) \
		{ \
			if ( ri->mapsref == LONG_MAX ) \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n",str); \
				ret = -10000; \
			} \
			else \
			{ \
				mapscr *m = GetMapscr(ri->mapsref); \
				ret = (m->member *10000); \
			} \
		} \

		#define	GET_MAPDATA_VAR_BYTE(member, str) \
		{ \
			if ( ri->mapsref == LONG_MAX ) \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n",str); \
				ret = -10000; \
			} \
			else \
			{ \
				mapscr *m = GetMapscr(ri->mapsref); \
				ret = (m->member *10000); \
			} \
		} \
		
		#define GET_MAPDATA_VAR_INDEX32(member, str, indexbound) \
		{ \
			int indx = ri->d[0] / 10000; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", str, indx); \
				ret = -10000; \
			} \
			else \
			{ \
				if ( ri->mapsref == LONG_MAX ) \
				{ \
					Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n",str); \
					ret = -10000; \
				} \
				else \
				{ \
					mapscr *m = GetMapscr(ri->mapsref); \
					ret = (m->member[indx] *10000); \
				} \
			} \
		} \
		
		#define GET_MAPDATA_VAR_INDEX16(member, str, indexbound) \
		{ \
			int indx = ri->d[0] / 10000; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", str, indx); \
				ret = -10000; \
			} \
			else \
			{ \
				if ( ri->mapsref == LONG_MAX ) \
				{ \
					Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n",str); \
					ret = -10000; \
				} \
				else \
				{ \
					mapscr *m = GetMapscr(ri->mapsref); \
					ret = (m->member[indx] *10000); \
				} \
			} \
		} \
		
		#define GET_MAPDATA_BYTE_INDEX(member, str, indexbound) \
		{ \
			int indx = ri->d[0] / 10000; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", str, indx); \
				ret = -10000; \
			} \
			else \
			{ \
				if ( ri->mapsref == LONG_MAX ) \
				{ \
					Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n",str); \
					ret = -10000; \
				} \
				else \
				{ \
					mapscr *m = GetMapscr(ri->mapsref); \
					ret = (m->member[indx] *10000); \
				} \
			} \
		} \
		
		/*
		#define GET_MAPDATA_LAYER_INDEX(member, str, indexbound) \
		{ \
			int indx = ri->d[0] / 10000; \
			mapscr *m = GetMapscr(ri->mapsref); \
			if ( indx == 0 ) \
			{ \
				\
			} \
			else \
			{ \
				ret = (m->member[indx-1] *10000); \
			} \
		} \
		*/
		
		#define GET_MAPDATA_LAYER_INDEX(member, str, indexbound) \
		{ \
			int indx = ri->d[0] / 10000; \
			if ( FFCore.quest_format[vFFScript] < 11 ) ++indx; \
			if(indx < 1 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", str, indx); \
				ret = -10000; \
			} \
			else \
			{ \
				if ( ri->mapsref == LONG_MAX ) \
				{ \
					Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n",str); \
					ret = -10000; \
				} \
				else \
				{ \
					mapscr *m = GetMapscr(ri->mapsref); \
					ret = (m->member[indx-1] *10000); \
				} \
			} \
		} \
		
		#define GET_MAPDATA_BOOL_INDEX(member, str, indexbound) \
		{ \
			int indx = ri->d[0] / 10000; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", str, indx); \
				ret = -10000; \
			} \
			else \
			{ \
				if ( ri->mapsref == LONG_MAX ) \
				{ \
					Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n",str); \
					ret = -10000; \
				} \
				else \
				{ \
					mapscr *m = GetMapscr(ri->mapsref); \
					ret = (m->member[indx]?10000:0); \
				} \
			} \
		} \
		
		#define GET_MAPDATA_FLAG(member, str) \
		{ \
			long flag =  (value/10000);  \
			if ( ri->mapsref == LONG_MAX ) \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n",str); \
				ret = -10000; \
			} \
			else \
			{ \
				mapscr *m = GetMapscr(ri->mapsref); \
				ret = (m->member&flag) ? 10000 : 0); \
			} \
		} \
		
		#define GET_SCREENDATA_COMBO_VAR(member, str) \
		{ \
			if ( ri->mapsref == LONG_MAX ) \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n",str); \
				ret = -10000; \
			} \
			else \
			{ \
				mapscr *m = GetMapscr(ri->mapsref); \
				int pos = ri->d[0] / 10000; \
				if(BC::checkComboPos(pos, str) != SH::_NoError) \
				ret = -10000; \
				else \
					ret = m->member[pos]*10000; \
			} \
		} \

		#define GET_MAPDATA_COMBO_VAR_BUF(member, str) \
		{ \
			if ( ri->mapsref == LONG_MAX ) \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n",str); \
				ret = -10000; \
			} \
			else \
			{ \
				mapscr *m = GetMapscr(ri->mapsref); \
				int pos = ri->d[0] / 10000; \
				if(BC::checkComboPos(pos, str) != SH::_NoError) \
					ret = -10000; \
				else \
					ret = combobuf[m->data[pos]].member * 10000; \
			} \
		} \
		
		#define GET_MAPDATA_FFCPOS_INDEX32(member, str, indexbound) \
		{ \
			int indx = (ri->d[0] / 10000)-1; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", (indx+1), str); \
				ret = -10000; \
			} \
			else if ( ri->mapsref == LONG_MAX ) \
			{ \
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","str"); \
				ret = -10000; \
			} \
			else \
			{ \
				mapscr *m = GetMapscr(ri->mapsref); \
				ret = (m->member[indx]); \
			} \
		} \
		
		#define GET_MAPDATA_FFC_INDEX32(member, str, indexbound) \
		{ \
			int indx = (ri->d[0] / 10000)-1; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", (indx+1), str); \
				ret = -10000; \
			} \
			else if ( ri->mapsref == LONG_MAX ) \
			{ \
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","str"); \
				ret = -10000; \
			} \
			else \
			{ \
				mapscr *m = GetMapscr(ri->mapsref); \
				ret = (m->member[indx])*10000; \
			} \
		} \

		#define GET_MAPDATA_FFC_INDEX32(member, str, indexbound) \
		{ \
			int indx = (ri->d[0] / 10000)-1; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", (indx+1), str); \
				ret = -10000; \
			} \
			else if ( ri->mapsref == LONG_MAX ) \
			{ \
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","str"); \
				ret = -10000; \
			} \
			else \
			{ \
				mapscr *m = GetMapscr(ri->mapsref); \
				ret = (m->member[indx])*10000; \
			} \
		} \
			
		case LOADMAPDATA:
				ret=FFScript::loadMapData();
				break;

		case NPCCOLLISION:
				ret=FFCore.npc_collision();
				break;

		case NPCLINEDUP:
				ret=FFCore.npc_linedup();
				break;

		case CREATEBITMAP:
		{
			ret=FFCore.do_create_bitmap();
			break;
		}


		case MAPDATAVALID:		GET_MAPDATA_VAR_BYTE(valid, "Valid"); break;		//b
		case MAPDATAGUY: 		GET_MAPDATA_VAR_BYTE(guy, "Guy"); break;		//b
		case MAPDATASTRING:		GET_MAPDATA_VAR_INT32(str, "String"); break;		//w
		case MAPDATAROOM: 		GET_MAPDATA_VAR_BYTE(room, "RoomType");	break;		//b
		case MAPDATAITEM: 		GET_MAPDATA_VAR_BYTE(item, "Item"); break;		//b
		case MAPDATAHASITEM: 		GET_MAPDATA_VAR_BYTE(hasitem, "HasItem"); break;	//b
		case MAPDATATILEWARPTYPE: 	GET_MAPDATA_BYTE_INDEX(tilewarptype, "TileWarpType", 3); break;	//b, 4 of these
		//case MAPDATATILEWARPOVFLAGS: 	GET_MAPDATA_VAR_BYTE(tilewarpoverlayflags, "TileWarpOverlayFlags"); break;	//b, tilewarpoverlayflags
		case MAPDATADOORCOMBOSET: 	GET_MAPDATA_VAR_INT32(door_combo_set, "DoorComboSet"); break;	//w
		case MAPDATAWARPRETX:	 	GET_MAPDATA_BYTE_INDEX(warpreturnx, "WarpReturnX", 3); break;	//b, 4 of these
		case MAPDATAWARPRETY:	 	GET_MAPDATA_BYTE_INDEX(warpreturny, "WarpReturnY", 3); break;	//b, 4 of these
		case MAPDATAWARPRETURNC: 	GET_MAPDATA_VAR_INT32(warpreturnc, "WarpReturnC"); break;	//w
		case MAPDATASTAIRX: 		GET_MAPDATA_VAR_BYTE(stairx, "StairsX"); break;	//b
		case MAPDATASTAIRY: 		GET_MAPDATA_VAR_BYTE(stairy, "StairsY"); break;	//b
		case MAPDATAITEMX:		GET_MAPDATA_VAR_BYTE(itemx, "ItemX"); break; //itemx
		case MAPDATAITEMY:		GET_MAPDATA_VAR_BYTE(itemy, "ItemY"); break;	//itemy
		case MAPDATACOLOUR: 		GET_MAPDATA_VAR_INT32(color, "CSet"); break;	//w
		case MAPDATAENEMYFLAGS: 	GET_MAPDATA_VAR_BYTE(enemyflags, "EnemyFlags");	break;	//b
		case MAPDATADOOR: 		GET_MAPDATA_BYTE_INDEX(door, "Door", 3); break;	//b, 4 of these
		case MAPDATATILEWARPDMAP: 	GET_MAPDATA_VAR_INDEX32(tilewarpdmap, "TileWarpDMap", 3); break;	//w, 4 of these
		case MAPDATATILEWARPSCREEN: 	GET_MAPDATA_BYTE_INDEX(tilewarpscr, "TileWarpScreen", 3); break;	//b, 4 of these
		case MAPDATAEXITDIR: 		GET_MAPDATA_VAR_BYTE(exitdir, "ExitDir"); break;	//b
		case MAPDATAENEMY: 		GET_MAPDATA_VAR_INDEX32(enemy, "Enemy", 9); break;	//w, 10 of these
		case MAPDATAPATTERN: 		GET_MAPDATA_VAR_BYTE(pattern, "Pattern"); break;	//b
		case MAPDATASIDEWARPTYPE: 	GET_MAPDATA_BYTE_INDEX(sidewarptype, "SideWarpType", 3); break;	//b, 4 of these
		//case MAPDATASIDEWARPOVFLAGS: 	GET_MAPDATA_VAR_BYTE(sidewarpoverlayflags, "SideWarpOverlayFlags"); break;	//b
		case MAPDATAWARPARRIVALX: 	GET_MAPDATA_VAR_BYTE(warparrivalx, "WarpArrivalX"); break;	//b
		case MAPDATAWARPARRIVALY: 	GET_MAPDATA_VAR_BYTE(warparrivaly, "WarpArrivalY"); break;	//b
		case MAPDATAPATH: 		GET_MAPDATA_BYTE_INDEX(path, "MazePath", 3); break;	//b, 4 of these
		case MAPDATASIDEWARPSC: 	GET_MAPDATA_BYTE_INDEX(sidewarpscr, "SideWarpScreen", 3); break;	//b, 4 of these
		case MAPDATAINITD:	 	GET_MAPDATA_VAR_INDEX32(screeninitd, "InitD", 8); break;	//w, 4 of these
		case MAPDATASIDEWARPDMAP: 	GET_MAPDATA_VAR_INDEX32(sidewarpdmap, "SideWarpDMap", 3); break;	//w, 4 of these
		case MAPDATASIDEWARPINDEX: 	GET_MAPDATA_VAR_BYTE(sidewarpindex, "SideWarpIndex"); break;	//b
		case MAPDATAUNDERCOMBO: 	GET_MAPDATA_VAR_INT32(undercombo, "UnderCombo"); break;	//w
		case MAPDATAUNDERCSET:	 	GET_MAPDATA_VAR_BYTE(undercset,	"UnderCSet"); break; //b
		case MAPDATACATCHALL:	 	GET_MAPDATA_VAR_INT32(catchall,	"Catchall"); break; //W

		case MAPDATACSENSITIVE: 	GET_MAPDATA_VAR_BYTE(csensitive, "CSensitive"); break;	//B
		case MAPDATANORESET: 		GET_MAPDATA_VAR_INT32(noreset, "NoReset"); break;	//W
		case MAPDATANOCARRY: 		GET_MAPDATA_VAR_INT32(nocarry, "NoCarry"); break;	//W
		case MAPDATALAYERMAP:	 	GET_MAPDATA_LAYER_INDEX(layermap, "LayerMap", 6); break;	//B, 6 OF THESE
		case MAPDATALAYERSCREEN: 	GET_MAPDATA_LAYER_INDEX(layerscreen, "LayerScreen", 6); break;	//B, 6 OF THESE
		case MAPDATALAYEROPACITY: 	GET_MAPDATA_LAYER_INDEX(layeropacity, "LayerOpacity", 6); break;	//B, 6 OF THESE
		case MAPDATATIMEDWARPTICS: 	GET_MAPDATA_VAR_INT32(timedwarptics, "TimedWarpTimer"); break;	//W
		case MAPDATANEXTMAP: 		GET_MAPDATA_VAR_BYTE(nextmap, "NextMap"); break;	//B
		case MAPDATANEXTSCREEN: 	GET_MAPDATA_VAR_BYTE(nextscr, "NextScreen"); break;	//B
		case MAPDATASECRETCOMBO: 	GET_MAPDATA_VAR_INDEX32(secretcombo, "SecretCombo", 127); break;	//W, 128 OF THESE
		case MAPDATASECRETCSET: 	GET_MAPDATA_BYTE_INDEX(secretcset, "SecretCSet", 127); break;	//B, 128 OF THESE
		case MAPDATASECRETFLAG: 	GET_MAPDATA_BYTE_INDEX(secretflag, "SecretFlags", 127); break;	//B, 128 OF THESE

		case MAPDATAVIEWX: 		GET_MAPDATA_VAR_INT32(viewX, "ViewX"); break;	//W
		case MAPDATASCRIPT: 		GET_MAPDATA_VAR_INT32(script, "Script"); break;	//W
		case MAPDATAVIEWY: 		GET_MAPDATA_VAR_INT32(viewY, "ViewY"); break; //W
		case MAPDATASCREENWIDTH: 	GET_MAPDATA_VAR_BYTE(scrWidth, "Width"); break;	//B
		case MAPDATASCREENHEIGHT: 	GET_MAPDATA_VAR_BYTE(scrHeight,	"Height"); break;	//B
		case MAPDATAENTRYX: 		GET_MAPDATA_VAR_BYTE(entry_x, "EntryX"); break;	//B
		case MAPDATAENTRYY: 		GET_MAPDATA_VAR_BYTE(entry_y, "EntryY"); break;	//B
		//case MAPDATANUMFF: 		GET_MAPDATA_VAR_INT16(numff, "NumFFCs"); break;	//INT16
		case MAPDATAFFDATA:         GET_MAPDATA_FFC_INDEX32(ffdata, "FFCData", 31); break;  //W, 32 OF THESE
		case MAPDATAFFCSET:         GET_MAPDATA_FFC_INDEX32(ffcset, "FFCCSet", 31); break;  //B, 32
		case MAPDATAFFDELAY:        GET_MAPDATA_FFC_INDEX32(ffdelay, "FFCDelay", 31); break;    //W, 32
		case MAPDATAFFX:        GET_MAPDATA_FFCPOS_INDEX32(ffx, "FFCX", 31); break; //INT32, 32 OF THESE
		case MAPDATAFFY:        GET_MAPDATA_FFCPOS_INDEX32(ffy, "FFCY", 31); break; //..
		case MAPDATAFFXDELTA:       GET_MAPDATA_FFCPOS_INDEX32(ffxdelta, "FFCVx", 31); break;   //..
		case MAPDATAFFYDELTA:       GET_MAPDATA_FFCPOS_INDEX32(ffydelta, "FFCVy", 31); break;   //..
		case MAPDATAFFXDELTA2:      GET_MAPDATA_FFCPOS_INDEX32(ffxdelta2, "FFCAx", 31); break;  //..
		case MAPDATAFFYDELTA2:      GET_MAPDATA_FFCPOS_INDEX32(ffydelta2, "FFCAy", 31); break;  //..
		case MAPDATAFFFLAGS:        GET_MAPDATA_FFC_INDEX32(ffflags, "FFCFlags", 31); break;    //INT16, 32 OF THESE
		case MAPDATASIDEWARPID: 
		{
			int indx = ri->d[0] / 10000;
			if ( ri->mapsref == LONG_MAX )
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n","SideWarpID");
				ret = -10000;
			}
			else
			{
				mapscr *m = GetMapscr(ri->mapsref);
				ret = (((m->flags2 >> indx) & 1)
					? (m->sidewarpindex >> (2*indx)) & 3 //Return which warp is set
					: -1 //Returns -1 if no warp is set
					)*10000;
			} 
			break;
		}
		//Number of ffcs that are in use (have valid data
		case MAPDATANUMFF: 	
		{
			int indx = ri->d[0] / 10000;
			if ( !indx )
			{
				Z_scripterrlog("Invalid Index passed to mapdata->NumFFCs[%d].\n Valid indices are 1 through [32].\n", indx);
				ret = 0;
			}
			else if(((unsigned)indx)>32)
			{
				Z_scripterrlog("Invalid Index passed to mapdata->NumFFCs[%d].\n Valid indices are 1 through [32].\n", indx);
				ret = 0;
			}
			else if ( ri->mapsref == LONG_MAX )
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n","NumFFCs[]");
				ret = 0;
			}
			else
			{
				--indx;
				mapscr *m = GetMapscr(ri->mapsref);
				ret = (((m->numff) & (1<<indx))) ? 10000 : 0;
				//ret = ((tmpscr->hidescriptlayers >> indx) & 1) ? 0 : 10000;
			}
			break;
		}

		case MAPDATATILEWARPOVFLAGS: 
		{
			int indx = ri->d[0] / 10000;
			if ( ((unsigned)indx) > 3 ) 
			{
				Z_scripterrlog("Invalid index passed to TileWarpOverlayFlags[%d].\n. Valid indices are [0] through [3].\n", indx);
				ret = 0;
			}
			else if ( ri->mapsref == LONG_MAX )
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n","NumFFCs[]");
				ret = 0;
			}
			else
			{
				mapscr *m = GetMapscr(ri->mapsref);
				ret = (m->tilewarpoverlayflags & (1<<indx))?10000:0;
			}
			break;
		}

		case MAPDATASIDEWARPOVFLAGS: 
		{
			int indx = ri->d[0] / 10000;
			if ( ((unsigned)indx) > 3 ) 
			{
				Z_scripterrlog("Invalid index passed to SideWarpOverlayFlags[%d].\n. Valid indices are [0] through [3].\n", indx);
				ret = 0;
			}
			else if ( ri->mapsref == LONG_MAX )
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n","NumFFCs[]");
				ret = 0;
			}
			else
			{
				mapscr *m = GetMapscr(ri->mapsref);
				ret = (m->sidewarpoverlayflags & (1<<indx))?10000:0;
			}
			break;
		}

		case MAPDATATWARPRETSQR:
		{
			int indx = ri->d[0] / 10000;
			if ( ((unsigned)indx) > 3)
			{
				ret = -10000;
				Z_scripterrlog("Invalid Array Index passed to mapdata->TileWarpReturnSquare[]: %d\n", indx);
				
			}
			else if ( ri->mapsref == LONG_MAX )
				{
					Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","str"); 
					ret = -10000; 
				}
				else 
				{ 
				mapscr *m = GetMapscr(ri->mapsref);
				ret = ((m->warpreturnc>>(indx*2))&3) * 10000;
			}
			break;
		}

		case MAPDATASWARPRETSQR:
		{
			int indx = ri->d[0] / 10000;
			if ( ((unsigned)indx) > 3)
			{
				ret = -10000;
				Z_scripterrlog("Invalid Array Index passed to mapdata->TileWarpReturnSquare[]: %d\n", indx);
				
			}
			else if ( ri->mapsref == LONG_MAX )
				{
					Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","str"); 
					ret = -10000; 
				}
				else 
				{ 
				mapscr *m = GetMapscr(ri->mapsref);
				ret = ((m->warpreturnc>>(8+(indx*2)))&3) * 10000;
			}
			break;
		}
		
		case MAPDATAFFWIDTH:       
		{
			if ( ri->mapsref == LONG_MAX )
			{
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","FFCTileWidth[]");
				ret = -10000;
				break;
			}
			else
			{
				mapscr *m = GetMapscr(ri->mapsref);
				int indx = (ri->d[0] / 10000)-1;
				if ( indx < 0 || indx > 32 )
				{
					Z_scripterrlog("Invalid FFC Index passed to MapData->FFCTileWidth[]: %d\n", indx+1);
					ret = -10000;
					break;
				}
				ret=((m->ffwidth[indx]>>6)+1)*10000;
				break;
			}
		}
		
		//GET_MAPDATA_BYTE_INDEX(ffwidth, "FFCTileWidth");  //B, 32 OF THESE
		case MAPDATAFFHEIGHT:      
		{
			if ( ri->mapsref == LONG_MAX  )
			{
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","FFCTileHeight[]");
				ret = -10000;
				break;
			}
			else
			{
				mapscr *m = GetMapscr(ri->mapsref);
				int indx = (ri->d[0] / 10000)-1;
				if ( indx < 0 || indx > 32 )
				{
					Z_scripterrlog("Invalid FFC Index passed to MapData->FFCTileHeight[]: %d\n", indx+1);
					ret = -10000;
					break;
				}
				ret=((m->ffheight[indx]>>6)+1)*10000;
				break;
			}
			
		}
		 
		//EffectWidth tmpscr->ffwidth[ri->ffcref]= (tmpscr->ffwidth[ri->ffcref]&63) | ((((value/10000)-1)&3)<<6);
		 
		//GET_MAPDATA_BYTE_INDEX(ffheight, "FFCTileHeight"  //B, 32 OF THESE
		case MAPDATAFFEFFECTWIDTH:     
		{
			if ( ri->mapsref == LONG_MAX  )
			{
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","FFCEffectWidth[]");
				ret = -10000;
				break;
			}
			else
			{
				mapscr *m = GetMapscr(ri->mapsref);
				int indx = (ri->d[0] / 10000)-1;
				if ( indx < 0 || indx > 32 )
				{
					Z_scripterrlog("Invalid FFC Index passed to MapData->FFCEffectWidth[]: %d\n", indx+1);
					ret = -10000;
					break;
				}
				ret=((m->ffwidth[indx]&0x3F)+1)*10000;
				break;
			}
		}
		
		//GET_MAPDATA_BYTE_INDEX(ffwidth, "FFCEffectWidth");    //B, 32 OF THESE
		case MAPDATAFFEFFECTHEIGHT:
		{
			if ( ri->mapsref == LONG_MAX  )
			{
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","FFCEffectHeight[]");
				ret = -10000;
				break;
			}
			else
			{
				mapscr *m = GetMapscr(ri->mapsref);
				int indx = (ri->d[0] / 10000)-1;
				if ( indx < 0 || indx > 32 )
				{
					Z_scripterrlog("Invalid FFC Index passed to MapData->FFCEffectHeight[]: %d\n", indx+1);
					ret = -10000;
					break;
				}
				ret=((m->ffheight[indx]&0x3F)+1)*10000;
				
				break;
			}
		}
			
		//GET_MAPDATA_BYTE_INDEX(ffheight, "FFCEffectHeight"    //B, 32 OF THESE   
		 
		case MAPDATAFFLINK:         GET_MAPDATA_FFC_INDEX32(fflink, "FFCLink", 31); break;  //B, 32 OF THESE
		case MAPDATAFFSCRIPT:       GET_MAPDATA_FFC_INDEX32(ffscript, "FFCScript", 31); break;  //W, 32 OF THESE

		case MAPDATAINTID: 	 //Same form as SetScreenD()
			//SetFFCInitD(ffindex, d, value)
		{
			if ( ri->mapsref == LONG_MAX  )
			{
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","GetFFCInitD()");
				ret = -10000;
				break;
			}
			else
			{
				mapscr *m = GetMapscr(ri->mapsref); 
				int ffid = (ri->d[0]/10000) -1;
				int indx = ri->d[1]/10000;
					
				if ( (unsigned)ffid > 31 ) 
				{
					Z_scripterrlog("Invalid FFC id passed to mapdata->FFCInitD[]: %d",ffid); 
					ret = -10000;
				}
				else if ( (unsigned)indx > 7 )
				{
					Z_scripterrlog("Invalid InitD[] index passed to mapdata->FFCInitD[]: %d",indx);
					ret = -10000;
				}
				else
				{ 
					ret = (m->initd[ffid][indx]);
				}
				
				//int ffindex = ri->d[0]/10000;
				//int d = ri->d[1]/10000;
				//int v = (value/10000);
			}	
			break;
		}	



		//initd	//INT32 , 32 OF THESE, EACH WITH 10 INDICES. 

		case MAPDATAINITA: 		
			//same form as SetScreenD
		{
			if ( ri->mapsref == LONG_MAX  )
			{
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","GetFFCInitD()");
				ret = -10000;
				break;
			}
			else
			{
				mapscr *m = GetMapscr(ri->mapsref); 
				//int ffindex = ri->d[0]/10000;
				//int d = ri->d[1]/10000;
				//int v = (value/10000);
				
				int ffid = (ri->d[0]/10000) -1;
				int indx = ri->d[1]/10000;
					
				if ( (unsigned)ffid > 31 ) 
				{
					Z_scripterrlog("Invalid FFC id passed to mapdata->FFCInitD[]: %d",ffid); 
					ret = -10000;
				}
				else if ( (unsigned)indx > 1 )
				{
					Z_scripterrlog("Invalid InitD[] index passed to mapdata->FFCInitD[]: %d",indx);
					ret = -10000;
				}
				else
				{ 
					ret = (m->inita[ffid][indx]);
				}
				break;
			}
		}	

			//inita	//INT32, 32 OF THESE, EACH WITH 2
		case MAPDATAFFINITIALISED: 	GET_MAPDATA_BOOL_INDEX(initialized, "FFCRunning", 31); break;	//BOOL, 32 OF THESE
		case MAPDATASCRIPTENTRY: 	GET_MAPDATA_VAR_INT32(script_entry, "ScriptEntry"); break;	//W
		case MAPDATASCRIPTOCCUPANCY: 	GET_MAPDATA_VAR_INT32(script_occupancy,	"ScriptOccupancy");  break;//W
		case MAPDATASCRIPTEXIT: 	GET_MAPDATA_VAR_INT32(script_exit, "ExitScript"); break;	//W
		case MAPDATAOCEANSFX:	 	GET_MAPDATA_VAR_BYTE(oceansfx, "OceanSFX"); break;	//B
		case MAPDATABOSSSFX: 		GET_MAPDATA_VAR_BYTE(bosssfx, "BossSFX"); break;	//B
		case MAPDATASECRETSFX:	 	GET_MAPDATA_VAR_BYTE(secretsfx, "SecretSFX"); break;	//B
		case MAPDATAHOLDUPSFX:	 	GET_MAPDATA_VAR_BYTE(holdupsfx,	"ItemSFX"); break; //B
		case MAPDATASCREENMIDI:
		{
			if ( ri->mapsref == LONG_MAX )
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n","MIDI");
				ret = -10000;
			}
			else
			{
				mapscr *m = GetMapscr(ri->mapsref);
				ret = ((m->screen_midi+(MIDIOFFSET_MAPSCR-MIDIOFFSET_ZSCRIPT)) *10000);
			}
			break;
		}
		case MAPDATALENSLAYER:	 	GET_MAPDATA_VAR_BYTE(lens_layer, "LensLayer"); break;	//B, OLD QUESTS ONLY?
		case MAPDATAMAP:
		{
			if ( ri->mapsref == LONG_MAX )
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n","Map");
				ret = -10000;
			}
			ret = getMap(ri->mapsref) * 10000;
			break;
		}
		case MAPDATASCREEN:
		{
			if ( ri->mapsref == LONG_MAX )
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n","Screen");
				ret = -10000;
			}
			ret = getScreen(ri->mapsref) * 10000;
			break;
		}

		case MAPDATAFLAGS: 
		{
			if ( get_bit(quest_rules, qr_OLDMAPDATAFLAGS) )
			{
				mapscr *m = GetMapscr(ri->mapsref);
				ret = get_screenflags(m,vbound(ri->d[0] / 10000,0,9));
			}
			else
			{
				int flagid = (ri->d[0])/10000;
				mapscr *m = GetMapscr(ri->mapsref); 
				//bool valtrue = ( value ? 10000 : 0);
				switch(flagid)
				{
					case 0: ret = (m->flags * 10000); break;
					case 1: ret = (m->flags2 * 10000); break;
					case 2: ret = (m->flags3 * 10000); break;
					case 3: ret = (m->flags4 * 10000); break;
					case 4: ret = (m->flags5 * 10000); break;
					case 5: ret = (m->flags6 * 10000); break;
					case 6: ret = (m->flags7 * 10000); break;
					case 7: ret = (m->flags8 * 10000); break;
					case 8: ret = (m->flags9 * 10000); break;
					case 9: ret = (m->flags10 * 10000); break;
					default:
					{
						Z_scripterrlog("Invalid index passed to mapdata->flags[]: %d\n", flagid); 
						ret = -10000;
						break;
						
					}
				}
			}
			
			break;
			//GET_MAPDATA_BYTE_INDEX	//B, 11 OF THESE, flags, flags2-flags10
		}

		case MAPDATAMISCD:
		{
			int indx = (ri->d[0])/10000;
			int mi = ri->mapsref;
			mi -= 8*((ri->mapsref) / MAPSCRS);
			if( ((unsigned)indx) > 7 )
			{
				Z_scripterrlog("You were trying to reference an out-of-bounds array index for a screen's D[] array (%ld); valid indices are from 0 to 7.\n", indx);
				ret = -10000;
				break;
			}
			else 
			{
				ret = (game->screen_d[mi][indx]) * 10000;
				break;
			}
		}

		case MAPDATACOMBODD:
		{
			if ( ri->mapsref == LONG_MAX )
			{
				Z_scripterrlog("Mapdata->%s pointer (%d) is either invalid or uninitialised.\n","mapdata->ComboD[]()",ri->mapsref);
				break;
			}
			else
			{
				mapscr *m = GetMapscr(ri->mapsref); 
				//int ffindex = ri->d[0]/10000;
				//int d = ri->d[1]/10000;
				//int v = (value/10000);
				int pos = ri->d[0] / 10000;
				if(BC::checkComboPos(pos, "mapdata->ComboD[pos]") != SH::_NoError)
				{
					ret = -10000; break;
				}
				else
				{
					ret = m->data[pos] * 10000;
					break;
				}
				
			}
			//GET_SCREENDATA_COMBO_VAR(data,  "mapdata->ComboD") break;
		}
			
		case MAPDATACOMBOCD:
		{
			if ( ri->mapsref == LONG_MAX )
			{
				Z_scripterrlog("Mapdata->%s pointer (%d) is either invalid or uninitialised.\n","mapdata->ComboC[]()",ri->mapsref);
				break;
			}
			else
			{
				mapscr *m = GetMapscr(ri->mapsref); 
				//int ffindex = ri->d[0]/10000;
				//int d = ri->d[1]/10000;
				//int v = (value/10000);
				int pos = ri->d[0] / 10000;
				if(BC::checkComboPos(pos, "mapdata->ComboC[pos]") != SH::_NoError)
				{
					ret = -10000; break;
				}
				else
				{
					ret = m->cset[pos] * 10000;
					break;
				}
			}
		}
			//GET_SCREENDATA_COMBO_VAR(cset,  "mapdata->ComboC") break;
			
		case MAPDATACOMBOFD:
		{
			if ( ri->mapsref == LONG_MAX )
			{
				Z_scripterrlog("Mapdata->%s pointer (%d) is either invalid or uninitialised.\n","mapdata->ComboF[]()",ri->mapsref);
				break;
			}
			else
			{
				mapscr *m = GetMapscr(ri->mapsref); 
				//int ffindex = ri->d[0]/10000;
				//int d = ri->d[1]/10000;
				//int v = (value/10000);
				int pos = ri->d[0] / 10000;
				if(BC::checkComboPos(pos, "mapdata->ComboF[pos]") != SH::_NoError)
				{
					ret = -10000; break;
				}
				else
				{
					ret = m->sflag[pos] * 10000;
					break;
				}
			}
		}
			//GET_SCREENDATA_COMBO_VAR(sflag, "mapdata->ComboF") break;
			

			
		case MAPDATACOMBOTD:
		{
			if ( ri->mapsref == LONG_MAX )
			{
				Z_scripterrlog("Mapdata->%s pointer (%d) is either invalid or uninitialised.\n","mapdata->ComboT[]()",ri->mapsref);
				break;
			}
			else
			{
				mapscr *m = GetMapscr(ri->mapsref); 
				//int ffindex = ri->d[0]/10000;
				//int d = ri->d[1]/10000;
				//int v = (value/10000);
				int pos = ri->d[0] / 10000;
				if(BC::checkComboPos(pos, "mapdata->ComboT[pos]") != SH::_NoError)
				{
					ret = -10000; break;
					
				}
				else
				{
					ret = combobuf[m->data[pos]].type * 10000;
					break;
				}
				
			}
		}
			//GET_MAPDATA_COMBO_VAR_BUF(type, "mapdata->ComboT") break;
			
		case MAPDATACOMBOID:
		{
			if ( ri->mapsref == LONG_MAX )
			{
				Z_scripterrlog("Mapdata->%s pointer (%d) is either invalid or uninitialised.\n","mapdata->ComboI[]()",ri->mapsref);
				break;
			}
			else
			{
				mapscr *m = GetMapscr(ri->mapsref); 
				//int ffindex = ri->d[0]/10000;
				//int d = ri->d[1]/10000;
				//int v = (value/10000);
				int pos = ri->d[0] / 10000;
				if(BC::checkComboPos(pos, "mapdata->ComboI[pos]") != SH::_NoError)
				{
					ret = -10000; break;
					
				}
				else
				{
					ret = combobuf[m->data[pos]].flag * 10000;
					break;
				}
				
			}
			//GET_SCREENDATA_COMBO_VAR(data,  "mapdata->ComboD") break;
		}
			//GET_MAPDATA_COMBO_VAR_BUF(flag, "mapdata->ComboI") break;
			
		case MAPDATACOMBOSD:
		{
			if ( ri->mapsref == LONG_MAX )
			{
				Z_scripterrlog("Mapdata->%s pointer (%d) is either invalid or uninitialised.\n","mapdata->ComboS[]()", ri->mapsref);
				break;
			}
			else
			{
				mapscr *m = GetMapscr(ri->mapsref); 
				//int ffindex = ri->d[0]/10000;
				//int d = ri->d[1]/10000;
				//int v = (value/10000);
				int pos = ri->d[0] / 10000;
				if(BC::checkComboPos(pos, "mapdata->ComboS[pos]") != SH::_NoError)
				{
					
					ret = -10000; break;
					
				}
				else
				{
					ret = (combobuf[m->data[pos]].walk & 0xF) * 10000;
					break;
				}	
			}
		}
		
		case MAPDATASCREENSTATED:
		{
			int mi = ri->mapsref;
			mi -= 8*((ri->mapsref) / MAPSCRS);
			ret=((game->maps[mi]>>((ri->d[0]/10000)))&1)?10000:0;
		}
		break;
		case MAPDATASCREENFLAGSD:
		{
			mapscr *m = GetMapscr(ri->mapsref);
			ret = get_screenflags(m,vbound(ri->d[0] / 10000,0,9));
			break;
		}
			
		case MAPDATASCREENEFLAGSD:
		{
			mapscr *m = GetMapscr(ri->mapsref);
			ret = get_screeneflags(m,vbound(ri->d[0] / 10000,0,2));
			break;
		}

		///----------------------------------------------------------------------------------------------------//
		//shopdata sd-> variables
	
		case SHOPDATATYPE:
		{
			int ref = ri->shopsref; 
			if ( ref > NUMINFOSHOPS || ref < 0 ) ret = 0;
			else ret = ( ( ref <= NUMSHOPS ) ? 10000 : 20000 ); 
			break;
		}
		case SHOPDATAITEM:
		{ 
			
			int ref = ri->shopsref; 
			bool isInfo = ( ref > NUMSHOPS && ref < LONG_MAX ); 
			int indx = ri->d[0] / 10000; 
			if ( indx < 0 || indx > 2 ) 
			{ 
				Z_scripterrlog("Invalid Array Index passed to shopdata->%s: %d\n", indx, "Item");
				ret = -10000;
			} 
			else 
			{ 
				if ( isInfo ) 
				{ 
					Z_scripterrlog("Attempted to load an 'item' from an infoshop, using shop ID: %d\n", ri->shopsref); 
					ret = -10000;
				} 
				else 
				{ 
					ret = ((int)(QMisc.shop[ref].item[indx]) * 10000); 
				} 
			} 
			break;
		} 
		
		
		// GET_SHOPDATA_VAR_INDEX(item, "Item", 2); break;
		case SHOPDATAHASITEM: 
		{ 
			
			int ref = ri->shopsref; 
			bool isInfo = ( ref > NUMSHOPS && ref < LONG_MAX ); 
			int indx = ri->d[0] / 10000; 
			if ( indx < 0 || indx > 2 ) 
			{ 
				Z_scripterrlog("Invalid Array Index passed to shopdata->%s: %d\n", indx, "HasItem"); 
				ret = -10000;
			} 
			else 
			{ 
				if ( isInfo ) 
				{ 
					Z_scripterrlog("Attempted to load 'hasitem' from an infoshop, using shop ID: %d\n", ri->shopsref); 
					ret = -10000;
				} 
				else 
				{ 
					ret = ((int)(QMisc.shop[ref].hasitem[indx]) * 10000); 
				} 
			} 
			break;
		} 
		
			
		//GET_SHOPDATA_VAR_INDEX(hasitem, "HasItem", 2); break;
		case SHOPDATAPRICE: 
		{ 
			
			int ref = ri->shopsref; 
			bool isInfo = ( ref > NUMSHOPS && ref < LONG_MAX ); 
			int indx = ri->d[0] / 10000; 
			if ( indx < 0 || indx > 2 ) 
			{ 
				Z_scripterrlog("Invalid Array Index passed to shopdata->%s: %d\n", indx, "Price"); 
				ret = -10000;
			} 
			else 
			{ 
				if ( isInfo ) 
				{ 
					ret = ((int)(QMisc.info[ref].price[indx]) * 10000); 
				} 
				else 
				{ 
					ret = ((int)(QMisc.shop[ref].price[indx]) * 10000); 
				} 
			} 
			break;
		} 
		
		
		//GET_SHOPDATA_VAR_INDEX(price, "Price", 2); break;
		//Pay for info
		case SHOPDATASTRING:
		{
			if (((unsigned)ri->shopsref) > NUMINFOSHOPS)
			{
				Z_scripterrlog("Invalid shop pointer passed to shopdata->String[]: %d\n", ri->shopsref); 
				ret = -10000;
			}
			else 
			{
				int ref = ri->shopsref; 
				bool isInfo = ( ref > NUMSHOPS && ref < LONG_MAX ); 
				int indx = ri->d[0] / 10000; 
				if ( indx < 0 || indx > 2 ) 
				{ 
					Z_scripterrlog("Invalid Array Index passed to shopdata->%s: %d\n", indx, "String"); 
				} 
				else 
				{ 
					if ( isInfo ) 
					{ 
						ret = ((int)(QMisc.info[ref].str[indx]) * 10000); 
					} 
					else 
					{ 
						ret = ((int)(QMisc.shop[ref].str[indx]) * 10000); 
					} 
				} 
		
		
			}
				
			//GET_SHOPDATA_VAR_INDEX(str, String, 2); break;
			break;
		}
		
		
		///----------------------------------------------------------------------------------------------------//
		//dmapdata dmd-> variables

		//getter
		case DMAPDATAID: ret = ri->dmapsref*10000; break; //read-only, equal to CurrentDMap
			
		case DMAPDATAMAP: 	//byte
		{
			ret = ((byte)DMaps[ri->dmapsref].map + 1) * 10000; break;
		}
		case DMAPDATALEVEL:	//word
		{
			ret = ((word)DMaps[ri->dmapsref].level) * 10000; break;
		}
		case DMAPDATAOFFSET:	//char
		{
			ret = ((char)DMaps[ri->dmapsref].xoff) * 10000; break;
		}
		case DMAPDATACOMPASS:	//byte
		{
			ret = ((byte)DMaps[ri->dmapsref].compass) * 10000; break;
		}
		case DMAPDATAPALETTE:	//word
		{
			ret = ((word)DMaps[ri->dmapsref].color) * 10000; break;
		}
		case DMAPSCRIPT:	//word
		{
			ret = (DMaps[ri->dmapsref].script) * 10000; break;
		}
		case DMAPDATAMIDI:	//byte
		{
			ret = (DMaps[ri->dmapsref].midi-MIDIOFFSET_DMAP) * 10000; break;
		}
		case DMAPDATACONTINUE:	//byte
		{
			ret = ((byte)DMaps[ri->dmapsref].cont) * 10000; break;
		}
		case DMAPDATATYPE:	//byte
		{
			ret = ((byte)DMaps[ri->dmapsref].type) * 10000; break;
		}
		case DMAPDATASIDEVIEW:	//byte
		{
			ret = ((DMaps[ri->dmapsref].sideview) ? 10000 : 0); break;
		}
		case DMAPDATAGRID:	//byte[8] --array
		{
			int indx = ri->d[0] / 10000;
			if ( indx < 0 || indx > 7 ) 
			{
				Z_scripterrlog("Invalid index supplied to dmapdata->Grid[]: %d\n", indx);
				ret = -10000;
				break;
			}
			else
			{
				ret = ((byte)DMaps[ri->dmapsref].grid[indx]) * 10000;  break;
			}
		}
		case DMAPINITD:	//byte[8] --array
		{
			int indx = ri->d[0] / 10000;
			if ( indx < 0 || indx > 7 ) 
			{
				Z_scripterrlog("Invalid index supplied to dmapdata->InitD[]: %d\n", indx);
				ret = -10000;
				break;
			}
			else
			{
				ret = DMaps[ri->dmapsref].initD[indx]; break;
			}
		}
		case DMAPDATAMINIMAPTILE:	//word - two of these, so let's do MinimapTile[2]
		{
			int indx = ri->d[0] / 10000;
			switch(indx)
			{
				case 0: { ret = ((word)DMaps[ri->dmapsref].minimap_1_tile) * 10000; break; }
				case 1: { ret = ((word)DMaps[ri->dmapsref].minimap_2_tile) * 10000; break; }
				default: 
				{
					Z_scripterrlog("Invalid index supplied to dmapdata->MiniMapTile[]: %d\n", indx);
					ret = -10000;
					break;
				}
			}
			break;
		}
		case DMAPDATAMINIMAPCSET:	//byte - two of these, so let's do MinimapCSet[2]
		{
			int indx = ri->d[0] / 10000;
			switch(indx)
			{
				case 0: { ret = ((byte)DMaps[ri->dmapsref].minimap_1_cset) * 10000; break; }
				case 1: { ret = ((byte)DMaps[ri->dmapsref].minimap_2_cset) * 10000; break; }
				default: 
				{
					Z_scripterrlog("Invalid index supplied to dmapdata->MiniMapCSet[]: %d\n", indx);
					ret = -10000;
					break;
				}
			}
			break;
		}
		case DMAPDATALARGEMAPTILE:	//word -- two of these, so let's to LargemapTile[2]
		{
			int indx = ri->d[0] / 10000;
			switch(indx)
			{
				case 0: { ret = ((word)DMaps[ri->dmapsref].largemap_1_tile) * 10000; break; }
				case 1: { ret = ((word)DMaps[ri->dmapsref].largemap_2_tile) * 10000; break; }
				default: 
				{
					Z_scripterrlog("Invalid index supplied to dmapdata->MapTile[]: %d\n", indx);
					ret = -10000;
					break;
				}
			}
			break;
		}
		case DMAPDATALARGEMAPCSET:	//word -- two of these, so let's to LargemaCSet[2]
		{
			int indx = ri->d[0] / 10000;
			switch(indx)
			{
				case 0: { ret = ((byte)DMaps[ri->dmapsref].largemap_1_cset) * 10000; break; }
				case 1: { ret = ((byte)DMaps[ri->dmapsref].largemap_2_cset) * 10000; break; }
				default: 
				{
					Z_scripterrlog("Invalid index supplied to dmapdata->MapCSet[]: %d\n", indx);
					ret = -10000;
					break;
				}
			}
			break;
		}
		case DMAPDATAMUISCTRACK:	//byte
		{
			ret = ((byte)DMaps[ri->dmapsref].tmusictrack) * 10000; break;
		}
		case DMAPDATASUBSCRA:	 //byte, active subscreen
		{
			ret = ((byte)DMaps[ri->dmapsref].active_subscreen) * 10000; break;
		}
		case DMAPDATASUBSCRP:	 //byte, passive subscreen
		{
			ret = ((byte)DMaps[ri->dmapsref].passive_subscreen) * 10000; break;
		}
		case DMAPDATADISABLEDITEMS:	 //byte[iMax]
		{
			int indx = ri->d[0] / 10000;
			if ( indx < 0 || indx > (iMax-1) ) 
			{
				Z_scripterrlog("Invalid index supplied to dmapdata->Grid[]: %d\n", indx);
				ret = -10000;
				break;
			}
			else
			{
				ret = ((byte)DMaps[ri->dmapsref].disableditems[indx]) * 10000; break;
			}
		}
		case DMAPDATAFLAGS:	 //long
		{
			ret = (DMaps[ri->dmapsref].flags) * 10000; break;
		}
		case DMAPDATAASUBSCRIPT:	//word
		{
			ret = (DMaps[ri->dmapsref].active_sub_script) * 10000; break;
		}
		case DMAPDATAPSUBSCRIPT:	//word
		{
			ret = (DMaps[ri->dmapsref].passive_sub_script) * 10000; break;
		}
		case DMAPDATASUBINITD:	//byte[8] --array
		{
			int indx = ri->d[0] / 10000;
			if ( indx < 0 || indx > 7 ) 
			{
				Z_scripterrlog("Invalid index supplied to dmapdata->SubInitD[]: %d\n", indx);
				ret = -10000;
				break;
			}
			else
			{
				ret = DMaps[ri->dmapsref].sub_initD[indx]; break;
			}
		}
		//case DMAPDATAGRAVITY:	 //unimplemented
		//case DMAPDATAJUMPLAYER:	 //unimplemented
			
		///----------------------------------------------------------------------------------------------------//
		//messagedata msgd-> variables
		case MESSAGEDATANEXT: //W
		{
			long ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Next") != SH::_NoError)
			{
				ret = -10000; break;
			}
			else 
			{
				ret = ((int)MsgStrings[ID].nextstring) * 10000;
				break;
			}
		}	

		case MESSAGEDATATILE: //W
		{
			long ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Tile") != SH::_NoError)
				ret = -10000;
			else 
				ret = ((int)MsgStrings[ID].tile) * 10000;
			break;
		}	

		case MESSAGEDATACSET: //b
		{
			long ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->CSet") != SH::_NoError)
				ret = -10000;
			else 
				ret = ((int)MsgStrings[ID].cset) * 10000;
			break;
		}	
		case MESSAGEDATATRANS: //BOOL
		{
			long ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Transparent") != SH::_NoError)
				ret = -10000;
			else 
				ret = ((MsgStrings[ID].trans)?10000:0);
			break;
		}	
		case MESSAGEDATAFONT: //B
		{
			long ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Font") != SH::_NoError)
				ret = -10000;
			else 
				ret = (int)MsgStrings[ID].font * 10000;
			break;
		}	
		case MESSAGEDATAX: //SHORT
		{
			long ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->X") != SH::_NoError)
				ret = -10000;
			else 
				ret = ((int)MsgStrings[ID].x) * 10000;
			break;
		}	
		case MESSAGEDATAY: //SHORT
		{
			long ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Y") != SH::_NoError)
				ret = -10000;
			else 
				ret = ((int)MsgStrings[ID].y) * 10000;
			break;
		}	
		case MESSAGEDATAW: //UNSIGNED SHORT
		{
			long ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Width") != SH::_NoError)
				ret = -10000;
			else 
				ret = ((int)MsgStrings[ID].w) * 10000;
			break;
		}	
		case MESSAGEDATAH: //UNSIGNED SHORT
		{
			long ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Height") != SH::_NoError)
				ret = -10000;
			else 
				ret = ((int)MsgStrings[ID].h) * 10000;
			break;
		}	
		case MESSAGEDATASFX: //BYTE
		{
			long ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Sound") != SH::_NoError)
				ret = -10000;
			else 
				ret = ((int)MsgStrings[ID].sfx) * 10000;
			break;
		}	
		case MESSAGEDATALISTPOS: //WORD
		{
			long ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->ListPosition") != SH::_NoError)
				ret = -10000;
			else 
				ret = ((int)MsgStrings[ID].listpos) * 10000;
			break;
		}	
		case MESSAGEDATAVSPACE: //BYTE
		{
			long ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->VSpace") != SH::_NoError)
				ret = -10000;
			else 
				ret = ((int)MsgStrings[ID].vspace) * 10000;
			break;
		}	
		case MESSAGEDATAHSPACE: //BYTE
		{
			long ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->HSpace") != SH::_NoError)
				ret = -10000;
			else 
				ret = ((int)MsgStrings[ID].hspace) * 10000;
			break;
		}	
		case MESSAGEDATAFLAGS: //BYTE
		{
			long ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Flags") != SH::_NoError)
				ret = -10000;
			else 
				ret = ((int)MsgStrings[ID].stringflags) * 10000;
			break;
		}
		case MESSAGEDATAMARGINS: //BYTE, 4
		{
			int indx = ri->d[0] / 10000;
			if ( indx < 0 || indx > 3 ) 
			{
				Z_scripterrlog("Invalid index supplied to messagedata->Margins[]: %d\n", indx);
				ret = -10000;
				break;
			}
			long ID = ri->zmsgref;
			
			if(BC::checkMessage(ID, "messagedata->Margins[]") != SH::_NoError)
				ret = -10000;
			else
				ret = ((int)MsgStrings[ID].margins[indx]) * 10000;
			break;
		}
		case MESSAGEDATAPORTTILE: //INT
		{
			long ID = ri->zmsgref;
			
			if(BC::checkMessage(ID, "messagedata->PortraitTile") != SH::_NoError)
				ret = -10000;
			else
				ret = ((int)MsgStrings[ID].portrait_tile) * 10000;
			break;
		}
		case MESSAGEDATAPORTCSET: //BYTE
		{
			long ID = ri->zmsgref;
			
			if(BC::checkMessage(ID, "messagedata->PortraitCSet") != SH::_NoError)
				ret = -10000;
			else
				ret = ((int)MsgStrings[ID].portrait_cset) * 10000;
			break;
		}
		case MESSAGEDATAPORTX: //BYTE
		{
			long ID = ri->zmsgref;
			
			if(BC::checkMessage(ID, "messagedata->PortraitX") != SH::_NoError)
				ret = -10000;
			else
				ret = ((int)MsgStrings[ID].portrait_x) * 10000;
			break;
		}
		case MESSAGEDATAPORTY: //BYTE
		{
			long ID = ri->zmsgref;
			
			if(BC::checkMessage(ID, "messagedata->PortraitY") != SH::_NoError)
				ret = -10000;
			else
				ret = ((int)MsgStrings[ID].portrait_y) * 10000;
			break;
		}
		case MESSAGEDATAPORTWID: //BYTE
		{
			long ID = ri->zmsgref;
			
			if(BC::checkMessage(ID, "messagedata->PortraitTileWidth") != SH::_NoError)
				ret = -10000;
			else
				ret = ((int)MsgStrings[ID].portrait_tw) * 10000;
			break;
		}
		case MESSAGEDATAPORTHEI: //BYTE
		{
			long ID = ri->zmsgref;
			
			if(BC::checkMessage(ID, "messagedata->PortraitTileHeight") != SH::_NoError)
				ret = -10000;
			else
				ret = ((int)MsgStrings[ID].portrait_th) * 10000;
			break;
		}
		case MESSAGEDATATEXTWID:
		{
			ret = do_msgwidth(ri->zmsgref, "messagedata->TextWidth")*10000;
			break;
		}
		case MESSAGEDATATEXTHEI:
		{
			ret = do_msgheight(ri->zmsgref, "messagedata->TextHeight")*10000;
			break;
		}
		case MESSAGEDATAFLAGSARR: //BOOL, 7
		{
			int indx = ri->d[0] / 10000;
			long ID = ri->zmsgref;
			
			if(BC::checkMessage(ID, "messagedata->Flags[]") != SH::_NoError)
				ret = -10000;
			else
			{
				switch(indx)
				{
					case 0:
						ret = (MsgStrings[ID].stringflags & STRINGFLAG_WRAP)!=0 ? 10000 : 0;
						break;
					case 1:
						ret = (MsgStrings[ID].stringflags & STRINGFLAG_CONT)!=0 ? 10000 : 0;
						break;
					case 2: //Not implemented
						ret = 0;//ret = (MsgStrings[ID].stringflags & STRINGFLAG_CENTER)!=0 ? 10000 : 0;
						break;
					case 3: //Not implemented
						ret = 0;//ret = (MsgStrings[ID].stringflags & STRINGFLAG_RIGHT)!=0 ? 10000 : 0;
						break;
					case 4:
						ret = (MsgStrings[ID].stringflags & STRINGFLAG_FULLTILE)!=0 ? 10000 : 0;
						break;
					case 5:
						ret = (MsgStrings[ID].stringflags & STRINGFLAG_TRANS_BG)!=0 ? 10000 : 0;
						break;
					case 6:
						ret = (MsgStrings[ID].stringflags & STRINGFLAG_TRANS_FG)!=0 ? 10000 : 0;
						break;
					default:
						Z_scripterrlog("Invalid index supplied to messagedata->Flags[]: %d\n", indx);
						ret = -10000;
				}
			}
			break;
		}

		///----------------------------------------------------------------------------------------------------//
		//combodata cd-> Getter variables
		#define	GET_COMBO_VAR_INT(member, str) \
		{ \
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
			{ \
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
				ret = -10000; \
			} \
			else \
			{ \
				ret = (combobuf[ri->combosref].member *10000); \
			} \
		} \

		#define	GET_COMBO_VAR_BYTE(member, str) \
		{ \
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
			{ \
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
				ret = -10000; \
			} \
			else \
			{ \
				ret = (combobuf[ri->combosref].member *10000); \
			} \
		} \
		
		#define	GET_COMBO_VAR_DWORD(member, str) \
		{ \
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
			{ \
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
				ret = -10000; \
			} \
			else \
			{ \
				ret = (combobuf[ri->combosref].member *10000); \
			} \
		} \
		
		#define GET_COMBO_VAR_INDEX(member, str, indexbound) \
		{ \
				int indx = ri->d[0] / 10000; \
				if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
				{ \
					Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
					ret = -10000; \
				} \
				else if ( indx < 0 || indx > indexbound ) \
				{ \
					Z_scripterrlog("Invalid Array Index passed to combodata->%s: %d\n", indx, str); \
					ret = -10000; \
				} \
				else \
				{ \
					ret = (combobuf[ri->combosref].member[indx] * 10000); \
				} \
		}

		#define GET_COMBO_BYTE_INDEX(member, str, indexbound) \
		{ \
				int indx = ri->d[0] / 10000; \
				if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
				{ \
					Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
					ret = -10000; \
				} \
				else if ( indx < 0 || indx > indexbound ) \
				{ \
					Z_scripterrlog("Invalid Array Index passed to combodata->%s: %d\n", indx, str); \
					ret = -10000; \
				} \
				else \
				{ \
					ret = (combobuf[ri->combosref].member[indx] * 100000); \
				} \
		}
		
		#define GET_COMBO_FLAG(member, str, indexbound) \
		{ \
			long flag =  (value/10000);  \
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
			{ \
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
			} \
			else \
			{ \
				ret = (combobuf[ri->combosref].member&flag) ? 10000 : 0); \
			} \
		} \

		//comboclass macros

		#define	GET_COMBOCLASS_VAR_INT(member, str) \
		{ \
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
			{ \
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
				ret = -10000; \
			} \
			else \
			{ \
				ret = (combo_class_buf[combobuf[ri->combosref].type].member *10000); \
			} \
		} \

		#define	GET_COMBOCLASS_VAR_BYTE(member, str) \
		{ \
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
			{ \
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
				ret = -10000; \
			} \
			else \
			{ \
				ret = (combo_class_buf[combobuf[ri->combosref].type].member *10000); \
			} \
		} \
		
		#define	GET_COMBOCLASS_VAR_DWORD(member, str) \
		{ \
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
			{ \
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
				ret = -10000; \
			} \
			else \
			{ \
				ret = (combo_class_buf[combobuf[ri->combosref].type].member *10000); \
			} \
		} \
		
		#define GET_COMBOCLASS_VAR_INDEX(member, str, indexbound) \
		{ \
				int indx = ri->d[0] / 10000; \
				if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
				{ \
					Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
					ret = -10000; \
				} \
				else if ( indx < 0 || indx > indexbound ) \
				{ \
					Z_scripterrlog("Invalid Array Index passed to combodata->%s: %d\n", indx, str); \
					ret = -10000; \
				} \
				else \
				{ \
					ret = (combo_class_buf[combobuf[ri->combosref].type].member[indx] * 10000); \
				} \
		}

		#define GET_COMBOCLASS_BYTE_INDEX(member, str, indexbound) \
		{ \
				int indx = ri->d[0] / 10000; \
				if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
				{ \
					Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
					ret = -10000; \
				} \
				else if ( indx < 0 || indx > indexbound ) \
				{ \
					Z_scripterrlog("Invalid Array Index passed to combodata->%s: %d\n", indx, str); \
					ret = -10000; \
				} \
				else \
				{ \
					ret = (combo_class_buf[combobuf[ri->combosref].type].member[indx] * 100000); \
				} \
		}
		
		#define GET_COMBOCLASS_FLAG(member, str, indexbound) \
		{ \
			long flag =  (value/10000);  \
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
			{ \
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
			} \
			else \
			{ \
				ret = (combo_class_buf[combobuf[ri->combosref].type].member&flag) ? 10000 : 0); \
			} \
		} \
		
		case COMBOXR:
		{
			//ri->combosref = id; //'this' pointer
			//ri->comboposref = i; //used for X(), Y(), Layer(), and so forth.
			if ( curScriptType == SCRIPT_COMBO )
			{
				ret = (( ((ri->comboposref)%16*16) ) * 10000); //comboscriptstack[i]
				//this may be wrong...may need a special new var for this, storing the exact combopos
				//i is the current script number
			}
			else
			{
				Z_scripterrlog("combodata->X() can only be called by combodata scripts, but you tried to use it from script type %s, script token %s\n", scripttypenames[curScriptType], comboscriptmap[ri->combosref].scriptname.c_str() );
				ret = -10000;
			}
			break;
		}

		case COMBOYR:
		{
			if ( curScriptType == SCRIPT_COMBO )
			{
				ret = (( ((ri->comboposref)&0xF0) ) * 10000); //comboscriptstack[i]
			}
			else
			{
				Z_scripterrlog("combodata->X() can only be called by combodata scripts, but you tried to use it from script type %s, script token %s\n", scripttypenames[curScriptType], comboscriptmap[ri->combosref].scriptname.c_str() );
				ret = -10000;
			}
			break;
		}
		case COMBOPOSR:
		{
			if ( curScriptType == SCRIPT_COMBO )
			{
				ret = (( ((ri->comboposref)%176) ) * 10000); //comboscriptstack[i]
			}
			else
			{
				Z_scripterrlog("combodata->Pos() can only be called by combodata scripts, but you tried to use it from script type %s, script token %s\n", scripttypenames[curScriptType], comboscriptmap[ri->combosref].scriptname.c_str() );
				ret = -10000;
			}
			break;
		}
		
		//NEWCOMBO STRUCT
		case COMBODTILE:		GET_COMBO_VAR_DWORD(tile, "Tile"); break;					//word
		case COMBODOTILE:		GET_COMBO_VAR_DWORD(o_tile, "OriginalTile"); break;			//word
		case COMBODFRAME:		GET_COMBO_VAR_BYTE(cur_frame, "Frame"); break;				//char
		case COMBODACLK:		GET_COMBO_VAR_BYTE(aclk, "AClk"); break;				//char
		case COMBODASPEED:		GET_COMBO_VAR_BYTE(speed, "ASpeed"); break;					//char
		case COMBODFLIP:		GET_COMBO_VAR_BYTE(flip, "Flip"); break;					//char
		case COMBODWALK:		GET_COMBO_VAR_BYTE(walk, "Walk"); break;					//char
		case COMBODTYPE:		GET_COMBO_VAR_BYTE(type, "Type"); break;					//char
		case COMBODCSET:		GET_COMBO_VAR_BYTE(csets, "CSet"); break;					//C
		case COMBODFOO:			GET_COMBO_VAR_DWORD(foo, "Foo"); break;						//W
		case COMBODATASCRIPT:			GET_COMBO_VAR_DWORD(script, "Script"); break;						//W
		case COMBODFRAMES:		GET_COMBO_VAR_BYTE(frames, "Frames"); break;					//C
		case COMBODNEXTD:		GET_COMBO_VAR_DWORD(speed, "NextData"); break;					//W
		case COMBODNEXTC:		GET_COMBO_VAR_BYTE(nextcombo, "NextCSet"); break;				//C
		case COMBODFLAG:		GET_COMBO_VAR_BYTE(nextcset, "Flag"); break;					//C
		case COMBODSKIPANIM:		GET_COMBO_VAR_BYTE(skipanim, "SkipAnim"); break;				//C
		case COMBODNEXTTIMER:		GET_COMBO_VAR_DWORD(nexttimer, "NextTimer"); break;				//W
		case COMBODAKIMANIMY:		GET_COMBO_VAR_BYTE(skipanimy, "SkipAnimY"); break;				//C
		case COMBODANIMFLAGS:		GET_COMBO_VAR_BYTE(animflags, "AnimFlags"); break;				//C
		case COMBODEXPANSION:		GET_COMBO_BYTE_INDEX(expansion, "Expansion[]", 6); break;				//C , 6 INDICES
		case COMBODATTRIBUTES: 		GET_COMBO_VAR_INDEX(attributes,	"Attributes[]", 4); break;			//LONG, 4 INDICES, INDIVIDUAL VALUES
		case COMBODATAINITD: 		GET_COMBO_VAR_INDEX(initd,	"InitD[]", 2); break;			//LONG, 4 INDICES, INDIVIDUAL VALUES
		case COMBODATTRIBYTES: 		GET_COMBO_VAR_INDEX(attribytes,	"Attribytes[]", 4); break;			//LONG, 4 INDICES, INDIVIDUAL VALUES
		case COMBODUSRFLAGS:		GET_COMBO_VAR_INT(usrflags, "UserFlags"); break;				//LONG
		case COMBODTRIGGERFLAGS:	GET_COMBO_VAR_INDEX(triggerflags, "TriggerFlags[]", 3);	break;			//LONG 3 INDICES AS FLAGSETS
		case COMBODTRIGGERLEVEL:	GET_COMBO_VAR_INT(triggerlevel, "TriggerLevel"); break;				//LONG
		case COMBODATAID: 		ret = (ri->combosref*10000); break;
		//COMBOCLASS STRUCT
		//case COMBODNAME:		//CHAR[64], STRING
		case COMBODBLOCKNPC:		GET_COMBOCLASS_VAR_BYTE(block_enemies, "BlockNPC"); break;			//C
		case COMBODBLOCKHOLE:		GET_COMBOCLASS_VAR_BYTE(block_hole, "BlockHole"); break;			//C
		case COMBODBLOCKTRIG:		GET_COMBOCLASS_VAR_BYTE(block_trigger,	"BlockTrigger"); break; 		//C
		case COMBODBLOCKWEAPON:		GET_COMBOCLASS_BYTE_INDEX(block_weapon,	"BlockWeapon[]", 32); break;		//C, 32 INDICES
		case COMBODCONVXSPEED:		GET_COMBOCLASS_VAR_DWORD(conveyor_x_speed, "ConveyorSpeedX"); break;		//SHORT
		case COMBODCONVYSPEED:		GET_COMBOCLASS_VAR_DWORD(conveyor_y_speed, "ConveyorSpeedY"); break;		//SHORT
		case COMBODSPAWNNPC:		GET_COMBOCLASS_VAR_DWORD(create_enemy, "SpawnNPC"); break;			//W
		case COMBODSPAWNNPCWHEN:	GET_COMBOCLASS_VAR_BYTE(create_enemy_when, "SpawnNPCWhen"); break;		//C
		case COMBODSPAWNNPCCHANGE:	GET_COMBOCLASS_VAR_INT(create_enemy_change, "SpawnNPCChange"); break;		//LONG
		case COMBODDIRCHANGETYPE:	GET_COMBOCLASS_VAR_BYTE(directional_change_type, "DirChange"); break;		//C
		case COMBODDISTANCECHANGETILES:	GET_COMBOCLASS_VAR_INT(distance_change_tiles, "DistanceChangeTiles"); break; 	//LONG
		case COMBODDIVEITEM:		GET_COMBOCLASS_VAR_DWORD(dive_item, "DiveItem"); break;				//SHORT
		case COMBODDOCK:		GET_COMBOCLASS_VAR_BYTE(dock, "Dock"); break;					//C
		case COMBODFAIRY:		GET_COMBOCLASS_VAR_BYTE(fairy, "Fairy"); break;					//C
		case COMBODFFATTRCHANGE:	GET_COMBOCLASS_VAR_BYTE(ff_combo_attr_change, "FFCAttributeChange"); break;	//C
		case COMBODFOORDECOTILE:	GET_COMBOCLASS_VAR_INT(foot_decorations_tile, "DecorationTile"); break;		//LONG
		case COMBODFOORDECOTYPE:	GET_COMBOCLASS_VAR_BYTE(foot_decorations_type, "DecorationType"); break;	//C
		case COMBODHOOKSHOTPOINT:	GET_COMBOCLASS_VAR_BYTE(hookshot_grab_point, "Hookshot"); break;		//C
		case COMBODLADDERPASS:		GET_COMBOCLASS_VAR_BYTE(ladder_pass, "Ladder"); break;				//C
		case COMBODLOCKBLOCK:		GET_COMBOCLASS_VAR_BYTE(lock_block_type, "LockBlock"); break;			//C
		case COMBODLOCKBLOCKCHANGE:	GET_COMBOCLASS_VAR_INT(lock_block_change, "LockBlockChange"); break;		//LONG
		case COMBODMAGICMIRROR:		GET_COMBOCLASS_VAR_BYTE(magic_mirror_type, "Mirror"); break;			//C
		case COMBODMODHPAMOUNT:		GET_COMBOCLASS_VAR_DWORD(modify_hp_amount, "DamageAmount"); break;		//SHORT
		case COMBODMODHPDELAY:		GET_COMBOCLASS_VAR_BYTE(modify_hp_delay, "DamageDelay"); break;			//C
		case COMBODMODHPTYPE:		GET_COMBOCLASS_VAR_BYTE(modify_hp_type,	"DamageType"); break; 			//C
		case COMBODNMODMPAMOUNT:	GET_COMBOCLASS_VAR_DWORD(modify_mp_amount, "MagicAmount"); break;		//SHORT
		case COMBODMODMPDELAY:		GET_COMBOCLASS_VAR_BYTE(modify_mp_delay, "MagicDelay"); break;			//C
		case COMBODMODMPTYPE:		GET_COMBOCLASS_VAR_BYTE(modify_mp_type,	"MagicType");	break;			//C
		case COMBODNOPUSHBLOCK:		GET_COMBOCLASS_VAR_BYTE(no_push_blocks, "NoPushBlocks"); break;			//C
		case COMBODOVERHEAD:		GET_COMBOCLASS_VAR_BYTE(overhead, "Overhead"); break;				//C
		case COMBODPLACENPC:		GET_COMBOCLASS_VAR_BYTE(place_enemy, "PlaceNPC"); break;			//C
		case COMBODPUSHDIR:		GET_COMBOCLASS_VAR_BYTE(push_direction,	"PushDir"); break; 			//C
		case COMBODPUSHWAIT:		GET_COMBOCLASS_VAR_BYTE(push_wait, "PushDelay"); break;				//C
		case COMBODPUSHHEAVY:		GET_COMBOCLASS_VAR_BYTE(push_weight, "PushHeavy");				//C
		case COMBODPUSHED:		GET_COMBOCLASS_VAR_BYTE(pushed, "Pushed"); break;				//C
		case COMBODRAFT:		GET_COMBOCLASS_VAR_BYTE(raft, "Raft"); break;					//C
		case COMBODRESETROOM:		GET_COMBOCLASS_VAR_BYTE(reset_room, "ResetRoom"); break;			//C
		case COMBODSAVEPOINTTYPE:	GET_COMBOCLASS_VAR_BYTE(save_point_type, "SavePoint"); break;			//C
		case COMBODSCREENFREEZETYPE:	GET_COMBOCLASS_VAR_BYTE(screen_freeze_type, "FreezeScreen"); break;		//C
		case COMBODSECRETCOMBO:		GET_COMBOCLASS_VAR_BYTE(secret_combo, "SecretCombo"); break;			//C
		case COMBODSINGULAR:		GET_COMBOCLASS_VAR_BYTE(singular, "Singular"); break;				//C
		case COMBODSLOWWALK:		GET_COMBOCLASS_VAR_BYTE(slow_movement, "SlowWalk"); break;			//C
		case COMBODSTATUETYPE:		GET_COMBOCLASS_VAR_BYTE(statue_type, "Statue"); break;				//C
		case COMBODSTEPTYPE:		GET_COMBOCLASS_VAR_BYTE(step_type, "Step"); break;				//C
		case COMBODSTEPCHANGEINTO:	GET_COMBOCLASS_VAR_INT(step_change_to, "StepChange"); break;			//LONG
		case COMBODSTRIKEWEAPONS:	GET_COMBOCLASS_BYTE_INDEX(strike_weapons, "Strike[]", 32); break;			//BYTE, 32 INDICES. 
		case COMBODSTRIKEREMNANTS:	GET_COMBOCLASS_VAR_INT(strike_remnants,	"StrikeRemnants"); break;		//LONG
		case COMBODSTRIKEREMNANTSTYPE:	GET_COMBOCLASS_VAR_BYTE(strike_remnants_type, "StrikeRemnantsType"); break;	//C
		case COMBODSTRIKECHANGE:	GET_COMBOCLASS_VAR_INT(strike_change, "StrikeChange"); break;			//LONG
		case COMBODSTRIKEITEM:		GET_COMBOCLASS_VAR_DWORD(strike_item, "StrikeItem"); break;			//SHORT
		case COMBODTOUCHITEM:		GET_COMBOCLASS_VAR_DWORD(touch_item, "TouchItem"); break;			//SHORT
		case COMBODTOUCHSTAIRS:		GET_COMBOCLASS_VAR_BYTE(touch_stairs, "TouchStairs"); break;			//C
		case COMBODTRIGGERTYPE:		GET_COMBOCLASS_VAR_BYTE(trigger_type, "TriggerType"); break;			//C
		case COMBODTRIGGERSENS:		GET_COMBOCLASS_VAR_BYTE(trigger_sensitive, "TriggerSensitivity"); break;	//C
		case COMBODWARPTYPE:		GET_COMBOCLASS_VAR_BYTE(warp_type, "Warp"); break;				//C
		case COMBODWARPSENS:		GET_COMBOCLASS_VAR_BYTE(warp_sensitive,	"WarpSensitivity"); break; 		//C
		case COMBODWARPDIRECT:		GET_COMBOCLASS_VAR_BYTE(warp_direct, "WarpDirect"); break;			//C
		case COMBODWARPLOCATION:	GET_COMBOCLASS_VAR_BYTE(warp_location, "WarpLocation"); break;			//C
		case COMBODWATER:		GET_COMBOCLASS_VAR_BYTE(water, "Water"); break;					//C
		case COMBODWHISTLE:		GET_COMBOCLASS_VAR_BYTE(whistle, "Whistle"); break;				//C
		case COMBODWINGAME:		GET_COMBOCLASS_VAR_BYTE(win_game, "WinGame"); break; 				//C
		case COMBODBLOCKWPNLEVEL:	GET_COMBOCLASS_VAR_BYTE(block_weapon_lvl, "BlockWeaponLevel"); break;		//C


		
		///----------------------------------------------------------------------------------------------------//
		//npcdata nd-> variables
			
		//npcdata nd->member variable
		#define	GET_NPCDATA_VAR_INT32(member, str) \
		{ \
			if( (unsigned) ri->npcdataref > (MAXNPCS-1) ) \
			{ \
				Z_scripterrlog("Invalid NPC ID passed to npcdata->%s: %d\n", (ri->npcdataref*10000), str); \
				ret = -10000; \
			} \
			else \
			{ \
				ret = (guysbuf[ri->npcdataref].member *10000); \
			} \
		} \

		#define	GET_NPCDATA_VAR_BYTE(member, str) \
		{ \
			if( (unsigned) ri->npcdataref > (MAXNPCS-1) ) \
			{ \
				Z_scripterrlog("Invalid NPC ID passed to npcdata->%s: %d\n", (ri->npcdataref*10000), str); \
				ret = -10000; \
			} \
			else \
			{ \
				ret = (guysbuf[ri->npcdataref].member *10000); \
			} \
		} \
		
		#define	GET_NPCDATA_VAR_INT16(member, str) \
		{ \
			if( (unsigned) ri->npcdataref > (MAXNPCS-1) ) \
			{ \
				Z_scripterrlog("Invalid NPC ID passed to npcdata->%s: %d\n", (ri->npcdataref*10000), str); \
				ret = -10000; \
			} \
			else \
			{ \
				ret = (guysbuf[ri->npcdataref].member *10000); \
			} \
		} \
		
		#define GET_NPCDATA_VAR_INDEX(member, str, indexbound) \
		{ \
				int indx = ri->d[0] / 10000; \
				if( (unsigned) ri->npcdataref > (MAXNPCS-1) ) \
				{ \
					Z_scripterrlog("Invalid NPC ID passed to npcdata->%s: %d\n", (ri->npcdataref*10000), str); \
					ret = -10000; \
				} \
				else if ( (unsigned)indx > indexbound ) \
				{ \
					Z_scripterrlog("Invalid Array Index passed to npcdata->%s: %d\n", indx, str); \
					ret = -10000; \
				} \
				else \
				{ \
					ret = (guysbuf[ri->npcdataref].member[indx] * 10000); \
				} \
		}

		#define GET_NPCDATA_BYTE_INDEX(member, str, indexbound) \
		{ \
				int indx = ri->d[0] / 10000; \
				if( (unsigned) ri->npcdataref > (MAXNPCS-1) ) \
				{ \
					Z_scripterrlog("Invalid NPC ID passed to npcdata->%s: %d\n", (ri->npcdataref*10000), str); \
					ret = -10000; \
				} \
				else if ( (unsigned)indx > indexbound ) \
				{ \
					Z_scripterrlog("Invalid Array Index passed to npcdata->%s: %d\n", indx, str); \
					ret = -10000; \
				} \
				else \
				{ \
					ret = (guysbuf[ri->npcdataref].member[indx] * 100000); \
				} \
		}
		
		#define GET_NPCDATA_FLAG(member, str, indexbound) \
		{ \
			long flag =  (value/10000);  \
			if( (unsigned) ri->npcdataref > (MAXNPCS-1) ) \
			{ \
				Z_scripterrlog("Invalid NPC ID passed to npcdata->%s: %d\n", (ri->npcdataref*10000), str); \
			} \
			else \
			{ \
				ret = (guysbuf[ID].member&flag) ? 10000 : 0); \
			} \
		} \
		
		case NPCDATATILE: GET_NPCDATA_VAR_BYTE(tile, "Tile"); break;
		case NPCDATAWIDTH: GET_NPCDATA_VAR_BYTE(width, "Width"); break;
		case NPCDATAHEIGHT: GET_NPCDATA_VAR_BYTE(height, "Height"); break;
		case NPCDATAFLAGS: GET_NPCDATA_VAR_INT16(flags, "Flags"); break; //16 b its
		case NPCDATAFLAGS2: GET_NPCDATA_VAR_INT16(flags2, "Flags2"); break; //16 bits
		case NPCDATASTILE: GET_NPCDATA_VAR_BYTE(s_tile, "STile"); break;
		case NPCDATASWIDTH: GET_NPCDATA_VAR_BYTE(s_width, "SWidth"); break;
		case NPCDATASHEIGHT: GET_NPCDATA_VAR_BYTE(s_height, "SHeight"); break;
		case NPCDATAETILE: GET_NPCDATA_VAR_INT32(e_tile, "ExTile"); break;
		case NPCDATAEWIDTH: GET_NPCDATA_VAR_BYTE(e_width, "ExWidth"); break;
		case NPCDATAEHEIGHT: GET_NPCDATA_VAR_BYTE(e_height, "ExHeight"); break;
		case NPCDATAHP: GET_NPCDATA_VAR_INT16(hp, "HP"); break;
		case NPCDATAFAMILY: GET_NPCDATA_VAR_INT16(family, "Family"); break;
		case NPCDATACSET: GET_NPCDATA_VAR_INT16(cset, "CSet"); break;
		case NPCDATAANIM: GET_NPCDATA_VAR_INT16(anim, "Anim"); break;
		case NPCDATAEANIM: GET_NPCDATA_VAR_INT16(e_anim, "ExAnim"); break;
		case NPCDATAFRAMERATE: GET_NPCDATA_VAR_INT16(frate, "Framerate"); break;
		case NPCDATAEFRAMERATE: GET_NPCDATA_VAR_INT16(e_frate, "ExFramerate"); break;
		case NPCDATATOUCHDAMAGE: GET_NPCDATA_VAR_INT16(dp, "TouchDamage"); break;
		case NPCDATAWEAPONDAMAGE: GET_NPCDATA_VAR_INT16(wdp, "WeaponDamage"); break;
		case NPCDATAWEAPON: GET_NPCDATA_VAR_INT16(weapon, "Weapon"); break;
		case NPCDATARANDOM: GET_NPCDATA_VAR_INT16(rate, "Random"); break;
		case NPCDATAHALT: GET_NPCDATA_VAR_INT16(hrate, "Haltrate"); break;
		case NPCDATASTEP: GET_NPCDATA_VAR_INT16(step, "Step"); break;
		case NPCDATAHOMING: GET_NPCDATA_VAR_INT16(homing, "Homing"); break;
		case NPCDATAHUNGER: GET_NPCDATA_VAR_INT16(grumble, "Hunger"); break;
		case NPCDATADROPSET: GET_NPCDATA_VAR_INT16(item_set, "Dropset"); break;
		case NPCDATABGSFX: GET_NPCDATA_VAR_INT16(bgsfx, "BGSFX"); break;
		case NPCDATADEATHSFX: GET_NPCDATA_VAR_BYTE(deadsfx, "DeathSFX"); break;
		case NPCDATAHITSFX: GET_NPCDATA_VAR_BYTE(hitsfx, "HitSFX"); break;
		case NPCDATAXOFS: GET_NPCDATA_VAR_INT32(xofs, "DrawXOffset"); break;
		case NPCDATAYOFS: GET_NPCDATA_VAR_INT32(yofs, "DrawYOffset"); break;
		case NPCDATAZOFS: GET_NPCDATA_VAR_INT32(zofs, "DrawZOffset"); break;
		case NPCDATAHXOFS: GET_NPCDATA_VAR_INT32(hxofs, "HitXOffset"); break;
		case NPCDATAHYOFS: GET_NPCDATA_VAR_INT32(hyofs, "HitYOffset"); break;
		case NPCDATAHITWIDTH: GET_NPCDATA_VAR_INT32(hxsz, "HitWidth"); break;
		case NPCDATAHITHEIGHT: GET_NPCDATA_VAR_INT32(hysz, "HitHeight"); break;
		case NPCDATAHITZ: GET_NPCDATA_VAR_INT32(hzsz, "HitZHeight"); break;
		case NPCDATASCRIPT: GET_NPCDATA_VAR_INT32(script, "Script"); break;
		case NPCDATATILEWIDTH: GET_NPCDATA_VAR_INT32(txsz, "TileWidth"); break;
		case NPCDATATILEHEIGHT: GET_NPCDATA_VAR_INT32(tysz, "TileHeight"); break;
		case NPCDATAWPNSPRITE: GET_NPCDATA_VAR_INT32(wpnsprite, "WeaponSprite"); break;
		case NPCDATAWEAPONSCRIPT: GET_NPCDATA_VAR_INT32(weaponscript, "WeaponScript"); break;
		case NPCDATADEFENSE: GET_NPCDATA_VAR_INDEX(defense, "Defense", 42); break;
		case NPCDATAINITD: GET_NPCDATA_VAR_INDEX(initD, "InitD", 8); break;
		case NPCDATAWEAPONINITD: GET_NPCDATA_VAR_INDEX(weap_initiald, "WeaponInitD", 8); break;
		case NPCDATASIZEFLAG: GET_NPCDATA_VAR_INT32(SIZEflags, "SizeFlags"); break;

		case NPCDATAFROZENTILE: GET_NPCDATA_VAR_INT32(frozentile, "FrozenTile"); break;
		case NPCDATAFROZENCSET: GET_NPCDATA_VAR_INT32(frozencset, "FrozenCSet"); break;


		case NPCDATAATTRIBUTE: 
		{
			int indx = ri->d[0] / 10000; 
			if(ri->npcdataref < 0 || ri->npcdataref > (MAXNPCS-1) ) 
			{
				Z_scripterrlog("Invalid Sprite ID passed to npcdata->Attributes[]: %d\n", (ri->npcdataref*10000)); 
				ret = -10000;
			}
			else if ( indx < 0 || indx > MAX_NPC_ATRIBUTES )
			{ 
				Z_scripterrlog("Invalid Array Index passed to npcdata->Attributes[]: %d\n", (ri->npcdataref*10000)); 
				ret = -10000; 
			} 
			else 
			{ 
				switch(indx)
				{
					case 0: ret = (guysbuf[ri->npcdataref].misc1 * 10000); break;
					case 1: ret = (guysbuf[ri->npcdataref].misc2 * 10000); break;
					case 2: ret = (guysbuf[ri->npcdataref].misc3 * 10000); break;
					case 3: ret = (guysbuf[ri->npcdataref].misc4 * 10000); break;
					case 4: ret = (guysbuf[ri->npcdataref].misc5 * 10000); break;
					case 5: ret = (guysbuf[ri->npcdataref].misc6 * 10000); break;
					case 6: ret = (guysbuf[ri->npcdataref].misc7 * 10000); break;
					case 7: ret = (guysbuf[ri->npcdataref].misc8 * 10000); break;
					case 8: ret = (guysbuf[ri->npcdataref].misc9 * 10000); break;
					case 9: ret = (guysbuf[ri->npcdataref].misc10 * 10000); break;
					case 10: ret = (guysbuf[ri->npcdataref].misc11 * 10000); break;
					case 11: ret = (guysbuf[ri->npcdataref].misc12 * 10000); break;
					case 12: ret = (guysbuf[ri->npcdataref].misc13 * 10000); break;
					case 13: ret = (guysbuf[ri->npcdataref].misc14 * 10000); break;
					case 14: ret = (guysbuf[ri->npcdataref].misc15 * 10000); break;
					case 15: ret = (guysbuf[ri->npcdataref].misc16 * 10000); break;
					case 16: ret = (guysbuf[ri->npcdataref].misc17 * 10000); break;
					case 17: ret = (guysbuf[ri->npcdataref].misc18* 10000); break;
					case 18: ret = (guysbuf[ri->npcdataref].misc19 * 10000); break;
					case 19: ret = (guysbuf[ri->npcdataref].misc20 * 10000); break;
					case 20: ret = (guysbuf[ri->npcdataref].misc21 * 10000); break;
					case 21: ret = (guysbuf[ri->npcdataref].misc22 * 10000); break;
					case 22: ret = (guysbuf[ri->npcdataref].misc23 * 10000); break;
					case 23: ret = (guysbuf[ri->npcdataref].misc24 * 10000); break;
					case 24: ret = (guysbuf[ri->npcdataref].misc25 * 10000); break;
					case 25: ret = (guysbuf[ri->npcdataref].misc26 * 10000); break;
					case 26: ret = (guysbuf[ri->npcdataref].misc27 * 10000); break;
					case 27: ret = (guysbuf[ri->npcdataref].misc28 * 10000); break;
					case 28: ret = (guysbuf[ri->npcdataref].misc29 * 10000); break;
					case 29: ret = (guysbuf[ri->npcdataref].misc30 * 10000); break;
					case 30: ret = (guysbuf[ri->npcdataref].misc31 * 10000); break;
					case 31: ret = (guysbuf[ri->npcdataref].misc32 * 10000); break;
					
					
					
					default: 
					{
						Z_scripterrlog("Invalid Array Index passed to npcdata->Attributes[]: %d\n", (ri->npcdataref*10000)); 
						ret = -10000;
						break;
					}
				}
					
			} 
			break;
		}

		case NPCDATABEHAVIOUR: 
		{
			if(ri->npcdataref < 0 || ri->npcdataref > (MAXNPCS-1) ) 
			{
				ret = -10000;
				break;
			}
			int index = vbound(ri->d[0]/10000,0,4);
			switch(index)
			{
				case 0:
					ret=(guysbuf[ri->npcdataref].editorflags & ENEMY_FLAG1)?10000:0; break;
				case 1:
					ret=(guysbuf[ri->npcdataref].editorflags & ENEMY_FLAG2)?10000:0; break;
				case 2:
					ret=(guysbuf[ri->npcdataref].editorflags & ENEMY_FLAG3)?10000:0; break;
				case 3:
					ret=(guysbuf[ri->npcdataref].editorflags & ENEMY_FLAG4)?10000:0; break;
				case 4:
					ret=(guysbuf[ri->npcdataref].editorflags & ENEMY_FLAG5)?10000:0; break;
				case 5:
					ret=(guysbuf[ri->npcdataref].editorflags & ENEMY_FLAG6)?10000:0; break;
				case 6:
					ret=(guysbuf[ri->npcdataref].editorflags & ENEMY_FLAG7)?10000:0; break;
				case 7:
					ret=(guysbuf[ri->npcdataref].editorflags & ENEMY_FLAG8)?10000:0; break;
				case 8:
					ret=(guysbuf[ri->npcdataref].editorflags & ENEMY_FLAG9)?10000:0; break;
				case 9:
					ret=(guysbuf[ri->npcdataref].editorflags & ENEMY_FLAG10)?10000:0; break;
				case 10:
					ret=(guysbuf[ri->npcdataref].editorflags & ENEMY_FLAG11)?10000:0; break;
				case 11:
					ret=(guysbuf[ri->npcdataref].editorflags & ENEMY_FLAG12)?10000:0; break;
				case 12:
					ret=(guysbuf[ri->npcdataref].editorflags & ENEMY_FLAG13)?10000:0; break;
				case 13:
					ret=(guysbuf[ri->npcdataref].editorflags & ENEMY_FLAG14)?10000:0; break;
				case 14:
					ret=(guysbuf[ri->npcdataref].editorflags & ENEMY_FLAG15)?10000:0; break;
				case 15:
					ret=(guysbuf[ri->npcdataref].editorflags & ENEMY_FLAG16)?10000:0; break;
				
				
				default: 
					ret = 0; break;
			}
				
			break;
		}
		
		case NPCDATASHIELD:
		{
			int indx = ri->d[0] / 10000; 
			if(ri->npcdataref < 0 || ri->npcdataref > (MAXNPCS-1) ) 
			{ 
				Z_scripterrlog("Invalid NPC ID passed to npcdata->Shield[]: %d\n", (ri->npcdataref*10000)); 
				ret = -10000; 
				break;
			} 
			else 
			{ 
				switch(indx)
				{
					case 0:
					{
						ret = ((guysbuf[ri->npcdataref].flags&inv_front) ? 10000 : 0);
						break;
					}
					case 1:
					{
						ret = ((guysbuf[ri->npcdataref].flags&inv_left) ? 10000 : 0);
						break;
					}
					case 2:
					{
						ret = ((guysbuf[ri->npcdataref].flags&inv_right) ? 10000 : 0);
						break;
					}
					case 3:
					{
						ret = ((guysbuf[ri->npcdataref].flags&inv_back) ? 10000 : 0);
						break;
					}
					case 4:
					{
						ret = ((guysbuf[ri->npcdataref].flags&guy_bkshield) ? 10000 : 0);
						break;
					}
					default:
					{
						Z_scripterrlog("Invalid Array Index passed to npcdata->Shield[]: %d\n", indx); 
						ret = -10000; 
						break;
					}
				}
			} 
		}

		case NPCMATCHINITDLABEL: 	 //Same form as SetScreenD()
			//bool npcdata->MatchInitDLabel("label", d)
		{
			
			if( (unsigned) ri->npcdataref > (MAXNPCS-1) ) \
			{ 
				Z_scripterrlog("Invalid NPC ID passed to npcdata->%s: %d\n", (ri->npcdataref*10000), "MatchInitDLabel()"); 
				ret = 0; 
				break;
			} 
			
			long arrayptr = get_register(sarg1) / 10000;
			long init_d_index = get_register(sarg2) / 10000;
			
			string name;
			int num=-1;
			ArrayH::getString(arrayptr, name, 256); // What's the limit on name length?
			
			bool match = (!( strcmp(name.c_str(), guysbuf[ri->npcdataref].initD_label[init_d_index] )));
			
			ret = ( match ? 10000 : 0 );
			break;
		}
		
		///----------------------------------------------------------------------------------------------------//
		//Dropset Variables

		case DROPSETITEMS:
		{
			if(ri->dropsetref < 0 || ri->dropsetref > MAXITEMDROPSETS)
			{
				Z_scripterrlog("Invalid dropset pointer %d\n", ri->dropsetref);
				ret = -10000;
				break;
			}
			int indx = ri->d[0]/10000;
			if(indx < 0 || indx > 9)
			{
				Z_scripterrlog("Invalid index passed to dropdata->Items[]: %d\n", indx);
				ret = -10000;
			}
			else
			{
				ret = item_drop_sets[ri->dropsetref].item[indx] * 10000;
			}
			break;
		}
		case DROPSETCHANCES:
		{
			if(ri->dropsetref < 0 || ri->dropsetref > MAXITEMDROPSETS)
			{
				Z_scripterrlog("Invalid dropset pointer %d\n", ri->dropsetref);
				ret = -10000;
				break;
			}
			int indx = ri->d[0]/10000;
			if(indx < 0 || indx > 9)
			{
				Z_scripterrlog("Invalid index passed to dropdata->Chances[]: %d\n", indx);
				ret = -10000;
			}
			else
			{
				ret = item_drop_sets[ri->dropsetref].chance[indx+1] * 10000; //+1 is because '0' is 'nothing''s chance
			}
			break;
		}
		case DROPSETNULLCHANCE:
		{
			if(ri->dropsetref < 0 || ri->dropsetref > MAXITEMDROPSETS)
			{
				Z_scripterrlog("Invalid dropset pointer %d\n", ri->dropsetref);
				ret = -10000;
				break;
			}
			ret = item_drop_sets[ri->dropsetref].chance[0] * 10000;
			break;
		}
		case DROPSETCHOOSE:
		{
			if(ri->dropsetref < 0 || ri->dropsetref > MAXITEMDROPSETS)
			{
				Z_scripterrlog("Invalid dropset pointer %d\n", ri->dropsetref);
				ret = -10000;
				break;
			}
			ret = select_dropitem(ri->dropsetref) * 10000;
			break;
		}
		
		///----------------------------------------------------------------------------------------------------//
		//Audio Variables

		case AUDIOVOLUME:
		{
			int indx = ri->d[0] / 10000;
			switch(indx)
			{
				
				case 0: //midi volume
				{
					ret = FFScript::do_getMIDI_volume() * 10000;
					break;
				}
				case 1: //digi volume
				{
					ret = FFScript::do_getDIGI_volume() * 10000;
					break;
				}
				case 2: //emh music volume
				{
					ret = FFScript::do_getMusic_volume() * 10000;
					break;
				}
				case 3: //sfx volume
				{
					ret = FFScript::do_getSFX_volume() * 10000;
					break;
				}
				default:
				{
					Z_scripterrlog("Attempted to access an invalid index of Audio->Volume[]", indx); 
					ret = -10000;
					break;
				}
			}
		}

		case AUDIOPAN:
		{
			ret = FFScript::do_getSFX_pan() * 10000;
			break;
		}

		///----------------------------------------------------------------------------------------------------//
		//Graphics->

		case NUMDRAWS:
			ret = FFCore.numscriptdraws * 10000;
			break;

		case MAXDRAWS:
			ret = MAX_SCRIPT_DRAWING_COMMANDS * 10000;
			break;
		
		case ISBLANKTILE: ret = (FFCore.IsBlankTile(ri->d[0]/10000) * 10000); break;

		case BITMAPWIDTH:
		{
			//if ( scb.script_created_bitmaps[ri->bitmapref].u_bmp ) 
			//{
			//	ret = scb.script_created_bitmaps[ri->bitmapref].u_bmp->w * 10000;
			//}
			//else ret = 0;
			ret = scb.script_created_bitmaps[ri->bitmapref-10].width * 10000;
			break;
		}

		case BITMAPHEIGHT:
		{
			//Z_scripterrlog("BITMAPHEI|GHT ri->BitmapRef is %d\n", ri->bitmapref);
			//Z_scripterrlog("ref bitmap height: %d\n", scb.script_created_bitmaps[ri->bitmapref-10].u_bmp->h);
			//if ( scb.script_created_bitmaps[ri->bitmapref].u_bmp )
			//{
			//	ret = scb.script_created_bitmaps[ri->bitmapref].u_bmp->h * 10000;
			//}
			//else ret = 0;
			ret = scb.script_created_bitmaps[ri->bitmapref-10].height * 10000;
			break;
		}
		///----------------------------------------------------------------------------------------------------//
		//File->
		case FILEPOS:
		{
			if(user_file* f = checkFile(ri->fileref, "Pos", true))
			{
				ret = ftell(f->file); //NOT *10000 -V
			}
			else ret = -10000L;
			break;
		}
		case FILEEOF:
		{
			if(user_file* f = checkFile(ri->fileref, "EOF", true))
			{
				ret = feof(f->file) ? 10000L : 0L; //Boolean
			}
			else ret = -10000L;
			break;
		}
		case FILEERR:
		{
			if(user_file* f = checkFile(ri->fileref, "Error", true))
			{
				ret = ferror(f->file) * 10000L;
			}
			else ret = -10000L;
			break;
		}
		
		///----------------------------------------------------------------------------------------------------//
		//Module->
		
		case MODULEGETINT:
		{
			int section_pointer = ((ri->d[0])/10000);
			int element_pointer = ((ri->d[1])/10000);
			string sectionid;
			string elementid;
		
			FFCore.getString(section_pointer, sectionid);
			FFCore.getString(element_pointer, elementid);
			
			///set config file
			if(!fileexists((char*)moduledata.module_name))
			{
				Z_scripterrlog("I/O Error: No module definitions found when using Module->GetInt()\n");
				ret = -10000;
			}	
			else
			{
				set_config_file(moduledata.module_name);
				ret = get_config_int(sectionid.c_str(), elementid.c_str(), 0)*10000;
				//return config file to zc.cfg
				set_config_file("zc.cfg");
			}
			break;
		}
		
		///----------------------------------------------------------------------------------------------------//
		//Misc./Internal
		case REFFFC:
			ret = ri->ffcref * 10000;
			break;
			
		case REFITEM:
			ret = ri->itemref;
			break;
			
		case REFITEMCLASS:
			ret = ri->idata;
			break;
			
		case REFLWPN:
			ret = ri->lwpn;
			break;
			
		case REFEWPN:
			ret = ri->ewpn;
			break;
			
		case REFNPC:
			ret = ri->guyref;
			break;
		
		case REFMAPDATA: ret = ri->mapsref; break;
		case REFSCREENDATA: ret = ri->screenref; break;
		case REFCOMBODATA: ret = ri->combosref; break;
		case REFSPRITEDATA: ret = ri->spritesref; break;
		case REFBITMAP: ret = ri->bitmapref; break;
		case REFNPCCLASS: ret = ri->npcdataref; break;
		
		
		case REFDMAPDATA: ret = ri->dmapsref; break;
		case REFSHOPDATA: ret = ri->shopsref; break;
		case REFMSGDATA: ret = ri->zmsgref; break;
		case REFUNTYPED: ret = ri->untypedref; break;
		
		case REFDROPS: ret = ri->dropsetref; break;
		case REFPONDS: ret = ri->pondref; break;
		case REFWARPRINGS: ret = ri->warpringref; break;
		case REFDOORS: ret = ri->doorsref; break;
		case REFUICOLOURS: ret = ri->zcoloursref; break;
		case REFRGB: ret = ri->rgbref; break;
		case REFPALETTE: ret = ri->paletteref; break;
		case REFTUNES: ret = ri->tunesref; break;
		case REFPALCYCLE: ret = ri->palcycleref; break;
		case REFGAMEDATA: ret = ri->gamedataref; break;
		case REFCHEATS: ret = ri->cheatsref; break;
		case REFFILE: ret = ri->fileref; break;
		case REFSUBSCREEN: ret = ri->subscreenref; break;
		
			
		case SP:
			ret = ri->sp * 10000;
			break;
			
		case PC:
			ret = ri->pc;
			break;
		
		case SWITCHKEY:
			ret = ri->switchkey;
			break;
			
		case SCRIPTRAM:
		case GLOBALRAM:
			ret = ArrayH::getElement(ri->d[0] / 10000, ri->d[1] / 10000);
			break;
			
		case SCRIPTRAMD:
		case GLOBALRAMD:
			ret = ArrayH::getElement(ri->d[0] / 10000, 0);
			break;
			
		case GDD://Doesn't work like this =(
			ret = game->global_d[ri->d[0] / 10000];
			break;
			
		///----------------------------------------------------------------------------------------------------//
		//Most of this is deprecated I believe ~Joe123
		default:
		{
			if(arg >= D(0) && arg <= D(7))			ret = ri->d[arg - D(0)];
			else if(arg >= A(0) && arg <= A(1))		ret = ri->a[arg - A(0)];
			else if(arg >= GD(0) && arg <= GD(MAX_SCRIPT_REGISTERS))	ret = game->global_d[arg - GD(0)];
			
			break;
		}
	}
		
	if ( zasm_debugger ) FFCore.ZASMPrintVarGet(arg, ret);
	return ret;
}

//Setter Instructions


void set_register(const long arg, const long value)
{
	if ( zasm_debugger ) FFCore.ZASMPrintVarSet(arg, value);
	//Macros
	
	#define	SET_SPRITEDATA_VAR_INT(member, str) \
	{ \
		if(ri->spritesref < 0 || ri->spritesref > (MAXWPNS-1) ) \
		{ \
			Z_scripterrlog("Invalid Sprite ID passed to spritedata->%s: %d\n", (ri->spritesref*10000), str); \
		} \
		else \
		{ \
			wpnsbuf[ri->spritesref].member = vbound((value / 10000),0,214747); \
		} \
	} \

	#define	SET_SPRITEDATA_VAR_BYTE(member, str) \
	{ \
		if(ri->spritesref < 0 || ri->spritesref > (MAXWPNS-1) ) \
		{ \
			Z_scripterrlog("Invalid Sprite ID passed to spritedata->%s: %d\n", (ri->spritesref*10000), str); \
		} \
		else \
		{ \
			wpnsbuf[ri->spritesref].member = vbound((value / 10000),0,255); \
		} \
	} \
	
	switch(arg)
	{
		//debug ri->d[]
		case DEBUGD:
		{
			int a = vbound((ri->d[0] / 10000), 0, 255);
			ri->d[a] = value/10000;
			break;
		}    
		
	///----------------------------------------------------------------------------------------------------//
	//FFC Variables
		case DATA:
			if(BC::checkFFC(ri->ffcref, "ffc->Data") == SH::_NoError)
				tmpscr->ffdata[ri->ffcref] = vbound(value/10000,0,MAXCOMBOS-1);
			break;
			
		case CHANGEFFSCRIPTR:
			FFScript::do_changeffcscript(false);
			break;
		
		case CHANGEFFSCRIPTV:
			FFScript::do_changeffcscript(true);
			break;
		
		case FFSCRIPT:
			if(BC::checkFFC(ri->ffcref, "ffc->Script") == SH::_NoError)
			{
				tmpscr->ffscript[ri->ffcref] = vbound(value/10000, 0, NUMSCRIPTFFC-1);
				if ( get_bit(quest_rules,qr_CLEARINITDONSCRIPTCHANGE))
				{
					for(int i=0; i<2; i++)
						tmpscr->inita[ri->ffcref][i] = 0;
					
					for(int i=0; i<8; i++)
						tmpscr->initd[ri->ffcref][i] = 0;
				}
				for(int i=0; i<16; i++)
					ffmisc[ri->ffcref][i] = 0;
				
				ffcScriptData[ri->ffcref].Clear();
				FFScript::deallocateAllArrays(SCRIPT_FFC, ri->ffcref);
				tmpscr->initialized[ri->ffcref] = false;
			}
			break;
			
			
		case FCSET:
			if(BC::checkFFC(ri->ffcref, "ffc->CSet") == SH::_NoError)
				tmpscr->ffcset[ri->ffcref] = (value/10000)&15;
			break;
			
		case DELAY:
			if(BC::checkFFC(ri->ffcref, "ffc->Delay") == SH::_NoError)
				tmpscr->ffdelay[ri->ffcref] = value/10000;
			break;
			
		case FX:
			if(BC::checkFFC(ri->ffcref, "ffc->X") == SH::_NoError)
				tmpscr->ffx[ri->ffcref] = value;
			break;
			
		case FY:
			if(BC::checkFFC(ri->ffcref, "ffc->Y") == SH::_NoError)
				tmpscr->ffy[ri->ffcref]=value;
			break;
			
		case XD:
			if(BC::checkFFC(ri->ffcref, "ffc->Vx") == SH::_NoError)
				tmpscr->ffxdelta[ri->ffcref]=value;
			break;
			
		case YD:
			if(BC::checkFFC(ri->ffcref, "ffc->Vy") == SH::_NoError)
				tmpscr->ffydelta[ri->ffcref]=value;
			break;
		
		case FFCID:
			//if(BC::checkFFC(ri->ffcref, "ffc->ID") != SH::_NoError)
				ri->ffcref = vbound((value-10000)/10000, 0, 31);
			break;
			
		case XD2:
			if(BC::checkFFC(ri->ffcref, "ffc->Ax") == SH::_NoError)
				tmpscr->ffxdelta2[ri->ffcref]=value;
			break;
			
		case YD2:
			if(BC::checkFFC(ri->ffcref, "ffc->Ay") == SH::_NoError)
				tmpscr->ffydelta2[ri->ffcref]=value;
			break;
			
		case FFFLAGSD:
			if(BC::checkFFC(ri->ffcref, "ffc->Flags[]") == SH::_NoError)
				value ? tmpscr->ffflags[ri->ffcref] |=   1<<((ri->d[0])/10000)
					: tmpscr->ffflags[ri->ffcref] &= ~(1<<((ri->d[0])/10000));
			break;
			
		case FFCWIDTH:
			if(BC::checkFFC(ri->ffcref, "ffc->EffectWidth") == SH::_NoError)
				tmpscr->ffwidth[ri->ffcref]= (tmpscr->ffwidth[ri->ffcref] & ~63) | (((value/10000)-1)&63);
			break;
			
		case FFCHEIGHT:
			if(BC::checkFFC(ri->ffcref, "ffc->EffectHeight") == SH::_NoError)
				tmpscr->ffheight[ri->ffcref]= (tmpscr->ffheight[ri->ffcref] & ~63) | (((value/10000)-1)&63);
			break;
			
		case FFTWIDTH:
			if(BC::checkFFC(ri->ffcref, "ffc->TileWidth") == SH::_NoError)
				tmpscr->ffwidth[ri->ffcref]= (tmpscr->ffwidth[ri->ffcref]&63) | ((((value/10000)-1)&3)<<6);
			break;
			
		case FFTHEIGHT:
			if(BC::checkFFC(ri->ffcref, "ffc->TileHeight") == SH::_NoError)
				tmpscr->ffheight[ri->ffcref]=(tmpscr->ffheight[ri->ffcref]&63) | ((((value/10000)-1)&3)<<6);
			break;
			
		case FFLINK:
			if(BC::checkFFC(ri->ffcref, "ffc->Link") == SH::_NoError)
				(tmpscr->fflink[ri->ffcref])=vbound(value/10000, 0, 32); // Allow "ffc->Link = 0" to unlink ffc.
			//0 is none, setting this before made it impssible to clear it. -Z
			break;
			
		case FFMISCD:
		{
			int a = vbound(ri->d[0]/10000,0,15);
			if(BC::checkFFC(ri->ffcref, "ffc->Misc[]")== SH::_NoError)
				ffmisc[ri->ffcref][a]=value;
			break;
		}
		
		case FFINITDD:
			if(BC::checkFFC(ri->ffcref, "ffc->InitD[]") == SH::_NoError)
				(tmpscr->initd[ri->ffcref][vbound(ri->d[0]/10000,0,7)])=value;
			break;
		
			
			
	///----------------------------------------------------------------------------------------------------//
	//Link's Variables
		case LINKX:
		{
			if ( get_bit(quest_rules,qr_SPRITEXY_IS_FLOAT) )
			{
				Link.setXfix(zslongToFix(value));
			}
			else
			{
				Link.setX(value/10000);
			}
		}
		break;
			
		case LINKY:
		{
			if ( get_bit(quest_rules,qr_SPRITEXY_IS_FLOAT) )
			{
				Link.setYfix(zslongToFix(value));
			}
			else
			{
				Link.setY(value/10000);
			}
		}
		break;
			
		case LINKZ:
		{
			if ( get_bit(quest_rules,qr_SPRITEXY_IS_FLOAT) )
			{
				Link.setZfix(zslongToFix(value));
			}
			else
			{
				Link.setZ(value/10000);
			}
		}
		break;
			
		case LINKJUMP:
			Link.setFall(zslongToFix(value) * -100);
			break;
			
		case LINKDIR:
		{
			//Link->setDir() calls reset_hookshot(), which removes the sword sprite.. O_o
			if(Link.getAction() == attacking) Link.dir = (value/10000);
			else Link.setDir(value/10000);
			
			break;
		}
		
		case LINKHITDIR:
			Link.setHitDir(value / 10000);
			break;
		
		case LINKGRAVITY:
			if(value)
				Link.moveflags |= FLAG_OBEYS_GRAV;
			else
				Link.moveflags &= ~FLAG_OBEYS_GRAV;
			break;
		
		case HERONOSTEPFORWARD:
			FFCore.nostepforward = ( (value) ? 1 : 0 ); 
			break;
			
		case LINKHP:
			game->set_life(zc_max(0, zc_min(value/10000,game->get_maxlife())));
			break;
			
		case LINKMP:
			game->set_magic(zc_max(0, zc_min(value/10000,game->get_maxmagic())));
			break;
			
		case LINKMAXHP:
			game->set_maxlife(value/10000);
			break;
			
		case LINKMAXMP:
			game->set_maxmagic(value/10000);
			break;
			
		case LINKACTION:
		{
			int act = value / 10000;
			if ( act < 25 || (FFCore.getQuestHeaderInfo(vZelda) >= 0x255 && (act == falling)) )
			{
				Link.setAction((actiontype)(act));
			}
			else FFCore.setLinkAction(act); //Protect from writing illegal actions to Link's raw variable. 
			//in the future, we can move all scripted actions that are not possible
			//to set in ZC into this mechanic. -Z
			break;
		}
			
		case HEROHEALTHBEEP:
		{
			int beep = vbound((value/10000),-4, 255); 
			//-2 suspends system control of stopping the sound
			//-3 suspends system control of stopping the sound AND suspends
			// system control over starting or playing it.
			heart_beep_timer = beep;
			if ( heart_beep_timer > -1 )
			{
				cont_sfx(WAV_ER);
			}
			else
			{
				stop_sfx(WAV_ER);
			}
			break;
		}
		
		case LINKHELD:
			Link.setHeldItem(vbound(value/10000,0,MAXITEMS-1));
			break;
		
		case HEROSTEPS:
		{
			lsteps[vbound(ri->d[0]/10000,0,7)] = value/10000;
			break;
		}
		
		case HEROSTEPRATE:
			if(!get_bit(quest_rules, qr_NEW_HERO_MOVEMENT))
			{
				Z_scripterrlog("To use '%s', you must %s the quest rule '%s'.", "Hero->Step", "enable", "New Hero Movement");
			}
			Link.setStepRate(zc_max(value/10000,0));
			zinit.heroStep = Link.getStepRate();
			break;
		
		case LINKITEMD:
		{
			int itemID=vbound(ri->d[0]/10000,0,MAXITEMS-1);
			
			// If the Cane of Byrna is being removed, cancel its effect.
			if(value==0 && itemID==current_item_id(itype_cbyrna))
				stopCaneOfByrna();
		
			//Stop current script if set false.
			if ( !value && item_doscript[itemID] )
			{
				item_doscript[itemID] = 4; //Val of 4 means 'clear stack and quit'
				//itemScriptData[itemID].Clear(); //Don't clear here, causes crash if is current item!
			}
			else if ( value && !item_doscript[itemID] )
			{
				//Clear the item refInfo and stack for use.
				itemScriptData[itemID].Clear();
				memset(item_stack[itemID], 0xFFFF, MAX_SCRIPT_REGISTERS * sizeof(long));
				if ( (itemsbuf[itemID].flags&ITEM_FLAG16) ) item_doscript[itemID] = 1;
				
			}
			else if ( value && item_doscript[itemID] == 4 ) 
			{
				// Arbitrary event number 49326: Writing the item false, then true, in the same frame. -Z
				if ( (itemsbuf[itemID].flags&ITEM_FLAG16) ) item_doscript[itemID] = 1;
			}
			
			bool settrue = ( value != 0 );
			
			//Sanity check to prevent setting the item if the value would be the same. -Z
			if ( game->item[itemID] != settrue ) 
			{
				game->set_item(itemID,(value != 0));
			}
					
			//resetItems(game); - Is this really necessary? ~Joe123
			if((get_bit(quest_rules,qr_OVERWORLDTUNIC) != 0) || (currscr<128 || dlevel)) 
			{
				ringcolor(false);
				//refreshpal=true;
			}
			if ( !value ) //setting the item false clears the state of forced ->Equipment writes.
			{
				if ( game->forced_bwpn == itemID ) 
				{
					game->forced_bwpn = -1;
				} //not else if! -Z
				if ( game->forced_awpn == itemID ) 
				{
					game->forced_awpn = -1;
				}
			}
		}
		break;
			
		case LINKEQUIP:
		{
			if ( FFCore.getQuestHeaderInfo(vZelda) == 0x250 && FFCore.getQuestHeaderInfo(vBuild) < 33 )
			{
				break;
			}
			//int seta = (value/10000) >> 8; int setb = value/10000) & 0xFF;
			int setb = ((value/10000)&0xFF00)>>8, seta = (value/10000)&0xFF;
			seta = vbound(seta,-1,255);
			setb = vbound(setb,-1,255);
			//zprint("A is: %d\n", seta);
			//zprint("A is: %d\n", setb);
				
			Awpn = seta;
			game->awpn = seta;
			game->forced_awpn = seta;
			game->items_off[seta] = 0;
			//directItemA = directItem;
			
			Bwpn = setb;
			game->bwpn = setb;
			game->forced_bwpn = setb;
			game->items_off[setb] = 0;
			//directItemB = directItem;
			break;
		}
		
		  
		case SETITEMSLOT:
		{
			//ri->d[1] = 1st arg
			//ri->d[0] = 2nd arg
			//value = third arg
			//int item, int slot, int force
			int itm = ri->d[0]/10000;
			itm = vbound(itm, -1, 255);
			
			int slot = ri->d[1]/10000;
			int force = ri->d[2]/10000;
			
			zprint("SetItemSlot rid->[0] is (%i), trying to use for '%s'\n", itm, "itm");
			zprint("SetItemSlot rid->[1] is (%i), trying to use for '%s'\n", slot, "slot");
			zprint("SetItemSlot rid->[2] is (%i), trying to use for '%s'\n", force, "force");
			
			//If we add more item buttons, slot should be an int
			//and force shuld be an int
			
			/*
				For zScript, 
					const int ITM_REQUIRE_NONE = 0
					const int ITM_REQUIRE_INVENTORY = 1
					const int ITM_REQUIRE_A_SLOT_RULE = 2
					//Combine as flags
			*/
			if ( force == 0 )
			{
				if ( slot == 1 )
				{
					Awpn = itm;
					game->items_off[itm] = 0;
					game->awpn = itm;
					game->forced_awpn = itm;
					//directItemA = directItem;
				}
				else 
				{
					Bwpn = itm;
					game->items_off[itm] = 0;
					game->bwpn = itm;
					game->forced_bwpn = itm;
					//directItemB = directItem;
				}
			}
			else if ( force == 1 )
			{
				if(slot == 1 && game->item[itm])
				{
					Awpn = itm;
					game->items_off[itm] = 0;
					game->awpn = itm;
					game->forced_awpn = itm;
					//directItemA = directItem;
					
				}
				else if ( game->item[itm] ) 
				{
					Bwpn = itm;
					game->items_off[itm] = 0;
					game->bwpn = itm;
					game->forced_bwpn = itm;
					//directItemB = directItem;
				}
			}
			else if ( force == 2 )
			{
				if(slot == 1 && get_bit(quest_rules,qr_SELECTAWPN) )
				{
					Awpn = itm;
					game->items_off[itm] = 0;
					game->awpn = itm;
					game->forced_awpn = itm;
					//directItemA = directItem;
				}
				else 
				{ 
					Bwpn = itm;
					game->items_off[itm] = 0;
					game->bwpn = itm;
					game->forced_bwpn = itm;
					//directItemB = directItem;
				}
			}
			else if ( force == 3 ) //Flag ITM_REQUIRE_INVENTORY + ITM_REQUIRE_SLOT_A_RULE
			{
				if(slot == 1 && get_bit(quest_rules,qr_SELECTAWPN) && game->item[itm])
				{
					Awpn = itm;
					game->items_off[itm] = 0;
					game->awpn = itm;
					game->forced_awpn = itm;
					//directItemA = directItem;
				}
				else if(game->item[itm])
				{ 
					Bwpn = itm;
					game->items_off[itm] = 0;
					game->bwpn = itm;
					game->forced_bwpn = itm;
					//directItemB = directItem;
				}
			}
		}
		break;
		  
		case LINKINVIS:
			Link.setDontDraw((value ? 2 : 0));
			break;
			
		case LINKINVINC:
			Link.scriptcoldet=(value/10000);
			break;
		
		case LINKENGINEANIMATE:
			Link.do_animation=(value/10000);
			break;
			
		case LINKSWORDJINX:
			Link.setSwordClk(value/10000);
			break;
			
		case LINKITEMJINX:
			Link.setItemClk(value/10000);
			break;
			
		case LINKDRUNK:
			Link.setDrunkClock(value/10000);
			break;
			
		case LINKMISCD:
			Link.miscellaneous[vbound(ri->d[0]/10000,0,31)] = value; 
			break;
		
		case LINKHITBY:
		{
			int indx = ri->d[0]/10000;
			switch(indx)
			{
				//screen index objects
				case 0:
				case 1:
				case 2:
				case 3:
				{
					Link.sethitLinkUID(indx, vbound((value/10000), 0, 255)); //Why the Flidd did I vbound this? UIDs are LONGs, with a starting value of 0.0001. Why did I allow it, in fact? -Z
					break;
				}
				//UIDs
				case 4:
				case 5:
				case 6:
				case 7:
				{
					Link.sethitLinkUID(indx, vbound((value), 0, 255)); //Why the Flidd did I vbound this? UIDs are LONGs, with a starting value of 0.0001. Why did I allow it, in fact? -Z
					break;
				}
				default: { al_trace("Invalid index passed to Link->HitBy[%d] /n", indx); break; }
			}
			break;
		}
		
		case LINKDEFENCE:
			Link.set_defence(vbound(ri->d[0]/10000,0,255), ((char)vbound((value/10000), 0, 255)));
			break;
			
		case LINKHXOFS:
			(Link.hxofs)=(zfix)(value/10000);
			break;

		case LINKROTATION:
			if ( get_bit(quest_rules, qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"Link->Rotation");
				break;
			}
			(Link.rotation)=(value/10000);
			break;
		
		case LINKSCALE:
		{
			if ( get_bit(quest_rules, qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"Link->Scale");
				break;
			}
			(Link.scale)=(value/100.0);
			//al_trace("Link.scale is: %d\n", Link.scale);
			//al_trace("Trying to set Link.scale to: %d\n", value/100.0);
			break;
		}

		case LINKHYOFS:
			(Link.hyofs)=(zfix)(value/10000);
			break;
			
		case LINKXOFS:
			(Link.xofs)=(zfix)(value/10000);
			break;
			
		case LINKYOFS:
			(Link.yofs)=(zfix)(value/10000)+playing_field_offset;
			break;
			
		case LINKZOFS:
			(Link.zofs)=(zfix)(value/10000);
			break;
			
		case LINKHXSZ:
			(Link.hxsz)=(zfix)(value/10000);
			break;
			
		case LINKHYSZ:
			(Link.hysz)=(zfix)(value/10000);
			break;
			
		case LINKHZSZ:
			(Link.hzsz)=(zfix)(value/10000);
			break;
			
		case LINKTXSZ:
			(Link.txsz)=(zfix)(value/10000);
			break;
			
		case LINKTYSZ:
			(Link.tysz)=(zfix)(value/10000);
			break;
			
		case LINKTILE:
			(Link.tile)=(zfix)(value/10000);
			break;
			
		case LINKFLIP:
			(Link.flip)=(zfix)(value/10000);
			break;
		
		
		
		case LINKINVFRAME:
			Link.setHClk( (int)vbound((value/10000), 0, 214747) );
			break;
		
		case LINKCANFLICKER:
			Link.setCanLinkFlicker((value/10000)?1:0);
			break;
		
		case LINKHURTSFX:
			Link.setHurtSFX( (int)vbound((value/10000), 0, 255) );
			break;
			
		
		case LINKITEMB:
		{
			if ( value/10000 < -1 ) 
			{
				al_trace("Tried to write an invalid item ID to Link->Item: %ld\n",value/10000);
				break;
			}		
			if ( value/10000 > MAXITEMS-1 ) 
			{
				al_trace("Tried to write an invalid item ID to Link->Item: %ld\n",value/10000);
				break;
			}
			//Link->setBButtonItem(vbound((value/10000),0,(MAXITEMS-1)));
			
			
			Bwpn = value/10000;
			game->bwpn = value/10000;
			game->forced_bwpn = value/10000;
			game->items_off[value/10000] = 0;
			//directItemB = directItem;
			break;
		}
		
		
		case LINKITEMA:
		{
			if ( value/10000 < -1 ) 
			{
				Z_scripterrlog("Tried to write an invalid item ID to Link->Item: %d\n",value/10000);
				break;
			}		
			if ( value/10000 > MAXITEMS-1 ) 
			{
				Z_scripterrlog("Tried to write an invalid item ID to Link->Item: %d\n",value/10000);
				break;
			}		
			//Link->setBButtonItem(vbound((value/10000),0,(MAXITEMS-1)));
			
			Awpn = value/10000;
			game->awpn = value/10000;
			game->items_off[value/10000] = 0;
			game->forced_awpn = value/10000;
			//directItemB = directItem;
			break;
		}
		
		case LINKTILEMOD:
		{
			Link.setTileModifier(value/10000);
			break;
		}


		case LINKEATEN:
			Link.setEaten(value/10000);
			break;
		case LINKSTUN:
			Link.setStunClock(value/10000);
			break;
		case LINKSCRIPTTILE:
			script_link_sprite=vbound((value/10000), -1, NEWMAXTILES-1);
			break;
		
		case HEROSCRIPTCSET:
			script_link_cset=vbound((value/10000), 0, 0xF);
			break;
		case LINKSCRIPFLIP:
			script_link_flip=vbound((value/10000),-1,256);
			break;
		
		case GAMESETA:
		{
			//int state   = (ri->d[1]/10000);
			//int extend = (ri->d[1]/10000);
			//int dir = (ri->d[0]/10000);
			Z_message("Trying to force-set the A-button item().\n");
			Link.setAButtonItem(vbound((value/10000),0,(MAXITEMS-1)));
		}
		break;
		
		case GAMESETB:
		{
			//int state   = (ri->d[1]/10000);
			//int extend = (ri->d[1]/10000);
			//int dir = (ri->d[0]/10000);
			Z_message("Trying to force-set the A-button item().\n");
			Link.setBButtonItem(vbound((value/10000),0,(MAXITEMS-1)));
		}
		break;
		
		//Set Link Diagonal
		case LINKDIAG:
			Link.setDiagMove(value?1:0);
			set_bit(quest_rules, qr_LTTPWALK, value?1:0);
			break;
		
		//Set Link Big Hitbox
		case LINKBIGHITBOX:
			Link.setBigHitbox((value/10000)?1:0);
			set_bit(quest_rules, qr_LTTPCOLLISION, (value/10000)?1:0);
			break;
		
		case LINKCLIMBING:
			Link.setOnSideviewLadder(value!=0?true:false);
			break;
			
		case HEROJUMPCOUNT:
			Link.extra_jump_count = value/10000;
			break;
		
		case HEROPULLCLK:
			Link.pit_pullclk = value/10000;
			break;
		case HEROFALLCLK:
		{
			int val = vbound(value/10000,0,70);
			if(val)
				Link.setAction(falling);
			else if(Link.action == falling)
			{
				Link.setAction(none);
			}
			Link.fallclk = val;
			break;
		}
		case HEROFALLCMB:
			Link.fallCombo = vbound(value/10000,0,MAXCOMBOS-1);
			break;
		case HEROMOVEFLAGS:
		{
			int indx = ri->d[0]/10000;
			if(BC::checkBounds(indx, 0, 1, "Hero->MoveFlags[]") == SH::_NoError)
			{
				//All bits, in order, of a single byte; just use bitwise
				byte bit = 1<<indx;
				if(value)
					Link.moveflags |= bit;
				else
					Link.moveflags &= ~bit;
			}
			break;
		}
		
	///----------------------------------------------------------------------------------------------------//
	//Input States
		case INPUTSTART:
		{
			control_state[6]=((value/10000)!=0)?true:false;
			if ( get_bit(quest_rules,qr_FIXDRUNKINPUTS) ) drunk_toggle_state[6]=false;
			break;
		}
			
		case INPUTMAP:
		{
			control_state[9]=((value/10000)!=0)?true:false;
			if ( get_bit(quest_rules,qr_FIXDRUNKINPUTS) ) 
				drunk_toggle_state[9]=false;
			break;
		}
			
		case INPUTUP:
		{
			control_state[0]=((value/10000)!=0)?true:false;
			if ( get_bit(quest_rules,qr_FIXDRUNKINPUTS) ) drunk_toggle_state[0]=false;
			break;
		}
			
		case INPUTDOWN:
		{
			control_state[1]=((value/10000)!=0)?true:false;
			if ( get_bit(quest_rules,qr_FIXDRUNKINPUTS) ) 
				drunk_toggle_state[1]=false;
			break;
		}
			
		case INPUTLEFT:
		{
			control_state[2]=((value/10000)!=0)?true:false;
			if ( get_bit(quest_rules,qr_FIXDRUNKINPUTS) ) drunk_toggle_state[2]=false;
			break;
		}
			
		case INPUTRIGHT:
		{
			control_state[3]=((value/10000)!=0)?true:false;
			if ( get_bit(quest_rules,qr_FIXDRUNKINPUTS) ) drunk_toggle_state[3]=false;
			break;
		}
			
		case INPUTA:
		{
			control_state[4]=((value/10000)!=0)?true:false;
			if ( get_bit(quest_rules,qr_FIXDRUNKINPUTS) ) drunk_toggle_state[4]=false;
			break;
		}
			
		case INPUTB:
		{
			control_state[5]=((value/10000)!=0)?true:false;
			if ( get_bit(quest_rules,qr_FIXDRUNKINPUTS) ) drunk_toggle_state[5]=false;
			break;
		}
			
		case INPUTL:
		{
			control_state[7]=((value/10000)!=0)?true:false;
			if ( get_bit(quest_rules,qr_FIXDRUNKINPUTS) ) drunk_toggle_state[7]=false;
			break;
		}
			
		case INPUTR:
		{
			control_state[8]=((value/10000)!=0)?true:false;
			if ( get_bit(quest_rules,qr_FIXDRUNKINPUTS) ) drunk_toggle_state[8]=false;
			break;
		}
			
		case INPUTEX1:
		{
			control_state[10]=((value/10000)!=0)?true:false;
			break;
		}
			
		case INPUTEX2:
			control_state[11]=((value/10000)!=0)?true:false;
			break;
			
		case INPUTEX3:
			control_state[12]=((value/10000)!=0)?true:false;
			break;
			
		case INPUTEX4:
			control_state[13]=((value/10000)!=0)?true:false;
			break;
			
		case INPUTAXISUP:
			control_state[14]=((value/10000)!=0)?true:false;
			break;
			
		case INPUTAXISDOWN:
			control_state[15]=((value/10000)!=0)?true:false;
			break;
			
		case INPUTAXISLEFT:
			control_state[16]=((value/10000)!=0)?true:false;
			break;
			
		case INPUTAXISRIGHT:
			control_state[17]=((value/10000)!=0)?true:false;
			break;
			
		case INPUTPRESSSTART:
			button_press[6]=((value/10000)!=0)?true:false;
			break;
			
		case INPUTPRESSMAP:
			button_press[9]=((value/10000)!=0)?true:false;
			break;
			
		case INPUTPRESSUP:
			button_press[0]=((value/10000)!=0)?true:false;
			break;
			
		case INPUTPRESSDOWN:
			button_press[1]=((value/10000)!=0)?true:false;
			break;
			
		case INPUTPRESSLEFT:
			button_press[2]=((value/10000)!=0)?true:false;
			break;
			
		case INPUTPRESSRIGHT:
			button_press[3]=((value/10000)!=0)?true:false;
			break;
			
		case INPUTPRESSA:
			button_press[4]=((value/10000)!=0)?true:false;
			break;
			
		case INPUTPRESSB:
			button_press[5]=((value/10000)!=0)?true:false;
			break;
			
		case INPUTPRESSL:
			button_press[7]=((value/10000)!=0)?true:false;
			break;
			
		case INPUTPRESSR:
			button_press[8]=((value/10000)!=0)?true:false;
			break;
			
		case INPUTPRESSEX1:
			button_press[10]=((value/10000)!=0)?true:false;
			break;
			
		case INPUTPRESSEX2:
			button_press[11]=((value/10000)!=0)?true:false;
			break;
			
		case INPUTPRESSEX3:
			button_press[12]=((value/10000)!=0)?true:false;
			break;
			
		case INPUTPRESSEX4:
			button_press[13]=((value/10000)!=0)?true:false;
			break;
			
		case INPUTPRESSAXISUP:
			button_press[14]=((value/10000)!=0)?true:false;
			break;
			
		case INPUTPRESSAXISDOWN:
			button_press[15]=((value/10000)!=0)?true:false;
			break;
			
		case INPUTPRESSAXISLEFT:
			button_press[16]=((value/10000)!=0)?true:false;
			break;
			
		case INPUTPRESSAXISRIGHT:
			button_press[17]=((value/10000)!=0)?true:false;
			break;
			
		case INPUTMOUSEX:
		{
			int leftOffset=(resx/2)-(128*screen_scale);
			position_mouse((value/10000)*screen_scale+leftOffset, gui_mouse_y());
			break;
		}
		
		case INPUTMOUSEY:
		{
			int mousequakeoffset = 56+((int)(sin((double)(--quakeclk*2-frame))*4));
			int tempoffset = (quakeclk > 0) ? mousequakeoffset : playing_field_offset;
			int topOffset=(resy/2)-((112-tempoffset)*screen_scale);
			position_mouse(gui_mouse_x(), (value/10000)*screen_scale+topOffset);
			break;
		}
		
		case INPUTMOUSEZ:
			position_mouse_z(value/10000);
			break;
		
		case FFRULE:
		{
			int ruleid = vbound((ri->d[0]/10000),0,qr_MAX);
			set_bit(quest_rules, ruleid, (value?true:false));
			switch(ruleid)
			{
				case qr_LTTPWALK:
					Link.setDiagMove(value?1:0);
					break;
				case qr_LTTPCOLLISION:
					Link.setBigHitbox(value?1:0);
					break;
			}
		}
		break;
		
		case BUTTONPRESS:
			// DUkey, DDkey, DLkey, DRkey, Akey, Bkey, Skey, Lkey, Rkey, Pkey, Exkey1, Exkey2, Exkey3, Exkey4 };
		{
			//Read-only
			int button = vbound((ri->d[0]/10000),0,17);
			button_press[button]=((value/10000)!=0)?true:false;
			if ( button < 11 && get_bit(quest_rules,qr_FIXDRUNKINPUTS) ) drunk_toggle_state[button]=false;
			
		}
		break;

		case BUTTONINPUT:
		{
			//Read-only
			int button = vbound((ri->d[0]/10000),0,17);
			control_state[button]=((value/10000)!=0)?true:false;
			if ( button < 11 && get_bit(quest_rules,qr_FIXDRUNKINPUTS) ) drunk_toggle_state[button]=false;
		}
		break;

		case BUTTONHELD:
		{
			//Read-only
			int button = vbound((ri->d[0]/10000),0,17);
			button_hold[button]=((value/10000)!=0)?true:false;
		}
		break;

		case RAWKEY:
		{	//Game->KeyPressed[], read-only
			//if ( !keypressed() ) break; //Don;t return values set by setting Link->Input/Press
			//hmm...no, this won;t return properly for modifier keys. 
			int keyid = ri->d[0]/10000;
			//key = vbound(key,0,n);
			key[keyid]=((value/10000)!=0)?true:false; //It isn't possible to set keys true, because polling occurs before they are set?
			//but they *can* be set false; ??? -Z
		}
		break;
		
		case KEYINPUT:
		{
			KeyInput[ri->d[0]/10000] = (value/10000)!=0;
			switch(ri->d[0]/10000)
			{
				case KEY_F6: onTryQuit(); break;
				case KEY_F3: Paused = !Paused; break;
				case KEY_F4: Paused = true; Advance = true; break;
			}
			break;
		}
		case KEYPRESS:
		{
			KeyPress[ri->d[0]/10000] = (value/10000)!=0;
			break;
		}
		
		case SIMULATEKEYPRESS:
		{	//Game->KeyPressed[], read-only
			//if ( !keypressed() ) break; //Don;t return values set by setting Link->Input/Press
			//hmm...no, this won;t return properly for modifier keys. 
			int keyid = ri->d[0]/10000;
			//key = vbound(key,0,n);
			if (value/10000) simulate_keypress(keyid << 8);
		}
		break;
		
		case KEYMODIFIERS:
		{
			key_shifts = ( value/10000 );
			break;
		}
		
		case KEYBINDINGS:
		{
			int keyid = ri->d[0]/10000;
			switch(keyid)
			{
				case 0: DUkey = ( value/10000 ); break;
				case 1: DDkey = ( value/10000 ); break; 
				case 2: DLkey = ( value/10000 ); break;
				case 3: DRkey = ( value/10000 ); break;
				case 4: Akey = ( value/10000 ); break;
				case 5: Bkey = ( value/10000 ); break;
				case 6: Skey = ( value/10000 ); break;
				case 7: Lkey = ( value/10000 ); break;
				case 8: Rkey = ( value/10000 ); break;
				case 9: Pkey = ( value/10000 ); /*map*/ break; 
				case 10: Exkey1 = ( value/10000 ); break;
				case 11: Exkey2 = ( value/10000 ); break;
				case 12: Exkey3 = ( value/10000 ); break;
				case 13: Exkey4 = ( value/10000 ); break;
				
				default: { Z_scripterrlog("Invalid index [%d] passed to Input->KeyBindings[]\n", keyid); break; }
			}
			break;
		}
		
		case DISABLEKEY:
		{
			//Input->DisableKey(int key, bool disable)
			int keyid = ri->d[0]/10000;
			if(!zc_disablekey(keyid, value))
			{
				//Z_scripterrlog("The key %d passed to Input->DisableKey[] is system-reserved, and cannot be disabled\n",keyid);
			}
			break;
		}
		
		case DISABLEBUTTON:
		{
			//Input->DisableButton(int cb, bool disable)
			int cbid = ri->d[0]/10000;
			disable_control[cbid] = value?true:false;
			break;
		}
		
		case MOUSEARR:
		{	
			int indx = (ri->d[0]/10000);
			switch (indx)
			{
				case 0: //MouseX
				{
					int leftOffset=(resx/2)-(128*screen_scale);
					position_mouse((value/10000)*screen_scale+leftOffset, gui_mouse_y());
					break;	
				}
				case 1: //MouseY
				{
					int mousequakeoffset = 56+((int)(sin((double)(--quakeclk*2-frame))*4));
					int tempoffset = (quakeclk > 0) ? mousequakeoffset : playing_field_offset;
					int topOffset=(resy/2)-((112-tempoffset)*screen_scale);
					position_mouse(gui_mouse_x(), (value/10000)*screen_scale+topOffset);
					break;
					
				}
				case 2: //MouseZ
				{
					position_mouse_z(value/10000);
					break;
				}
				case 3: //Left Click
				{
					if ( value ) mouse_b |= 1;
					else mouse_b &= ~1;
					break;
				}
				case 4: //Right Click
				{
					if ( value ) mouse_b |= 2;
					else mouse_b &= ~2;
					break;
				}
				case 5: //Middle Click
				{
					if ( value ) mouse_b |= 4;
					else mouse_b &= ~4;
					break;
				}
				default:
				{
					Z_scripterrlog("Invalid index passed to Input->Mouse[]: %d\n", indx);
				}
			}
				
		}
		break;
			
			
	///----------------------------------------------------------------------------------------------------//
	//Item Variables
		
		case ITEMFAMILY:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->family)=value/10000;
			}
			
			break;
		
		case ITEMLEVEL:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->lvl)=value/10000;
			}
			
			break;
			
		case SPRITEMAXITEM:
		{
			//No bounds check, as this is a universal function and works from NULL pointers!
			items.setMax(vbound((value/10000),1,MAX_ITEM_SPRITES));
			break;
		}
		
		case ITEMX:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(s->x)=get_bit(quest_rules,qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000);
				
				// Move the Fairy enemy as well.
				if(itemsbuf[((item*)(s))->id].family==itype_fairy && itemsbuf[((item*)(s))->id].misc3)
					movefairy2(((item*)(s))->x,((item*)(s))->y,((item*)(s))->misc);
			}
			
			break;
		
		case ITEMSPRITESCRIPT:
			FFScript::deallocateAllArrays(SCRIPT_ITEMSPRITE, ri->itemref);
			if(0!=(s=checkItem(ri->itemref)))
			{
				(s->script)=(value/10000);
			}
			break;
		
		case ITEMSCALE:
			if ( get_bit(quest_rules, qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"item->Scale");
				break;
			}
			if(0!=(s=checkItem(ri->itemref)))
			{
				(s->scale)=(zfix)(value/100.0);
			}
			
			break;
			
		case ITEMY:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(s->y)=get_bit(quest_rules,qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000);
				
				// Move the Fairy enemy as well.
				if(itemsbuf[((item*)(s))->id].family==itype_fairy && itemsbuf[((item*)(s))->id].misc3)
					movefairy2(((item*)(s))->x,((item*)(s))->y,((item*)(s))->misc);
			}
			
			break;
			
		case ITEMZ:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(s->z)=(zfix)(value/10000);
				
				if(s->z < 0)
					s->z = 0;
			}
			
			break;
			
		case ITEMJUMP:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->fall)=zslongToFix(value)*-100;
			}
			
			break;
			
		case ITEMDRAWTYPE:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->drawstyle)=value/10000;
			}
			
			break;
			
		 case ITEMSPRITEINITD:
			if(0!=(s=checkItem(ri->itemref)))
			{
				int a = vbound(ri->d[0]/10000,0,7);
				(((item *)s)->initD[a])=value;
			}
			
			break;
			
		case ITEMGRAVITY:
			if(0!=(s=checkItem(ri->itemref)))
			{
				if(value)
					((item *)s)->moveflags |= FLAG_OBEYS_GRAV;
				else
					((item *)s)->moveflags &= ~FLAG_OBEYS_GRAV;
			}
			
			break;
			
		case ITEMID:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->id)=value/10000;
				flushItemCache();
			}
			
			break;
			
		case ITEMTILE:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->tile)=vbound(value/10000,0,NEWMAXTILES-1);
			}
			
			break;
			
		case ITEMSCRIPTTILE:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->scripttile)=vbound(value/10000,-1,NEWMAXTILES-1);
			}
			break;
			
		case ITEMSCRIPTFLIP:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->scriptflip)=vbound((value/10000),-1,127);
			}
			break;
		
		case ITEMPSTRING:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->pstring)=vbound(value/10000,0,(msg_count-1));
			}
			
			break;
		
		case ITEMPSTRINGFLAGS:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->pickup_string_flags)=(value/10000);
			}
			
			break;
		
		case ITEMOVERRIDEFLAGS:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->overrideFLAGS)=(value/10000);
			}
			
			break;
			
		case ITEMOTILE:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->o_tile)=vbound(value/10000,0,NEWMAXTILES-1);
			}
			
			break;
			
		case ITEMCSET:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->o_cset) = (((item *)s)->o_cset & ~15) | ((value/10000)&15);
				(((item *)s)->cs) = (((item *)s)->o_cset & 15);
			}
			
			break;
			
		case ITEMFLASHCSET:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->o_cset) = ((value/10000)<<4) | (((item *)s)->o_cset & 15);
			}
			
			break;
			
		case ITEMFRAMES:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->frames)=value/10000;
			}
			
			break;
			
		case ITEMFRAME:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->aframe)=value/10000;
			}
			
			break;
			
		case ITEMASPEED:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->o_speed)=value/10000;
			}
			
			break;
		
		 case ITEMACLK:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->aclk)=value/10000;
			}
			
			break;
		
		case ITEMDELAY:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->o_delay)=value/10000;
			}
			
			break;
			
		case ITEMFLIP:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->flip)=value/10000;
			}
			
			break;
			
		case ITEMFLASH:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->flash)= (value/10000)?1:0;
			}
			
			break;
			
		case ITEMEXTEND:
			if(0!=(s=checkItem(ri->itemref)))
			{
				(((item *)s)->extend)=value/10000;
			}
			
			break;
			
		case ITEMHXOFS:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->hxofs=value/10000;
			}
			
			break;
			
		case ITEMROTATION:
			if ( get_bit(quest_rules, qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"item->Rotation");
				break;
			}
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->rotation=value/10000;
			}
			
			break;
			
		case ITEMHYOFS:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->hyofs=value/10000;
			}
			
			break;
			
		case ITEMXOFS:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->xofs=(zfix)(value/10000);
			}
			
			break;
			
		case ITEMYOFS:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->yofs=(zfix)(value/10000)+playing_field_offset;
			}
			
			break;
			
		case ITEMZOFS:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->zofs=(zfix)(value/10000);
			}
			
			break;
			
		case ITEMHXSZ:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->hxsz=value/10000;
			}
			
			break;
			
		case ITEMHYSZ:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->hysz=value/10000;
			}
			
			break;
			
		case ITEMHZSZ:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->hzsz=value/10000;
			}
			
			break;
			
		case ITEMTXSZ:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->txsz=vbound((value/10000),1,20);
			}
			
			break;
			
		case ITEMTYSZ:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->tysz=vbound((value/10000),1,20);
			}
			
			break;
			
		case ITEMPICKUP:
			if(0!=(s=checkItem(ri->itemref)))
			{
				int newpickup = value/10000;
				// Values that the questmaker should not use, ever
				//Allowing it, for now, until something breaks. -Z 21-Jan-2020
				//newpickup &= ~(ipBIGRANGE | ipCHECK | ipMONEY | ipBIGTRI | ipNODRAW | ipFADE);
				//
				if (( FFCore.GetQuestVersion() == 0x250 && FFCore.GetQuestBuild() < 33 ) //this ishowit looks in 2.53.1, Beta 25
					|| ( FFCore.GetQuestVersion() < 0x250  ))
				{
					newpickup &= ~(ipBIGRANGE | ipCHECK | ipMONEY | ipBIGTRI | ipNODRAW | ipFADE);
				}
				
				// If making an item timeout, set its timer
				if(newpickup & ipFADE)
				{
					(((item*)(s))->clk2) = 512;
				}
				//else if(newpickup & ~ipFADE)
				//{
				//    (((item*)(s))->clk2) = 0;
				//}
				
				// If making it a carried item,
				// alter hasitem and set an itemguy.
				if((((item*)(s))->pickup & ipENEMY) < (newpickup & ipENEMY))
				{
					hasitem |= 2;
					bool hasitemguy = false;
					
					for(int i=0; i<guys.Count(); i++)
					{
						if(((enemy*)guys.spr(i))->itemguy)
						{
							hasitemguy = true;
						}
					}
					
					if(!hasitemguy && guys.Count()>0)
					{
						((enemy*)guys.spr(guys.Count()-1))->itemguy = true;
					}
				}
				// If unmaking it a carried item,
				// alter hasitem if there are no more carried items.
				else if((((item*)(s))->pickup & ipENEMY) > (newpickup & ipENEMY))
				{
					// Move it back onscreen!
					if(get_bit(quest_rules,qr_HIDECARRIEDITEMS))
					{
						for(int i=0; i<guys.Count(); i++)
						{
							if(((enemy*)guys.spr(i))->itemguy)
							{
								((item*)(s))->x = ((enemy*)guys.spr(i))->x;
								((item*)(s))->y = ((enemy*)guys.spr(i))->y;
								((item*)(s))->z = ((enemy*)guys.spr(i))->z;
								break;
							}
						}
					}
					
					if(more_carried_items()<=1)  // 1 includes this own item.
					{
						hasitem &= ~2;
					}
				}
				
				((item*)(s))->pickup=value/10000;
			}
			
			break;
			
		case ITEMMISCD:
			if(0!=(s=checkItem(ri->itemref)))
			{
				int a = vbound(ri->d[0]/10000,0,31);
				(((item*)(s))->miscellaneous[a])=value;
			}
			
			break;
		case ITEMFALLCLK:
			if(0!=(s=checkItem(ri->itemref)))
			{
				if(((item*)(s))->fallclk != 0 && value == 0)
				{
					((item*)(s))->cs = ((item*)(s))->old_cset;
					((item*)(s))->tile = ((item*)(s))->o_tile;
				}
				else if(((item*)(s))->fallclk == 0 && value != 0) ((item*)(s))->old_cset = ((item*)(s))->cs;
				((item*)(s))->fallclk = vbound(value/10000,0,70);
			}
			break;
		case ITEMFALLCMB:
			if(0!=(s=checkItem(ri->itemref)))
			{
				((item*)(s))->fallCombo = vbound(value/10000,0,MAXCOMBOS-1);
			}
			break;
		case ITEMMOVEFLAGS:
		{
			if(0!=(s=checkItem(ri->itemref)))
			{
				int indx = ri->d[0]/10000;
				if(BC::checkBounds(indx, 0, 1, "itemsprite->MoveFlags[]") == SH::_NoError)
				{
					//All bits, in order, of a single byte; just use bitwise
					byte bit = 1<<indx;
					if(value)
						((item*)(s))->moveflags |= bit;
					else
						((item*)(s))->moveflags &= ~bit;
				}
			}
			break;
		}
			
	///----------------------------------------------------------------------------------------------------//
	//Itemdata Variables
		//not mine, but let;s guard some of them all the same -Z
		//item class
		case IDATAFAMILY:
			(itemsbuf[ri->idata].family)=vbound(value/10000,0, 254);
			flushItemCache();
			break;
		
		case IDATAUSEWPN:
			(itemsbuf[ri->idata].useweapon)=vbound(value/10000, 0, 255);
			break;
		case IDATAUSEDEF:
			(itemsbuf[ri->idata].usedefence)=vbound(value/10000, 0, 255);
			break;
		case IDATAWRANGE:
			(itemsbuf[ri->idata].weaprange)=vbound(value/10000, 0, 255);
			break;
		case IDATAMAGICTIMER:
			(itemsbuf[ri->idata].magiccosttimer)=vbound(value/10000, 0, 214747);
			break;
		case IDATADURATION:
			(itemsbuf[ri->idata].weapduration)=vbound(value/10000, 0, 255);
			break;
		 
		case IDATADUPLICATES:
			(itemsbuf[ri->idata].duplicates)=vbound(value/10000, 0, 255);
			break;
		case IDATADRAWLAYER:
			(itemsbuf[ri->idata].drawlayer)=vbound(value/10000, 0, 7);
			break;
		case IDATACOLLECTFLAGS:
			//int a = ri->d[0] / 10000;
			(itemsbuf[ri->idata].collectflags)=vbound(value/10000, 0, 214747);
			break;
		case IDATAWEAPONSCRIPT:
			(itemsbuf[ri->idata].weaponscript)=vbound(value/10000, 0, 255);
			break;
		case IDATAMISCD:
		{
			int a = vbound((ri->d[0] / 10000),0,31);
			(itemsbuf[ri->idata].wpn_misc_d[a])=(value/10000);
		}
		break;
		case IDATAWPNINITD:
		{
			int a = vbound((ri->d[0] / 10000),0,7);
			(itemsbuf[ri->idata].weap_initiald[a])=(value);
		}
		break;
		case IDATAWEAPHXOFS:
			(itemsbuf[ri->idata].weap_hxofs)=(value/10000);
			break;
		case IDATAWEAPHYOFS:
			(itemsbuf[ri->idata].weap_hyofs)=(value/10000);
			break;
		case IDATAWEAPHXSZ:
			(itemsbuf[ri->idata].weap_hxsz)=(value/10000);
			break;
		case IDATAWEAPHYSZ:
			(itemsbuf[ri->idata].weap_hysz)=(value/10000);
			break;
		case IDATAWEAPHZSZ:
			(itemsbuf[ri->idata].weap_hzsz)=(value/10000);
			break;
		case IDATAWEAPXOFS:
			(itemsbuf[ri->idata].weap_xofs)=(value/10000);
			break;
		case IDATAWEAPYOFS:
			(itemsbuf[ri->idata].weap_yofs)=(value/10000);
			break;

		
		case IDATAHXOFS:
			(itemsbuf[ri->idata].hxofs)=(value/10000);
			break;
		case IDATAHYOFS:
			(itemsbuf[ri->idata].hyofs)=(value/10000);
			break;
		case IDATAHXSZ:
			(itemsbuf[ri->idata].hxsz)=(value/10000);
			break;
		case IDATAHYSZ:
			(itemsbuf[ri->idata].hysz)=(value/10000);
			break;
		case IDATAHZSZ:
			(itemsbuf[ri->idata].hzsz)=(value/10000);
			break;
		case IDATADXOFS:
			(itemsbuf[ri->idata].xofs)=(value/10000);
			break;
		case IDATADYOFS:
			(itemsbuf[ri->idata].yofs)=(value/10000);
			break;
		case IDATATILEW:
			(itemsbuf[ri->idata].tilew)=(value/10000);
			break;
		case IDATATILEH:
			(itemsbuf[ri->idata].tileh)=(value/10000);
			break;
		case IDATAPICKUP:
			(itemsbuf[ri->idata].pickup)=(value/10000);
			break;
		case IDATAOVERRIDEFL:
			(itemsbuf[ri->idata].overrideFLAGS)=(value/10000);
			break;

		case IDATATILEWWEAP:
			(itemsbuf[ri->idata].weap_tilew)=(value/10000);
			break;
		case IDATATILEHWEAP:
			(itemsbuf[ri->idata].weap_tileh)=(value/10000);
			break;
		case IDATAOVERRIDEFLWEAP:
			(itemsbuf[ri->idata].weapoverrideFLAGS)=(value/10000);
			break;
		
		case IDATAUSEMVT:
		{
			long a = vbound((ri->d[0] / 10000),0,(ITEM_MOVEMENT_PATTERNS-1));
			(itemsbuf[ri->idata].weap_pattern[a])=vbound(value/10000, 0, 255);
			break;
		}
		
		
		//item level
		case IDATALEVEL:
			(itemsbuf[ri->idata].fam_type)=vbound(value/10000, 0, 512);
			flushItemCache();
			break;
			//bool keep
		case IDATAKEEP:
			(itemsbuf[ri->idata].flags)|=(value/10000)?ITEM_GAMEDATA:0;
			break;
			//Need the legal range -Z
		case IDATAAMOUNT:
			(itemsbuf[ri->idata].amount)=value/10000;
			break;
			
		case IDATASETMAX:
			(itemsbuf[ri->idata].setmax)=value/10000;
			break;
			
		case IDATAMAX:
			(itemsbuf[ri->idata].max)=value/10000;
			break;
			
		case IDATAPOWER:
			(itemsbuf[ri->idata].power)=value/10000;
			break;
			
		case IDATACOUNTER:
			(itemsbuf[ri->idata].count)=vbound(value/10000,0,31);
			break;
			
		case IDATAUSESOUND:
			(itemsbuf[ri->idata].usesound)=vbound(value/10000, 0, 255);
			break;
		
		//2.54
		//My additions begin here. -Z
		//Stack item to gain next level
		case IDATACOMBINE:
			(value) ? (itemsbuf[ri->idata].flags)|=ITEM_COMBINE: (itemsbuf[ri->idata].flags)&= ~ITEM_COMBINE;
			break;
		//using a level of an item downgrades to a lower one
		case IDATADOWNGRADE:
			(value) ? (itemsbuf[ri->idata].flags)|=ITEM_DOWNGRADE: (itemsbuf[ri->idata].flags)&= ~ITEM_DOWNGRADE;
			break;
		  //Only validate the cost, don't charge it
		case IDATAVALIDATE:
			(value) ? (itemsbuf[ri->idata].flags)|=ITEM_VALIDATEONLY: (itemsbuf[ri->idata].flags)&= ~ITEM_VALIDATEONLY;
			break;

		//Flags[5]
		case IDATAFLAGS:
		{
			int index = vbound(ri->d[0]/10000,0,15);
			switch(index)
			{
				case 0:
					(value) ? (itemsbuf[ri->idata].flags)|=ITEM_FLAG1 : (itemsbuf[ri->idata].flags)&= ~ITEM_FLAG1; 
					break;
				case 1:
					(value) ? (itemsbuf[ri->idata].flags)|=ITEM_FLAG2 : (itemsbuf[ri->idata].flags)&= ~ITEM_FLAG2; 
					break;
				case 2:
					(value) ? (itemsbuf[ri->idata].flags)|=ITEM_FLAG3 : (itemsbuf[ri->idata].flags)&= ~ITEM_FLAG3; 
					break;
				case 3:
					(value) ? (itemsbuf[ri->idata].flags)|=ITEM_FLAG4 : (itemsbuf[ri->idata].flags)&= ~ITEM_FLAG4; 
					break;
				case 4:
					(value) ? (itemsbuf[ri->idata].flags)|=ITEM_FLAG5 : (itemsbuf[ri->idata].flags)&= ~ITEM_FLAG5; 
					break;
				case 5:
					(value) ? (itemsbuf[ri->idata].flags)|=ITEM_FLAG6 : (itemsbuf[ri->idata].flags)&= ~ITEM_FLAG6;  
					break;
				case 6:
					(value) ? (itemsbuf[ri->idata].flags)|=ITEM_FLAG7 : (itemsbuf[ri->idata].flags)&= ~ITEM_FLAG7;  
					break;
				case 7:
					(value) ? (itemsbuf[ri->idata].flags)|=ITEM_FLAG8 : (itemsbuf[ri->idata].flags)&= ~ITEM_FLAG8; 
					break;
				case 8:
					(value) ? (itemsbuf[ri->idata].flags)|=ITEM_FLAG9 : (itemsbuf[ri->idata].flags)&= ~ITEM_FLAG9; 
					break;
				case 9:
					(value) ? (itemsbuf[ri->idata].flags)|=ITEM_FLAG10 : (itemsbuf[ri->idata].flags)&= ~ITEM_FLAG10;  
					break;
				case 10:
					(value) ? (itemsbuf[ri->idata].flags)|=ITEM_FLAG11 : (itemsbuf[ri->idata].flags)&= ~ITEM_FLAG11; 
					break;
				case 11:
					(value) ? (itemsbuf[ri->idata].flags)|=ITEM_FLAG12 : (itemsbuf[ri->idata].flags)&= ~ITEM_FLAG12;  
					break;
				case 12:
					(value) ? (itemsbuf[ri->idata].flags)|=ITEM_FLAG13 : (itemsbuf[ri->idata].flags)&= ~ITEM_FLAG13; 
					break;
				case 13:
					(value) ? (itemsbuf[ri->idata].flags)|=ITEM_FLAG14 : (itemsbuf[ri->idata].flags)&= ~ITEM_FLAG14; 
					break;
				case 14:
					(value) ? (itemsbuf[ri->idata].flags)|=ITEM_FLAG15 : (itemsbuf[ri->idata].flags)&= ~ITEM_FLAG15;  
					break;
				case 15:
					(value) ? (itemsbuf[ri->idata].flags)|=ITEM_FLAG16 : (itemsbuf[ri->idata].flags)&= ~ITEM_FLAG16; 
					break;
				
				
				default: 
					break;
			}
				
			break;
		}
		//Keep Old in editor
		case IDATAKEEPOLD:
			(value) ? (itemsbuf[ri->idata].flags)|=ITEM_KEEPOLD : (itemsbuf[ri->idata].flags)&= ~ITEM_KEEPOLD;
			break;
		//Ruppes for magic
		case IDATARUPEECOST:
			(value) ? (itemsbuf[ri->idata].flags)|=ITEM_RUPEE_MAGIC : (itemsbuf[ri->idata].flags)&= ~ITEM_RUPEE_MAGIC;
			break;
		//can be eaten
		case IDATAEDIBLE:
			(value) ? (itemsbuf[ri->idata].flags)|=ITEM_EDIBLE : (itemsbuf[ri->idata].flags)&= ~ITEM_EDIBLE;
			break;
		//Reserving this for item editor stuff. 
		case IDATAFLAGUNUSED:
			(value) ? (itemsbuf[ri->idata].flags)|=ITEM_UNUSED : (itemsbuf[ri->idata].flags)&= ~ITEM_UNUSED;
			break;
		//gain lower level items
		case IDATAGAINLOWER:
			(value) ? (itemsbuf[ri->idata].flags)|=ITEM_GAINOLD : (itemsbuf[ri->idata].flags)&= ~ITEM_GAINOLD;
			break;
		//Set the action script
		case IDATASCRIPT:
			FFScript::deallocateAllArrays(SCRIPT_ITEM, ri->idata);
			itemsbuf[ri->idata].script=vbound(value/10000,0,255);
			break;
		
		/*
		case ITEMMISCD:
			if(0!=(s=checkItem(ri->itemref)))
			{
				int a = vbound(ri->d[0]/10000,0,31);
				(((item*)(s))->miscellaneous[a])=value;
			}
			
			break;*/
		//Attributes[10]
		case IDATAATTRIB: {
			int index = vbound(ri->d[0]/10000,0,9);
			switch(index)
			{
				case 0:
					itemsbuf[ri->idata].misc1=value/10000;
					break;
				case 1:
					itemsbuf[ri->idata].misc2=value/10000; break;
				case 2:
					itemsbuf[ri->idata].misc3=value/10000; break;
				case 3:
					itemsbuf[ri->idata].misc4=value/10000; break;
				case 4:
					itemsbuf[ri->idata].misc5=value/10000; break;
				case 5:
					itemsbuf[ri->idata].misc6=value/10000; break;
				case 6:
					itemsbuf[ri->idata].misc7=value/10000; break;
				case 7:
					itemsbuf[ri->idata].misc8=value/10000; break;
				case 8:
					itemsbuf[ri->idata].misc9=value/10000; break;
				case 9:
					itemsbuf[ri->idata].misc10=value/10000; break;

				default: 
					break;
			}
				
			break;
		}
		//SpriteSprites[10]
		case IDATASPRITE:
		{
			int index = vbound(ri->d[0]/10000,0,9);
			switch(index)
			{
				case 0:
					itemsbuf[ri->idata].wpn=vbound(value/10000, 0, 255);
					break;
				case 1:
					itemsbuf[ri->idata].wpn2=vbound(value/10000, 0, 255); break;
				case 2:
					itemsbuf[ri->idata].wpn3=vbound(value/10000, 0, 255); break;
				case 3:
					itemsbuf[ri->idata].wpn4=vbound(value/10000, 0, 255); break;
				case 4:
					itemsbuf[ri->idata].wpn5=vbound(value/10000, 0, 255); break;
				case 5:
					itemsbuf[ri->idata].wpn6=vbound(value/10000, 0, 255); break;
				case 6:
					itemsbuf[ri->idata].wpn7=vbound(value/10000, 0, 255); break;
				case 7:
					itemsbuf[ri->idata].wpn8=vbound(value/10000, 0, 255); break;
				case 8:
					itemsbuf[ri->idata].wpn9=vbound(value/10000, 0, 255); break;
				case 9:
					itemsbuf[ri->idata].wpn10=vbound(value/10000, 0, 255); break;
				
				default: 
					break;
			}
				
			break;
		}
		//Link tile modifier. 
		case IDATALTM:
			itemsbuf[ri->idata].ltm=value/10000;
			break;
		//Pickup script
		case IDATAPSCRIPT:
		{
			//Need to get collect script ref, not standard idata ref!
			const long new_ref = ri->idata!=0 ? -(ri->idata) : COLLECT_SCRIPT_ITEM_ZERO;
			FFScript::deallocateAllArrays(SCRIPT_ITEM,new_ref);
			itemsbuf[ri->idata].collect_script=vbound(value/10000, 0, 255);
			break;
		}
		//pickup string
		case IDATAPSTRING:
			itemsbuf[ri->idata].pstring=vbound(value/10000, 1, 255);
			break;
		//magic cost
		case IDATAMAGCOST:
			itemsbuf[ri->idata].magic=value/10000;
			break;
		//cost counter ref
		case IDATACOSTCOUNTER:
			itemsbuf[ri->idata].cost_counter=(vbound(value/10000,0,255));
			break;
		//min hearts to pick up
		case IDATAMINHEARTS:
			itemsbuf[ri->idata].pickup_hearts=vbound(value/10000, 0, 214748);
			break;
		//item tile
		case IDATATILE:
			itemsbuf[ri->idata].tile=vbound(value/10000, 0, 65519);
			break;
		//flash
		case IDATAMISC:
			itemsbuf[ri->idata].misc=value/10000;
			break;
		//cset
		case IDATACSET:
			itemsbuf[ri->idata].csets=vbound(value/10000,0,13);
			break;
		/*
		case IDATAFRAME:
			itemsbuf[ri->idata].frame=value/10000;
			break;
		*/
		//A.Frames
		case IDATAFRAMES:
			(itemsbuf[ri->idata].frames)=vbound(value/10000, 0, 214748);
			break;
		//A.speed
		case IDATAASPEED:
			itemsbuf[ri->idata].speed=vbound(value/10000, 0, 214748);
			break;
		//Anim delay
		case IDATADELAY:
			itemsbuf[ri->idata].delay=vbound(value/10000, 0, 214748);
			break;
		 
			//not one of mine. 
		case IDATAINITDD:
		{
			int a = ri->d[0] / 10000;
			
			if(BC::checkBounds(a, 0, 7, "itemdata->InitD") == SH::_NoError)
				itemsbuf[ri->idata].initiald[a] = value;
		}
		break;
		
	///----------------------------------------------------------------------------------------------------//
	//LWeapon Variables
		
		case LWPNSCALE:
			if ( get_bit(quest_rules, qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"lweapon->Scale");
				break;
			}
			if(0!=(s=checkLWpn(ri->lwpn,"Scale")))
				((weapon*)s)->scale=(zfix)(value/100.0);
				
			break;
		
		case LWPNX:
			if(0!=(s=checkLWpn(ri->lwpn,"X")))
				((weapon*)s)->x=get_bit(quest_rules,qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000);
			break;
		
		case SPRITEMAXLWPN:
		{
			//No bounds check, as this is a universal function and works from NULL pointers!
			Lwpns.setMax(vbound((value/10000),1,MAX_LWPN_SPRITES));
			break;
		}
			
		case LWPNY:
			if(0!=(s=checkLWpn(ri->lwpn,"Y")))
				((weapon*)s)->y=get_bit(quest_rules,qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000);
				
			break;
			
		case LWPNZ:
			if(0!=(s=checkLWpn(ri->lwpn,"Z")))
			{
				((weapon*)s)->z=get_bit(quest_rules,qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000);
				if(((weapon*)s)->z < 0) ((weapon*)s)->z = zfix(0);
			}
				
			break;
			
		case LWPNJUMP:
			if(0!=(s=checkLWpn(ri->lwpn,"Jump")))
				((weapon*)s)->fall=zslongToFix(value)*-100;
				
			break;
			
		case LWPNDIR:
			if(0!=(s=checkLWpn(ri->lwpn,"Dir")))
				((weapon*)s)->dir=(value/10000);
				
			break;
			
		case LWPNSPECIAL:
			if(0!=(s=checkLWpn(ri->lwpn,"Special")))
				((weapon*)s)->specialinfo=(value/10000);
				
			break;
		 
		case LWPNGRAVITY:
			if(0!=(s=checkLWpn(ri->lwpn,"Gravity")))
			{
				if(value)
					((weapon*)s)->moveflags |= FLAG_OBEYS_GRAV;
				else
					((weapon*)s)->moveflags &= ~FLAG_OBEYS_GRAV;
			}
			break;
			
		case LWPNSTEP:
			if(0!=(s=checkLWpn(ri->lwpn,"Step")))
			{
				if ( get_bit(quest_rules,qr_STEP_IS_FLOAT) )
				{
					((weapon*)s)->step= zslongToFix(value / 100);
				}
				else
				{
					//old, buggy code replication, round two: Go! -Z
					//zfix val = zslongToFix(value);
					//val.doFloor();
					//((weapon*)s)->step = ((val / 100.0).getFloat());
					
					//old, buggy code replication, round THREE: Go! -Z
					((weapon*)s)->step = ((value/10000)/100.0);
				}
				
			}
				
			break;
			
		case LWPNANGLE:
			if(0!=(s=checkLWpn(ri->lwpn,"Angle")))
				((weapon*)s)->angle=(double)(value/10000.0);
				
			break;
			
		case LWPNANGULAR:
			if(0!=(s=checkLWpn(ri->lwpn,"Angular")))
				((weapon*)s)->angular=(value/10000) != 0;
				
			break;
			
		case LWPNBEHIND:
			if(0!=(s=checkLWpn(ri->lwpn,"Behind")))
				((weapon*)s)->behind=(value/10000) != 0;
				
			break;
			
		case LWPNDRAWTYPE:
			if(0!=(s=checkLWpn(ri->lwpn,"DrawStyle")))
				((weapon*)s)->drawstyle=(value/10000);
				
			break;
			
		case LWPNPOWER:
			if(0!=(s=checkLWpn(ri->lwpn,"Damage")))
				((weapon*)s)->power=(value/10000);
				
			break;
		/*
		case LWPNRANGE:
			if(0!=(s=checkLWpn(ri->lwpn,"Range")))
			((weapon*)s)->scriptrange=vbound((value/10000),0,512); //Allow it to move off-screen. -Z           
			break;
		*/        
		case LWPNDEAD:
			if(0!=(s=checkLWpn(ri->lwpn,"DeadState")))
				((weapon*)s)->dead=(value/10000);
				
			break;
			
		case LWPNID:
			if(0!=(s=checkLWpn(ri->lwpn,"ID")))
				((weapon*)s)->id=(value/10000);
				
			break;
			
		case LWPNTILE:
			if(0!=(s=checkLWpn(ri->lwpn,"Tile")))
				((weapon*)s)->tile=(value/10000);
				
			break;
		
		case LWPNSCRIPTTILE:
			if(0!=(s=checkLWpn(ri->lwpn,"ScriptTile")))
				((weapon*)s)->scripttile=vbound((value/10000),-1,NEWMAXTILES-1);
				
			break;
		
		case LWPNSCRIPTFLIP:
			if(0!=(s=checkLWpn(ri->lwpn,"ScriptFlip")))
				((weapon*)s)->scriptflip=vbound((value/10000),-1,127);
				
			break;
			
		case LWPNCSET:
			if(0!=(s=checkLWpn(ri->lwpn,"CSet")))
				((weapon*)s)->cs=(value/10000)&15;
				
			break;
			
		case LWPNFLASHCSET:
			if(0!=(s=checkLWpn(ri->lwpn,"FlashCSet")))
				(((weapon*)s)->o_cset)|=(value/10000)<<4;
				
			break;
			
		case LWPNFRAMES:
			if(0!=(s=checkLWpn(ri->lwpn,"NumFrames")))
				((weapon*)s)->frames=(value/10000);
				
			break;
			
		case LWPNFRAME:
			if(0!=(s=checkLWpn(ri->lwpn,"Frame")))
				((weapon*)s)->aframe=(value/10000);
				
			break;
			
		case LWPNASPEED:
			if(0!=(s=checkLWpn(ri->lwpn,"ASpeed")))
				((weapon*)s)->o_speed=(value/10000);
				
			break;
			
		case LWPNFLASH:
			if(0!=(s=checkLWpn(ri->lwpn,"Flash")))
				((weapon*)s)->flash=(value/10000);
				
			break;
			
		case LWPNFLIP:
			if(0!=(s=checkLWpn(ri->lwpn,"Flip")))
				((weapon*)s)->flip=(value/10000);
				
			break;

		case LWPNROTATION:
			if ( get_bit(quest_rules, qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"lweapon->Rotation");
				break;
			}
			if(0!=(s=checkLWpn(ri->lwpn,"Rotation")))
				((weapon*)s)->rotation=(value/10000);
				
			break;
			
		case LWPNEXTEND:
			if(0!=(s=checkLWpn(ri->lwpn,"Extend")))
				((weapon*)s)->extend=(value/10000);
				
			break;
			
		case LWPNOTILE:
			if(0!=(s=checkLWpn(ri->lwpn,"OriginalTile")))
			{
				//zprint("LWPNOTILE before write: %d\n", ((weapon*)s)->o_tile);
					((weapon*)s)->o_tile=(value/10000);
					//((weapon*)s)->script_wrote_otile=1; //Removing this as of 26th October, 2019 -Z
				//if at some future point we WANT writing ->Tile to also overwrite ->OriginalTile,
				//then either the user will need to manually write tile, or we can add a QR and 
				// write ->tile here. 'script_wrote_otile' is out.
				//zprint("LWPNOTILE after write: %d\n", ((weapon*)s)->o_tile);
			}
			break;
			
		case LWPNOCSET:
			if(0!=(s=checkLWpn(ri->lwpn,"OriginalCSet")))
				(((weapon*)s)->o_cset)|=(value/10000)&15;
				
			break;
			
		case LWPNHXOFS:
			if(0!=(s=checkLWpn(ri->lwpn,"HitXOffset")))
				(((weapon*)s)->hxofs)=(value/10000);
				
			break;
			
		case LWPNHYOFS:
			if(0!=(s=checkLWpn(ri->lwpn,"HitYOffset")))
				(((weapon*)s)->hyofs)=(value/10000);
				
			break;
			
		case LWPNXOFS:
			if(0!=(s=checkLWpn(ri->lwpn,"DrawXOffset")))
				(((weapon*)s)->xofs)=(zfix)(value/10000);
				
			break;
			
		case LWPNYOFS:
			if(0!=(s=checkLWpn(ri->lwpn,"DrawYOffset")))
				(((weapon*)s)->yofs)=(zfix)(value/10000)+playing_field_offset;
				
			break;
			
		case LWPNZOFS:
			if(0!=(s=checkLWpn(ri->lwpn,"DrawZOffset")))
				(((weapon*)s)->zofs)=(zfix)(value/10000);
				
			break;
			
		case LWPNHXSZ:
			if(0!=(s=checkLWpn(ri->lwpn,"HitWidth")))
				(((weapon*)s)->hxsz)=(value/10000);
				
			break;
			
		case LWPNHYSZ:
			if(0!=(s=checkLWpn(ri->lwpn,"HitHeight")))
				(((weapon*)s)->hysz)=(value/10000);
				
			break;
			
		case LWPNHZSZ:
			if(0!=(s=checkLWpn(ri->lwpn,"HitZHeight")))
				(((weapon*)s)->hzsz)=(value/10000);
				
			break;
			
		case LWPNTXSZ:
			if(0!=(s=checkLWpn(ri->lwpn,"TileWidth")))
				(((weapon*)s)->txsz)=vbound((value/10000),1,20);
				
			break;
			
		case LWPNTYSZ:
			if(0!=(s=checkLWpn(ri->lwpn,"TileHeight")))
				(((weapon*)s)->tysz)=vbound((value/10000),1,20);
				
			break;
			
		case LWPNMISCD:
			if(0!=(s=checkLWpn(ri->lwpn,"Misc")))
			{
				int a = vbound(ri->d[0]/10000,0,31);
				(((weapon*)(s))->miscellaneous[a])=value;
			}
			
			break;
			
		case LWPNCOLLDET:
			if(0!=(s=checkLWpn(ri->lwpn,"CollDetection")))
				(((weapon*)(s))->scriptcoldet)=value/10000;
				
			break;
		
		case LWPNENGINEANIMATE:
			if(0!=(s=checkLWpn(ri->lwpn,"Animation")))
				(((weapon*)(s))->do_animation)=value/10000;
				
			break;
		
		case LWPNPARENT:
		{
			//int pitm = (vbound(value/10000,1,(MAXITEMS-1)));
			//zprint("Attempting to set ParentItem to: %d\n", pitm); 
					
			if(0!=(s=checkLWpn(ri->lwpn,"Parent")))
				(((weapon*)(s))->parentitem)=(vbound(value/10000,-1,(MAXITEMS-1)));
			break;
		}

		case LWPNLEVEL:
			if(0!=(s=checkLWpn(ri->lwpn,"Level")))
				(((weapon*)(s))->type)=value/10000;
				
			break;
		
		case LWPNSCRIPT:
			if(0!=(s=checkLWpn(ri->lwpn,"Script")))
			{
				FFScript::deallocateAllArrays(SCRIPT_LWPN, ri->lwpn);
				(((weapon*)(s))->weaponscript)=vbound(value/10000,0,NUMSCRIPTWEAPONS-1);
				if ( get_bit(quest_rules,qr_CLEARINITDONSCRIPTCHANGE))
				{
					for(int q=0; q<8; q++)
						(((weapon*)(s))->weap_initd[q]) = 0;
				}
			}  
			break;
		
		case LWPNUSEWEAPON:
			if(0!=(s=checkLWpn(ri->lwpn,"Weapon")))
			(((weapon*)(s))->useweapon)=vbound(value/10000,0,255);
				
			break;
		
		case LWPNUSEDEFENCE:
			if(0!=(s=checkLWpn(ri->lwpn,"Defense")))
			(((weapon*)(s))->usedefence)=vbound(value/10000,0,255);
				
			break;
		
		case LWPNINITD:
		{
			int a = vbound((ri->d[0] / 10000),0,7);
			if(0!=(s=checkLWpn(ri->lwpn,"InitD[]")))
			{
				(((weapon*)(s))->weap_initd[a])=value;
			}
			break;
		}
		case LWPNFALLCLK:
			if(0!=(s=checkLWpn(ri->lwpn,"Falling")))
			{
				if(((weapon*)(s))->fallclk != 0 && value == 0)
				{
					((weapon*)(s))->cs = ((weapon*)(s))->old_cset;
					((weapon*)(s))->tile = ((weapon*)(s))->o_tile;
				}
				else if(((weapon*)(s))->fallclk == 0 && value != 0) ((weapon*)(s))->old_cset = ((weapon*)(s))->cs;
				((weapon*)(s))->fallclk = vbound(value/10000,0,70);
			}
			break;
		case LWPNFALLCMB:
			if(0!=(s=checkLWpn(ri->lwpn,"FallCombo")))
			{
				((weapon*)(s))->fallCombo = vbound(value/10000,0,MAXCOMBOS-1);
			}
			break;
		case LWPNMOVEFLAGS:
		{
			if(0!=(s=checkLWpn(ri->lwpn,"MoveFlags[]")))
			{
				int indx = ri->d[0]/10000;
				if(BC::checkBounds(indx, 0, 1, "lweapon->MoveFlags[]") == SH::_NoError)
				{
					//All bits, in order, of a single byte; just use bitwise
					byte bit = 1<<indx;
					if(value)
						((weapon*)(s))->moveflags |= bit;
					else
						((weapon*)(s))->moveflags &= ~bit;
				}
			}
			break;
		}
			
	///----------------------------------------------------------------------------------------------------//
	//EWeapon Variables
		case EWPNSCALE:
			if ( get_bit(quest_rules, qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"eweapon->Scale");
				break;
			}
			if(0!=(s=checkEWpn(ri->ewpn,"Scale")))
				((weapon*)s)->scale=(zfix)(value/100.0);
				
			break;
		
		case EWPNX:
			if(0!=(s=checkEWpn(ri->ewpn,"X")))
				((weapon*)s)->x = (get_bit(quest_rules,qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000));
				
			break;
		
		case SPRITEMAXEWPN:
		{
			//No bounds check, as this is a universal function and works from NULL pointers!
			Ewpns.setMax(vbound((value/10000),1,MAX_EWPN_SPRITES));
			break;
		}
		
		case EWPNY:
			if(0!=(s=checkEWpn(ri->ewpn,"Y")))
				((weapon*)s)->y = (get_bit(quest_rules,qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000));
				
			break;
			
		case EWPNZ:
			if(0!=(s=checkEWpn(ri->ewpn,"Z")))
			{
				((weapon*)s)->z=get_bit(quest_rules,qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000);
				if(((weapon*)s)->z < 0) ((weapon*)s)->z = zfix(0);
			}
				
			break;
			
		case EWPNJUMP:
			if(0!=(s=checkEWpn(ri->ewpn,"Jump")))
				((weapon*)s)->fall=zslongToFix(value)*-100;
				
			break;
			
		case EWPNDIR:
			if(0!=(s=checkEWpn(ri->ewpn,"Dir")))
				((weapon*)s)->dir=(value/10000);
				
			break;
			
		case EWPNLEVEL:
			if(0!=(s=checkEWpn(ri->ewpn,"Level")))
				((weapon*)s)->type=(value/10000);
				
			break;
		  
		case EWPNGRAVITY:
			if(0!=(s=checkEWpn(ri->ewpn,"Gravity")))
			{
				if(value)
					((weapon*)s)->moveflags |= FLAG_OBEYS_GRAV;
				else
					((weapon*)s)->moveflags &= ~FLAG_OBEYS_GRAV;
			}
			break;
			
		case EWPNSTEP:
			if(0!=(s=checkEWpn(ri->ewpn,"Step")))
			{
				if ( get_bit(quest_rules,qr_STEP_IS_FLOAT) )
				{
					((weapon*)s)->step= zslongToFix(value / 100);
				}
				else
				{
					//old, buggy code replication, round two: Go! -Z
					//zfix val = zslongToFix(value);
					//val.doFloor();
					//((weapon*)s)->step = ((val / 100.0).getFloat());
					
					//old, buggy code replication, round THREE: Go! -Z
					((weapon*)s)->step = ((value/10000)/100.0);
					//zprint2("ewpn step is %d\n", ((weapon*)s)->step);
				}
			}
				
			break;
			
		case EWPNANGLE:
			if(0!=(s=checkEWpn(ri->ewpn,"Angle")))
				((weapon*)s)->angle=(double)(value/10000.0);
				
			break;
			
		case EWPNANGULAR:
			if(0!=(s=checkEWpn(ri->ewpn,"Angular")))
				((weapon*)s)->angular=(value/10000) != 0;
				
			break;
			
		case EWPNBEHIND:
			if(0!=(s=checkEWpn(ri->ewpn,"Behind")))
				((weapon*)s)->behind=(value/10000) != 0;
				
			break;
			
		case EWPNDRAWTYPE:
			if(0!=(s=checkEWpn(ri->ewpn,"DrawStyle")))
				((weapon*)s)->drawstyle=(value/10000);
				
			break;
			
		case EWPNPOWER:
			if(0!=(s=checkEWpn(ri->ewpn,"Damage")))
				((weapon*)s)->power=(value/10000);
				
			break;
			
		case EWPNDEAD:
			if(0!=(s=checkEWpn(ri->ewpn,"DeadState")))
				((weapon*)s)->dead=(value/10000);
				
			break;
			
		case EWPNID:
			if(0!=(s=checkEWpn(ri->ewpn,"ID")))
				((weapon*)s)->id=(value/10000);
				
			break;
			
		case EWPNTILE:
			if(0!=(s=checkEWpn(ri->ewpn,"Tile")))
				((weapon*)s)->tile=(value/10000);
				
			break;
			
		case EWPNSCRIPTTILE:
			if(0!=(s=checkEWpn(ri->ewpn,"ScriptTile")))
				((weapon*)s)->scripttile=vbound((value/10000),-1, NEWMAXTILES-1);
				
			break;
		
		case EWPNSCRIPTFLIP:
			if(0!=(s=checkEWpn(ri->ewpn,"ScriptFlip")))
				((weapon*)s)->scriptflip=vbound((value/10000),-1, 127);
				
			break;
			
		case EWPNCSET:
			if(0!=(s=checkEWpn(ri->ewpn,"CSet")))
				((weapon*)s)->cs=(value/10000)&15;
				
			break;
			
		case EWPNFLASHCSET:
			if(0!=(s=checkEWpn(ri->ewpn,"FlashCSet")))
				(((weapon*)s)->o_cset)|=(value/10000)<<4;
				
			break;
			
		case EWPNFRAMES:
			if(0!=(s=checkEWpn(ri->ewpn,"NumFrames")))
				((weapon*)s)->frames=(value/10000);
				
			break;
			
		case EWPNFRAME:
			if(0!=(s=checkEWpn(ri->ewpn,"Frame")))
				((weapon*)s)->aframe=(value/10000);
				
			break;
			
		case EWPNASPEED:
			if(0!=(s=checkEWpn(ri->ewpn,"ASpeed")))
				((weapon*)s)->o_speed=(value/10000);
				
			break;
			
		case EWPNFLASH:
			if(0!=(s=checkEWpn(ri->ewpn,"Flash")))
				((weapon*)s)->flash=(value/10000);
				
			break;
			
		case EWPNFLIP:
			if(0!=(s=checkEWpn(ri->ewpn,"Flip")))
				((weapon*)s)->flip=(value/10000);
				
			break;
			
		case EWPNROTATION:
			if ( get_bit(quest_rules, qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"eweapon->Rotation");
				break;
			}
			if(0!=(s=checkEWpn(ri->ewpn,"Rotation")))
				((weapon*)s)->rotation=(value/10000);
				
			break;
			
		case EWPNEXTEND:
			if(0!=(s=checkEWpn(ri->ewpn,"Extend")))
				((weapon*)s)->extend=(value/10000);
				
			break;
			
		case EWPNOTILE:
			if(0!=(s=checkEWpn(ri->ewpn,"OriginalTile")))
				((weapon*)s)->o_tile=(value/10000);
				
			break;
			
		case EWPNOCSET:
			if(0!=(s=checkEWpn(ri->ewpn,"OriginalCSet")))
				(((weapon*)s)->o_cset)|=(value/10000)&15;
				
			break;
			
		case EWPNHXOFS:
			if(0!=(s=checkEWpn(ri->ewpn,"HitXOffset")))
				(((weapon*)s)->hxofs)=(value/10000);
				
			break;
			
		case EWPNHYOFS:
			if(0!=(s=checkEWpn(ri->ewpn,"HitYOffset")))
				(((weapon*)s)->hyofs)=(value/10000);
				
			break;
			
		case EWPNXOFS:
			if(0!=(s=checkEWpn(ri->ewpn,"DrawXOffset")))
				(((weapon*)s)->xofs)=(zfix)(value/10000);
				
			break;
			
		case EWPNYOFS:
			if(0!=(s=checkEWpn(ri->ewpn,"DrawYOffset")))
				(((weapon*)s)->yofs)=(zfix)(value/10000)+playing_field_offset;
				
			break;
			
		case EWPNZOFS:
			if(0!=(s=checkEWpn(ri->ewpn,"DrawZOffset")))
				(((weapon*)s)->zofs)=(zfix)(value/10000);
				
			break;
			
		case EWPNHXSZ:
			if(0!=(s=checkEWpn(ri->ewpn,"HitWidth")))
				(((weapon*)s)->hxsz)=(value/10000);
				
			break;
			
		case EWPNHYSZ:
			if(0!=(s=checkEWpn(ri->ewpn,"HitHeight")))
				(((weapon*)s)->hysz)=(value/10000);
				
			break;
			
		case EWPNHZSZ:
			if(0!=(s=checkEWpn(ri->ewpn,"HitZHeight")))
				(((weapon*)s)->hzsz)=(value/10000);
				
			break;
			
		case EWPNTXSZ:
			if(0!=(s=checkEWpn(ri->ewpn,"TileWidth")))
				(((weapon*)s)->txsz)=vbound((value/10000),1,20);
				
			break;
			
		case EWPNTYSZ:
			if(0!=(s=checkEWpn(ri->ewpn,"TileHeight")))
				(((weapon*)s)->tysz)=vbound((value/10000),1,20);
				
			break;
			
		case EWPNMISCD:
			if(0!=(s=checkEWpn(ri->ewpn,"Misc")))
			{
				int a = vbound(ri->d[0]/10000,0,31);
				(((weapon*)(s))->miscellaneous[a])=value;
			}
			
			break;
			
		case EWPNCOLLDET:
			if(0!=(s=checkEWpn(ri->ewpn,"CollDetection")))
				(((weapon*)(s))->scriptcoldet)=value/10000;
				
			break;
		
		case EWPNENGINEANIMATE:
			if(0!=(s=checkEWpn(ri->ewpn,"Animation")))
				(((weapon*)(s))->do_animation)=value/10000;
				
			break;
		
		
		case EWPNPARENTUID:
			if(0!=(s=checkEWpn(ri->ewpn, "ParentUID")))
			(((weapon*)(s))->parent_script_UID) = value; //literal, not *10000
			break;
		
		case EWPNPARENT:
			if(0!=(s=checkEWpn(ri->ewpn, "Parent")))
				(((weapon*)(s))->parentid)= ( (get_bit(quest_rules,qr_OLDEWPNPARENT)) ? value / 10000 : value );
				
			break;
		
		case EWPNSCRIPT:
			if(0!=(s=checkEWpn(ri->ewpn,"Script")))
			{
				FFScript::deallocateAllArrays(SCRIPT_EWPN, ri->ewpn);
				(((weapon*)(s))->weaponscript)=vbound(value/10000,0,NUMSCRIPTWEAPONS-1);
				if ( get_bit(quest_rules,qr_CLEARINITDONSCRIPTCHANGE))
				{
					for(int q=0; q<8; q++)
						(((weapon*)(s))->weap_initd[q]) = 0;
				}
			}
			break;
		
		case EWPNINITD:
		{
			int a = vbound((ri->d[0] / 10000),0,7);
			if(0!=(s=checkEWpn(ri->ewpn,"InitD[]")))
			{
				(((weapon*)(s))->weap_initd[a])=value;
			}
			break;
		}
		case EWPNFALLCLK:
			if(0!=(s=checkEWpn(ri->ewpn,"Falling")))
			{
				if(((weapon*)(s))->fallclk != 0 && value == 0)
				{
					((weapon*)(s))->cs = ((weapon*)(s))->old_cset;
					((weapon*)(s))->tile = ((weapon*)(s))->o_tile;
				}
				else if(((weapon*)(s))->fallclk == 0 && value != 0) ((weapon*)(s))->old_cset = ((weapon*)(s))->cs;
				((weapon*)(s))->fallclk = vbound(value/10000,0,70);
			}
			break;
		case EWPNFALLCMB:
			if(0!=(s=checkEWpn(ri->ewpn,"FallCombo")))
			{
				((weapon*)(s))->fallCombo = vbound(value/10000,0,MAXCOMBOS-1);
			}
			break;
		case EWPNMOVEFLAGS:
		{
			if(0!=(s=checkEWpn(ri->ewpn,"MoveFlags[]")))
			{
				int indx = ri->d[0]/10000;
				if(BC::checkBounds(indx, 0, 1, "eweapon->MoveFlags[]") == SH::_NoError)
				{
					//All bits, in order, of a single byte; just use bitwise
					byte bit = 1<<indx;
					if(value)
						((weapon*)(s))->moveflags |= bit;
					else
						((weapon*)(s))->moveflags &= ~bit;
				}
			}
			break;
		}
			
	///----------------------------------------------------------------------------------------------------//
	//NPC Variables

		//Fixs are all a bit different
		case NPCX:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->X") == SH::_NoError)
			{
				GuyH::getNPC()->x = get_bit(quest_rules,qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000);
				
				if(GuyH::hasLink())
					Link.setXfix(get_bit(quest_rules,qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000));
			}
		}
		break;
		
		case NPCSCALE:
		{
			if ( get_bit(quest_rules, qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"npc->Scale");
				break;
			}
			if(GuyH::loadNPC(ri->guyref, "npc->Scale") == SH::_NoError)
			{
				GuyH::getNPC()->scale = (value / 100.0);
			}
		}
		break;
		
		case NPCIMMORTAL:
			if(GuyH::loadNPC(ri->guyref, "npc->Immortal") == SH::_NoError)
			{
				GuyH::getNPC()->immortal = (value ? true : false);
			}
			break;
		
		case NPCNOSLIDE:
			if(GuyH::loadNPC(ri->guyref, "npc->NoSlide") == SH::_NoError)
			{
				if(value)
				{
					GuyH::getNPC()->knockbackflags |= FLAG_NOSLIDE;
				}
				else
				{
					GuyH::getNPC()->knockbackflags &= ~FLAG_NOSLIDE;
				}
			}
			break;
		
		case NPCNOSCRIPTKB:
			if(GuyH::loadNPC(ri->guyref, "npc->NoScriptKnockback") == SH::_NoError)
			{
				if(value)
				{
					GuyH::getNPC()->knockbackflags |= FLAG_NOSCRIPTKNOCKBACK;
				}
				else
				{
					GuyH::getNPC()->knockbackflags &= ~FLAG_NOSCRIPTKNOCKBACK;
				}
			}
			break;
		
		case NPCKNOCKBACKSPEED:
			if(GuyH::loadNPC(ri->guyref, "npc->NoKnockback") == SH::_NoError)
			{
				GuyH::getNPC()->knockbackSpeed = vbound(value/10000, 0, 255);
			}
			break;
		
		case SPRITEMAXNPC:
		{
			//No bounds check, as this is a universal function and works from NULL pointers!
			guys.setMax(vbound((value/10000),1,MAX_NPC_SPRITES));
			break;
		}
			
		case NPCY:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->Y") == SH::_NoError)
			{
				zfix oldy = GuyH::getNPC()->y;
				GuyH::getNPC()->y = get_bit(quest_rules,qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000);
				GuyH::getNPC()->floor_y += ((get_bit(quest_rules,qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000)) - oldy);
				
				if(GuyH::hasLink())
					Link.setYfix(get_bit(quest_rules,qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000));
			}
		}
		break;
		
		case NPCZ:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->Z") == SH::_NoError)
			{
				if(!never_in_air(GuyH::getNPC()->id))
				{
					if(value < 0)
						GuyH::getNPC()->z = zfix(0);
					else
						GuyH::getNPC()->z = get_bit(quest_rules,qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000);
						
					if(GuyH::hasLink())
						Link.setZfix(get_bit(quest_rules,qr_SPRITEXY_IS_FLOAT) ? zslongToFix(value) : zfix(value/10000));
				}
			}
		}
		break;
		
		case NPCJUMP:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->Jump") == SH::_NoError)
			{
				if(canfall(GuyH::getNPC()->id))
					GuyH::getNPC()->fall =zslongToFix(value)*-100;
					
				if(GuyH::hasLink())
					Link.setFall(zslongToFix(value)*-100);
			}
		}
		break;
		
		case NPCSTEP:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->Step") == SH::_NoError)
			{
				if ( get_bit(quest_rules,qr_STEP_IS_FLOAT) )
				{	
					GuyH::getNPC()->step = zslongToFix(value / 100);
				}
				else
				{
					//old, buggy code replication, round two: Go! -Z
					//zfix val = zslongToFix(value);
					//val.doFloor();
					//GuyH::getNPC()->step = ((val / 100.0).getFloat());
					
					//old, buggy code replication, round THREE: Go! -Z
					GuyH::getNPC()->step = ((value/10000)/100.0);
				}
			}
		}
		break;
		
		case NPCGRAVITY:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->Gravity") == SH::_NoError)
			{
				if(value)
					GuyH::getNPC()->moveflags |= FLAG_OBEYS_GRAV;
				else
					GuyH::getNPC()->moveflags &= ~FLAG_OBEYS_GRAV;
			}
		}
		break;
		
		case NPCXOFS:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->DrawXOffset") == SH::_NoError)
				GuyH::getNPC()->xofs = zfix(value / 10000);
		}
		break;
		
		case NPCYOFS:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->DrawYOffset") == SH::_NoError)
				GuyH::getNPC()->yofs = zfix(value / 10000) + playing_field_offset;
		}
		break;
		
		case NPCROTATION:
		{
			if ( get_bit(quest_rules, qr_OLDSPRITEDRAWS) ) 
			{
				Z_scripterrlog("To use %s you must disable the quest rule 'Old (Faster) Sprite Drawing'.\n",
					"npc->Rotation");
				break;
			}
			if(GuyH::loadNPC(ri->guyref, "npc->Rotation") == SH::_NoError)
				GuyH::getNPC()->rotation = (value / 10000);
		}
		break;
		
		case NPCZOFS:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->DrawZOffset") == SH::_NoError)
				GuyH::getNPC()->zofs = zfix(value / 10000);
		}
		break;
		
		#define SET_NPC_VAR_INT(member, str) \
		{ \
			if(GuyH::loadNPC(ri->guyref, str) == SH::_NoError) \
				GuyH::getNPC()->member = value / 10000; \
		}
		
		
		case NPCISCORE:
			if(GuyH::loadNPC(ri->guyref, "npc->isCore") == SH::_NoError)
			GuyH::getNPC()->isCore = ( (value / 10000) ? true : false );
			break;
		
		
		case NPCDIR:
			SET_NPC_VAR_INT(dir, "npc->Dir") break;
			
		case NPCRATE:
			SET_NPC_VAR_INT(rate, "npc->Rate") break;
			
		case NPCHOMING:
			SET_NPC_VAR_INT(homing, "npc->Homing") break;
			
		case NPCFRAMERATE:
			SET_NPC_VAR_INT(frate, "npc->ASpeed") break;
			
		case NPCHALTRATE:
			SET_NPC_VAR_INT(hrate, "npc->HaltRate") break;
		
		case NPCRANDOM:
			SET_NPC_VAR_INT(rate, "npc->Random") break;
			
		case NPCDRAWTYPE:
			SET_NPC_VAR_INT(drawstyle, "npc->DrawStyle") break;
			
		case NPCHP:
			SET_NPC_VAR_INT(hp, "npc->HP") break;
			
			//case NPCID:        SET_NPC_VAR_INT(id, "npc->ID") break; ~Disallowed
		case NPCDP:
			SET_NPC_VAR_INT(dp, "npc->Damage") break;
			
		case NPCTYPE:
		{
			SET_NPC_VAR_INT(family, "npc->Type") break;
		}
		
		case NPCWDP:
			SET_NPC_VAR_INT(wdp, "npc->WeaponDamage") break;
			
		case NPCITEMSET:
			SET_NPC_VAR_INT(item_set, "npc->ItemSet") break;
			
		case NPCBOSSPAL:
			SET_NPC_VAR_INT(bosspal, "npc->BossPal") break;
			
		case NPCBGSFX:
			if(GuyH::loadNPC(ri->guyref, "npc->SFX") == SH::_NoError)
			{
				enemy *en=GuyH::getNPC();
				int newSFX = value / 10000;
				
				// Stop the old sound and start the new one
				if(en->bgsfx != newSFX)
				{
					en->stop_bgsfx(GuyH::getNPCIndex(ri->guyref));
					cont_sfx(newSFX);
					en->bgsfx = newSFX;
				}
			}
			break;
			
			
		case NPCEXTEND:
			SET_NPC_VAR_INT(extend, "npc->Extend") break;
			
		case NPCHXOFS:
			SET_NPC_VAR_INT(hxofs, "npc->HitXOffset") break;
			
		case NPCHYOFS:
			SET_NPC_VAR_INT(hyofs, "npc->HitYOffset") break;
			
		case NPCHXSZ:
			SET_NPC_VAR_INT(hxsz, "npc->HitWidth") break;
			
		case NPCHYSZ:
			SET_NPC_VAR_INT(hysz, "npc->HitHeight") break;
			
		case NPCHZSZ:
			SET_NPC_VAR_INT(hzsz, "npc->HitZHeight") break;
			
		case NPCCOLLDET:
			SET_NPC_VAR_INT(scriptcoldet, "npc->CollDetection") break;
			
		case NPCENGINEANIMATE:
			SET_NPC_VAR_INT(do_animation, "npc->Animation") break;
			
		case NPCSTUN:
			SET_NPC_VAR_INT(stunclk, "npc->Stun") break;
			
		case NPCHUNGER:
			SET_NPC_VAR_INT(grumble, "npc->Hunger") break;
		
		case NPCWEAPSPRITE:
			SET_NPC_VAR_INT(wpnsprite, "npc->WeaponSprite") break;
			
		case NPCCSET:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->CSet") == SH::_NoError)
				GuyH::getNPC()->cs = (value / 10000) & 0xF;
		}
		break;
		
		//Bounds on value
		case NPCTXSZ:
		{
			long height = value / 10000;
			
			if(GuyH::loadNPC(ri->guyref, "npc->TileWidth") == SH::_NoError &&
					BC::checkBounds(height, 0, 20, "npc->TileWidth") == SH::_NoError)
				GuyH::getNPC()->txsz = height;
		}
		break;
		
		case NPCTYSZ:
		{
			long width = value / 10000;
			
			if(GuyH::loadNPC(ri->guyref, "npc->TileHeight") == SH::_NoError &&
					BC::checkBounds(width, 0, 20, "npc->TileHeight") == SH::_NoError)
				GuyH::getNPC()->tysz = width;
		}
		break;
		
		case NPCOTILE:
		{
			long tile = value / 10000;
			
			if(GuyH::loadNPC(ri->guyref, "npc->OriginalTile") == SH::_NoError &&
					BC::checkTile(tile, "npc->OriginalTile") == SH::_NoError)
				GuyH::getNPC()->o_tile = tile;
		}
		break;
		
		case NPCTILE:
		{
			long tile = value / 10000;
			
			if(GuyH::loadNPC(ri->guyref, "npc->Tile") == SH::_NoError &&
					BC::checkTile(tile, "npc->Tile") == SH::_NoError)
				GuyH::getNPC()->tile = tile;
		}
		break;
		
		case NPCSCRIPTTILE:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->ScriptTile") == SH::_NoError)
				GuyH::getNPC()->scripttile = vbound((value/10000),-1, NEWMAXTILES-1);
		}
		break;
		
		case NPCSCRIPTFLIP:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->ScriptFlip") == SH::_NoError )
				GuyH::getNPC()->scriptflip = vbound(value/10000, -1, 127);
		}
		break;
		
		case NPCWEAPON:
		{
			long weapon = value / 10000;
			
			if(GuyH::loadNPC(ri->guyref, "npc->Weapon") == SH::_NoError &&
					BC::checkBounds(weapon, 0, MAXWPNS-1, "npc->Weapon") == SH::_NoError)
			{
				GuyH::getNPC()->wpn = weapon;
			
				//al_trace("Correct weapon sprite is: %d /n", FFCore.GetDefaultWeaponSprite(weapon));
				if ( get_bit(quest_rules, qr_SETENEMYWEAPONSPRITESONWPNCHANGE) ) //this should probably just be an extra_rule
				{
					GuyH::getNPC()->wpnsprite = FFCore.GetDefaultWeaponSprite(weapon);
				}
				//else GuyH::getNPC()->wpnsprite = FFCore.GetDefaultWeaponSprite(weapon); //just to test that this works. 
			}
		}
		break;
		
		//Indexed
		case NPCDEFENSED:
		{
			long a = ri->d[0] / 10000;
			
			if(GuyH::loadNPC(ri->guyref, "npc->Defense") == SH::_NoError &&
					BC::checkBounds(a, 0, (edefLAST255), "npc->Defense") == SH::_NoError)
			{
				if ( ( get_bit(quest_rules, qr_250WRITEEDEFSCRIPT) ) && a == edefSCRIPT ) 
				{
					for ( int sd = edefSCRIPT01; sd <= edefSCRIPT10; sd++ )
					{
						GuyH::getNPC()->defense[sd] = vbound((value / 10000),0,255);
					}
				}
				//no else here, is intentional as a fallthrough. -Z
				GuyH::getNPC()->defense[a] = vbound((value / 10000),0,255);
			}
		}
		break;
		
		case NPCPARENTUID:
			if(GuyH::loadNPC(ri->guyref, "npc->ParentUID") == SH::_NoError)
			{
				GuyH::getNPC()->parent_script_UID = value; //literal, not *10000
			}
			break;
		
		case NPCHITBY:
		{
			long indx = ri->d[0] / 10000;
			
			if(GuyH::loadNPC(ri->guyref, "npc->HitBy[]") == SH::_NoError)
			{
				switch(indx)
				{
					//screen index objects
					case 0:
					case 1:
					case 2:
					case 3:
					case 8:
					case 9:
					case 10:
					case 11:
					case 12:
					case 13:
					case 14:
					case 15:
					{
						GuyH::getNPC()->hitby[indx] = vbound((value / 10000),0,255); //Once again, why did I vbound this, and why did I allow it to be written? UIDs are LONGs, with a starting value of 0.0001. -Z
							break;
					}
					//UIDs
					case 4:
					case 5:
					case 6:
					case 7:
					{
						GuyH::getNPC()->hitby[indx] = value; //Once again, why did I vbound this, and why did I allow it to be written? UIDs are LONGs, with a starting value of 0.0001. -Z
							break;
					}
					default: al_trace("Invalid index used with npc->hitBy[%ld]. /n", indx); break;
				}
			}
			break;
		}
		
		//2.future compat. -Z
		
		
		case NPCSCRDEFENSED:
		{
			long a = ri->d[0] / 10000;
			
			if(GuyH::loadNPC(ri->guyref, "npc->ScriptDefense") == SH::_NoError &&
					BC::checkBounds(a, 0, edefSCRIPTDEFS_MAX, "npc->ScriptDefense") == SH::_NoError)
				GuyH::getNPC()->defense[a+edefSCRIPT01] = value / 10000;
		}
		break;
		
		case NPCMISCD:
		{
			long a = ri->d[0] / 10000;
			
			if(GuyH::loadNPC(ri->guyref, "npc->Misc") == SH::_NoError &&
					BC::checkMisc32(a, "npc->Misc") == SH::_NoError)
				GuyH::getNPC()->miscellaneous[a] = value;
				
		}
		
		break;
		
		case NPCINITD:
		{
			long a = ri->d[0] / 10000;
			
			if(GuyH::loadNPC(ri->guyref, "npc->InitD[]") == SH::_NoError)
			{
				//enemy *e = (enemy*)guys.spr(ri->guyref);
				//e->initD[a] = value; 
				GuyH::getNPC()->initD[a] = value;
			}
		}
		break;
		
		case NPCSCRIPT:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->Script") == SH::_NoError)
			{
				FFScript::deallocateAllArrays(SCRIPT_NPC, ri->guyref);
				//enemy *e = (enemy*)guys.spr(ri->guyref);
				//e->initD[a] = value; 
				if ( get_bit(quest_rules,qr_CLEARINITDONSCRIPTCHANGE))
				{
					for(int q=0; q<8; q++)
						GuyH::getNPC()->initD[q] = 0;
				}
				GuyH::getNPC()->script = vbound((value/10000), 0, NUMSCRIPTGUYS-1);
			}
		}
		break;
		
		//npc->Attributes[] setter -Z
		case NPCDD:
		{
			long a = ri->d[0] / 10000;
			
			if(GuyH::loadNPC(ri->guyref, "npc->Attributes") == SH::_NoError &&
					BC::checkBounds(a, 0, 31, "npc->Attributes") == SH::_NoError)
		
			switch(a)
			{
				case 0: GuyH::getNPC()->dmisc1 = value / 10000; break;
				case 1: GuyH::getNPC()->dmisc2 = value / 10000; break;
				case 2: GuyH::getNPC()->dmisc3 = value / 10000; break;
				case 3: GuyH::getNPC()->dmisc4 = value / 10000; break;
				case 4: GuyH::getNPC()->dmisc5 = value / 10000; break;
				case 5: GuyH::getNPC()->dmisc6 = value / 10000; break;
				case 6: GuyH::getNPC()->dmisc7 = value / 10000; break;
				case 7: GuyH::getNPC()->dmisc8 = value / 10000; break;
				case 8: GuyH::getNPC()->dmisc9 = value / 10000; break;
				case 9: GuyH::getNPC()->dmisc10 = value / 10000; break;
				case 10: GuyH::getNPC()->dmisc11 = value / 10000; break;
				case 11: GuyH::getNPC()->dmisc12 = value / 10000; break;
				case 12: GuyH::getNPC()->dmisc13 = value / 10000; break;
				case 13: GuyH::getNPC()->dmisc14 = value / 10000; break;
				case 14: GuyH::getNPC()->dmisc15 = value / 10000; break;
				case 15: GuyH::getNPC()->dmisc16 = value / 10000; break;
				case 16: GuyH::getNPC()->dmisc17 = value / 10000; break;
				case 17: GuyH::getNPC()->dmisc18 = value / 10000; break;
				case 18: GuyH::getNPC()->dmisc19 = value / 10000; break;
				case 19: GuyH::getNPC()->dmisc20 = value / 10000; break;
				case 20: GuyH::getNPC()->dmisc21 = value / 10000; break;
				case 21: GuyH::getNPC()->dmisc22 = value / 10000; break;
				case 22: GuyH::getNPC()->dmisc23 = value / 10000; break;
				case 23: GuyH::getNPC()->dmisc24 = value / 10000; break;
				case 24: GuyH::getNPC()->dmisc25 = value / 10000; break;
				case 25: GuyH::getNPC()->dmisc26 = value / 10000; break;
				case 26: GuyH::getNPC()->dmisc27 = value / 10000; break;
				case 27: GuyH::getNPC()->dmisc28 = value / 10000; break;
				case 28: GuyH::getNPC()->dmisc28 = value / 10000; break;
				case 29: GuyH::getNPC()->dmisc30 = value / 10000; break;
				case 30: GuyH::getNPC()->dmisc31 = value / 10000; break;
				case 31: GuyH::getNPC()->dmisc32 = value / 10000; break;
				default: break;
			}
			break;
		}
		
			
		case NPCINVINC:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->InvFrames") == SH::_NoError)
				GuyH::getNPC()->hclk = (int)value/10000;
		}
		break;
		
		case NPCSUPERMAN:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->Invincible") == SH::_NoError)
				GuyH::getNPC()->superman = (int)value/10000;
		}
		break;
		
		case NPCHASITEM:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->HasItem") == SH::_NoError)
				GuyH::getNPC()->itemguy = (value/10000)?1:0;
		}
		break;
		
		case NPCRINGLEAD:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->Ringleader") == SH::_NoError)
				GuyH::getNPC()->leader = (value/10000)?1:0;
		}
		break;
		
		case NPCSHIELD:
		{
			int indx = ri->d[0];
			if(GuyH::loadNPC(ri->guyref, "npc->Shield[]") == SH::_NoError)
			{
				switch(indx)
				{
					case 0:
					{
						(ri->d[1])? (GuyH::getNPC()->flags |= inv_front) : (GuyH::getNPC()->flags &= ~inv_front);
						break;
					}
					case 1:
					{
						(ri->d[1])? (GuyH::getNPC()->flags |= inv_left) : (GuyH::getNPC()->flags &= ~inv_left);
						break;
					}
					case 2:
					{
						(ri->d[1])? (GuyH::getNPC()->flags |= inv_right) : (GuyH::getNPC()->flags &= ~inv_right);
						break;
					}
					case 3:
					{
						(ri->d[1])? (GuyH::getNPC()->flags |= inv_back) : (GuyH::getNPC()->flags &= ~inv_back);
						break;
					}
					case 4: //shield can be broken
					{
						(ri->d[1])? (GuyH::getNPC()->flags |= guy_bkshield) : (GuyH::getNPC()->flags &= ~guy_bkshield);
						break;
					}
					default:
					{
						Z_scripterrlog("Invalid Array Index passed to npc->Shield[]: %d\n", indx); 
						break;
					}
				}
			}
		}
		
		case NPCFROZENTILE:
			SET_NPC_VAR_INT(frozentile, "npc->FrozenTile"); break;
		case NPCFROZENCSET:
			SET_NPC_VAR_INT(frozencset, "npc->FrozenCSet"); break;
		case NPCFROZEN:
			SET_NPC_VAR_INT(frozenclock, "npc->Frozen"); break;
		
		case NPCBEHAVIOUR: 
		{
			if(GuyH::loadNPC(ri->guyref, "npc->Behaviour[]") != SH::_NoError) 
			{
				break;
			}
			int index = vbound(ri->d[0]/10000,0,4);
			switch(index)
			{
				case 0:
					(value) ? GuyH::getNPC()->editorflags|=ENEMY_FLAG1 : GuyH::getNPC()->editorflags&= ~ENEMY_FLAG1;
					break;
				case 1:
					(value) ? GuyH::getNPC()->editorflags|=ENEMY_FLAG2 : GuyH::getNPC()->editorflags&= ~ENEMY_FLAG2;
					break;
				case 2:
					(value) ? GuyH::getNPC()->editorflags|=ENEMY_FLAG3 : GuyH::getNPC()->editorflags&= ~ENEMY_FLAG3;
					break;
				case 3:
					(value) ? GuyH::getNPC()->editorflags|=ENEMY_FLAG4 : GuyH::getNPC()->editorflags&= ~ENEMY_FLAG4; 
					break;
				case 4:
					(value) ? GuyH::getNPC()->editorflags|=ENEMY_FLAG5 : GuyH::getNPC()->editorflags&= ~ENEMY_FLAG5;
					break;
				case 5:
					(value) ? GuyH::getNPC()->editorflags|=ENEMY_FLAG6 : GuyH::getNPC()->editorflags&= ~ENEMY_FLAG6; 
					break;
				case 6:
					(value) ? GuyH::getNPC()->editorflags|=ENEMY_FLAG7 : GuyH::getNPC()->editorflags&= ~ENEMY_FLAG7;
					break;
				case 7:
					(value) ? GuyH::getNPC()->editorflags|=ENEMY_FLAG8 : GuyH::getNPC()->editorflags&= ~ENEMY_FLAG8;
					break;
				case 8:
					(value) ? GuyH::getNPC()->editorflags|=ENEMY_FLAG9 : GuyH::getNPC()->editorflags&= ~ENEMY_FLAG9;
					break;		    
				case 9:
					(value) ? GuyH::getNPC()->editorflags|=ENEMY_FLAG10 : GuyH::getNPC()->editorflags&= ~ENEMY_FLAG10;
					break;
				case 10:
					(value) ? GuyH::getNPC()->editorflags|=ENEMY_FLAG11 : GuyH::getNPC()->editorflags&= ~ENEMY_FLAG11; 
					break;
				case 11:
					(value) ? GuyH::getNPC()->editorflags|=ENEMY_FLAG12 : GuyH::getNPC()->editorflags&= ~ENEMY_FLAG12;
					break;
				case 12:
					(value) ? GuyH::getNPC()->editorflags|=ENEMY_FLAG13 : GuyH::getNPC()->editorflags&= ~ENEMY_FLAG13;
					break;
				case 13:
					(value) ? GuyH::getNPC()->editorflags|=ENEMY_FLAG14 : GuyH::getNPC()->editorflags&= ~ENEMY_FLAG14;
					break;
				case 14:
					(value) ? GuyH::getNPC()->editorflags|=ENEMY_FLAG15 : GuyH::getNPC()->editorflags&= ~ENEMY_FLAG15; 
					break;
				case 15:
					(value) ? GuyH::getNPC()->editorflags|=ENEMY_FLAG16 : GuyH::getNPC()->editorflags&= ~ENEMY_FLAG16; 
					break;
				
				
				default: 
					break;
			}
				
			break;
		}
		case NPCFALLCLK:
			if(GuyH::loadNPC(ri->guyref, "npc->Falling") == SH::_NoError)
			{
				if(GuyH::getNPC()->fallclk != 0 && value == 0)
				{
					GuyH::getNPC()->cs = GuyH::getNPC()->old_cset;
					GuyH::getNPC()->tile = GuyH::getNPC()->o_tile;
				}
				else if(GuyH::getNPC()->fallclk == 0 && value != 0) GuyH::getNPC()->old_cset = GuyH::getNPC()->cs;
				GuyH::getNPC()->fallclk = vbound(value/10000,0,70);
			}
			break;
		case NPCFALLCMB:
			if(GuyH::loadNPC(ri->guyref, "npc->FallCombo") == SH::_NoError)
			{
				GuyH::getNPC()->fallCombo = vbound(value/10000,0,MAXCOMBOS-1);
			}
			break;
		case NPCMOVEFLAGS:
		{
			if(GuyH::loadNPC(ri->guyref, "npc->MoveFlags[]") == SH::_NoError)
			{
				int indx = ri->d[0]/10000;
				if(BC::checkBounds(indx, 0, 2, "npc->MoveFlags[]") == SH::_NoError)
				{
					//All bits, in order, of a single byte; just use bitwise
					byte bit = 1<<indx;
					if(value)
						GuyH::getNPC()->moveflags |= bit;
					else
						GuyH::getNPC()->moveflags &= ~bit;
				}
			}
			break;
		}
		
		
	///----------------------------------------------------------------------------------------------------//
	//Game Information
		
		case GAMESUBSCHEIGHT:
		{
			int v = vbound(value,0,256);
			passive_subscreen_height = (v/10000);   
		}
		break;
		
		case GAMEPLAYFIELDOFS:
		{
			int v = vbound(value,-256, 256);
			playing_field_offset = (v/10000);
		}
		break;
		
		case PASSSUBOFS:
		{
			int v = vbound(value,-256, 256);
			passive_subscreen_offset = (v/10000);
		}
		break;

		case ZSCRIPTVERSION:
		{
			(FFCore.quest_format[vLastCompile]) = value/10000;
			break;
		}
		
		case GAMEDEATHS:
			game->set_deaths(value/10000);
			break;
			
		case GAMECHEAT:
			game->set_cheat(value/10000);
			cheat=(value/10000);
			break;
			
		case GAMETIME:
			game->set_time(value);
			break; // Can't multiply by 10000 or the maximum result is too big
			
		case GAMETIMEVALID:
			game->set_timevalid((value/10000)?1:0);
			break;
			
		case GAMEHASPLAYED:
			game->set_hasplayed((value/10000)?1:0);
			break;
		
		case TYPINGMODE:
			FFCore.kb_typing_mode = ((value/10000)?true:false);
			break;
		
		case SKIPCREDITS:
			FFCore.skip_ending_credits = ((value/10000)?true:false);
			break;
		
		case SKIPF6:
			set_bit(quest_rules,qr_NOCONTINUE,((value/10000)?1:0));
			break;
		
		
			
		case GAMEGUYCOUNT:
		{
			int mi2 = (currmap*MAPSCRSNORMAL)+(ri->d[0]/10000);
			game->guys[mi2]=value/10000;
		}
		break;
		
		case GAMECONTSCR:
			game->set_continue_scrn(value/10000);
			break;
			
		case GAMECONTDMAP:
			game->set_continue_dmap(value/10000);
			break;
			
		case GAMEENTRSCR:
			lastentrance=value/10000;
			break;
			
		case GAMEENTRDMAP:
			lastentrance_dmap=value/10000;
			break;
			
		case GAMECOUNTERD:
			game->set_counter(value/10000, (ri->d[0])/10000);
			break;
			
		case GAMEMCOUNTERD:
			game->set_maxcounter(value/10000, (ri->d[0])/10000);
			break;
			
		case GAMEDCOUNTERD:
			game->set_dcounter(value/10000, (ri->d[0])/10000);
			break;
			
		case GAMEGENERICD:
			game->set_generic(value/10000, (ri->d[0])/10000);
			break;
		case GAMEMISC:
		{
			int indx = ri->d[0]/10000;
			if ( indx < 0 || indx > 31 )
			{
				Z_scripterrlog("Invalid index used to access Game->Misc: %d\n", indx);
			}
			else 
			{
				QMisc.questmisc[indx] = (value/((get_bit(quest_rules,qr_OLDQUESTMISC)) ? 10000 : 1));
			}
			break;
		}
		case GAMEITEMSD:
			game->set_item((ri->d[0])/10000,(value!=0));
			break;
		
		case DISABLEDITEM:
			game->items_off[(ri->d[0])/10000]=value/10000;
			break;
		
		case GAMESUSPEND:
		{
			int inx = (ri->d[0])/10000;
			if ( (unsigned) inx > (susptLAST-1) )
			{
				Z_scripterrlog("Invalid array index [%d] passed to Gme->Suspend[]\n");
			}
			FFCore.system_suspend[inx]= ( (value) ? 1 : 0 );
			break;
		}
			
		case GAMELITEMSD:
			game->lvlitems[(ri->d[0])/10000]=value/10000;
			break;
			
		case GAMELKEYSD:
			game->lvlkeys[(ri->d[0])/10000]=value/10000;
			break;
			
		case GAMEGRAVITY:
		{
			int indx = ri->d[0]/10000;
			if(indx < 0 || indx > 2)
			{
				Z_scripterrlog("Invalid index used to access Game->Gravity[]: %d\n", indx);
			}
			else
			{
				switch(indx)
				{
					case 0: //Gravity Strength
						zinit.gravity = value / 100;
						break;
					case 1: //Terminal Velocity
						zinit.terminalv = value / 100;
						break;
					case 2: //Sprite Layer Threshold
						zinit.jump_link_layer_threshold = value / 10000;
						break;
				}
			}
			break;
		}
			
		case SCREENSTATED:
		{
			int mi2 = (currmap*MAPSCRSNORMAL)+currscr;
			(value)?setmapflag(mi2, 1<<((ri->d[0])/10000)) : unsetmapflag(mi2, 1 << ((ri->d[0]) / 10000));
		}
		break;
		
		case SCREENSTATEDD:
		{
			int mi2 = ri->d[0]/10000;
			mi2 -= 8*(mi2/MAPSCRS);
			
			if(BC::checkMapID(mi2>>7, "Game->SetScreenState") == SH::_NoError)
				(value)?setmapflag(mi2, 1<<(ri->d[1]/10000)) : unsetmapflag(mi2, 1 << (ri->d[1] / 10000), true);
		}
		break;
		
		case GAMEGUYCOUNTD:
			game->guys[(currmap*MAPSCRSNORMAL)+(ri->d[0]/10000)] = value / 10000;
			break;
			
		case GAMECLICKFREEZE:
			disableClickToFreeze=value==0;
			break;
		
		
		case NOACTIVESUBSC:
			Link.stopSubscreenFalling((value/10000)?1:0);
			break;
			
	///----------------------------------------------------------------------------------------------------//
	//DMap Information

		#define SET_DMAP_VAR(member, str) \
		{ \
			int ID = ri->d[0] / 10000; \
			if(BC::checkDMapID(ID, str) == SH::_NoError) \
				DMaps[ID].member = value / 10000; \
		}

		case DMAPFLAGSD:
			SET_DMAP_VAR(flags, "Game->DMapFlags") break;
			
		case DMAPLEVELD:
			SET_DMAP_VAR(level, "Game->DMapLevel") break;
			
		case DMAPCOMPASSD:
			SET_DMAP_VAR(compass, "Game->DMapCompass") break;
			
		case DMAPCONTINUED:
			SET_DMAP_VAR(cont, "Game->DMapContinue") break;
			
		case DMAPLEVELPAL:
		{
			int ID = ri->d[0] / 10000; 
			int pal = value/10000;
			pal = vbound(pal, 0, 0x1FF);
				
			if(BC::checkDMapID(ID, "Game->DMapPalette") == SH::_NoError) 
				DMaps[ID].color = pal;

			loadlvlpal(DMaps[(ri->d[0] / 10000)].color);
			break;
		}
		
		case DMAPMIDID:
		{
			int ID = ri->d[0] / 10000;
			
			if(BC::checkDMapID(ID, "Game->DMapMIDI") == SH::_NoError)
			{
				// Based on play_DmapMusic
				switch(value / 10000)
				{
				case -6:
					DMaps[ID].midi = 2;
					break; // Dungeon
					
				case -3:
					DMaps[ID].midi = 3;
					break; // Level 9
					
				case -2:
					DMaps[ID].midi = 1;
					break; // Overworld
					
				case 0:
					DMaps[ID].midi = 0;
					break; // None
					
				default:
					DMaps[ID].midi = value / 10000 + 3;
				}
			}
			
			break;
		}
		
	///----------------------------------------------------------------------------------------------------//
	//Screen->ComboX
    case COMBODD:
    {
        int pos = (ri->d[0])/10000;
	int val = (value/10000);
        if ( ((unsigned) pos) > 175 )
	{
		Z_scripterrlog("Invalid [pos] %d used to write to Screen->ComboD[]\n", pos);
	}
	else if ( ((unsigned) val) >= MAXCOMBOS )
	{
		Z_scripterrlog("Invalid combo ID %d used to write to Screen->ComboD[]\n", val);
	}
        else
        {
            screen_combo_modify_preroutine(tmpscr,pos);
            tmpscr->data[pos]=(val);
            screen_combo_modify_postroutine(tmpscr,pos);
        }
    }
    break;
    
    case COMBOCD:
    {
        int pos = (ri->d[0])/10000;
        int val = (value/10000); //cset
	if ( ((unsigned) pos) > 175 )
	{
		Z_scripterrlog("Invalid [pos] %d used to write to Screen->ComboC[]\n", pos);
	}
	else if ( ((unsigned) val) >= 15 )
	{
		Z_scripterrlog("Invalid CSet ID %d used to write to Screen->ComboC[]\n", val);
	}
        else
        {
            screen_combo_modify_preroutine(tmpscr,pos);
            tmpscr->cset[pos]=(val)&15;
            screen_combo_modify_postroutine(tmpscr,pos);
        }
    }
    break;
    
    case COMBOFD:
    {
        int pos = (ri->d[0])/10000;
        int val = (value/10000); //flag
	if ( ((unsigned) pos) > 175 )
	{
		Z_scripterrlog("Invalid [pos] %d used to write to Screen->ComboF[]\n", pos);
	}
	else if ( ((unsigned) val) >= 256 )
	{
		Z_scripterrlog("Invalid Flag ID %d used to write to Screen->ComboF[]\n", val);
	}
        
        else
            tmpscr->sflag[pos]=(val);
    }
    break;
    
    case COMBOTD:
    {
        int pos = (ri->d[0])/10000;
        int val = (value/10000); //type
	if ( ((unsigned) pos) > 175 )
	{
		Z_scripterrlog("Invalid [pos] %d used to write to Screen->ComboT[]\n", pos);
	}
	else if ( ((unsigned) val) >= 256 )
	{
		Z_scripterrlog("Invalid Flag ID %d used to write to Screen->ComboT[]\n", val);
	}
        else
        {
            // Preprocess each instance of the combo on the screen
            for(int i = 0; i < 176; i++)
            {
                if(tmpscr->data[i] == tmpscr->data[pos])
                {
                    screen_combo_modify_preroutine(tmpscr,i);
                }
            }
            
            combobuf[tmpscr->data[pos]].type=val;
            
            for(int i = 0; i < 176; i++)
            {
                if(tmpscr->data[i] == tmpscr->data[pos])
                {
                    screen_combo_modify_postroutine(tmpscr,i);
                }
            }
        }
    }
    break;
    
    case COMBOID:
    {
        int pos = (ri->d[0])/10000;
        int val = (value/10000); //iflag
	if ( ((unsigned) pos) > 175 )
	{
		Z_scripterrlog("Invalid [pos] %d used to write to Screen->ComboI[]\n", pos);
	}
	else if ( ((unsigned) val) >= 256 )
	{
		Z_scripterrlog("Invalid Flag ID %d used to write to Screen->ComboI[]\n", val);
	}
        
        else
            combobuf[tmpscr->data[pos]].flag=val;
    }
    break;
    
    case COMBOSD:
    {
        int pos = (ri->d[0])/10000;
        int val = (value/10000); //iflag
	if ( ((unsigned) pos) > 175 )
	{
		Z_scripterrlog("Invalid [pos] %d used to write to Screen->ComboS[]\n", pos);
	}
	else if ( ((unsigned) val) >= 16 )//solidity 1, 2, 4, 8 max 15
	{
		Z_scripterrlog("Invalid Flag ID %d used to write to Screen->ComboS[]\n", val);
	}
        else
            combobuf[tmpscr->data[pos]].walk=(val)&15;
    }
    break;
		
	///----------------------------------------------------------------------------------------------------//
	//Game->SetComboX
		case COMBODDM:
		{
			int pos = (ri->d[0])/10000;
			int sc = (ri->d[2]/10000);
			int m = zc_max((ri->d[1]/10000)-1,0);
			long scr = zc_max(m*MAPSCRS+sc,0);
			
			if(!(pos >= 0 && pos < 176 && scr >= 0 && sc < MAPSCRS && m < map_count)) break;
			long combo = vbound(value/10000,0,MAXCOMBOS);
			if(scr==(currmap*MAPSCRS+currscr))
				screen_combo_modify_preroutine(tmpscr,pos);
				
			TheMaps[scr].data[pos]=combo;
			
			if(scr==(currmap*MAPSCRS+currscr))
			{
				tmpscr->data[pos] = combo;
				screen_combo_modify_postroutine(tmpscr,pos);
			}
			
			int layr = whichlayer(scr);
			
			if(layr>-1)
			{
				//if (layr==(currmap*MAPSCRS+currscr))
				//  screen_combo_modify_preroutine(tmpscr,pos);
				tmpscr2[layr].data[pos]=combo;
				//if (layr==(currmap*MAPSCRS+currscr))
				//  screen_combo_modify_postroutine(tmpscr,pos);
			}
		}
		break;
		
		case COMBOCDM:
		{
			int pos = (ri->d[0])/10000;
			int sc = (ri->d[2]/10000);
			int m = zc_max((ri->d[1]/10000)-1,0);
			long scr = zc_max(m*MAPSCRS+sc,0);
			
			if(!(pos >= 0 && pos < 176 && scr >= 0 && sc < MAPSCRS && m < map_count)) break;
			
			TheMaps[scr].cset[pos]=(value/10000)&15;
			
			if(scr==(currmap*MAPSCRS+currscr))
				tmpscr->cset[pos] = value/10000;
				
			int layr = whichlayer(scr);
			
			if(layr>-1)
				tmpscr2[layr].cset[pos]=(value/10000)&15;
		}
		break;
		
		case COMBOFDM:
		{
			int pos = (ri->d[0])/10000;
			int sc = (ri->d[2]/10000);
			int m = zc_max((ri->d[1]/10000)-1,0);
			long scr = zc_max(m*MAPSCRS+sc,0);
			
			if(!(pos >= 0 && pos < 176 && scr >= 0 && sc < MAPSCRS && m < map_count)) break;
			
			TheMaps[scr].sflag[pos]=value/10000;
			
			if(scr==(currmap*MAPSCRS+currscr))
				tmpscr->sflag[pos] = value/10000;
				
			int layr = whichlayer(scr);
			
			if(layr>-1)
				tmpscr2[layr].sflag[pos]=value/10000;
		}
		break;
		
		case COMBOTDM:
		{
			int pos = (ri->d[0])/10000;
			int sc = (ri->d[2]/10000);
			int m = zc_max((ri->d[1]/10000)-1,0);
			long scr = zc_max(m*MAPSCRS+sc,0);
			
			if(!(pos >= 0 && pos < 176 && scr >= 0 && sc < MAPSCRS && m < map_count))
				break;
				
			int cdata = TheMaps[scr].data[pos];
			
			// Preprocess the screen's combos in case the combo changed is present on the screen. -L
			for(int i = 0; i < 176; i++)
			{
				if(tmpscr->data[i] == cdata)
				{
					screen_combo_modify_preroutine(tmpscr,i);
				}
			}
			
			combobuf[cdata].type=value/10000;
			
			for(int i = 0; i < 176; i++)
			{
				if(tmpscr->data[i] == cdata)
				{
					screen_combo_modify_postroutine(tmpscr,i);
				}
			}
		}
		break;
		
		case COMBOIDM:
		{
			int pos = (ri->d[0])/10000;
			int sc = (ri->d[2]/10000);
			int m = zc_max((ri->d[1]/10000)-1,0);
			long scr = zc_max(m*MAPSCRS+sc,0);
			
			if(!(pos >= 0 && pos < 176 && scr >= 0 && sc < MAPSCRS && m < map_count))
				break;
				
			combobuf[TheMaps[scr].data[pos]].flag=value/10000;
		}
		break;
		
		case COMBOSDM:
		{
			//This is how it was in 2.50.1-2
			int pos = (ri->d[0])/10000;
			long scr = (ri->d[1]/10000)*MAPSCRS+(ri->d[2]/10000);
			//This (below) us the precise code from 2.50.1 (?)
			//long scr = zc_max((ri->d[1]/10000)*MAPSCRS+(ri->d[2]/10000),0); //Not below 0. 

			if(pos < 0 || pos >= 176 || scr < 0) break;

			combobuf[TheMaps[scr].data[pos]].walk=(value/10000)&15;	    
		}
		break;
		
	///----------------------------------------------------------------------------------------------------//
	//Screen Variables
		
			#define	SET_SCREENDATA_VAR_INT32(member, str) \
		{ \
			tmpscr->member = vbound((value / 10000),-214747,214747); \
		} \
		
		#define	SET_SCREENDATA_VAR_INT16(member, str) \
		{ \
			tmpscr->member = vbound((value / 10000),0,32767); \
		} \

		#define	SET_SCREENDATA_VAR_BYTE(member, str) \
		{ \
			tmpscr->member = vbound((value / 10000),0,255); \
		} \
		
		#define SET_SCREENDATA_VAR_INDEX32(member, str, indexbound) \
		{ \
			int indx = ri->d[0] / 10000; \
			tmpscr->member[indx] = vbound((value / 10000),-214747,214747); \
		} \
		
		#define SET_SCREENDATA_VAR_INDEX16(member, str, indexbound) \
		{ \
			int indx = ri->d[0] / 10000; \
			tmpscr->member[indx] = vbound((value / 10000),-32767,32767); \
		} \

		#define SET_SCREENDATA_BYTE_INDEX(member, str, indexbound) \
		{ \
			int indx = ri->d[0] / 10000; \
			tmpscr->member[indx] = vbound((value / 10000),0,255); \
		}
		#define SET_SCREENDATA_LAYER_INDEX(member, str, indexbound) \
		{ \
			int indx = ri->d[0] / 10000; \
			if ( FFCore.quest_format[vFFScript] < 11 ) ++indx; \
			if(indx < 1 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", str, indx); \
			} \
			else tmpscr->member[indx-1] = vbound((value / 10000),0,255); \
		}
		///max screen id is higher! vbound properly... -Z
		#define SET_SCREENDATA_LAYERSCREEN_INDEX(member, str, indexbound) \
		{ \
			int indx = ri->d[0] / 10000; \
			int scrn_id = value/10000; \
			if ( FFCore.quest_format[vFFScript] < 11 ) ++indx; \
			if(indx < 1 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", str, indx); \
			} \
			else if ( scrn_id > MAPSCRS ) \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->LayerScreen[%d].\n",scrn_id); \
				Z_scripterrlog("Valid Screen values are (0) through (%d).\n",MAPSCRS); \
			} \
			else tmpscr->member[indx-1] = vbound((scrn_id),0,MAPSCRS); \
		}
		
		#define SET_SCREENDATA_FLAG(member, str) \
		{ \
			long flag =  (value/10000);  \
			if ( flag != 0 ) \
			{ \
				tmpscr->member|=flag; \
			} \
			else tmpscr->.member|= ~flag; \
		} \
		
		#define SET_SCREENDATA_BOOL_INDEX(member, str, indexbound) \
		{ \
			int indx = ri->d[0] / 10000; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to Screen->%s[]: %d\n", (indx), str); \
				break; \
			} \
			tmpscr->member[indx] =( (value/10000) ? 1 : 0 ); \
		}
		

		case SCREENDATAVALID:		SET_SCREENDATA_VAR_BYTE(valid, "Valid"); break;		//b
		case SCREENDATAGUY: 		SET_SCREENDATA_VAR_BYTE(guy, "Guy"); break;		//b
		case SCREENDATASTRING:		SET_SCREENDATA_VAR_INT32(str, "String"); break;		//w
		case SCREENDATAROOM: 		SET_SCREENDATA_VAR_BYTE(room, "RoomType");	break;		//b
		case SCREENDATAITEM: 		SET_SCREENDATA_VAR_BYTE(item, "Item"); break;		//b
		case SCREENDATAHASITEM: 		SET_SCREENDATA_VAR_BYTE(hasitem, "HasItem"); break;	//b
		case SCREENDATATILEWARPTYPE: 	SET_SCREENDATA_BYTE_INDEX(tilewarptype, "TileWarpType", 3); break;	//b, 4 of these
		//case SCREENDATATILEWARPOVFLAGS: 	SET_SCREENDATA_VAR_BYTE(tilewarpoverlayflags, "TileWarpOverlayFlags"); break;	//b, tilewarpoverlayflags
		case SCREENDATADOORCOMBOSET: 	SET_SCREENDATA_VAR_INT32(door_combo_set, "DoorComboSet"); break;	//w
		case SCREENDATAWARPRETX:	 	SET_SCREENDATA_BYTE_INDEX(warpreturnx, "WarpReturnX", 3); break;	//b, 4 of these
		case SCREENDATAWARPRETY:	 	SET_SCREENDATA_BYTE_INDEX(warpreturny, "WarpReturnY", 3); break;	//b, 4 of these
		case SCREENDATAWARPRETURNC: 	SET_SCREENDATA_VAR_INT32(warpreturnc, "WarpReturnC"); break;	//w
		case SCREENDATASTAIRX: 		SET_SCREENDATA_VAR_BYTE(stairx, "StairsX"); break;	//b
		case SCREENDATASTAIRY: 		SET_SCREENDATA_VAR_BYTE(stairy, "StairsY"); break;	//b
		case SCREENDATAITEMX:		SET_SCREENDATA_VAR_BYTE(itemx, "ItemX"); break; //itemx
		case SCREENDATAITEMY:		SET_SCREENDATA_VAR_BYTE(itemy, "ItemY"); break;	//itemy
		case SCREENDATACOLOUR: 		SET_SCREENDATA_VAR_INT32(color, "CSet"); break;	//w
		case SCREENDATAENEMYFLAGS: 	SET_SCREENDATA_VAR_BYTE(enemyflags, "EnemyFlags");	break;	//b
		case SCREENDATADOOR: 		SET_SCREENDATA_BYTE_INDEX(door, "Door", 3); break;	//b, 4 of these
		case SCREENDATATILEWARPDMAP: 	SET_SCREENDATA_VAR_INDEX32(tilewarpdmap, "TileWarpDMap", 3); break;	//w, 4 of these
		case SCREENDATATILEWARPSCREEN: 	SET_SCREENDATA_BYTE_INDEX(tilewarpscr, "TileWarpScreen", 3); break;	//b, 4 of these
		case SCREENDATAEXITDIR: 		SET_SCREENDATA_VAR_BYTE(exitdir, "ExitDir"); break;	//b
		case SCREENDATAENEMY: 		SET_SCREENDATA_VAR_INDEX32(enemy, "Enemy", 9); break;	//w, 10 of these
		case SCREENDATAPATTERN: 		SET_SCREENDATA_VAR_BYTE(pattern, "Pattern"); break;	//b
		case SCREENDATASIDEWARPTYPE: 	SET_SCREENDATA_BYTE_INDEX(sidewarptype, "SideWarpType", 3); break;	//b, 4 of these
		//case SCREENDATASIDEWARPOVFLAGS: 	SET_SCREENDATA_VAR_BYTE(sidewarpoverlayflags, "SideWarpOverlayFlags"); break;	//b
		case SCREENDATAWARPARRIVALX: 	SET_SCREENDATA_VAR_BYTE(warparrivalx, "WarpArrivalX"); break;	//b
		case SCREENDATAWARPARRIVALY: 	SET_SCREENDATA_VAR_BYTE(warparrivaly, "WarpArrivalY"); break;	//b
		case SCREENDATAPATH: 		SET_SCREENDATA_BYTE_INDEX(path, "MazePath", 3); break;	//b, 4 of these
		case SCREENDATASIDEWARPSC: 	SET_SCREENDATA_BYTE_INDEX(sidewarpscr, "SideWarpScreen", 3); break;	//b, 4 of these
		case SCREENDATASIDEWARPDMAP: 	SET_SCREENDATA_VAR_INDEX32(sidewarpdmap, "SideWarpDMap", 3); break;	//w, 4 of these
		case SCREENDATASIDEWARPINDEX: 	SET_SCREENDATA_VAR_BYTE(sidewarpindex, "SideWarpIndex"); break;	//b
		case SCREENDATAUNDERCOMBO: 	SET_SCREENDATA_VAR_INT32(undercombo, "Undercombo"); break;	//w
		case SCREENDATAUNDERCSET:	 	SET_SCREENDATA_VAR_BYTE(undercset,	"UnderCSet"); break; //b
		case SCREENDATACATCHALL:	 	SET_SCREENDATA_VAR_INT32(catchall,	"Catchall"); break; //W

		case SCREENDATACSENSITIVE: 	SET_SCREENDATA_VAR_BYTE(csensitive, "CSensitive"); break;	//B
		case SCREENDATANORESET: 		SET_SCREENDATA_VAR_INT32(noreset, "NoReset"); break;	//W
		case SCREENDATANOCARRY: 		SET_SCREENDATA_VAR_INT32(nocarry, "NoCarry"); break;	//W
		case SCREENDATALAYERMAP:	 	SET_SCREENDATA_LAYER_INDEX(layermap, "LayerMap", 5); break;	//B, 6 OF THESE
		case SCREENDATALAYERSCREEN: 	SET_SCREENDATA_LAYERSCREEN_INDEX(layerscreen, "LayerScreen", 5); break;	//B, 6 OF THESE
		case SCREENDATALAYEROPACITY: 	SET_SCREENDATA_LAYER_INDEX(layeropacity, "LayerOpacity", 5); break;	//B, 6 OF THESE
		case SCREENDATALAYERINVIS: 	
		{
			int indx = ri->d[0] / 10000;
			if(indx < 0 || indx > 6 )
			{
				Z_scripterrlog("Invalid Index passed to Screen->LayerInvisible[]: %d\n", indx);
			}
			else
			{
				if(value)
					tmpscr->hidelayers |= (1<<indx);
				else
					tmpscr->hidelayers &= ~(1<<indx);
			}
			break;
		}
		case SCREENDATASCRIPTDRAWS: 	
		{
			int indx = ri->d[0] / 10000;
			if(indx < 0 || indx > 7 )
			{
				Z_scripterrlog("Invalid Index passed to Screen->HideScriptLayer[]: %d\n", indx);
			}
			else
			{
				if(value)
					tmpscr->hidescriptlayers &= ~(1<<indx);
				else
					tmpscr->hidescriptlayers |= (1<<indx);
			}
			break;
		}

		case SCREENDATATILEWARPOVFLAGS: 
		{
			int indx = ri->d[0] / 10000;
			if ( ((unsigned)indx) > 3 ) 
			{
				Z_scripterrlog("Invalid index passed to TileWarpOverlayFlags[%d].\n. Valid indices are [0] through [3].\n", indx);
			}
			else
			{
				if ( value ) tmpscr->tilewarpoverlayflags |= (1<<indx);
				else tmpscr->tilewarpoverlayflags &= ~(1<<indx);
			}
			break;
		}

		case SCREENDATASIDEWARPOVFLAGS: 
		{
			int indx = ri->d[0] / 10000;
			if ( ((unsigned)indx) > 3 ) 
			{
				Z_scripterrlog("Invalid index passed to SideWarpOverlayFlags[%d].\n. Valid indices are [0] through [3].\n", indx);
			}
			else
			{
				if ( value ) tmpscr->sidewarpoverlayflags |= (1<<indx);
				else tmpscr->sidewarpoverlayflags &= ~(1<<indx);
			}
			break;
		}

		case SCREENDATATIMEDWARPTICS: 	SET_SCREENDATA_VAR_INT32(timedwarptics, "TimedWarpTimer"); break;	//W
		case SCREENDATANEXTMAP: 		SET_SCREENDATA_VAR_BYTE(nextmap, "NextMap"); break;	//B
		case SCREENDATANEXTSCREEN: 	SET_SCREENDATA_VAR_BYTE(nextscr, "NextScreen"); break;	//B
		case SCREENDATASECRETCOMBO: 	SET_SCREENDATA_VAR_INDEX32(secretcombo, "SecretCombo", 127); break;	//W, 128 OF THESE
		case SCREENDATASECRETCSET: 	SET_SCREENDATA_BYTE_INDEX(secretcset, "SecretCSet", 127); break;	//B, 128 OF THESE
		case SCREENDATASECRETFLAG: 	SET_SCREENDATA_BYTE_INDEX(secretflag, "SecretFlags", 127); break;	//B, 128 OF THESE
		case SCREENDATAVIEWX: 		SET_SCREENDATA_VAR_INT32(viewX, "ViewX"); break;	//W
		case SCREENDATAVIEWY: 		SET_SCREENDATA_VAR_INT32(viewY, "ViewY"); break; //W
		case SCREENDATASCREENWIDTH: 	SET_SCREENDATA_VAR_BYTE(scrWidth, "Width"); break;	//B
		case SCREENDATASCREENHEIGHT: 	SET_SCREENDATA_VAR_BYTE(scrHeight,	"Height"); break;	//B
		case SCREENDATAENTRYX: 		SET_SCREENDATA_VAR_BYTE(entry_x, "EntryX"); break;	//B
		case SCREENDATAENTRYY: 		SET_SCREENDATA_VAR_BYTE(entry_y, "EntryY"); break;	//B
		//case SCREENDATANUMFF: 		SET_SCREENDATA_VAR_INT16(numff, "NumFFCs"); break;	//INT16

		case SCREENDATANUMFF: 	
		{
			int indx = ri->d[0] / 10000;
			if ( !indx )
			{
				Z_scripterrlog("Invalid Index passed to Screen->NumFFCs[%d].\n Valid indices are 1 through [32].\n", indx);
			}
			else if(((unsigned)indx)>32)
			{
				Z_scripterrlog("Invalid Index passed to Screen->NumFFCs[%d].\n Valid indices are 1 through [32].\n", indx);
			}
			else
			{
				--indx;
				if ( value ) { (((tmpscr->numff) |= (1<<indx))); }
				else { (((tmpscr->numff) &= ~(1<<indx))); }
				
				//ret = ((tmpscr->hidescriptlayers >> indx) & 1) ? 0 : 10000;
			}
			break;
		}

			//inita	//INT32, 32 OF THESE, EACH WITH 2
		case SCREENDATAFFINITIALISED: 	SET_SCREENDATA_BOOL_INDEX(initialized, "FFCRunning", 31); break;	//BOOL, 32 OF THESE
		case SCREENDATASCRIPTENTRY: 	SET_SCREENDATA_VAR_INT32(script_entry, "ScriptEntry"); break;	//W
		case SCREENDATASCRIPTOCCUPANCY: 	SET_SCREENDATA_VAR_INT32(script_occupancy,	"ScriptOccupancy");  break;//W
		case SCREENDATASCRIPTEXIT: 	SET_SCREENDATA_VAR_INT32(script_exit, "ExitScript"); break;	//W
		case SCREENDATAOCEANSFX:	 	SET_SCREENDATA_VAR_BYTE(oceansfx, "OceanSFX"); break;	//B
		case SCREENDATABOSSSFX: 		SET_SCREENDATA_VAR_BYTE(bosssfx, "BossSFX"); break;	//B
		case SCREENDATASECRETSFX:	 	SET_SCREENDATA_VAR_BYTE(secretsfx, "SecretSFX"); break;	//B
		case SCREENDATAHOLDUPSFX:	 	SET_SCREENDATA_VAR_BYTE(holdupsfx,	"ItemSFX"); break; //B
		case SCREENDATASCREENMIDI:
		{
			tmpscr->screen_midi = vbound((value / 10000)-(MIDIOFFSET_MAPSCR-MIDIOFFSET_ZSCRIPT),-1,32767);
			break;
		}
		case SCREENDATALENSLAYER:	 	SET_SCREENDATA_VAR_BYTE(lens_layer, "LensLayer"); break;	//B, OLD QUESTS ONLY?
			
		case SCREENSIDEWARPID:
		{
			int indx = ri->d[0] / 10000; //dir
			
			int new_warp_return = vbound((value / 10000),-1,3); //none, A, B, C, D
			if(new_warp_return == -1)
			{
				tmpscr->flags2 &= ~(1<<indx); //Unset the "Enabled" flag for this dir
				tmpscr->sidewarpindex &= ~(3<<(2*indx)); //Clear the dir as well.
			}
			else
			{
				tmpscr->flags2 |= 1<<indx; //Set the "Enabled" flag for this dir
				tmpscr->sidewarpindex &= ~(3<<(2*indx)); //Clear the dir bits
				tmpscr->sidewarpindex |= (new_warp_return<<(2*indx)); //Set the new dir
			}
			
			break;
		} 

		case SCREENDATATWARPRETSQR:
		{
			int indx = ri->d[0] / 10000;
			if ( ((unsigned)indx) > 3)
			{
				 Z_scripterrlog("Invalid Array Index passed to Screen->TileWarpReturnSquare[]: %d\n", indx);
			}
			else
			{
				int wrindex = vbound(value/10000, 0, 3);
				tmpscr->warpreturnc = (tmpscr->warpreturnc&~(3<<(indx*2))) | (wrindex<<(indx*2));
			}
			break;
		}

		//
		case SCREENDATASWARPRETSQR:
		{
			
			int indx = ri->d[0] / 10000;
			if ( ((unsigned)indx) > 3)
			{
				 Z_scripterrlog("Invalid Array Index passed to Screen->SideWarpReturnSquare[]: %d\n", indx);
			}
			else
			{
				int wrindex = vbound(value/10000, 0, 3);
				tmpscr->warpreturnc = (tmpscr->warpreturnc&~(3<<(8+(indx*2)))) | (wrindex<<(8+(indx*2)));
			}
			break;
		}


		case SCREENDATAFLAGS: 
		{
			int flagid = (ri->d[0])/10000;
			//bool valtrue = ( value ? 10000 : 0);
			switch(flagid)
			{
				case 0: tmpscr->flags = (value / 10000); break;
				case 1: tmpscr->flags2 = (value / 10000); break;
				case 2: tmpscr->flags3 = (value / 10000); break;
				case 3: tmpscr->flags4 = (value / 10000); break;
				case 4: tmpscr->flags5 = (value / 10000); break;
				case 5: tmpscr->flags6 = (value / 10000); break;
				case 6: tmpscr->flags7 = (value / 10000); break;
				case 7: tmpscr->flags8 = (value / 10000); break;
				case 8: tmpscr->flags9 = (value / 10000); break;
				case 9: tmpscr->flags10 = (value / 10000); break;
				default:
				{
					Z_scripterrlog("Invalid index passed to mapdata->flags[]: %d\n", flagid); 
					break;
					
				}
			}
			break;
			//GET_SCREENDATA_BYTE_INDEX	//B, 11 OF THESE, flags, flags2-flags10
		}


		//These use the same method as SetScreenD
		case SCREENWIDTH:
			FFScript::set_screenWidth(&TheMaps[(ri->d[1] / 10000) * MAPSCRS + (ri->d[0]/10000)], value/10000);
			break;

		case SCREENHEIGHT:
			FFScript::set_screenHeight(&TheMaps[(ri->d[1] / 10000) * MAPSCRS + (ri->d[0]/10000)], value/10000);
			break;

		case SCREENVIEWX:
			FFScript::set_screenViewX(&TheMaps[(ri->d[1] / 10000) * MAPSCRS + (ri->d[0]/10000)], value/10000);
			break;

		case SCREENVIEWY:
			FFScript::set_screenViewY(&TheMaps[(ri->d[1] / 10000) * MAPSCRS + (ri->d[0]/10000)], value/10000);
			break;

		case SCREENGUY:
			FFScript::set_screenGuy(&TheMaps[(ri->d[1] / 10000) * MAPSCRS + (ri->d[0]/10000)], value/10000);
			break;

		case SCREENSTRING:
		{
			FFScript::set_screenString(&TheMaps[(ri->d[1] / 10000) * MAPSCRS + (ri->d[0]/10000)], value/10000);
			//should this be either
			//set_screenString(&TheMaps[((ri->d[1] / 10000) * MAPSCRS + (ri->d[0]/10000)])-1), value/10000);
			//or
			//set_screenString(&TheMaps[((ri->d[1] / 10000) * MAPSCRS + (ri->d[0]/10000)])-+1), value/10000);
			Z_message("Map ref is: %d\n",((ri->d[1] / 10000) * MAPSCRS + (ri->d[0]/10000)));
		}
		break;

		case SCREENROOM:
			FFScript::set_screenRoomtype(&TheMaps[(ri->d[1] / 10000) * MAPSCRS + (ri->d[0]/10000)], value/10000);
			break;

		case SCREENENTX:
			FFScript::set_screenEntryX(&TheMaps[(ri->d[1] / 10000) * MAPSCRS + (ri->d[0]/10000)], value/10000);
			break;

		case SCREENENTY:
			FFScript::set_screenEntryY(&TheMaps[(ri->d[1] / 10000) * MAPSCRS + (ri->d[0]/10000)], value/10000);
			break;

		case SCREENITEM:
			FFScript::set_screenitem(&TheMaps[(ri->d[1] / 10000) * MAPSCRS + (ri->d[0]/10000)], value/10000);
			break;

		case SCREENUNDCMB:
			FFScript::set_screenundercombo(&TheMaps[(ri->d[1] / 10000) * MAPSCRS + (ri->d[0]/10000)], value/10000);
			break;

		case SCREENUNDCST:
			FFScript::set_screenundercset(&TheMaps[(ri->d[1] / 10000) * MAPSCRS + (ri->d[0]/10000)], value/10000);
			break;

		case SCREENCATCH:
			FFScript::set_screenatchall(&TheMaps[(ri->d[1] / 10000) * MAPSCRS + (ri->d[0]/10000)], value/10000);
			break;

		//These use the method of SetScreenEnemy


		//SetScreenLayerOpacity(int map, int scr, int layer, int v)
		case SETSCREENLAYOP:
		{ 
			long map     = (ri->d[1] / 10000) - 1; //Should this be +1? -Z
			long scrn  = ri->d[2] / 10000; 
			long index = ri->d[0] / 10000; 
			int nn = ri->d[3]/10000; 

			if(BC::checkMapID(map, "Game->SetScreenLayerOpacity(...map...)") != SH::_NoError ||
				BC::checkBounds(scrn, 0, 0x87, "Game->SetScreenLayerOpacity(...screen...)") != SH::_NoError ||
				BC::checkBounds(index, 0, 9, "Game->SetScreenLayerOpacity(...index...)") != SH::_NoError)
				return;
				
			FFScript::set_screenlayeropacity(&TheMaps[map * MAPSCRS + scrn], index, nn); 
		}
		break;

		case SETSCREENSECCMB:
		{ 
			long map     = (ri->d[1] / 10000) - 1; //Should this be +1? -Z
			long scrn  = ri->d[2] / 10000; 
			long index = ri->d[0] / 10000; 
			int nn = ri->d[3]/10000; 

			if(BC::checkMapID(map, "Game->SetScreenSecretCombo(...map...)") != SH::_NoError ||
				BC::checkBounds(scrn, 0, 0x87, "Game->SetScreenSecretCombo(...screen...)") != SH::_NoError ||
				BC::checkBounds(index, 0, 9, "Game->SetScreenSecretCombo(...index...)") != SH::_NoError)
				return;
				
			FFScript::set_screensecretcombo(&TheMaps[map * MAPSCRS + scrn], index, nn); 
		}
		break;

		case SETSCREENSECCST:
		{ 
			long map     = (ri->d[1] / 10000) - 1; //Should this be +1? -Z
			long scrn  = ri->d[2] / 10000; 
			long index = ri->d[0] / 10000; 
			int nn = ri->d[3]/10000; 

			if(BC::checkMapID(map, "Game->SetScreenSecretCSet(...map...)") != SH::_NoError ||
				BC::checkBounds(scrn, 0, 0x87, "Game->SetScreenSecretCSet(...screen...)") != SH::_NoError ||
				BC::checkBounds(index, 0, 9, "Game->SetScreenSecretCSet(...index...)") != SH::_NoError)
				return;
				
			FFScript::set_screensecretcset(&TheMaps[map * MAPSCRS + scrn], index, nn); 
		}
		break;

		case SETSCREENSECFLG:
		{ 
			long map     = (ri->d[1] / 10000) - 1; //Should this be +1? -Z
			long scrn  = ri->d[2] / 10000; 
			long index = ri->d[0] / 10000; 
			int nn = ri->d[3]/10000; 

			if(BC::checkMapID(map, "Game->SetScreenSecretFlag(...map...)") != SH::_NoError ||
				BC::checkBounds(scrn, 0, 0x87, "Game->SetScreenSecretFlag(...screen...)") != SH::_NoError ||
				BC::checkBounds(index, 0, 9, "Game->SetScreenSecretFlag(...index...)") != SH::_NoError)
				return;
				
			FFScript::set_screensecretflag(&TheMaps[map * MAPSCRS + scrn], index, nn); 
		}
		break;

		case SETSCREENLAYMAP:
		{ 
			long map     = (ri->d[1] / 10000) - 1; //Should this be +1? -Z
			long scrn  = ri->d[2] / 10000; 
			long index = ri->d[0] / 10000; 
			int nn = ri->d[3]/10000; 

			if(BC::checkMapID(map, "Game->SetScreenLayerMap(...map...)") != SH::_NoError ||
				BC::checkBounds(scrn, 0, 0x87, "Game->SetScreenLayerMap(...screen...)") != SH::_NoError ||
				BC::checkBounds(index, 0, 9, "Game->SetScreenLayerMap(...index...)") != SH::_NoError)
				return;
				
			FFScript::set_screenlayermap(&TheMaps[map * MAPSCRS + scrn], index, nn); 
		}
		break;

		case SETSCREENLAYSCR:
		{ 
			long map     = (ri->d[1] / 10000) - 1; //Should this be +1? -Z
			long scrn  = ri->d[2] / 10000; 
			long index = ri->d[0] / 10000; 
			int nn = ri->d[3]/10000; 

			if(BC::checkMapID(map, "Game->SetScreenLayerScreen(...map...)") != SH::_NoError ||
				BC::checkBounds(scrn, 0, 0x87, "Game->SetScreenLayerScreen(...screen...)") != SH::_NoError ||
				BC::checkBounds(index, 0, 9, "Game->SetScreenLayerScreen(...index...)") != SH::_NoError)
				return;
				
			FFScript::set_screenlayerscreen(&TheMaps[map * MAPSCRS + scrn], index, nn); 
		}
		break;

		case SETSCREENPATH:
		{ 
			long map     = (ri->d[1] / 10000) - 1; //Should this be +1? -Z
			long scrn  = ri->d[2] / 10000; 
			long index = ri->d[0] / 10000; 
			int nn = ri->d[3]/10000; 

			if(BC::checkMapID(map, "Game->SetScreenPath(...map...)") != SH::_NoError ||
				BC::checkBounds(scrn, 0, 0x87, "Game->SetScreenPath(...screen...)") != SH::_NoError ||
				BC::checkBounds(index, 0, 9, "Game->SetScreenPath(...index...)") != SH::_NoError)
				return;
				
			FFScript::set_screenpath(&TheMaps[map * MAPSCRS + scrn], index, nn); 
		}
		break;

		case SETSCREENWARPRX:
		{ 
			long map     = (ri->d[1] / 10000) - 1; //Should this be +1? -Z
			long scrn  = ri->d[2] / 10000; 
			long index = ri->d[0] / 10000; 
			int nn = ri->d[3]/10000; 

			if(BC::checkMapID(map, "Game->SetScreenWarpReturnX(...map...)") != SH::_NoError ||
				BC::checkBounds(scrn, 0, 0x87, "Game->SetScreenWarpReturnX(...screen...)") != SH::_NoError ||
				BC::checkBounds(index, 0, 9, "Game->SetScreenWarpReturnX(...index...)") != SH::_NoError)
				return;
				
			FFScript::set_screenwarpReturnX(&TheMaps[map * MAPSCRS + scrn], index, nn); 
		}
		break;

		case SETSCREENWARPRY:
		{ 
			long map     = (ri->d[1] / 10000) - 1; //Should this be +1? -Z
			long scrn  = ri->d[2] / 10000; 
			long index = ri->d[0] / 10000; 
			int nn = ri->d[3]/10000; 

			if(BC::checkMapID(map, "Game->SetScreenWarpReturnY(...map...)") != SH::_NoError ||
				BC::checkBounds(scrn, 0, 0x87, "Game->SetScreenWarpReturnY(...screen...)") != SH::_NoError ||
				BC::checkBounds(index, 0, 9, "Game->SetScreenWarpReturnY(...index...)") != SH::_NoError)
				return;
				
			FFScript::set_screenwarpReturnY(&TheMaps[map * MAPSCRS + scrn], index, nn); 
		}
		break;

		case SDD:
		{
			{
				int di2 = ((get_currdmap())<<7) + get_currscr()-(DMaps[get_currdmap()].type==dmOVERW ? 0 : DMaps[get_currdmap()].xoff);
				FFScript::set_screen_d(di2, ri->d[0]/10000, value);
				break;
			}
		}
		
		case GDD:
			al_trace("GDD");
			game->global_d[ri->d[0]/10000]=value;
			break;
			
		case SDDD:
			FFScript::set_screen_d((ri->d[0])/10000 + ((get_currdmap())<<7), ri->d[1]/10000, value);
			break;
			
		case SDDDD:
			FFScript::set_screen_d(ri->d[1]/10000 + ((ri->d[0]/10000)<<7), ri->d[2]/10000, value);
			break;
			
		case SCREENINITD:
			tmpscr->screeninitd[ri->d[0]/10000] = value;
			break;
		
		case SCREENSCRIPT:
		{
			FFScript::deallocateAllArrays(SCRIPT_SCREEN, 0);
			
			if ( get_bit(quest_rules,qr_CLEARINITDONSCRIPTCHANGE))
			{
				for(int q=0; q<8; q++)
					tmpscr->screeninitd[q] = 0;
			}
			screenScriptData.Clear();
			tmpscr->script=vbound(value/10000, 0, NUMSCRIPTSCREEN-1);
			break;
		}
		
		case MAPDATAINITD:
			tmpscr->screeninitd[ri->d[0]/10000]=value;
			break;
		
		case SCRDOORD:
			tmpscr->door[ri->d[0]/10000]=value/10000;
			putdoor(scrollbuf,0,ri->d[0]/10000,value/10000,true,true);
			break;
			
		case LIT:
			naturaldark = !value;
			lighting(false, false);
			break;
			
		case WAVY:
			wavy=value/10000;
			break;
			
		case QUAKE:
			quakeclk=value/10000;
			break;
			
		case ROOMTYPE:
			tmpscr->room=value/10000; break; //this probably doesn't work too well...
		
		case ROOMDATA:
			tmpscr->catchall=value/10000;
			break;
			
		case PUSHBLOCKCOMBO:
			mblock2.bcombo=value/10000;
			break;
			
		case PUSHBLOCKCSET:
			mblock2.cs=value/10000;
			mblock2.oldcset=value/10000;
			break;
			
		case UNDERCOMBO:
			tmpscr->undercombo=value/10000;
			break;
			
		case UNDERCSET:
			tmpscr->undercset=value/10000;
			break;
		
		
		case DEBUGGDR:
		{
			int a = vbound(ri->d[0]/10000,0,15);
			game->global_d[a] = value / 10000;;
			break;
		}
		
		case DEBUGSP:
			SH::write_stack(ri->sp,vbound((value / 10000),0,MAX_SCRIPT_REGISTERS-1));
			break;
			
		case DEBUGREFFFC:
			ri->ffcref = vbound((value / 10000),1,31);
			break;
			
		case DEBUGREFITEM:
			ri->itemref = vbound((value / 10000),0,255);
			break;
			
		case DEBUGREFITEMDATA:
			ri->idata = vbound((value / 10000),0,255);
			break;
			
		case DEBUGREFLWEAPON:
			ri->lwpn = vbound((value / 10000),0,255);
			break;
			
		case DEBUGREFEWEAPON:
			ri->ewpn = vbound((value / 10000),0,255);
			break;
			
		case DEBUGREFNPC:
			ri->guyref = vbound((value / 10000),0,255);
			break;
			
		
		//Game Over Screen
		case SETGAMEOVERELEMENT:
		{
			long colour = value/10000;
			int index = ri->d[0]/10000;
			index = vbound(index,0,11);
			al_trace("GameOverScreen Index: %d/n",index);
			al_trace("GameOverScreen Value: %ld/n",colour);
			SetSaveScreenSetting(index,colour);
			break;
		}

		case SETGAMEOVERSTRING:
		{
			long arrayptr = value/10000;
			int index = ri->d[0]/10000;
			string filename_str;
			ArrayH::getString(arrayptr, filename_str, 73);
			ChangeSubscreenText(index,filename_str.c_str());
			break;
		}

	///----------------------------------------------------------------------------------------------------//
	//New Datatype Variables
		
	///----------------------------------------------------------------------------------------------------//
	//spritedata sp-> Variables
		case SPRITEDATATILE: SET_SPRITEDATA_VAR_INT(newtile, "Tile"); break;
		case SPRITEDATAMISC: SET_SPRITEDATA_VAR_BYTE(misc, "Misc"); break;
		case SPRITEDATACSETS: SET_SPRITEDATA_VAR_BYTE(csets, "CSet"); break;
		case SPRITEDATAFRAMES: SET_SPRITEDATA_VAR_BYTE(frames, "Frames"); break;
		case SPRITEDATASPEED: SET_SPRITEDATA_VAR_BYTE(speed, "Speed"); break;
		case SPRITEDATATYPE: SET_SPRITEDATA_VAR_BYTE(type, "Type"); break;
		
	///----------------------------------------------------------------------------------------------------//
	//mapdata m-> Variables
		//mapdata m-> Variables
		
		#define	SET_MAPDATA_VAR_INT32(member, str) \
		{ \
			if ( ri->mapsref == LONG_MAX ) \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n",str); \
				break; \
			} \
			else \
			{ \
				mapscr *m = GetMapscr(ri->mapsref); \
				m->member = vbound((value / 10000),-214747,214747); \
			} \
		} \
		
		#define	SET_MAPDATA_VAR_INT16(member, str) \
		{ \
			if ( ri->mapsref == LONG_MAX ) \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n",str); \
				break; \
			} \
			else \
			{ \
				mapscr *m = GetMapscr(ri->mapsref); \
				m->member = vbound((value / 10000),0,32767); \
			} \
		} \

		#define	SET_MAPDATA_VAR_BYTE(member, str) \
		{ \
			if ( ri->mapsref == LONG_MAX ) \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n",str); \
				break; \
			} \
			else \
			{ \
				mapscr *m = GetMapscr(ri->mapsref); \
				m->member = vbound((value / 10000),0,255); \
			} \
		} \
		
		#define SET_MAPDATA_VAR_INDEX32(member, str, indexbound) \
		{ \
			int indx = ri->d[0] / 10000; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", str, indx); \
				break; \
			} \
			if ( ri->mapsref == LONG_MAX ) \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n",str); \
				break; \
			} \
			else \
			{ \
				mapscr *m = GetMapscr(ri->mapsref); \
				m->member[indx] = vbound((value / 10000),-214747,214747); \
			} \
		} \
		
		#define SET_MAPDATA_VAR_INDEX16(member, str, indexbound) \
		{ \
			int indx = ri->d[0] / 10000; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", str, indx); \
				break; \
			} \
			if ( ri->mapsref == LONG_MAX ) \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n",str); \
				break; \
			} \
			else \
			{ \
				mapscr *m = GetMapscr(ri->mapsref); \
				m->member[indx] = vbound((value / 10000),-32767,32767); \
			} \
		} \

		#define SET_MAPDATA_BYTE_INDEX(member, str, indexbound) \
		{ \
			int indx = ri->d[0] / 10000; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", str, indx); \
				break; \
			} \
			if ( ri->mapsref == LONG_MAX ) \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n",str); \
				break; \
			} \
			else \
			{ \
				mapscr *m = GetMapscr(ri->mapsref); \
				m->member[indx] = vbound((value / 10000),0,255); \
			} \
		}\
		
		#define SET_MAPDATA_LAYER_INDEX(member, str, indexbound) \
		{ \
			int indx = ri->d[0] / 10000; \
			if ( FFCore.quest_format[vFFScript] < 11 ) ++indx; \
			if(indx < 1 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", str, indx); \
				break; \
			} \
			if ( ri->mapsref == LONG_MAX ) \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n",str); \
				break; \
			} \
			else \
			{ \
				mapscr *m = GetMapscr(ri->mapsref); \
				m->member[indx-1] = vbound((value / 10000),0,255); \
			} \
		} \
		
		#define SET_MAPDATA_LAYERSCREEN_INDEX(member, str, indexbound) \
		{ \
			int indx = ri->d[0] / 10000; \
			if ( FFCore.quest_format[vFFScript] < 11 ) ++indx; \
			int scrn_id = value/10000; \
			if(indx < 1 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", str, indx); \
				break; \
			} \
			if ( ri->mapsref == LONG_MAX ) \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n",str); \
				break; \
			} \
			else if ( scrn_id > MAPSCRS ) \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->LayerScreen[%d].\n",scrn_id); \
				Z_scripterrlog("Valid Screen values are (0) through (%d).\n",MAPSCRS); \
				break; \
			} \
			else \
			{ \
				mapscr *m = GetMapscr(ri->mapsref); \
				m->member[indx-1] = vbound((scrn_id),0,MAPSCRS); \
			} \
		}\
		
		#define SET_MAPDATA_BOOL_INDEX(member, str, indexbound) \
		{ \
			int indx = ri->d[0] / 10000; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", str, indx); \
				break; \
			} \
			if ( ri->mapsref == LONG_MAX ) \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n",str); \
				break; \
			} \
			else \
			{ \
				mapscr *m = GetMapscr(ri->mapsref); \
				m->member[indx] =( (value/10000) ? 1 : 0 ); \
			} \
		} \
		
		#define SET_MAPDATA_FLAG(member, str) \
		{ \
			long flag =  (value/10000);  \
			if ( ri->mapsref == LONG_MAX ) \
			{ \
				Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n",str); \
				break; \
			} \
			else \
			{ \
				mapscr *m = GetMapscr(ri->mapsref); \
				if ( flag != 0 ) \
				{ \
					m->member|=flag; \
				} \
				else m->.member|= ~flag; \
			} \
		} \
		
		#define SET_MAPDATA_FFCPOS_INDEX32(member, str, indexbound) \
		{ \
			int indx = (ri->d[0] / 10000)-1; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", (indx+1), str); \
				break; \
			} \
			else if ( ri->mapsref == LONG_MAX ) \
			{ \
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","str"); \
				break; \
			} \
			else \
			{ \
				mapscr *m = GetMapscr(ri->mapsref); \
				m->member[indx] = value; \
			} \
		} \
		
		#define SET_MAPDATA_FFC_INDEX32(member, str, indexbound) \
		{ \
			int indx = (ri->d[0] / 10000)-1; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", (indx+1), str); \
				break; \
			} \
			else if ( ri->mapsref == LONG_MAX ) \
			{ \
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","str"); \
				break; \
			} \
			else \
			{ \
				mapscr *m = GetMapscr(ri->mapsref); \
				m->member[indx] = value/10000; \
			} \
		} \
		
		#define SET_MAPDATA_FFC_INDEX_VBOUND(member, str, indexbound, min, max) \
		{ \
			int v = value/10000; \
			int indx = (ri->d[0] / 10000)-1; \
			if(indx < 0 || indx > indexbound ) \
			{ \
				Z_scripterrlog("Invalid Index passed to mapdata->%s[]: %d\n", (indx+1), str); \
				break; \
			} \
			if(v < min || v > max ) \
			{ \
				Z_scripterrlog("Invalid value assigned to mapdata->%s[]: %d\n", (indx+1), str); \
				break; \
			} \
			else if ( ri->mapsref == LONG_MAX ) \
			{ \
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","str"); \
				break; \
			} \
			else \
			{ \
				mapscr *m = GetMapscr(ri->mapsref); \
				m->member[indx] = v; \
			} \
		} \
		
		case MAPDATAVALID:		SET_MAPDATA_VAR_BYTE(valid, "Valid"); break;		//b
		case MAPDATAGUY: 		SET_MAPDATA_VAR_BYTE(guy, "Guy"); break;		//b
		case MAPDATASTRING:		SET_MAPDATA_VAR_INT32(str, "String"); break;		//w
		case MAPDATAROOM: 		SET_MAPDATA_VAR_BYTE(room, "RoomType");	break;		//b
		case MAPDATAITEM: 		SET_MAPDATA_VAR_BYTE(item, "Item"); break;		//b
		case MAPDATAHASITEM: 		SET_MAPDATA_VAR_BYTE(hasitem, "HasItem"); break;	//b
		case MAPDATATILEWARPTYPE: 	SET_MAPDATA_BYTE_INDEX(tilewarptype, "TileWarpType", 3); break;	//b, 4 of these
		//case MAPDATATILEWARPOVFLAGS: 	SET_MAPDATA_VAR_BYTE(tilewarpoverlayflags, "TileWarpOverlayFlags"); break;	//b, tilewarpoverlayflags
		case MAPDATADOORCOMBOSET: 	SET_MAPDATA_VAR_INT32(door_combo_set, "DoorComboSet"); break;	//w
		case MAPDATAWARPRETX:	 	SET_MAPDATA_BYTE_INDEX(warpreturnx, "WarpReturnX", 3); break;	//b, 4 of these
		case MAPDATAWARPRETY:	 	SET_MAPDATA_BYTE_INDEX(warpreturny, "WarpReturnY", 3); break;	//b, 4 of these
		case MAPDATAWARPRETURNC: 	SET_MAPDATA_VAR_INT32(warpreturnc, "WarpReturnC"); break;	//w
		case MAPDATASTAIRX: 		SET_MAPDATA_VAR_BYTE(stairx, "StairsX"); break;	//b
		case MAPDATASTAIRY: 		SET_MAPDATA_VAR_BYTE(stairy, "StairsY"); break;	//b
		case MAPDATAITEMX:		SET_MAPDATA_VAR_BYTE(itemx, "ItemX"); break; //itemx
		case MAPDATAITEMY:		SET_MAPDATA_VAR_BYTE(itemy, "ItemY"); break;	//itemy
		case MAPDATACOLOUR: 		SET_MAPDATA_VAR_INT32(color, "CSet"); break;	//w
		case MAPDATAENEMYFLAGS: 	SET_MAPDATA_VAR_BYTE(enemyflags, "EnemyFlags");	break;	//b
		case MAPDATADOOR: 		SET_MAPDATA_BYTE_INDEX(door, "Door", 3); break;	//b, 4 of these
		case MAPDATATILEWARPDMAP: 	SET_MAPDATA_VAR_INDEX32(tilewarpdmap, "TileWarpDMap", 3); break;	//w, 4 of these
		case MAPDATATILEWARPSCREEN: 	SET_MAPDATA_BYTE_INDEX(tilewarpscr, "TileWarpScreen", 3); break;	//b, 4 of these
		case MAPDATAEXITDIR: 		SET_MAPDATA_VAR_BYTE(exitdir, "ExitDir"); break;	//b
		case MAPDATAENEMY: 		SET_MAPDATA_VAR_INDEX32(enemy, "Enemy", 9); break;	//w, 10 of these
		case MAPDATAPATTERN: 		SET_MAPDATA_VAR_BYTE(pattern, "Pattern"); break;	//b
		case MAPDATASIDEWARPTYPE: 	SET_MAPDATA_BYTE_INDEX(sidewarptype, "SideWarpType", 3); break;	//b, 4 of these
		//case MAPDATASIDEWARPOVFLAGS: 	SET_MAPDATA_VAR_BYTE(sidewarpoverlayflags, "SideWarpOverlayFlags"); break;	//b
		case MAPDATAWARPARRIVALX: 	SET_MAPDATA_VAR_BYTE(warparrivalx, "WarpArrivalX"); break;	//b
		case MAPDATAWARPARRIVALY: 	SET_MAPDATA_VAR_BYTE(warparrivaly, "WarpArrivalY"); break;	//b
		case MAPDATAPATH: 		SET_MAPDATA_BYTE_INDEX(path, "MazePath", 3); break;	//b, 4 of these
		case MAPDATASIDEWARPSC: 	SET_MAPDATA_BYTE_INDEX(sidewarpscr, "SideWarpScreen", 3); break;	//b, 4 of these
		case MAPDATAINITDARRAY:	 	
		{
			
			if ( ri->mapsref == LONG_MAX ) 
			{ 
				Z_scripterrlog("Script attempted to use a mapdata->InitD[%d] on a pointer that is uninitialised\n",ri->d[0]/10000); 
				break; 
			} 
			else 
			{ 
				mapscr *m = GetMapscr(ri->mapsref); 
				m->screeninitd[ri->d[0]/10000] = value;
			} 
			break;
		}


		case MAPDATALAYERINVIS: 	
		{
			int indx = ri->d[0] / 10000;
			if(indx < 0 || indx > 6 )
			{
				Z_scripterrlog("Invalid Index passed to mapdata->LayerInvisible[]: %d\n", indx);
				break;
			}
			else
			{
				
				if ( ri->mapsref == LONG_MAX )
				{
					Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n","LayerInvisible");
					break;
				}
				else
				{
					mapscr *m = GetMapscr(ri->mapsref);
					if(value)
					{
						tmpscr->hidelayers |= (1<<indx);
					}
					else
					{
						tmpscr->hidelayers &= ~(1<<indx);
					}
				}
			}
			break;
		}
		case MAPDATASCRIPTDRAWS: 	
		{
			int indx = ri->d[0] / 10000;
			if(indx < 0 || indx > 7 )
			{
				Z_scripterrlog("Invalid Index passed to mapdata->DisableScriptDraw[]: %d\n", indx);
			}
			else
			{
				if ( ri->mapsref == LONG_MAX )
				{
					Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n","DisableScriptDraw");
					break;
				}
				else
				{	mapscr *m = GetMapscr(ri->mapsref);
					if(value)
					{
						tmpscr->hidescriptlayers &= ~(1<<indx);
					}
					else
					{
						tmpscr->hidescriptlayers |= (1<<indx);
					}
				}
			}
			break;
		}

		case MAPDATATILEWARPOVFLAGS: 
		{
			int indx = ri->d[0] / 10000;
			if ( ((unsigned)indx) > 3 ) 
			{
				Z_scripterrlog("Invalid index passed to TileWarpOverlayFlags[%d].\n. Valid indices are [0] through [3].\n", indx);
			}
			else if ( ri->mapsref == LONG_MAX )
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n","NumFFCs[]");
			}
			else
			{
				mapscr *m = GetMapscr(ri->mapsref);
				if ( value ) m->tilewarpoverlayflags |= (1<<indx);
				else m->tilewarpoverlayflags &= ~(1<<indx);
			}
			break;
		}

		case MAPDATASIDEWARPOVFLAGS: 
		{
			int indx = ri->d[0] / 10000;
			if ( ((unsigned)indx) > 3 ) 
			{
				Z_scripterrlog("Invalid index passed to SideWarpOverlayFlags[%d].\n. Valid indices are [0] through [3].\n", indx);
			}
			else if ( ri->mapsref == LONG_MAX )
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n","NumFFCs[]");
			}
			else
			{
				mapscr *m = GetMapscr(ri->mapsref);
				if ( value ) m->sidewarpoverlayflags |= (1<<indx);
				else m->sidewarpoverlayflags &= ~(1<<indx);
			}
			break;
		}

		case MAPDATASIDEWARPDMAP: 	SET_MAPDATA_VAR_INDEX32(sidewarpdmap, "SideWarpDMap", 3); break;	//w, 4 of these
		case MAPDATASIDEWARPINDEX: 	SET_MAPDATA_VAR_BYTE(sidewarpindex, "SideWarpIndex"); break;	//b
		case MAPDATAUNDERCOMBO: 	SET_MAPDATA_VAR_INT32(undercombo, "UnderCombo"); break;	//w
		case MAPDATAUNDERCSET:	 	SET_MAPDATA_VAR_BYTE(undercset,	"UnderCSet"); break; //b
		case MAPDATACATCHALL:	 	SET_MAPDATA_VAR_INT32(catchall,	"Catchall"); break; //W

		case MAPDATACSENSITIVE: 	SET_MAPDATA_VAR_BYTE(csensitive, "CSensitive"); break;	//B
		case MAPDATANORESET: 		SET_MAPDATA_VAR_INT32(noreset, "NoReset"); break;	//W
		case MAPDATANOCARRY: 		SET_MAPDATA_VAR_INT32(nocarry, "NoCarry"); break;	//W
		//! Layer arrays should be a size of 7, and return the current screen / map / and OP_OPAQUE 
		//! if you try to read 0, so that they correspond to actual layer IDs. 
		//! 
		case MAPDATALAYERMAP:	 	SET_MAPDATA_LAYER_INDEX(layermap, "LayerMap", 6); break;	//B, 6 OF THESE
		case MAPDATALAYERSCREEN: 	SET_MAPDATA_LAYERSCREEN_INDEX(layerscreen, "LayerScreen", 6); break;	//B, 6 OF THESE
		case MAPDATALAYEROPACITY: 	SET_MAPDATA_LAYER_INDEX(layeropacity, "LayerOpacity", 6); break;	//B, 6 OF THESE
		case MAPDATATIMEDWARPTICS: 	SET_MAPDATA_VAR_INT32(timedwarptics, "TimedWarpTimer"); break;	//W
		case MAPDATANEXTMAP: 		SET_MAPDATA_VAR_BYTE(nextmap, "NextMap"); break;	//B
		case MAPDATANEXTSCREEN: 	SET_MAPDATA_VAR_BYTE(nextscr, "NextScreen"); break;	//B
		case MAPDATASECRETCOMBO: 	SET_MAPDATA_VAR_INDEX32(secretcombo, "SecretCombo", 127); break;	//W, 128 OF THESE
		case MAPDATASECRETCSET: 	SET_MAPDATA_BYTE_INDEX(secretcset, "SecretCSet", 127); break;	//B, 128 OF THESE
		case MAPDATASECRETFLAG: 	SET_MAPDATA_BYTE_INDEX(secretflag, "SecretFlags", 127); break;	//B, 128 OF THESE
		case MAPDATAVIEWX: 		SET_MAPDATA_VAR_INT32(viewX, "ViewX"); break;	//W
		case MAPDATASCRIPT:
		{
			if ( ri->mapsref == LONG_MAX ) 
			{ 
				Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n","Script"); 
				break; 
			} 
			else 
			{ 
				//FFScript::deallocateAllArrays(SCRIPT_SCREEN, ri->mapsref);//Mapdata never updates a running script, so does not need this deallocation block.
				
				mapscr *m = GetMapscr(ri->mapsref);
				
				/*if ( get_bit(quest_rules,qr_CLEARINITDONSCRIPTCHANGE)) //Mapdata never updates a running script. Why would it clear `tmpscr`, in any case?
				{
					for(int q=0; q<8; q++)
						tmpscr->screeninitd[q] = 0;
				}*/
				
				/*screenScriptData.Clear();*/ //Mapdata never updates a running script. Why would it clear the current screen script's data, in any case?
				m->script=vbound(value/10000, 0, NUMSCRIPTSCREEN-1);
			} 
			break;
			
		}
		case MAPDATAVIEWY: 		SET_MAPDATA_VAR_INT32(viewY, "ViewY"); break; //W
		case MAPDATASCREENWIDTH: 	SET_MAPDATA_VAR_BYTE(scrWidth, "Width"); break;	//B
		case MAPDATASCREENHEIGHT: 	SET_MAPDATA_VAR_BYTE(scrHeight,	"Height"); break;	//B
		case MAPDATAENTRYX: 		SET_MAPDATA_VAR_BYTE(entry_x, "EntryX"); break;	//B
		case MAPDATAENTRYY: 		SET_MAPDATA_VAR_BYTE(entry_y, "EntryY"); break;	//B
		//case MAPDATANUMFF: 		SET_MAPDATA_VAR_INT16(numff, "NumFFCs"); break;	//INT16
		case MAPDATAFFDATA:         SET_MAPDATA_FFC_INDEX32(ffdata, "FFCData", 31); break;  //W, 32 OF THESE
		case MAPDATAFFCSET:         SET_MAPDATA_FFC_INDEX32(ffcset, "FFCCSet", 31); break;  //B, 32
		case MAPDATAFFDELAY:        SET_MAPDATA_FFC_INDEX32(ffdelay, "FFCDelay", 31); break;    //W, 32
		case MAPDATAFFX:        SET_MAPDATA_FFCPOS_INDEX32(ffx, "FFCX", 31); break; //INT32, 32 OF THESE
		case MAPDATAFFY:        SET_MAPDATA_FFCPOS_INDEX32(ffy, "FFCY", 31); break; //..
		case MAPDATAFFXDELTA:       SET_MAPDATA_FFCPOS_INDEX32(ffxdelta, "FFCVx", 31); break;   //..
		case MAPDATAFFYDELTA:       SET_MAPDATA_FFCPOS_INDEX32(ffydelta, "FFCVy", 31); break;   //..
		case MAPDATAFFXDELTA2:      SET_MAPDATA_FFCPOS_INDEX32(ffxdelta2, "FFCAx", 31); break;  //..
		case MAPDATAFFYDELTA2:      SET_MAPDATA_FFCPOS_INDEX32(ffydelta2, "FFCAy", 31); break;  //..
		case MAPDATAFFFLAGS:        SET_MAPDATA_FFC_INDEX32(ffflags, "FFCFlags", 31); break;    //INT16, 32 OF THESE

		//Number of ffcs that are in use (have valid data
		case MAPDATANUMFF: 	
		{
			int indx = ri->d[0] / 10000;
			if ( !indx )
			{
				Z_scripterrlog("Invalid Index passed to mapdata->NumFFCs[%d].\n Valid indices are 1 through [32].\n", indx);
			}
			else if(((unsigned)indx)>32)
			{
				Z_scripterrlog("Invalid Index passed to mapdata->NumFFCs[%d].\n Valid indices are 1 through [32].\n", indx);
			}
			else if ( ri->mapsref == LONG_MAX )
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n","NumFFCs[]");
			}
			else
			{
				--indx;
				mapscr *m = GetMapscr(ri->mapsref);
				if ( value ) { (((m->numff) |= (1<<indx))); }
				else { (((m->numff) &= ~(1<<indx))); }
			}
			break;
		}

		case MAPDATASIDEWARPID:
		{
			
			int indx = ri->d[0] / 10000; //dir
			if ( ri->mapsref == LONG_MAX )
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n","SideWarpID"); 
				break; 
			}
			else
			{
				mapscr *m = GetMapscr(ri->mapsref);
				int new_warp_return = vbound((value / 10000),-1,3); //none, A, B, C, D
				if(new_warp_return == -1)
				{
					m->flags2 &= ~(1<<indx); //Unset the "Enabled" flag for this dir
					m->sidewarpindex &= ~(3<<(2*indx)); //Clear the dir as well.
				}
				else
				{
					m->flags2 |= 1<<indx; //Set the "Enabled" flag for this dir
					m->sidewarpindex &= ~(3<<(2*indx)); //Clear the dir bits
					m->sidewarpindex |= (new_warp_return<<(2*indx)); //Set the new dir
				}
			} 
			break;
		} 

		case MAPDATATWARPRETSQR:
		{
			int indx = ri->d[0] / 10000;
			if ( ((unsigned)indx) > 3)
			{
				 Z_scripterrlog("Invalid Array Index passed to mapdata->TileWarpReturnSquare[]: %d\n", indx);
			}
			else if ( ri->mapsref == LONG_MAX )
				{
					Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","str"); 
				} 
			else
			{
				mapscr *m = GetMapscr(ri->mapsref); 
				int wrindex = vbound(value/10000, 0, 3);
				m->warpreturnc = (m->warpreturnc&~(3<<(indx*2))) | (wrindex<<(indx*2));
			}
			break;
		}

		//
		case MAPDATASWARPRETSQR:
		{
			
			int indx = ri->d[0] / 10000;
			if ( ((unsigned)indx) > 3)
			{
				 Z_scripterrlog("Invalid Array Index passed to MAPDATA->SideWarpReturnSquare[]: %d\n", indx);
			}
			else if ( ri->mapsref == LONG_MAX )
				{
					Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","str"); 
				} 
			else
			{
				mapscr *m = GetMapscr(ri->mapsref); 
				int wrindex = vbound(value/10000, 0, 3);
				m->warpreturnc = (m->warpreturnc&~(3<<(8+(indx*2)))) | (wrindex<<(8+(indx*2)));
			}
			break;
		}

		//Height and With are Or'd together, and need to be separate:
		/*
		 //TileWidth ffwidth[ri->ffcref]= (tmpscr->ffwidth[ri->ffcref] & ~63) | (((value/10000)-1)&63);
		*/
		case MAPDATAFFWIDTH:       
		{
			if ( ri->mapsref == LONG_MAX )
			{
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","FFCTileWidth[]");
				break;
			}
			else
			{
				mapscr *m = GetMapscr(ri->mapsref);
				int indx = (ri->d[0] / 10000)-1;
				if ( indx < 0 || indx > 32 )
				{
					Z_scripterrlog("Invalid FFC Index passed to MapData->FFCTileWidth[]: %d\n", indx+1);
					break;
				}
				if ( (value/10000) < 0 || (value/10000) > 4 )
				{
					Z_scripterrlog("Invalid WIDTH value passed to MapData->FFCTileWidth[]: %d\n", value/10000);
					break;
				}
				m->ffwidth[indx]= (m->ffwidth[indx]&63) | ((((value/10000)-1)&3)<<6);
			
				break;
			}
		}  
		 
		 
		//SET_MAPDATA_BYTE_INDEX(ffwidth, "FFCTileWidth");  //B, 32 OF THESE
		case MAPDATAFFHEIGHT:      
		{
			if ( ri->mapsref == LONG_MAX )
			{
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","FFCTileHeight[]");
				break;
			}
			else
			{
				mapscr *m = GetMapscr(ri->mapsref);
				int indx = (ri->d[0] / 10000)-1;
				if ( indx < 0 || indx > 31 )
				{
					Z_scripterrlog("Invalid FFC Index passed to MapData->FFCTileHeight[]: %d\n", indx+1);
					break;
				}
				if ( (value/10000) < 0 || (value/10000) > 4 )
				{
					Z_scripterrlog("Invalid WIDTH value passed to MapData->FFCTileHeight[]: %d\n", value/10000);
					break;
				}
				m->ffheight[indx]=(m->ffheight[indx]&63) | ((((value/10000)-1)&3)<<6);
				break;
			}
			
		}
		 
		//EffectWidth tmpscr->ffwidth[ri->ffcref]= (tmpscr->ffwidth[ri->ffcref]&63) | ((((value/10000)-1)&3)<<6);
		 
		//SET_MAPDATA_BYTE_INDEX(ffheight, "FFCTileHeight"  //B, 32 OF THESE
		case MAPDATAFFEFFECTWIDTH:     
		{
			if ( ri->mapsref == LONG_MAX )
			{
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","FFCEffectWidth[]");
				break;
			}
			else
			{
				mapscr *m = GetMapscr(ri->mapsref);
				int indx = (ri->d[0] / 10000)-1;
				if ( indx < 0 || indx > 31 )
				{
					Z_scripterrlog("Invalid FFC Index passed to MapData->FFCEffectWidth[]: %d\n", indx+1);
					break;
				}
				if ( (value/10000) < 0 )
				{
					Z_scripterrlog("Invalid WIDTH value passed to MapData->FFCEffectWidth[]: %d\n", value/10000);
					break;
				}
				m->ffwidth[indx]= (m->ffwidth[indx] & ~63) | (((value/10000)-1)&63);
				break;
			}
		}
		 
		 
		//SET_MAPDATA_BYTE_INDEX(ffwidth, "FFCEffectWidth");    //B, 32 OF THESE
		case MAPDATAFFEFFECTHEIGHT:
		{
			if ( ri->mapsref == LONG_MAX )
			{
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","FFCEffectHeight[]");
				break;
			}
			else
			{
				mapscr *m = GetMapscr(ri->mapsref);
				int indx = (ri->d[0] / 10000)-1;
				if ( indx < 0 || indx > 31 )
				{
					Z_scripterrlog("Invalid FFC Index passed to MapData->FFCEffectHeight[]: %d\n", indx+1);
					break;
				}
				if ( (value/10000) < 0 )
				{
					Z_scripterrlog("Invalid HEIGHT value passed to MapData->FFCEffectHeight[]: %d\n", value/10000);
					break;
				}
				m->ffheight[indx]= (m->ffheight[indx] & ~63) | (((value/10000)-1)&63);
				break;
			}
		}
			
		//SET_MAPDATA_BYTE_INDEX(ffheight, "FFCEffectHeight"    //B, 32 OF THESE   
		 
		case MAPDATAFFLINK:         SET_MAPDATA_FFC_INDEX_VBOUND(fflink, "FFCLink", 31, 0, 32); break;  //B, 32 OF THESE
		case MAPDATAFFSCRIPT:       SET_MAPDATA_FFC_INDEX_VBOUND(ffscript, "FFCScript", 31, 0, 255); break; //W, 32 OF THESE

		case MAPDATAINTID: 	 //Same form as SetScreenD()
			//SetFFCInitD(ffindex, d, value)
		{
			if ( ri->mapsref == LONG_MAX )
			{
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","SetFFCInitD()");
				break;
			}
			else
			{
				mapscr *m = GetMapscr(ri->mapsref); 
				//int ffindex = ri->d[0]/10000;
				//int d = ri->d[1]/10000;
				//int v = (value/10000);
				int ffid = (ri->d[0]/10000) -1;
				int indx = ri->d[1]/10000;
					
				if ( (unsigned)ffid > 31 ) 
				{
					Z_scripterrlog("Invalid FFC id passed to mapdata->FFCInitD[]: %d",ffid); 
				}
				else if ( (unsigned)indx > 7 )
				{
					Z_scripterrlog("Invalid InitD[] index passed to mapdata->FFCInitD[]: %d",indx);
				}
				else
				{ 
					 m->initd[ffid][indx] = value;
				}
				break;
			}
		}	
			

		//initd	//INT32 , 32 OF THESE, EACH WITH 10 INDICES. 


		case MAPDATAINITA: 		
			//same form as SetScreenD
		{
			if ( ri->mapsref == LONG_MAX )
			{
				Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","SetFFCInitA()");
				break;
			}
			else
			{
				mapscr *m = GetMapscr(ri->mapsref); 
				//int ffindex = ri->d[0]/10000;
				//int d = ri->d[1]/10000;
				//int v = (value/10000);
				int ffid = (ri->d[0]/10000) -1;
				int indx = ri->d[1]/10000;
					
				if ( (unsigned)ffid > 31 ) 
				{
					Z_scripterrlog("Invalid FFC id passed to mapdata->FFCInitD[]: %d",ffid); 
				}
				else if ( (unsigned)indx > 7 )
				{
					Z_scripterrlog("Invalid InitD[] index passed to mapdata->FFCInitD[]: %d",indx);
				}
				else
				{ 
					 m->inita[ffid][indx] = value;
				}
				
				break;
			}
		}	
			
		case MAPDATAFFINITIALISED: 	SET_MAPDATA_BOOL_INDEX(initialized, "FFCRunning", 31); break;	//BOOL, 32 OF THESE
		case MAPDATASCRIPTENTRY: 	SET_MAPDATA_VAR_INT32(script_entry, "ScriptEntry"); break;	//W
		case MAPDATASCRIPTOCCUPANCY: 	SET_MAPDATA_VAR_INT32(script_occupancy,	"ScriptOccupancy");  break;//W
		case MAPDATASCRIPTEXIT: 	SET_MAPDATA_VAR_INT32(script_exit, "ExitScript"); break;	//W
		case MAPDATAOCEANSFX:	 	SET_MAPDATA_VAR_BYTE(oceansfx, "OceanSFX"); break;	//B
		case MAPDATABOSSSFX: 		SET_MAPDATA_VAR_BYTE(bosssfx, "BossSFX"); break;	//B
		case MAPDATASECRETSFX:	 	SET_MAPDATA_VAR_BYTE(secretsfx, "SecretSFX"); break;	//B
		case MAPDATAHOLDUPSFX:	 	SET_MAPDATA_VAR_BYTE(holdupsfx,	"ItemSFX"); break; //B
		case MAPDATASCREENMIDI:
		{
			if ( ri->mapsref == LONG_MAX )
			{
				Z_scripterrlog("Script attempted to use a mapdata->%s on a pointer that is uninitialised\n","MIDI");
				break;
			}
			else
			{
				mapscr *m = GetMapscr(ri->mapsref);
				m->screen_midi = vbound((value / 10000)-(MIDIOFFSET_MAPSCR-MIDIOFFSET_ZSCRIPT),-1,32767);
			}
			break;
		}
		case MAPDATALENSLAYER:	 	SET_MAPDATA_VAR_BYTE(lens_layer, "LensLayer"); break;	//B, OLD QUESTS ONLY?
			

		case MAPDATAFLAGS: 
		{
			int flagid = (ri->d[0])/10000;
			mapscr *m = GetMapscr(ri->mapsref); 
			//bool valtrue = ( value ? 10000 : 0);
			switch(flagid)
			{
				case 0: m->flags = (value / 10000); break;
				case 1: m->flags2 = (value / 10000); break;
				case 2: m->flags3 = (value / 10000); break;
				case 3: m->flags4 = (value / 10000); break;
				case 4: m->flags5 = (value / 10000); break;
				case 5: m->flags6 = (value / 10000); break;
				case 6: m->flags7 = (value / 10000); break;
				case 7: m->flags8 = (value / 10000); break;
				case 8: m->flags9 = (value / 10000); break;
				case 9: m->flags10 = (value / 10000); break;
				default:
				{
					Z_scripterrlog("Invalid index passed to mapdata->flags[]: %d\n", flagid); 
					break;
					
				}
			}
			break;
			//SET_MAPDATA_BYTE_INDEX	//B, 11 OF THESE, flags, flags2-flags10
		}

		case MAPDATAMISCD:
		{
			int indx = (ri->d[0])/10000;
			int mi = ri->mapsref;
			mi -= 8*((ri->mapsref) / MAPSCRS);
			if( ((unsigned)indx) > 7 )
			{
				Z_scripterrlog("You were trying to reference an out-of-bounds array index for a screen's D[] array (%ld); valid indices are from 0 to 7.\n", indx);
				break;
			}
			else 
			{
				game->screen_d[mi][indx] = value/10000;
				break;
			}
		}


		case MAPDATACOMBODD:
		{
			int pos = (ri->d[0])/10000;
			int val = (value/10000);
      
			mapscr *m = GetMapscr(ri->mapsref);
			if ( ((unsigned) pos) > 175 )
			{
				Z_scripterrlog("Invalid [pos] %d used to write to mapdata->ComboD[]\n", pos);
			}
			else if ( ((unsigned) val) >= MAXCOMBOS )
			{
				Z_scripterrlog("Invalid combo ID %d used to write to mapdata->ComboD[]\n", val);
			}
			else
			{
				screen_combo_modify_preroutine(m,pos);
				m->data[pos]=val;
				screen_combo_modify_postroutine(m,pos);
			}
		}
		break;
		
		case MAPDATACOMBOCD:
		{
			int pos = (ri->d[0])/10000;
			int val = (value/10000); //cset
			mapscr *m = GetMapscr(ri->mapsref);
			if ( ((unsigned) pos) > 175 )
			{
				Z_scripterrlog("Invalid [pos] %d used to write to mapdata->ComboC[]\n", pos);
			}
			else if ( ((unsigned) val) >= 15 )
			{
				Z_scripterrlog("Invalid CSet ID %d used to write to mapdata->ComboC[]\n", val);
			}
			else
			{
				screen_combo_modify_preroutine(m,pos);
				m->cset[pos]=(val)&15;
				screen_combo_modify_postroutine(m,pos);
			}
		}
		break;
		
		case MAPDATACOMBOFD:
		{
			int pos = (ri->d[0])/10000;
			int val = (value/10000); //flag
			mapscr *m = GetMapscr(ri->mapsref);
			if ( ((unsigned) pos) > 175 )
			{
				Z_scripterrlog("Invalid [pos] %d used to write to mapdata->ComboF[]\n", pos);
			}
			else if ( ((unsigned) val) >= 256 )
			{
				Z_scripterrlog("Invalid Flag ID %d used to write to mapdata->ComboF[]\n", val);
			}
			
			else
				m->sflag[pos]=(val);
		}
		break;
		
		case MAPDATACOMBOTD:
		{
			int pos = (ri->d[0])/10000;
			int val = (value/10000); //type
			mapscr *m = GetMapscr(ri->mapsref);
			if ( ((unsigned) pos) > 175 )
			{
				Z_scripterrlog("Invalid [pos] %d used to write to mapdata->ComboT[]\n", pos);
			}
			else if ( ((unsigned) val) >= 256 )
			{
				Z_scripterrlog("Invalid Flag ID %d used to write to mapdata->ComboT[]\n", val);
			}
			else
			{
				// Preprocess each instance of the combo on the screen
				for(int i = 0; i < 176; i++)
				{
					if(m->data[i] == m->data[pos])
					{
						screen_combo_modify_preroutine(m,i);
					}
				}
				
				combobuf[m->data[pos]].type=val;
				
				for(int i = 0; i < 176; i++)
				{
					if(m->data[i] == m->data[pos])
					{
						screen_combo_modify_postroutine(m,i);
					}
				}
			}
		}
		break;
		
		case MAPDATACOMBOID:
		{
			int pos = (ri->d[0])/10000;
			int val = (value/10000); //iflag
			mapscr *m = GetMapscr(ri->mapsref);
			if(pos >= 0 && pos < 176)
				combobuf[m->data[pos]].flag=value/10000;
		}
		break;
		
		case MAPDATACOMBOSD:
		{
			int pos = (ri->d[0])/10000;
			int val = (value/10000); //solidity
			mapscr *m = GetMapscr(ri->mapsref);
			if ( ((unsigned) pos) > 175 )
			{
				Z_scripterrlog("Invalid [pos] %d used to write to mapdata->ComboI[]\n", pos);
			}
			else if ( ((unsigned) val) >= 256 )
			{
				Z_scripterrlog("Invalid Flag ID %d used to write to mapdata->ComboI[]\n", val);
			}
			
			else
				combobuf[m->data[pos]].walk=(val)&15;
		}
		break;

		case MAPDATASCREENSTATED:
		{
			int mi = ri->mapsref;
			mi -= 8*((ri->mapsref) / MAPSCRS);
			(value)?setmapflag(mi, 1<<((ri->d[0])/10000)) : unsetmapflag(mi, 1 << ((ri->d[0]) / 10000));
		}
		break;
		
	///----------------------------------------------------------------------------------------------------//
	//shopdata sd-> Variables
		
		case SHOPDATAITEM: 
		{ 
			
			int ref = ri->shopsref; 
			bool isInfo = ( ref > NUMSHOPS && ref < LONG_MAX ); 
			int indx = ri->d[0] / 10000; 
			if ( indx < 0 || indx > 2 ) 
			{ 
				Z_scripterrlog("Invalid Array Index passed to shopdata->%s: %d\n", indx, "Item"); 
				break;
			} 
			else 
			{ 
				if ( isInfo ) 
				{ 
					Z_scripterrlog("Attempted to write an 'item' to an infoshop, using shop ID: %d\n", ri->shopsref); 
					break;
				} 
				else 
				{ 
					QMisc.shop[ref].item[indx] = (byte)(vbound((value/10000), 0, 255)); 
					break;
				} 
			} 
		} 
		break;
		//SET_SHOPDATA_VAR_INDEX(item, "Item", 2); break;
		case SHOPDATAHASITEM: 
		{ 
			
			int ref = ri->shopsref; 
			bool isInfo = ( ref > NUMSHOPS && ref < LONG_MAX ); 
			int indx = ri->d[0] / 10000; 
			if ( indx < 0 || indx > 2 ) 
			{ 
				Z_scripterrlog("Invalid Array Index passed to shopdata->%s: %d\n", indx, "HasItem"); 
				break;
			} 
			else 
			{ 
				if ( isInfo ) 
				{ 
					Z_scripterrlog("Attempted to write 'hasitem' to an infoshop, using shop ID: %d\n", ri->shopsref); 
					break;
				} 
				else 
				{ 
					QMisc.shop[ref].hasitem[indx] = (byte)(vbound((value/10000), 0, 255)); break;
				} 
			} 
		} 
		break;
		//SET_SHOPDATA_VAR_INDEX(hasitem, "HasItem", 2); break;
		case SHOPDATAPRICE: 
		{ 
			
			int ref = ri->shopsref; 
			bool isInfo = ( ref > NUMSHOPS && ref < LONG_MAX ); 
			int indx = ri->d[0] / 10000; 
			if ( indx < 0 || indx > 2 ) 
			{ 
				Z_scripterrlog("Invalid Array Index passed to shopdata->%s: %d\n", indx, "Price"); 
				break;
			} 
			else 
			{ 
				if ( isInfo ) 
				{ 
					QMisc.shop[ref].price[indx] = (byte)(vbound((value/10000), 0, 214747));
					break;
				} 
				else 
				{ 
					QMisc.shop[ref].price[indx] = (byte)(vbound((value/10000), 0, 214747));
					break;
				} 
			} 
		} 
		//SET_SHOPDATA_VAR_INDEX(price, "Price", 2); break;
		//Pay for info
		case SHOPDATASTRING:
		{
			{
				if ( ri->shopsref < NUMSHOPS || ri->shopsref > NUMINFOSHOPS )
				{
					Z_scripterrlog("Invalid Info Shop ID passed to shopdata->String[]: %d\n", ri->shopsref); 
					break;
				}
				else 
				{
					int ref = ri->shopsref; 
					bool isInfo = ( ref > NUMSHOPS && ref < LONG_MAX ); 
					int indx = ri->d[0] / 10000; 
					if ( indx < 0 || indx > 2 ) 
					{ 
						Z_scripterrlog("Invalid Array Index passed to shopdata->%s: %d\n", indx, "HasItem"); 
						break;
					} 
					else 
					{ 
						if ( isInfo ) 
						{ 
							QMisc.info[ref].str[indx] = (word)(vbound((value/10000), 0, 32767));
							break;
						} 
						else 
						{ 
							QMisc.shop[ref].str[indx] = (word)(vbound((value/10000), 0, 32767));
							break;
						} 
					} 
			
			
				}
					
				//GET_SHOPDATA_VAR_INDEX(str, String, 2); break;
			} break;
		}

		///----------------------------------------------------------------------------------------------------//
		//dmapdata dmd-> Variables
		case DMAPDATAMAP: 	//byte
		{
			DMaps[ri->dmapsref].map = ((byte)(value / 10000)) - 1; break;
		}
		case DMAPDATALEVEL:	//word
		{
			DMaps[ri->dmapsref].level = ((word)(value / 10000)); break;
		}
		case DMAPDATAOFFSET:	//char
		{
			DMaps[ri->dmapsref].xoff = ((char)(value / 10000)); break;
		}
		case DMAPDATACOMPASS:	//byte
		{
			DMaps[ri->dmapsref].compass = ((byte)(value / 10000)); break;
		}
		case DMAPDATAPALETTE:	//word
		{
			DMaps[ri->dmapsref].color= ((word)(value / 10000)); break;
		}
		case DMAPDATAMIDI:	//byte
		{
			DMaps[ri->dmapsref].midi = ((byte)((value / 10000)+MIDIOFFSET_DMAP)); break;
		}
		case DMAPDATACONTINUE:	//byte
		{
			DMaps[ri->dmapsref].cont = ((byte)(value / 10000)); break;
		}
		case DMAPDATATYPE:	//byte
		{
			DMaps[ri->dmapsref].type = ((byte)(value / 10000)); break;
		}
		case DMAPSCRIPT:	//byte
		{
			FFScript::deallocateAllArrays(SCRIPT_DMAP, ri->dmapsref);
			DMaps[ri->dmapsref].script = vbound((value / 10000),0,NUMSCRIPTSDMAP-1); break;
		}
		case DMAPDATASIDEVIEW:	//byte, treat as bool
		{
			DMaps[ri->dmapsref].sideview = ((value) ? 1 : 0); break;
		}
		case DMAPDATAGRID:	//byte[8] --array
		{
			int indx = ri->d[0] / 10000;
			if ( indx < 0 || indx > 7 ) 
			{
				Z_scripterrlog("Invalid index supplied to dmapdata->Grid[]: %d\n", indx); break;
			}
			else
			{
				DMaps[ri->dmapsref].grid[indx] = ((byte)(value / 10000)); break;
			}
		}
		case DMAPINITD:
		{
			int indx = ri->d[0] / 10000;
			if ( indx < 0 || indx > 7 ) 
			{
				Z_scripterrlog("Invalid index supplied to dmapdata->InitD[]: %d\n", indx); break;
			}
			else
			{
				DMaps[ri->dmapsref].initD[indx] = value; break;
			}
		}
		case DMAPDATAMINIMAPTILE:	//word - two of these, so let's do MinimapTile[2]
		{
			int indx = ri->d[0] / 10000;
			switch(indx)
			{
				case 0: { DMaps[ri->dmapsref].minimap_1_tile = ((word)(value / 10000)); break; }
				case 1: { DMaps[ri->dmapsref].minimap_2_tile = ((word)(value / 10000)); break; }
				default: 
				{
					Z_scripterrlog("Invalid index supplied to dmapdata->MiniMapTile[]: %d\n", indx);
					break;
				}
			}
			break;
		}
		case DMAPDATAMINIMAPCSET:	//byte - two of these, so let's do MinimapCSet[2]
		{
			int indx = ri->d[0] / 10000;
			switch(indx)
			{
				case 0: { DMaps[ri->dmapsref].minimap_1_cset= ((byte)(value / 10000)); break; }
				case 1: { DMaps[ri->dmapsref].minimap_2_cset= ((byte)(value / 10000)); break; }
				default: 
				{
					Z_scripterrlog("Invalid index supplied to dmapdata->MiniMapCSet[]: %d\n", indx);
					break;
				}
			}
			break;
		}
		case DMAPDATALARGEMAPTILE:	//word -- two of these, so let's to LargemapTile[2]
		{
			int indx = ri->d[0] / 10000;
			switch(indx)
			{
				case 0: { DMaps[ri->dmapsref].largemap_1_tile = ((word)(value / 10000)); break; }
				case 1: { DMaps[ri->dmapsref].largemap_2_tile = ((word)(value / 10000)); break; }
				default: 
				{
					Z_scripterrlog("Invalid index supplied to dmapdata->LargeMapTile[]: %d\n", indx);
					break;
				}
			}
			break;
		}
		case DMAPDATALARGEMAPCSET:	//word -- two of these, so let's to LargemaCSet[2]
		{
			int indx = ri->d[0] / 10000;
			switch(indx)
			{
				case 0: { DMaps[ri->dmapsref].largemap_1_cset= ((byte)(value / 10000)); break; }
				case 1: { DMaps[ri->dmapsref].largemap_2_cset= ((byte)(value / 10000)); break; }
				default: 
				{
					Z_scripterrlog("Invalid index supplied to dmapdata->LargeMapCSet[]: %d\n", indx);
					break;
				}
			}
			break;
		}
		case DMAPDATAMUISCTRACK:	//byte
		{
			DMaps[ri->dmapsref].tmusictrack= ((byte)(value / 10000)); break;
		}
		case DMAPDATASUBSCRA:	 //byte, active subscreen
		{
			DMaps[ri->dmapsref].active_subscreen= ((byte)(value / 10000)); break;
		}
		case DMAPDATASUBSCRP:	 //byte, passive subscreen
		{
			DMaps[ri->dmapsref].passive_subscreen= ((byte)(value / 10000)); break;
		}
		case DMAPDATADISABLEDITEMS:	 //byte[iMax]
		{
			int indx = ri->d[0] / 10000;
			if ( indx < 0 || indx > (iMax-1) ) 
			{
				Z_scripterrlog("Invalid index supplied to dmapdata->Grid[]: %d\n", indx); break;
			}
			else
			{
				DMaps[ri->dmapsref].disableditems[indx] = ((byte)(value / 10000)); break;
			}
		}
		case DMAPDATAFLAGS:	 //long
		{
			DMaps[ri->dmapsref].flags= ((byte)(value / 10000)); break;
		}
		case DMAPDATAASUBSCRIPT:	//byte
		{
			FFScript::deallocateAllArrays(SCRIPT_ACTIVESUBSCREEN, ri->dmapsref);
			DMaps[ri->dmapsref].active_sub_script = vbound((value / 10000),0,NUMSCRIPTSDMAP-1); break;
		}
		case DMAPDATAPSUBSCRIPT:	//byte
		{
			FFScript::deallocateAllArrays(SCRIPT_PASSIVESUBSCREEN, ri->dmapsref);
			word val = vbound((value / 10000),0,NUMSCRIPTSDMAP-1);
			if(passive_subscreen_doscript && ri->dmapsref == currdmap && val == DMaps[ri->dmapsref].passive_sub_script)
				break;
			DMaps[ri->dmapsref].passive_sub_script = val;
			if(ri->dmapsref == currdmap)
			{
				passive_subscreen_doscript = (val != 0) ? 1 : 0;
			};
			break;
		}
		case DMAPDATASUBINITD:
		{
			int indx = ri->d[0] / 10000;
			if ( indx < 0 || indx > 7 ) 
			{
				Z_scripterrlog("Invalid index supplied to dmapdata->SubInitD[]: %d\n", indx); break;
			}
			else
			{
				DMaps[ri->dmapsref].sub_initD[indx] = value; break;
			}
		}
		//case DMAPDATAGRAVITY:	 //unimplemented
		//case DMAPDATAJUMPLAYER:	 //unimplemented

		///----------------------------------------------------------------------------------------------------//
		//messagedata msgd-> Variables
		 

		case MESSAGEDATANEXT: //W
		{
			long ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Next") != SH::_NoError)
				break;
			else 
				MsgStrings[ID].nextstring = vbound((value/10000), 0, (msg_count-1));
			break;
		}	

		case MESSAGEDATATILE: //W
		{
			long ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Tile") != SH::_NoError)
				break;
			else 
				MsgStrings[ID].tile = vbound((value/10000), 0, (NEWMAXTILES));
			break;
		}	

		case MESSAGEDATACSET: //b
		{
			long ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->CSet") != SH::_NoError)
				break;
			else 
				MsgStrings[ID].cset = ((byte)vbound((value/10000), 0, 15));
			break;
		}	
		case MESSAGEDATATRANS: //BOOL
		{
			long ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Transparent") != SH::_NoError)
				break;
			else 
				(MsgStrings[ID].trans) = ((value)?true:false);
			break;
		}	
		case MESSAGEDATAFONT: //B
		{
			long ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Font") != SH::_NoError)
				break;
			else 
				MsgStrings[ID].font = ((byte)vbound((value/10000), 0, 255));
			break;
		}	
		case MESSAGEDATAX: //SHORT
		{
			long ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->X") != SH::_NoError)
				break;
			else 
				MsgStrings[ID].x = ((short)vbound((value/10000), SHRT_MIN, SHRT_MAX));
			break;
		}	
		case MESSAGEDATAY: //SHORT
		{
			long ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Y") != SH::_NoError)
				break;
			else 
				MsgStrings[ID].y = ((short)vbound((value/10000), SHRT_MIN, SHRT_MAX));
			break;
		}	
		case MESSAGEDATAW: //UNSIGNED SHORT
		{
			long ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Width") != SH::_NoError)
				break;
			else 
				MsgStrings[ID].w = ((unsigned short)vbound((value/10000), 0, USHRT_MAX));
			break;
		}	
		case MESSAGEDATAH: //UNSIGNED SHORT
		{
			long ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Height") != SH::_NoError)
				break;
			else 
				MsgStrings[ID].h = ((unsigned short)vbound((value/10000), 0, USHRT_MAX));
			break;
		}	
		case MESSAGEDATASFX: //BYTE
		{
			long ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Sound") != SH::_NoError)
				break;
			else 
				MsgStrings[ID].sfx = ((byte)vbound((value/10000), 0, 255));
			break;
		}	
		case MESSAGEDATALISTPOS: //WORD
		{
			long ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->ListPosition") != SH::_NoError)
				break;
			else 
				MsgStrings[ID].listpos = vbound((value/10000), 1, (msg_count-1));
			break;
		}	
		case MESSAGEDATAVSPACE: //BYTE
		{
			long ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->VSpace") != SH::_NoError)
				break;
			else 
				MsgStrings[ID].vspace = ((byte)vbound((value/10000), 0, 255));
			break;
		}	
		case MESSAGEDATAHSPACE: //BYTE
		{
			long ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->HSpace") != SH::_NoError)
				break;
			else 
				MsgStrings[ID].hspace = ((byte)vbound((value/10000), 0, 255));
			break;
		}	
		case MESSAGEDATAFLAGS: //BYTE
		{
			long ID = ri->zmsgref;	

			if(BC::checkMessage(ID, "messagedata->Flags") != SH::_NoError)
				break;
			else 
				MsgStrings[ID].stringflags = ((byte)vbound((value/10000), 0, 255));
			break;
		}
		case MESSAGEDATAMARGINS: //BYTE, 4
		{
			int indx = ri->d[0] / 10000;
			if ( indx < 0 || indx > 3 ) 
			{
				Z_scripterrlog("Invalid index supplied to messagedata->Margins[]: %d\n", indx);
				break;
			}
			long ID = ri->zmsgref;
			
			if(BC::checkMessage(ID, "messagedata->Margins[]") != SH::_NoError)
				break;
			else
				MsgStrings[ID].margins[indx] = ((byte)vbound((value/10000), 0, 255));
			break;
		}
		case MESSAGEDATAPORTTILE: //INT
		{
			long ID = ri->zmsgref;
			
			if(BC::checkMessage(ID, "messagedata->PortraitTile") != SH::_NoError)
				break;
			else
				MsgStrings[ID].portrait_tile = vbound((value/10000), 0, (NEWMAXTILES));
			break;
		}
		case MESSAGEDATAPORTCSET: //BYTE
		{
			long ID = ri->zmsgref;
			
			if(BC::checkMessage(ID, "messagedata->PortraitCSet") != SH::_NoError)
				break;
			else
				MsgStrings[ID].portrait_cset = ((byte)vbound((value/10000), 0, 15));
			break;
		}
		case MESSAGEDATAPORTX: //BYTE
		{
			long ID = ri->zmsgref;
			
			if(BC::checkMessage(ID, "messagedata->PortraitX") != SH::_NoError)
				break;
			else
				MsgStrings[ID].portrait_x = ((byte)vbound((value/10000), 0, 255));
			break;
		}
		case MESSAGEDATAPORTY: //BYTE
		{
			long ID = ri->zmsgref;
			
			if(BC::checkMessage(ID, "messagedata->PortraitY") != SH::_NoError)
				break;
			else
				MsgStrings[ID].portrait_y = ((byte)vbound((value/10000), 0, 255));
			break;
		}
		case MESSAGEDATAPORTWID: //BYTE
		{
			long ID = ri->zmsgref;
			
			if(BC::checkMessage(ID, "messagedata->PortraitTileWidth") != SH::_NoError)
				break;
			else
				MsgStrings[ID].portrait_tw = ((byte)vbound((value/10000), 0, 16));
			break;
		}
		case MESSAGEDATAPORTHEI: //BYTE
		{
			long ID = ri->zmsgref;
			
			if(BC::checkMessage(ID, "messagedata->PortraitTileHeight") != SH::_NoError)
				break;
			else
				MsgStrings[ID].portrait_th = ((byte)vbound((value/10000), 0, 14));
			break;
		}
		case MESSAGEDATAFLAGSARR: //BOOL, 7
		{
			int indx = ri->d[0] / 10000;
			long ID = ri->zmsgref;
			
			if(BC::checkMessage(ID, "messagedata->Flags[]") != SH::_NoError)
				break;
			else
			{
				switch(indx)
				{
					case 0:
						(value) ? (MsgStrings[ID].stringflags)|=STRINGFLAG_WRAP : (MsgStrings[ID].stringflags)&= ~STRINGFLAG_WRAP;
						break;
					case 1:
						(value) ? (MsgStrings[ID].stringflags)|=STRINGFLAG_CONT : (MsgStrings[ID].stringflags)&= ~STRINGFLAG_CONT;
						break;
					case 2: //Not implemented
						//(value) ? (MsgStrings[ID].stringflags)|=STRINGFLAG_CENTER : (MsgStrings[ID].stringflags)&= ~STRINGFLAG_CENTER;
						break;
					case 3: //Not implemented
						//(value) ? (MsgStrings[ID].stringflags)|=STRINGFLAG_RIGHT : (MsgStrings[ID].stringflags)&= ~STRINGFLAG_RIGHT;
						break;
					case 4:
						(value) ? (MsgStrings[ID].stringflags)|=STRINGFLAG_FULLTILE : (MsgStrings[ID].stringflags)&= ~STRINGFLAG_FULLTILE;
						break;
					case 5:
						(value) ? (MsgStrings[ID].stringflags)|=STRINGFLAG_TRANS_BG : (MsgStrings[ID].stringflags)&= ~STRINGFLAG_TRANS_BG;
						break;
					case 6:
						(value) ? (MsgStrings[ID].stringflags)|=STRINGFLAG_TRANS_FG : (MsgStrings[ID].stringflags)&= ~STRINGFLAG_TRANS_FG;
						break;
					default:
						Z_scripterrlog("Invalid index supplied to messagedata->Flags[]: %d\n", indx);
						break;
				}
			}
			break;
		}




	///----------------------------------------------------------------------------------------------------//
	//combodata cd-> Setter Variables
	//newcombo	
		#define	SET_COMBO_VAR_INT(member, str) \
		{ \
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
			{ \
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
			} \
			else \
			{ \
				combobuf[ri->combosref].member = vbound((value / 10000),0,214747); \
			} \
		} \
		
		#define	SET_COMBO_VAR_DWORD(member, str) \
		{ \
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
			{ \
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
			} \
			else \
			{ \
				combobuf[ri->combosref].member = vbound((value / 10000),0,32767); \
			} \
		} \

		#define	SET_COMBO_VAR_BYTE(member, str) \
		{ \
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
			{ \
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
			} \
			else \
			{ \
				combobuf[ri->combosref].member = vbound((value / 10000),0,255); \
			} \
		} \
		
		#define SET_COMBO_VAR_INDEX(member, str, indexbound) \
		{ \
				int indx = ri->d[0] / 10000; \
				if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
				{ \
					Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
				} \
				else if ( indx < 0 || indx > indexbound ) \
				{ \
					Z_scripterrlog("Invalid Array Index passed to combodata->%s: %d\n", indx, str); \
				} \
				else \
				{ \
					combobuf[ri->combosref].member[indx] = vbound((value / 10000),0,214747); \
				} \
		}

		#define SET_COMBO_BYTE_INDEX(member, str, indexbound) \
		{ \
				int indx = ri->d[0] / 10000; \
				if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
				{ \
					Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
				} \
				else if ( indx < 0 || indx > indexbound ) \
				{ \
					Z_scripterrlog("Invalid Array Index passed to combodata->%s: %d\n", indx, str); \
				} \
				else \
				{ \
					combobuf[ri->combosref].member[indx] = vbound((value / 10000),0,255); \
				} \
		}
		
		#define SET_COMBO_FLAG(member, str) \
		{ \
			long flag =  (value/10000);  \
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
			{ \
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
			} \
			else \
			{ \
				if ( flag != 0 ) \
				{ \
					combobuf[ri->combosref].member|=flag; \
				} \
				else combobuf[ri->combosref].member|= ~flag; \
			} \
		} \
		
		//comboclass
		#define	SET_COMBOCLASS_VAR_INT(member, str) \
		{ \
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
			{ \
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
			} \
			else \
			{ \
				combo_class_buf[combobuf[ri->combosref].type].member = vbound((value / 10000),0,214747); \
			} \
		} \
		
		#define	SET_COMBOCLASS_VAR_DWORD(member, str) \
		{ \
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
			{ \
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
			} \
			else \
			{ \
				combo_class_buf[combobuf[ri->combosref].type].member = vbound((value / 10000),0,32767); \
			} \
		} \

		#define	SET_COMBOCLASS_VAR_BYTE(member, str) \
		{ \
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
			{ \
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
			} \
			else \
			{ \
				combo_class_buf[combobuf[ri->combosref].type].member = vbound((value / 10000),0,255); \
			} \
		} \
		
		#define SET_COMBOCLASS_VAR_INDEX(member, str, indexbound) \
		{ \
				int indx = ri->d[0] / 10000; \
				if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
				{ \
					Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
				} \
				else if ( indx < 0 || indx > indexbound ) \
				{ \
					Z_scripterrlog("Invalid Array Index passed to combodata->%s: %d\n", indx, str); \
				} \
				else \
				{ \
					combo_class_buf[combobuf[ri->combosref].type].member[indx] = vbound((value / 10000),0,214747); \
				} \
		}

		#define SET_COMBOCLASS_BYTE_INDEX(member, str, indexbound) \
		{ \
				int indx = ri->d[0] / 10000; \
				if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
				{ \
					Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
				} \
				else if ( indx < 0 || indx > indexbound ) \
				{ \
					Z_scripterrlog("Invalid Array Index passed to combodata->%s: %d\n", indx, str); \
				} \
				else \
				{ \
					combo_class_buf[combobuf[ri->combosref].type].member[indx] = vbound((value / 10000),0,255); \
				} \
		}
		
		#define SET_COMBOCLASS_FLAG(member, str) \
		{ \
			long flag =  (value/10000);  \
			if(ri->combosref < 0 || ri->combosref > (MAXCOMBOS-1) ) \
			{ \
				Z_scripterrlog("Invalid Combo ID passed to combodata->%s: %d\n", (ri->combosref*10000), str); \
			} \
			else \
			{ \
				if ( flag != 0 ) \
				{ \
					combo_class_buf[combobuf[ri->combosref].type].member|=flag; \
				} \
				else combo_class_buf[combobuf[ri->combosref].type].member|= ~flag; \
			} \
		} \
		
		//NEWCOMBO STRUCT
		case COMBODTILE:	SET_COMBO_VAR_DWORD(tile, "Tile"); break;						//word
		case COMBODOTILE:		SET_COMBO_VAR_DWORD(o_tile, "OriginalTile"); break;			//word
		case COMBODFRAME:		SET_COMBO_VAR_BYTE(cur_frame, "Frame"); break;				//char
		case COMBODACLK:		SET_COMBO_VAR_BYTE(aclk, "AClk"); break;				//char
		case COMBODATASCRIPT:	SET_COMBO_VAR_DWORD(script, "Script"); break;						//word
		case COMBODASPEED:	SET_COMBO_VAR_BYTE(speed, "ASpeed"); break;						//char
		case COMBODFLIP:	SET_COMBO_VAR_BYTE(flip, "Flip"); break;						//char
		case COMBODWALK:	SET_COMBO_VAR_BYTE(walk, "Walk"); break;						//char
		case COMBODTYPE:	SET_COMBO_VAR_BYTE(type, "Type"); break;						//char
		case COMBODCSET:	SET_COMBO_VAR_BYTE(csets, "CSet"); break;						//C
		case COMBODFOO:		SET_COMBO_VAR_DWORD(foo, "Foo"); break;							//W
		case COMBODFRAMES:	SET_COMBO_VAR_BYTE(frames, "Frames"); break;						//C
		case COMBODNEXTD:	SET_COMBO_VAR_DWORD(speed, "NextData"); break;						//W
		case COMBODNEXTC:	SET_COMBO_VAR_BYTE(nextcombo, "NextCSet"); break;					//C
		case COMBODFLAG:	SET_COMBO_VAR_BYTE(nextcset, "Flag"); break;						//C
		case COMBODSKIPANIM:	SET_COMBO_VAR_BYTE(skipanim, "SkipAnim"); break;					//C
		case COMBODNEXTTIMER:	SET_COMBO_VAR_DWORD(nexttimer, "NextTimer"); break;					//W
		case COMBODAKIMANIMY:	SET_COMBO_VAR_BYTE(skipanimy, "SkipAnimY"); break;					//C
		case COMBODANIMFLAGS:	SET_COMBO_VAR_BYTE(animflags, "AnimFlags"); break;					//C
		case COMBODEXPANSION:	SET_COMBO_BYTE_INDEX(expansion, "Expansion[]", 6); break;					//C , 6 INDICES
		case COMBODATTRIBUTES: 	SET_COMBO_VAR_INDEX(attributes,	"Attributes[]", 4); break;				//LONG, 4 INDICES, INDIVIDUAL VALUES
		case COMBODATAINITD: 	SET_COMBO_VAR_INDEX(initd,	"InitD[]", 2); break;				//LONG, 4 INDICES, INDIVIDUAL VALUES
		case COMBODATTRIBYTES: 	SET_COMBO_VAR_INDEX(attribytes,	"Attribytes[]", 4); break;				//LONG, 4 INDICES, INDIVIDUAL VALUES
		case COMBODUSRFLAGS:	SET_COMBO_VAR_INT(usrflags, "UserFlags"); break;					//LONG
		case COMBODTRIGGERFLAGS:	SET_COMBO_VAR_INDEX(triggerflags, "TriggerFlags[]", 3);	break;			//LONG 3 INDICES AS FLAGSETS
		case COMBODTRIGGERLEVEL:	SET_COMBO_VAR_INT(triggerlevel, "TriggerLevel"); break;				//LONG



		//COMBOCLASS STRUCT
		//case COMBODNAME:		//CHAR[64], STRING
		case COMBODBLOCKNPC:		SET_COMBOCLASS_VAR_BYTE(block_enemies, "BlockNPC"); break;			//C
		case COMBODBLOCKHOLE:		SET_COMBOCLASS_VAR_BYTE(block_hole, "BlockHole"); break;			//C
		case COMBODBLOCKTRIG:		SET_COMBOCLASS_VAR_BYTE(block_trigger,	"BlockTrigger"); break; 		//C
		case COMBODBLOCKWEAPON:		SET_COMBOCLASS_BYTE_INDEX(block_weapon,	"BlockWeapon[]", 32); 			//C, 32 INDICES
		case COMBODCONVXSPEED:		SET_COMBOCLASS_VAR_DWORD(conveyor_x_speed, "ConveyorSpeedX"); break;		//SHORT
		case COMBODCONVYSPEED:		SET_COMBOCLASS_VAR_DWORD(conveyor_y_speed, "ConveyorSpeedY"); break;		//SHORT
		case COMBODSPAWNNPC:		SET_COMBOCLASS_VAR_DWORD(create_enemy, "SpawnNPC"); break;			//W
		case COMBODSPAWNNPCWHEN:	SET_COMBOCLASS_VAR_BYTE(create_enemy_when, "SpawnNPCWhen"); break;		//C
		case COMBODSPAWNNPCCHANGE:	SET_COMBOCLASS_VAR_INT(create_enemy_change, "SpawnNPCChange"); break;		//LONG
		case COMBODDIRCHANGETYPE:	SET_COMBOCLASS_VAR_BYTE(directional_change_type, "DirChange"); break;		//C
		case COMBODDISTANCECHANGETILES:	SET_COMBOCLASS_VAR_INT(distance_change_tiles, "DistanceChangeTiles"); break; 	//LONG
		case COMBODDIVEITEM:		SET_COMBOCLASS_VAR_DWORD(dive_item, "DiveItem"); break;				//SHORT
		case COMBODDOCK:		SET_COMBOCLASS_VAR_BYTE(dock, "Dock"); break;					//C
		case COMBODFAIRY:		SET_COMBOCLASS_VAR_BYTE(fairy, "Fairy"); break;					//C
		case COMBODFFATTRCHANGE:	SET_COMBOCLASS_VAR_BYTE(ff_combo_attr_change, "FFCAttributeChange"); break;	//C
		case COMBODFOORDECOTILE:	SET_COMBOCLASS_VAR_INT(foot_decorations_tile, "DecorationTile"); break;		//LONG
		case COMBODFOORDECOTYPE:	SET_COMBOCLASS_VAR_BYTE(foot_decorations_type, "DecorationType"); break;	//C
		case COMBODHOOKSHOTPOINT:	SET_COMBOCLASS_VAR_BYTE(hookshot_grab_point, "Hookshot"); break;		//C
		case COMBODLADDERPASS:		SET_COMBOCLASS_VAR_BYTE(ladder_pass, "Ladder"); break;				//C
		case COMBODLOCKBLOCK:		SET_COMBOCLASS_VAR_BYTE(lock_block_type, "LockBlock"); break;			//C
		case COMBODLOCKBLOCKCHANGE:	SET_COMBOCLASS_VAR_INT(lock_block_change, "LockBlockChange"); break;		//LONG
		case COMBODMAGICMIRROR:		SET_COMBOCLASS_VAR_BYTE(magic_mirror_type, "Mirror"); break;			//C
		case COMBODMODHPAMOUNT:		SET_COMBOCLASS_VAR_DWORD(modify_hp_amount, "DamageAmount"); break;		//SHORT
		case COMBODMODHPDELAY:		SET_COMBOCLASS_VAR_BYTE(modify_hp_delay, "DamageDelay"); break;			//C
		case COMBODMODHPTYPE:		SET_COMBOCLASS_VAR_BYTE(modify_hp_type,	"DamageType"); break; 			//C
		case COMBODNMODMPAMOUNT:	SET_COMBOCLASS_VAR_DWORD(modify_mp_amount, "MagicAmount"); break;		//SHORT
		case COMBODMODMPDELAY:		SET_COMBOCLASS_VAR_BYTE(modify_mp_delay, "MagicDelay"); break;			//C
		case COMBODMODMPTYPE:		SET_COMBOCLASS_VAR_BYTE(modify_mp_type,	"MagicType"); break;				//C
		case COMBODNOPUSHBLOCK:		SET_COMBOCLASS_VAR_BYTE(no_push_blocks, "NoPushBlocks"); break;			//C
		case COMBODOVERHEAD:		SET_COMBOCLASS_VAR_BYTE(overhead, "Overhead"); break;				//C
		case COMBODPLACENPC:		SET_COMBOCLASS_VAR_BYTE(place_enemy, "PlaceNPC"); break;			//C
		case COMBODPUSHDIR:		SET_COMBOCLASS_VAR_BYTE(push_direction,	"PushDir"); break; 			//C
		case COMBODPUSHWAIT:		SET_COMBOCLASS_VAR_BYTE(push_wait, "PushDelay"); break;				//C
		case COMBODPUSHHEAVY:		SET_COMBOCLASS_VAR_BYTE(push_weight, "PushHeavy"); break;				//C
		case COMBODPUSHED:		SET_COMBOCLASS_VAR_BYTE(pushed, "Pushed"); break;				//C
		case COMBODRAFT:		SET_COMBOCLASS_VAR_BYTE(raft, "Raft"); break;					//C
		case COMBODRESETROOM:		SET_COMBOCLASS_VAR_BYTE(reset_room, "ResetRoom"); break;			//C
		case COMBODSAVEPOINTTYPE:	SET_COMBOCLASS_VAR_BYTE(save_point_type, "SavePoint"); break;			//C
		case COMBODSCREENFREEZETYPE:	SET_COMBOCLASS_VAR_BYTE(screen_freeze_type, "FreezeScreen"); break;		//C
		case COMBODSECRETCOMBO:		SET_COMBOCLASS_VAR_BYTE(secret_combo, "SecretCombo"); break;			//C
		case COMBODSINGULAR:		SET_COMBOCLASS_VAR_BYTE(singular, "Singular"); break;				//C
		case COMBODSLOWWALK:		SET_COMBOCLASS_VAR_BYTE(slow_movement, "SlowWalk"); break;			//C
		case COMBODSTATUETYPE:		SET_COMBOCLASS_VAR_BYTE(statue_type, "Statue"); break;				//C
		case COMBODSTEPTYPE:		SET_COMBOCLASS_VAR_BYTE(step_type, "Step"); break;				//C
		case COMBODSTEPCHANGEINTO:	SET_COMBOCLASS_VAR_INT(step_change_to, "StepChange"); break;			//LONG
		case COMBODSTRIKEWEAPONS:	SET_COMBOCLASS_BYTE_INDEX(strike_weapons, "Strike[]", 32); break;			//BYTE, 32 INDICES. 
		case COMBODSTRIKEREMNANTS:	SET_COMBOCLASS_VAR_INT(strike_remnants,	"StrikeRemnants"); break;		//LONG
		case COMBODSTRIKEREMNANTSTYPE:	SET_COMBOCLASS_VAR_BYTE(strike_remnants_type, "StrikeRemnantsType"); break;	//C
		case COMBODSTRIKECHANGE:	SET_COMBOCLASS_VAR_INT(strike_change, "StrikeChange"); break;			//LONG
		case COMBODSTRIKEITEM:		SET_COMBOCLASS_VAR_DWORD(strike_item, "StrikeItem"); break;			//SHORT
		case COMBODTOUCHITEM:		SET_COMBOCLASS_VAR_DWORD(touch_item, "TouchItem"); break;			//SHORT
		case COMBODTOUCHSTAIRS:		SET_COMBOCLASS_VAR_BYTE(touch_stairs, "TouchStairs"); break;			//C
		case COMBODTRIGGERTYPE:		SET_COMBOCLASS_VAR_BYTE(trigger_type, "TriggerType"); break;			//C
		case COMBODTRIGGERSENS:		SET_COMBOCLASS_VAR_BYTE(trigger_sensitive, "TriggerSensitivity"); break;	//C
		case COMBODWARPTYPE:		SET_COMBOCLASS_VAR_BYTE(warp_type, "Warp"); break;				//C
		case COMBODWARPSENS:		SET_COMBOCLASS_VAR_BYTE(warp_sensitive,	"WarpSensitivity"); break; 		//C
		case COMBODWARPDIRECT:		SET_COMBOCLASS_VAR_BYTE(warp_direct, "WarpDirect"); break;			//C
		case COMBODWARPLOCATION:	SET_COMBOCLASS_VAR_BYTE(warp_location, "WarpLocation"); break;			//C
		case COMBODWATER:		SET_COMBOCLASS_VAR_BYTE(water, "Water"); break;					//C
		case COMBODWHISTLE:		SET_COMBOCLASS_VAR_BYTE(whistle, "Whistle"); break;				//C
		case COMBODWINGAME:		SET_COMBOCLASS_VAR_BYTE(win_game, "WinGame"); break; 				//C
		case COMBODBLOCKWPNLEVEL:	SET_COMBOCLASS_VAR_BYTE(block_weapon_lvl, "BlockWeaponLevel"); break;		//C



	///----------------------------------------------------------------------------------------------------//
	//npcdata nd-> Variables
		
		#define	SET_NPCDATA_VAR_INT(member, str) \
		{ \
			if( (unsigned) ri->npcdataref > (MAXNPCS-1) ) \
			{ \
				Z_scripterrlog("Invalid NPC ID passed to npcdata->%s: %d\n", (ri->npcdataref*10000), str); \
			} \
			else \
			{ \
				guysbuf[ri->npcdataref].member = vbound((value / 10000),0,214747); \
			} \
		} \
		
		#define	SET_NPCDATA_VAR_DWORD(member, str) \
		{ \
			if( (unsigned) ri->npcdataref > (MAXNPCS-1) ) \
			{ \
				Z_scripterrlog("Invalid NPC ID passed to npcdata->%s: %d\n", (ri->npcdataref*10000), str); \
			} \
			else \
			{ \
				guysbuf[ri->npcdataref].member = vbound((value / 10000),0,32767); \
			} \
		} \

		#define	SET_NPCDATA_VAR_BYTE(member, str) \
		{ \
			if( (unsigned) ri->npcdataref > (MAXNPCS-1) ) \
			{ \
				Z_scripterrlog("Invalid NPC ID passed to npcdata->%s: %d\n", (ri->npcdataref*10000), str); \
			} \
			else \
			{ \
				guysbuf[ri->npcdataref].member = vbound((value / 10000),0,255); \
			} \
		} \
		
		#define SET_NPCDATA_VAR_INDEX(member, str, indexbound) \
		{ \
				int indx = ri->d[0] / 10000; \
				if( (unsigned) ri->npcdataref > (MAXNPCS-1) ) \
				{ \
					Z_scripterrlog("Invalid NPC ID passed to npcdata->%s: %d\n", (ri->npcdataref*10000), str); \
				} \
				else if ( (unsigned)indx > indexbound ) \
				{ \
					Z_scripterrlog("Invalid Array Index passed to npcdata->%s: %d\n", indx, str); \
				} \
				else \
				{ \
					guysbuf[ri->npcdataref].member[indx] = vbound((value / 10000),0,214747); \
				} \
		}

		#define SET_NPCDATA_BYTE_INDEX(member, str, indexbound) \
		{ \
				int indx = ri->d[0] / 10000; \
				if( (unsigned) ri->npcdataref > (MAXNPCS-1) ) \
				{ \
					Z_scripterrlog("Invalid NPC ID passed to npcdata->%s: %d\n", (ri->npcdataref*10000), str); \
				} \
				else if ( (unsigned)indx > indexbound ) \
				{ \
					Z_scripterrlog("Invalid Array Index passed to npcdata->%s: %d\n", indx, str); \
				} \
				else \
				{ \
					guysbuf[ri->npcdataref].member[indx] = vbound((value / 10000),0,255); \
				} \
		}
		
		#define SET_NPCDATA_FLAG(member, str) \
		{ \
			long flag =  (value/10000);  \
			if( (unsigned) ri->npcdataref > (MAXNPCS-1) ) \
			{ \
				Z_scripterrlog("Invalid NPC ID passed to npcdata->%s: %d\n", (ri->npcdataref*10000), str); \
			} \
			else \
			{ \
				if ( flag ) \
				{ \
					guysbuf[ri->npcdataref].member|=flag; \
				} \
				else guysbuf[ri->npcdataref].member|= ~flag; \
			} \
		} \
		
		case NPCDATATILE: SET_NPCDATA_VAR_BYTE(tile, "Tile"); break;
		case NPCDATAWIDTH: SET_NPCDATA_VAR_BYTE(width, "Width"); break;
		case NPCDATAHEIGHT: SET_NPCDATA_VAR_BYTE(height, "Height"); break;
		case NPCDATAFLAGS: SET_NPCDATA_VAR_DWORD(flags, "Flags"); break; //16 b its
		case NPCDATAFLAGS2: SET_NPCDATA_VAR_DWORD(flags2, "Flags2"); break; //16 bits
		case NPCDATASTILE: SET_NPCDATA_VAR_BYTE(s_tile, "STile"); break;
		case NPCDATASWIDTH: SET_NPCDATA_VAR_BYTE(s_width, "SWidth"); break;
		case NPCDATASHEIGHT: SET_NPCDATA_VAR_BYTE(s_height, "SHeight"); break;
		case NPCDATAETILE: SET_NPCDATA_VAR_INT(e_tile, "ExTile"); break;
		case NPCDATAEWIDTH: SET_NPCDATA_VAR_BYTE(e_width, "ExWidth"); break;
		case NPCDATASCRIPT: SET_NPCDATA_VAR_BYTE(script, "Script"); break;
		case NPCDATAEHEIGHT: SET_NPCDATA_VAR_BYTE(e_height, "ExHeight"); break;
		case NPCDATAHP: SET_NPCDATA_VAR_DWORD(hp, "HP"); break;
		case NPCDATAFAMILY: SET_NPCDATA_VAR_DWORD(family, "Family"); break;
		case NPCDATACSET: SET_NPCDATA_VAR_DWORD(cset, "CSet"); break;
		case NPCDATAANIM: SET_NPCDATA_VAR_DWORD(anim, "Anim"); break;
		case NPCDATAEANIM: SET_NPCDATA_VAR_DWORD(e_anim, "ExAnim"); break;
		case NPCDATAFRAMERATE: SET_NPCDATA_VAR_DWORD(frate, "Framerate"); break;
		case NPCDATAEFRAMERATE: SET_NPCDATA_VAR_DWORD(e_frate, "ExFramerate"); break;
		case NPCDATATOUCHDAMAGE: SET_NPCDATA_VAR_DWORD(dp, "TouchDamage"); break;
		case NPCDATAWEAPONDAMAGE: SET_NPCDATA_VAR_DWORD(wdp, "WeaponDamage"); break;
		case NPCDATAWEAPON: SET_NPCDATA_VAR_DWORD(weapon, "Weapon"); break;
		case NPCDATARANDOM: SET_NPCDATA_VAR_DWORD(rate, "Random"); break;
		case NPCDATAHALT: SET_NPCDATA_VAR_DWORD(hrate, "Haltrate"); break;
		case NPCDATASTEP: SET_NPCDATA_VAR_DWORD(step, "Step"); break;
		case NPCDATAHOMING: SET_NPCDATA_VAR_DWORD(homing, "Homing"); break;
		case NPCDATAHUNGER: SET_NPCDATA_VAR_DWORD(grumble, "Hunger"); break;
		case NPCDATADROPSET: SET_NPCDATA_VAR_DWORD(item_set, "Dropset"); break;
		case NPCDATABGSFX: SET_NPCDATA_VAR_DWORD(bgsfx, "BGSFX"); break;
		case NPCDATADEATHSFX: SET_NPCDATA_VAR_BYTE(deadsfx, "DeathSFX"); break;
		case NPCDATAHITSFX: SET_NPCDATA_VAR_BYTE(hitsfx, "HitSFX"); break;
		case NPCDATAXOFS: SET_NPCDATA_VAR_INT(xofs, "DrawXOffset"); break;
		case NPCDATAYOFS: SET_NPCDATA_VAR_INT(yofs, "DrawYOffset"); break;
		case NPCDATAZOFS: SET_NPCDATA_VAR_INT(zofs, "DrawZOffset"); break;
		case NPCDATAHXOFS: SET_NPCDATA_VAR_INT(hxofs, "HitXOffset"); break;
		case NPCDATAHYOFS: SET_NPCDATA_VAR_INT(hyofs, "HitYOffset"); break;
		case NPCDATAHITWIDTH: SET_NPCDATA_VAR_INT(hxsz, "HitWidth"); break;
		case NPCDATAHITHEIGHT: SET_NPCDATA_VAR_INT(hysz, "HitHeight"); break;
		case NPCDATAHITZ: SET_NPCDATA_VAR_INT(hzsz, "HitZHeight"); break;
		case NPCDATATILEWIDTH: SET_NPCDATA_VAR_INT(txsz, "TileWidth"); break;
		case NPCDATATILEHEIGHT: SET_NPCDATA_VAR_INT(tysz, "TileHeight"); break;
		case NPCDATAWPNSPRITE: SET_NPCDATA_VAR_INT(wpnsprite, "WeaponSprite"); break;
		case NPCDATAWEAPONSCRIPT: SET_NPCDATA_VAR_INT(weaponscript, "WeaponScript"); break;
		case NPCDATADEFENSE: SET_NPCDATA_VAR_INDEX(defense, "Defense", 42); break;
		case NPCDATAWEAPONINITD: SET_NPCDATA_VAR_INDEX(weap_initiald, "WeaponInitD", 8); break;
		case NPCDATAINITD: SET_NPCDATA_VAR_INDEX(initD, "InitD", 8); break;
		case NPCDATASIZEFLAG: SET_NPCDATA_VAR_INT(SIZEflags, "SizeFlags"); break;

		case NPCDATAFROZENTILE: SET_NPCDATA_VAR_INT(frozentile, "FrozenTile"); break;
		case NPCDATAFROZENCSET: SET_NPCDATA_VAR_INT(frozencset, "FrozenCSet"); break;

		case NPCDATAATTRIBUTE: 
		{
			int indx = ri->d[0] / 10000; 
			if(ri->npcdataref < 0 || ri->npcdataref > (MAXNPCS-1) ) 
			{
				Z_scripterrlog("Invalid Sprite ID passed to npcdata->Attributes[]: %d\n", (ri->npcdataref*10000)); 
			}
			else if ( indx < 0 || indx > MAX_NPC_ATRIBUTES )
			{ 
				Z_scripterrlog("Invalid Array Index passed to npcdata->Attributes[]: %d\n", (ri->npcdataref*10000)); 
			} 
			else 
			{ 
				switch(indx)
				{
					case 0: guysbuf[ri->npcdataref].misc1 = (value / 10000); break;
					case 1: guysbuf[ri->npcdataref].misc2 = (value / 10000); break;
					case 2: guysbuf[ri->npcdataref].misc3 = (value / 10000); break;
					case 3: guysbuf[ri->npcdataref].misc4 = (value / 10000); break;
					case 4: guysbuf[ri->npcdataref].misc5 = (value / 10000); break;
					case 5: guysbuf[ri->npcdataref].misc6 = (value / 10000); break;
					case 6: guysbuf[ri->npcdataref].misc7 = (value / 10000); break;
					case 7: guysbuf[ri->npcdataref].misc8 = (value / 10000); break;
					case 8: guysbuf[ri->npcdataref].misc9 = (value / 10000); break;
					case 9: guysbuf[ri->npcdataref].misc10 = (value / 10000); break;
					case 10: guysbuf[ri->npcdataref].misc11 = (value / 10000); break;
					case 11: guysbuf[ri->npcdataref].misc12 = (value / 10000); break;
					case 12: guysbuf[ri->npcdataref].misc13 = (value / 10000); break;
					case 13: guysbuf[ri->npcdataref].misc14 = (value / 10000); break;
					case 14: guysbuf[ri->npcdataref].misc15 = (value / 10000); break;
					
					case 15: guysbuf[ri->npcdataref].misc16 = value / 10000; break;
					case 16: guysbuf[ri->npcdataref].misc17 = value / 10000; break;
					case 17: guysbuf[ri->npcdataref].misc18 = value / 10000; break;
					case 18: guysbuf[ri->npcdataref].misc19 = value / 10000; break;
					case 19: guysbuf[ri->npcdataref].misc20 = value / 10000; break;
					case 20: guysbuf[ri->npcdataref].misc21 = value / 10000; break;
					case 21: guysbuf[ri->npcdataref].misc22 = value / 10000; break;
					case 22: guysbuf[ri->npcdataref].misc23 = value / 10000; break;
					case 23: guysbuf[ri->npcdataref].misc24 = value / 10000; break;
					case 24: guysbuf[ri->npcdataref].misc25 = value / 10000; break;
					case 25: guysbuf[ri->npcdataref].misc26 = value / 10000; break;
					case 26: guysbuf[ri->npcdataref].misc27 = value / 10000; break;
					case 27: guysbuf[ri->npcdataref].misc28 = value / 10000; break;
					case 28: guysbuf[ri->npcdataref].misc29 = value / 10000; break;
					case 29: guysbuf[ri->npcdataref].misc30 = value / 10000; break;
					case 30: guysbuf[ri->npcdataref].misc31 = value / 10000; break;
					case 31: guysbuf[ri->npcdataref].misc32 = value / 10000; break;
					
						default: 
					{
						Z_scripterrlog("Invalid Array Index passed to npcdata->Attributes[]: %d\n", (ri->npcdataref*10000)); 
						break;
					}
				}
					
			} 
			break;
		}

		case NPCDATABEHAVIOUR: 
		{
			if(ri->npcdataref < 0 || ri->npcdataref > (MAXNPCS-1) ) 
			{
				break;
			}
			
			
			int index = vbound(ri->d[0]/10000,0,4);
			switch(index){
				case 0:
				(value) ? guysbuf[ri->npcdataref].editorflags|=ENEMY_FLAG1 : guysbuf[ri->npcdataref].editorflags&= ~ENEMY_FLAG1;
				break;
				case 1:
				(value) ? guysbuf[ri->npcdataref].editorflags|=ENEMY_FLAG2 : guysbuf[ri->npcdataref].editorflags&= ~ENEMY_FLAG2;
				break;
				case 2:
				(value) ? guysbuf[ri->npcdataref].editorflags|=ENEMY_FLAG3 : guysbuf[ri->npcdataref].editorflags&= ~ENEMY_FLAG3;
				break;
				case 3:
				(value) ? guysbuf[ri->npcdataref].editorflags|=ENEMY_FLAG4 : guysbuf[ri->npcdataref].editorflags&= ~ENEMY_FLAG4; 
				break;
				case 4:
				(value) ? guysbuf[ri->npcdataref].editorflags|=ENEMY_FLAG5 : guysbuf[ri->npcdataref].editorflags&= ~ENEMY_FLAG5;
				break;
				case 5:
				(value) ? guysbuf[ri->npcdataref].editorflags|=ENEMY_FLAG6 : guysbuf[ri->npcdataref].editorflags&= ~ENEMY_FLAG6; 
				break;
				case 6:
				(value) ? guysbuf[ri->npcdataref].editorflags|=ENEMY_FLAG7 : guysbuf[ri->npcdataref].editorflags&= ~ENEMY_FLAG7;
				break;
				case 7:
				(value) ? guysbuf[ri->npcdataref].editorflags|=ENEMY_FLAG8 : guysbuf[ri->npcdataref].editorflags&= ~ENEMY_FLAG8;
				break;
				case 8:
				(value) ? guysbuf[ri->npcdataref].editorflags|=ENEMY_FLAG9 : guysbuf[ri->npcdataref].editorflags&= ~ENEMY_FLAG9;
				break;		    
				case 9:
				(value) ? guysbuf[ri->npcdataref].editorflags|=ENEMY_FLAG10 : guysbuf[ri->npcdataref].editorflags&= ~ENEMY_FLAG10;
				break;
				case 10:
				(value) ? guysbuf[ri->npcdataref].editorflags|=ENEMY_FLAG11 : guysbuf[ri->npcdataref].editorflags&= ~ENEMY_FLAG11; 
				break;
				case 11:
				(value) ? guysbuf[ri->npcdataref].editorflags|=ENEMY_FLAG12 : guysbuf[ri->npcdataref].editorflags&= ~ENEMY_FLAG12;
				break;
				case 12:
				(value) ? guysbuf[ri->npcdataref].editorflags|=ENEMY_FLAG13 : guysbuf[ri->npcdataref].editorflags&= ~ENEMY_FLAG13;
				break;
				case 13:
				(value) ? guysbuf[ri->npcdataref].editorflags|=ENEMY_FLAG14 : guysbuf[ri->npcdataref].editorflags&= ~ENEMY_FLAG14;
				break;
				case 14:
				(value) ? guysbuf[ri->npcdataref].editorflags|=ENEMY_FLAG15 : guysbuf[ri->npcdataref].editorflags&= ~ENEMY_FLAG15; 
				break;
				case 15:
				(value) ? guysbuf[ri->npcdataref].editorflags|=ENEMY_FLAG16 : guysbuf[ri->npcdataref].editorflags&= ~ENEMY_FLAG16; 
				break;
				
				
				default: 
					break;
			}
				
			break;
		}

		case NPCDATASHIELD:
		{
			int indx = ri->d[0] / 10000; 
			if(ri->npcdataref < 0 || ri->npcdataref > (MAXNPCS-1) ) 
			{ 
				Z_scripterrlog("Invalid NPC ID passed to npcdata->Shield[]: %d\n", (ri->npcdataref*10000));
				break;
			} 
			else 
			{ 
				switch(indx)
				{
					case 0:
					{
						(ri->d[1])? (guysbuf[ri->npcdataref].flags |= inv_front) : (guysbuf[ri->npcdataref].flags &= ~inv_front);
						break;
					}
					case 1:
					{
						(ri->d[1])? (guysbuf[ri->npcdataref].flags |= inv_left) : (guysbuf[ri->npcdataref].flags &= ~inv_left);
						break;
					}
					case 2:
					{
						(ri->d[1])? (guysbuf[ri->npcdataref].flags |= inv_right) : (guysbuf[ri->npcdataref].flags &= ~inv_right);
						break;
					}
					case 3:
					{
						(ri->d[1])? (guysbuf[ri->npcdataref].flags |= inv_back) : (guysbuf[ri->npcdataref].flags &= ~inv_back);
						break;
					}
					case 4:
					{
						(ri->d[1])? (guysbuf[ri->npcdataref].flags |= guy_bkshield) : (guysbuf[ri->npcdataref].flags &= ~guy_bkshield);
						break;
					}
					default:
					{
						Z_scripterrlog("Invalid Array Index passed to npcdata->Shield[]: %d\n", indx); 
						break;
					}
				}
				break;
			} 
		}


	///----------------------------------------------------------------------------------------------------//
	//Dropset Variables

		case DROPSETITEMS:
		{
			if(ri->dropsetref < 0 || ri->dropsetref > MAXITEMDROPSETS)
			{
				Z_scripterrlog("Invalid dropset pointer %d\n", ri->dropsetref);
				break;
			}
			int indx = ri->d[0]/10000;
			if(indx < 0 || indx > 9)
			{
				Z_scripterrlog("Invalid index passed to dropdata->Items[]: %d\n", indx);
			}
			else
			{
				item_drop_sets[ri->dropsetref].item[indx] = vbound(value / 10000, 0, MAXITEMS-1);
			}
			break;
		}
		case DROPSETCHANCES:
		{
			if(ri->dropsetref < 0 || ri->dropsetref > MAXITEMDROPSETS)
			{
				Z_scripterrlog("Invalid dropset pointer %d\n", ri->dropsetref);
				break;
			}
			int indx = ri->d[0]/10000;
			if(indx < 0 || indx > 9)
			{
				Z_scripterrlog("Invalid index passed to dropdata->Chances[]: %d\n", indx);
			}
			else
			{
				item_drop_sets[ri->dropsetref].chance[indx+1] = vbound((value / 10000),0,32767); //+1 is because '0' is 'nothing''s chance
			}
			break;
		}
		case DROPSETNULLCHANCE:
		{
			if(ri->dropsetref < 0 || ri->dropsetref > MAXITEMDROPSETS)
			{
				Z_scripterrlog("Invalid dropset pointer %d\n", ri->dropsetref);
				break;
			}
			item_drop_sets[ri->dropsetref].chance[0] = vbound((value / 10000),0,32767);
			break;
		}

	///----------------------------------------------------------------------------------------------------//
	//Audio Variables

		case AUDIOVOLUME:
		{
			int indx = ri->d[0] / 10000;
			//zprint("Volume[index] is: %d", indx);
			//int vol = value / 10000;
			//zprint("Attempted to change volume to: %d", vol);
			switch(indx)
			{
				
				case 0: //midi volume
				{
					if ( !(FFCore.coreflags&FFCORE_SCRIPTED_MIDI_VOLUME) ) 
					{
						FFCore.usr_midi_volume = FFScript::do_getMIDI_volume();
						FFCore.SetFFEngineFlag(FFCORE_SCRIPTED_MIDI_VOLUME,true);
					}
					FFScript::do_setMIDI_volume(value / 10000);
					break;
				}
				case 1: //digi volume
				{
					if ( !(FFCore.coreflags&FFCORE_SCRIPTED_DIGI_VOLUME) ) 
					{
						FFCore.usr_digi_volume = FFScript::do_getDIGI_volume();
						FFCore.SetFFEngineFlag(FFCORE_SCRIPTED_DIGI_VOLUME,true);
					}
					FFScript::do_setDIGI_volume(value / 10000);
					break;
				}
				case 2: //emh music volume
				{
					if ( !(FFCore.coreflags&FFCORE_SCRIPTED_MUSIC_VOLUME) ) 
					{
						FFCore.usr_music_volume = FFScript::do_getMusic_volume();
						FFCore.SetFFEngineFlag(FFCORE_SCRIPTED_MUSIC_VOLUME,true);
					}
					FFScript::do_setMusic_volume(value / 10000);
					break;
				}
				case 3: //sfx volume
				{
					if ( !(FFCore.coreflags&FFCORE_SCRIPTED_SFX_VOLUME) ) 
					{
						FFCore.usr_sfx_volume = FFScript::do_getSFX_volume();
						FFCore.SetFFEngineFlag(FFCORE_SCRIPTED_SFX_VOLUME,true);
					}
					FFScript::do_setSFX_volume(value / 10000);
					break;
				}
				default:
				{
					Z_scripterrlog("Attempted to access an invalid index of Audio->Volume[]", indx); 
					break;
				}
			}
			break;
		}

		case AUDIOPAN:
		{
			if ( !(FFCore.coreflags&FFCORE_SCRIPTED_PANSTYLE) ) 
			{
				FFCore.usr_panstyle = FFScript::do_getSFX_pan();
				FFCore.SetFFEngineFlag(FFCORE_SCRIPTED_PANSTYLE,true);
			}
			FFScript::do_setSFX_pan(value/10000);
			break;
		}

	///----------------------------------------------------------------------------------------------------//
	//Graphics->

		case NUMDRAWS:
			break;
		
		case MAXDRAWS: break;
	
	///----------------------------------------------------------------------------------------------------//
	//Module->
	case MODULEGETSTR:
	{
		int buf_pointer = ((ri->d[0])/10000);
		int section_pointer = ((ri->d[1])/10000);
		int element_pointer = (value/10000);
		
		string sectionid;
		string elementid;
		
		FFCore.getString(section_pointer, sectionid);
		FFCore.getString(element_pointer, elementid);
		
		char buffer[256] = {0};
		
		
		if(!fileexists((char*)moduledata.module_name))
		{
			Z_scripterrlog("I/O Error: No module definitions found when using Module->GetString()\n");
		}	
		else
		{
			///set config file
			set_config_file(moduledata.module_name);
			strcpy(buffer,get_config_string(sectionid.c_str(), elementid.c_str(), ""));
			buffer[255] = '\0';
			if(ArrayH::setArray(buf_pointer, buffer) == SH::_Overflow)
				Z_scripterrlog("Dest string supplied to 'Module->GetString()' is not large enough\n");
			//return config file to zc.cfg
			set_config_file("zc.cfg");
		}
	
		break;
	}

	///----------------------------------------------------------------------------------------------------//
	//Misc./Internal
		case SP:
			ri->sp = value / 10000;
			break;
			
		case PC:
			ri->pc = value;
			break;
			
		case SWITCHKEY:
			ri->switchkey = value;
			break;
			
		case SCRIPTRAM:
		case GLOBALRAM:
			ArrayH::setElement(ri->d[0] / 10000, ri->d[1] / 10000, value);
			break;
			
		case SCRIPTRAMD:
		case GLOBALRAMD:
			ArrayH::setElement(ri->d[0] / 10000, 0, value);
			break;
			
		case REFFFC:
			ri->ffcref = value / 10000;
			break;
			
		case REFITEM:
			ri->itemref = value;
			break;
			
		case REFITEMCLASS:
			ri->idata = value;
			break;
			
		case REFLWPN:
			ri->lwpn = value;
			break;
			
		case REFEWPN:
			ri->ewpn = value;
			break;
			
		case REFNPC:
			ri->guyref = value;
			break;
		
		case REFMAPDATA: ri->mapsref = value; break;
		case REFSCREENDATA: ri->screenref = value; break;
		case REFCOMBODATA: ri->combosref = value; break;
		case REFSPRITEDATA: ri->spritesref = value; break;
		case REFBITMAP: ri->bitmapref = value; break;
		case REFNPCCLASS: ri->npcdataref = value; break;
		
		case REFDMAPDATA: ri->dmapsref = value; break;
		case REFSHOPDATA: ri->shopsref = value; break;
		case REFMSGDATA: ri->zmsgref = value; break;
		case REFUNTYPED: ri->untypedref = value; break;
		
		
		case REFDROPS:  ri->dropsetref = value; break;
		case REFPONDS:  ri->pondref = value; break;
		case REFWARPRINGS:  ri->warpringref = value; break;
		case REFDOORS:  ri->doorsref = value; break;
		case REFUICOLOURS:  ri->zcoloursref = value; break;
		case REFRGB:  ri->rgbref = value; break;
		case REFPALETTE:  ri->paletteref = value; break;
		case REFTUNES:  ri->tunesref = value; break;
		case REFPALCYCLE:  ri->palcycleref = value; break;
		case REFGAMEDATA:  ri->gamedataref = value; break;
		case REFCHEATS:  ri->cheatsref = value; break;
			
		default:
		{
			if(arg >= D(0) && arg <= D(7))			ri->d[arg - D(0)] = value;
			else if(arg >= A(0) && arg <= A(1))		ri->a[arg - A(0)] = value;
			else if(arg >= GD(0) && arg <= GD(MAX_SCRIPT_REGISTERS))	game->global_d[arg-GD(0)] = value;
			
			break;
		}
	}
} //end set_register

///----------------------------------------------------------------------------------------------------//
//                                       ASM Functions                                                 //
///----------------------------------------------------------------------------------------------------//


///----------------------------------------------------------------------------------------------------//
//Internal (to ZScript)

void do_set(const bool v, const byte whichType, const long whichUID)
{
	bool allowed = true;
	switch(whichType) //Check for objects attempting to change own script
	{
		//case SCRIPT_GLOBAL:
		
		case SCRIPT_FFC:
			if(sarg1==FFSCRIPT && ri->ffcref==whichUID)
				allowed = false;
			break;
		
		case SCRIPT_SCREEN:
			if(sarg1==SCREENSCRIPT) //Only 1 screen script running at a time, no UID check needed
				allowed = false;
			break;
		
		//case SCRIPT_LINK:
		
		case SCRIPT_ITEM:
		{
			bool collect = ( ( whichUID < 1 ) || (whichUID == COLLECT_SCRIPT_ITEM_ZERO) );
			long new_UID = ( collect ) ? (( whichUID != COLLECT_SCRIPT_ITEM_ZERO ) ? (whichUID * -1) : 0) : whichUID;
			
			if(collect)
			{
				if(sarg1==IDATAPSCRIPT && ri->idata==new_UID)
					allowed = false;
			}
			else if(sarg1==IDATASCRIPT && ri->idata==new_UID)
				allowed = false;
			break;
		}
		
		case SCRIPT_LWPN:
			if(sarg1==LWPNSCRIPT && ri->lwpn==whichUID)
				allowed = false;
			break;
			
		case SCRIPT_NPC:
			if(sarg1==NPCSCRIPT && ri->guyref==whichUID)
				allowed = false;
			break;
		
		//case SCRIPT_SUBSCREEN:
		
		case SCRIPT_EWPN:
			if(sarg1==EWPNSCRIPT && ri->ewpn==whichUID)
				allowed = false;
			break;
		
		case SCRIPT_DMAP:
			if(sarg1==DMAPSCRIPT && ri->dmapsref==whichUID)
				allowed = false;
			break;
		
		case SCRIPT_ITEMSPRITE:
			if(sarg1==ITEMSPRITESCRIPT && ri->itemref==whichUID)
				allowed = false;
			break;
	}   
	if(!allowed)
	{
		Z_scripterrlog("Script attempted to change own object's script! This has been ignored.\n");
		return;
	}
	long temp = SH::get_arg(sarg2, v);
	set_register(sarg1, temp);
}

void do_push(const bool v)
{
	const long value = SH::get_arg(sarg1, v);
	--ri->sp;
	SH::write_stack(ri->sp, value);
}

void do_pop()
{
	const long value = SH::read_stack(ri->sp);
	++ri->sp;
	set_register(sarg1, value);
}

void do_pops() // Pop past a bunch of stuff at once. Useful for clearing the stack.
{
	long num = sarg2;
	ri->sp += num;
	long value = SH::read_stack(ri->sp-1);
	set_register(sarg1, value);
}

void do_loadi()
{
	const long stackoffset = get_register(sarg2) / 10000;
	const long value = SH::read_stack(stackoffset);
	set_register(sarg1, value);
}

void do_storei()
{
	const long stackoffset = get_register(sarg2) / 10000;
	const long value = get_register(sarg1);
	SH::write_stack(stackoffset, value);
}

void do_enqueue(const bool)
{
}
void do_dequeue(const bool)
{
}

void do_comp(const bool v)
{
	long temp = SH::get_arg(sarg2, v);
	long temp2 = get_register(sarg1);
	
	if(temp2 >= temp)   ri->scriptflag |= MOREFLAG;
	else                ri->scriptflag &= ~MOREFLAG;
	
	if(temp2 == temp)   ri->scriptflag |= TRUEFLAG;
	else                ri->scriptflag &= ~TRUEFLAG;
}

void do_internal_strcmp()
{
	long arrayptr_a = get_register(sarg1)/10000;
	long arrayptr_b = get_register(sarg2)/10000;
	string strA;
	string strB;
	FFCore.getString(arrayptr_a, strA);
	FFCore.getString(arrayptr_b, strB);
	int temp = strcmp(strA.c_str(), strB.c_str());
	
	if(temp >= 0)       ri->scriptflag |= MOREFLAG;
	else                ri->scriptflag &= ~MOREFLAG;
	
	if(temp == 0)       ri->scriptflag |= TRUEFLAG;
	else                ri->scriptflag &= ~TRUEFLAG;
}

void do_internal_stricmp()
{
	long arrayptr_a = get_register(sarg1)/10000;
	long arrayptr_b = get_register(sarg2)/10000;
	string strA;
	string strB;
	FFCore.getString(arrayptr_a, strA);
	FFCore.getString(arrayptr_b, strB);
	int temp = stricmp(strA.c_str(), strB.c_str());
	
	if(temp >= 0)       ri->scriptflag |= MOREFLAG;
	else                ri->scriptflag &= ~MOREFLAG;
	
	if(temp == 0)       ri->scriptflag |= TRUEFLAG;
	else                ri->scriptflag &= ~TRUEFLAG;
}

void do_allocatemem(const bool v, const bool local, const byte type, const unsigned long UID)
{
	const long size = SH::get_arg(sarg2, v) / 10000;
	dword ptrval;
	
	if(size <= 0)
	{
		Z_scripterrlog("Array initialized to invalid size of %d\n", size);
		set_register(sarg1, 0); //Pass back NULL
		return;
	}
	
	if(local)
	{
		//localRAM[0] is used as an invalid container, so 0 can be the NULL pointer in ZScript
		for(ptrval = 1; localRAM[ptrval].Size() != 0; ptrval++) ;
		
		if(ptrval >= NUM_ZSCRIPT_ARRAYS)
		{
			Z_scripterrlog("%d local arrays already in use, no more can be allocated\n", NUM_ZSCRIPT_ARRAYS-1);
			ptrval = 0;
		}
		else
		{
			ZScriptArray &a = localRAM[ptrval]; //marginally faster for large arrays if we use a reference
			
			a.Resize(size);
			
			for(dword j = 0; j < (dword)size; j++)
				a[j] = 0; //initialize array
				
			// Keep track of which object created the array so we know which to deallocate
			//Z_eventlog("Allocating array %d to script %s, %d\n", ptrval, script_types[type], UID);
			arrayOwner[ptrval].scriptType = type;
			arrayOwner[ptrval].ownerUID = UID;
		}
	}
	else
	{
		//Globals are only allocated here at first play, otherwise in init_game
		for(ptrval = 0; game->globalRAM[ptrval].Size() != 0; ptrval++) ;
		
		if(ptrval >= game->globalRAM.size())
		{
			al_trace("Invalid pointer value of %ld passed to global allocate\n", ptrval);
			//this shouldn't happen, unless people are putting ALLOCATEGMEM in their ZASM scripts where they shouldn't be
		}
		
		ZScriptArray &a = game->globalRAM[ptrval];
		
		a.Resize(size);
		
		for(dword j = 0; j < (dword)size; j++)
			a[j] = 0;
			
		ptrval += NUM_ZSCRIPT_ARRAYS; //so each pointer has a unique value
	}
	
	
	set_register(sarg1, ptrval * 10000);
	
	// If this happens once per frame, it can drown out every other message. -L
	/*Z_eventlog("Allocated %s array of size %d, pointer address %ld\n",
				local ? "local": "global", size, ptrval);*/
}

void do_deallocatemem()
{
	const long ptrval = get_register(sarg1) / 10000;
	
	FFScript::deallocateZScriptArray(ptrval);
}

void do_loada(const byte a)
{
	if(ri->a[a] == 0)
	{
		Z_eventlog("Global scripts currently have no A registers\n");
		return;
	}
	
	long ffcref = (ri->a[a] / 10000) - 1; //FFC 2
	
	if(BC::checkFFC(ffcref, "LOAD%i") != SH::_NoError)
		return;
		
	long reg = get_register(sarg2); //Register in FFC 2
	
	if(reg >= D(0) || reg <= D(7))
		set_register(sarg1, ffcScriptData[ffcref].d[reg - D(0)]); //get back the info into *sarg1
	else if(reg == A(0) || reg == A(1))
		set_register(sarg1, ffcScriptData[ffcref].a[reg - A(0)]);
	else if(reg == SP)
		set_register(sarg1, ffcScriptData[ffcref].sp * 10000);
		
	//Can get everything else using REFFFC
}

void do_seta(const byte a)
{
	if(ri->a[a] == 0)
	{
		Z_eventlog("Global scripts currently have no A registers\n");
		return;
	}
	
	long ffcref = (ri->a[a] / 10000) - 1; //FFC 2
	
	if(BC::checkFFC(ffcref, "SETA%i") != SH::_NoError)
		return;
		
	long reg = get_register(sarg2); //Register in FFC 2
	
	if(reg >= D(0) || reg <= D(7))
		ffcScriptData[ffcref].d[reg - D(0)] = get_register(sarg1); //Set it to *sarg1
	else if(reg == A(0) || reg == A(1))
		ffcScriptData[ffcref].a[reg - A(0)] = get_register(sarg1);
	else if(reg == SP)
		ffcScriptData[ffcref].sp = get_register(sarg1) / 10000;
}

///----------------------------------------------------------------------------------------------------//
//Mathematical

void do_add(const bool v)
{
	long temp = SH::get_arg(sarg2, v);
	long temp2 = get_register(sarg1);
	
	set_register(sarg1, temp2 + temp);
}

void do_sub(const bool v)
{
	long temp = SH::get_arg(sarg2, v);
	long temp2 = get_register(sarg1);
	
	set_register(sarg1, temp2 - temp);
}

void do_mult(const bool v)
{
	long long temp = SH::get_arg(sarg2, v);
	long temp2 = get_register(sarg1);
	
	set_register(sarg1, long((temp * temp2) / 10000));
}

void do_div(const bool v)
{
	long long temp = SH::get_arg(sarg2, v);
	long long temp2 = get_register(sarg1);
	
	if(temp == 0)
	{
		Z_scripterrlog("Script attempted to divide %ld by zero!\n", temp2);
		set_register(sarg1, long(sign(temp2) * LONG_MAX));
	}
	else
	{
		set_register(sarg1, long((temp2 * 10000) / temp));
	}
}

void do_mod(const bool v)
{
	long temp = SH::get_arg(sarg2, v);
	long temp2 = get_register(sarg1);
	
	if(temp == 0)
	{
		Z_scripterrlog("Script attempted to modulo %ld by zero!\n",temp2);
		temp = 1;
	}
	
	set_register(sarg1, temp2 % temp);
}

void do_trig(const bool v, const byte type)
{
	double rangle = (SH::get_arg(sarg2, v) / 10000.0) * PI / 180.0;
	
	switch(type)
	{
		case 0:
			set_register(sarg1, long(sin(rangle) * 10000.0));
			break;
			
		case 1:
			set_register(sarg1, long(cos(rangle) * 10000.0));
			break;
			
		case 2:
			set_register(sarg1, long(tan(rangle) * 10000.0));
			break;
	}
}

void do_asin(const bool v)
{
	double temp = double(SH::get_arg(sarg2, v)) / 10000.0;
	
	if(temp >= -1 && temp <= 1)
		set_register(sarg1, long(asin(temp) * 10000.0));
	else
	{
		Z_scripterrlog("Script attempted to pass %ld into ArcSin!\n",temp);
		set_register(sarg1, -10000);
	}
}

void do_acos(const bool v)
{
	double temp = double(SH::get_arg(sarg2, v)) / 10000.0;
	
	if(temp >= -1 && temp <= 1)
		set_register(sarg1, long(acos(temp) * 10000.0));
	else
	{
		Z_scripterrlog("Script attempted to pass %ld into ArcCos!\n",temp);
		set_register(sarg1, -10000);
	}
}

void do_arctan()
{
	double xpos = ri->d[0] / 10000.0;
	double ypos = ri->d[1] / 10000.0;
	
	set_register(sarg1, long(atan2(ypos, xpos) * 10000.0));
}

void do_abs(const bool v)
{
	long temp = SH::get_arg(sarg1, v);
	set_register(sarg1, abs(temp));
}

void do_log10(const bool v)
{
	double temp = double(SH::get_arg(sarg1, v)) / 10000.0;
	
	if(temp > 0)
		set_register(sarg1, long(log10(temp) * 10000.0));
	else if(temp == 0)
	{
		Z_eventlog("Script tried to calculate log of 0\n");
		set_register(sarg1, -LONG_MAX);
	}
	else
	{
		Z_eventlog("Script tried to calculate log of %f\n", temp / 10000.0);
		set_register(sarg1, 0);
	}
}

void do_naturallog(const bool v)
{
	double temp = double(SH::get_arg(sarg1, v)) / 10000.0;
	
	if(temp > 0)
		set_register(sarg1, long(log(temp) * 10000.0));
	else if(temp == 0)
	{
		Z_eventlog("Script tried to calculate ln of 0\n");
		set_register(sarg1, -LONG_MAX);
	}
	else
	{
		Z_eventlog("Script tried to calculate ln of %f\n", temp / 10000.0);
		set_register(sarg1, 0);
	}
}

void do_min(const bool v)
{
	long temp = SH::get_arg(sarg2, v);
	long temp2 = get_register(sarg1);
	set_register(sarg1, zc_min(temp2, temp));
}

void do_max(const bool v)
{
	long temp = SH::get_arg(sarg2, v);
	long temp2 = get_register(sarg1);
	
	set_register(sarg1, zc_max(temp2, temp));
}


void do_rnd(const bool v)
{
	long temp = SH::get_arg(sarg2, v) / 10000;

	if(temp > 0)
		set_register(sarg1, (rand() % temp) * 10000);
	else if(temp < 0)
		set_register(sarg1, (rand() % (-temp)) * -10000);
	else
		set_register(sarg1, 0); // Just return 0. (Do not log an error)
}

void do_srnd(const bool v)
{
	unsigned int seed = SH::get_arg(sarg1, v); //Do not `/10000`- allow the decimal portion to be used! -V
	srand(seed);
}

void do_srndrnd()
{
	//Randomize the seed to the current system time, + or - the product of 2 random numbers.
	int seed = time(0) + ((rand() * rand()) * ((rand() % 2) ? 1 : -1));
	seed = vbound(seed, -2147479999, 2147479999); //Don't allow it to be outside ZScript range, so it can be returned.
	set_register(sarg1, seed);
	srand(seed);
}

//Returns the system Real-Time-Clock value for a specific type. 
void FFScript::getRTC(const bool v)
{
	//long type = get_register(sarg1) / 10000;
	//zprint("FFCore.getRTC() type == %d\n",type);
	//int time = getTime(type);
	//zprint("FFCore.getRTC() time == %d\n",time);
	//zprint("FFCore.getRTC() time * 10000 == %d\n",time);
	//set_register(sarg1, getTime((byte)(SH::get_arg(sarg2, v) / 10000)) * 10000);
	set_register(sarg1, getTime((get_register(sarg1) / 10000)) * 10000);
}


void do_factorial(const bool v)
{
	long temp;
	
	if(v)
		return;  //must factorial a register, not a value (why is this exactly? ~Joe123)
	else
	{
		temp = get_register(sarg1) / 10000;
		
		if(temp < 2)
		{
			set_register(sarg1, temp >= 0 ? 10000 : 00000);
			return;
		}
	}
	
	long temp2 = 1;
	
	for(long temp3 = temp; temp > 1; temp--)
		temp2 *= temp3;
		
	set_register(sarg1, temp2 * 10000);
}

void do_power(const bool v)
{
	double temp = double(SH::get_arg(sarg2, v)) / 10000.0;
	double temp2 = double(get_register(sarg1)) / 10000.0;
	
	if(temp == 0 && temp2 == 0)
	{
		Z_scripterrlog("Script attempted to calculate 0 to the power 0!\n");
		set_register(sarg1, 1);
		return;
	}
	
	set_register(sarg1, long(pow(temp2, temp) * 10000.0));
}

//could use recursion or something to avoid truncation.
void do_ipower(const bool v)
{
	double sarg2val = double(SH::get_arg(sarg2, v));
	if ( sarg2val == 0 )
	{
		Z_scripterrlog("Division by 0 Err: InvPower() exponent divisor cannot be 0!!\n");
		set_register(sarg1, 1);
		return;
	}
	double temp = 10000.0 / sarg2val;
	double temp2 = double(get_register(sarg1)) / 10000.0;
	
	if(temp == 0 && temp2 == 0)
	{
		Z_scripterrlog("Script attempted to calculate 0 to the power 0!\n");
		set_register(sarg1, 1);
		return;
	}
	
	set_register(sarg1, long(pow(temp2, temp) * 10000.0));
}

void do_sqroot(const bool v)
{
	double temp = double(SH::get_arg(sarg2, v)) / 10000.0;
	
	if(temp < 0)
	{
		Z_scripterrlog("Script attempted to calculate square root of %ld!\n", temp);
		set_register(sarg1, -10000);
		return;
	}
	
	set_register(sarg1, long(sqrt(temp) * 10000.0));
}

///----------------------------------------------------------------------------------------------------//
//Bitwise

void do_and(const bool v)
{
	long temp = SH::get_arg(sarg2, v) / 10000;
	long temp2 = get_register(sarg1) / 10000;
	set_register(sarg1, (temp2 & temp) * 10000);
}

void do_and32(const bool v)
{
	long temp = SH::get_arg(sarg2, v);
	long temp2 = get_register(sarg1);
	set_register(sarg1, (temp2 & temp));
}

void do_or(const bool v)
{
	long temp = SH::get_arg(sarg2, v) / 10000;
	long temp2 = get_register(sarg1) / 10000;
	set_register(sarg1, (temp2 | temp) * 10000);
}

void do_or32(const bool v)
{
	long temp = SH::get_arg(sarg2, v);
	long temp2 = get_register(sarg1);
	set_register(sarg1, (temp2 | temp));
}

void do_xor(const bool v)
{
	long temp = SH::get_arg(sarg2, v) / 10000;
	long temp2 = get_register(sarg1) / 10000;
	set_register(sarg1, (temp2 ^ temp) * 10000);
}

void do_xor32(const bool v)
{
	long temp = SH::get_arg(sarg2, v);
	long temp2 = get_register(sarg1);
	set_register(sarg1, (temp2 ^ temp));
}

void do_nand(const bool v)
{
	long temp = SH::get_arg(sarg2, v) / 10000;
	long temp2 = get_register(sarg1) / 10000;
	set_register(sarg1, (~(temp2 & temp)) * 10000);
}

void do_nor(const bool v)
{
	long temp = SH::get_arg(sarg2, v) / 10000;
	long temp2 = get_register(sarg1) / 10000;
	set_register(sarg1, (~(temp2 | temp)) * 10000);
}

void do_xnor(const bool v)
{
	long temp = SH::get_arg(sarg2, v) / 10000;
	long temp2 = get_register(sarg1) / 10000;
	set_register(sarg1, (~(temp2 ^ temp)) * 10000);
}

void do_not(const bool v)
{
	long temp = SH::get_arg(sarg2, v);
	set_register(sarg1, !temp);
}

void do_bitwisenot(const bool v)
{
	long temp = SH::get_arg(sarg1, v) / 10000;
	set_register(sarg1, (~temp) * 10000);
}

void do_bitwisenot32(const bool v)
{
	long temp = SH::get_arg(sarg1, v);
	set_register(sarg1, (~temp));
}

void do_lshift(const bool v)
{
	long temp = SH::get_arg(sarg2, v) / 10000;
	long temp2 = get_register(sarg1) / 10000;
	set_register(sarg1, (temp2 << temp) * 10000);
}

void do_lshift32(const bool v)
{
	long temp = SH::get_arg(sarg2, v) / 10000;
	long temp2 = get_register(sarg1);
	set_register(sarg1, (temp2 << temp));
}

void do_rshift(const bool v)
{
	long temp = SH::get_arg(sarg2, v) / 10000;
	long temp2 = get_register(sarg1) / 10000;
	set_register(sarg1, (temp2 >> temp) * 10000);
}

void do_rshift32(const bool v)
{
	long temp = SH::get_arg(sarg2, v) / 10000;
	long temp2 = get_register(sarg1);
	set_register(sarg1, (temp2 >> temp));
}

///----------------------------------------------------------------------------------------------------//
//Casting

void do_boolcast(const bool isFloat)
{
	set_register(sarg1, (get_register(sarg1) ? (isFloat ? 1 : 10000) : 0));
}

///----------------------------------------------------------------------------------------------------//
//Text ptr functions
void do_fontheight()
{
	int font = get_register(sarg1)/10000;
	ri->d[2] = text_height(get_zc_font(font))*10000;
}

void do_strwidth()
{
	int strptr = get_register(sarg1)/10000;
	int font = get_register(sarg2)/10000;
	string the_string;
	ArrayH::getString(strptr, the_string, 512);
	ri->d[2] = text_length(get_zc_font(font), the_string.c_str())*10000;
}

void do_charwidth()
{
	char chr = get_register(sarg1)/10000;
	int font = get_register(sarg2)/10000;
	char *cstr = new char[2];
	cstr[0] = chr;
	cstr[1] = '\0';
	ri->d[2] = text_length(get_zc_font(font), cstr)*10000;
	delete[] cstr;
}

int do_msgwidth(int msg, char const* str)
{
	if(BC::checkMessage(msg, str) != SH::_NoError)
	{
		return -1;
	}
	char *cstr = new char[MSGSIZE+1];
	strcpy(cstr,MsgStrings[msg].s);
	for(int q = MSGSIZE; q >= 0; --q) //trim trailing spaces
	{
		if(cstr[q]==' ')cstr[q]=0;
		else if(cstr[q]!=0) break;
	}
	int v = text_length(get_zc_font(MsgStrings[msg].font), cstr);
	delete[] cstr;
	return v;
}

int do_msgheight(int msg, char const* str)
{
	if(BC::checkMessage(msg, str) != SH::_NoError)
	{
		return -1;
	}
	return text_height(get_zc_font(MsgStrings[msg].font));
}

///----------------------------------------------------------------------------------------------------//
//Gameplay functions

void do_warp(bool v)
{
	int dmapid = SH::get_arg(sarg1, v) / 10000;
	int screenid = SH::get_arg(sarg2, v) / 10000;
	if ( ((unsigned)dmapid) >= MAXDMAPS ) 
	{
		Z_scripterrlog("Invalid DMap ID (%d) passed to Warp(). Aborting.\n", dmapid);
		return;
	}
	if ( ((unsigned)screenid) >= MAPSCRS ) 
	{
		Z_scripterrlog("Invalid Screen ID (%d) passed to Warp(). Aborting.\n", screenid);
		return;
	}
	if ( DMaps[dmapid].map*MAPSCRS+DMaps[dmapid].xoff+screenid >= (int)TheMaps.size() )
	{
		Z_scripterrlog("Invalid destination passed to Warp(). Aborting.\n");
		return;
	}
	tmpscr->sidewarpdmap[0] = dmapid;
	tmpscr->sidewarpscr[0]  = screenid;
	tmpscr->sidewarptype[0] = wtIWARP;
	Link.ffwarp = true;
}

void do_pitwarp(bool v)
{
	int dmapid = SH::get_arg(sarg1, v) / 10000;
	int screenid = SH::get_arg(sarg2, v) / 10000;
	if ( ((unsigned)dmapid) >= MAXDMAPS ) 
	{
		Z_scripterrlog("Invalid DMap ID (%d) passed to PitWarp(). Aborting.\n", dmapid);
		return;
	}
	if ( ((unsigned)screenid) >= MAPSCRS ) 
	{
		Z_scripterrlog("Invalid Screen ID (%d) passed to PitWarp(). Aborting.\n", screenid);
		return;
	}
	//Extra sanity guard. 
	if ( DMaps[dmapid].map*MAPSCRS+DMaps[dmapid].xoff+screenid >= (int)TheMaps.size() )
	{
		Z_scripterrlog("Invalid destination passed to Warp(). Aborting.\n");
		return;
	}
	tmpscr->sidewarpdmap[0] = dmapid;
	tmpscr->sidewarpscr[0]  = screenid;
	tmpscr->sidewarptype[0] = wtIWARP;
	Link.ffwarp = true;
	Link.ffpit = true;
}

void do_breakshield()
{
	long UID = get_register(sarg1);
	
	for(int j = 0; j < guys.Count(); j++)
		if(guys.spr(j)->getUID() == UID)
		{
			((enemy*)guys.spr(j))->break_shield();
			return;
		}
}

void do_showsavescreen()
{
	bool saved = save_game(false, 0);
	set_register(sarg1, saved ? 10000 : 0);
}

void do_selectweapon(bool v, bool Abtn)
{
	if(Abtn && !get_bit(quest_rules,qr_SELECTAWPN))
		return;
		
	byte dir=(byte)(SH::get_arg(sarg1, v)/10000);
	
	// Selection directions don't match the normal ones...
	switch(dir)
	{
	case 0:
		dir=SEL_UP;
		break;
		
	case 1:
		dir=SEL_DOWN;
		break;
		
	case 2:
		dir=SEL_LEFT;
		break;
		
	case 3:
		dir=SEL_RIGHT;
		break;
		
	default:
		return;
	}
	
	if(Abtn)
		selectNextAWpn(dir);
	else
		selectNextBWpn(dir);
}

///----------------------------------------------------------------------------------------------------//
//Screen Information

void do_issolid()
{
	int x = int(ri->d[0] / 10000);
	int y = int(ri->d[1] / 10000);
	
	set_register(sarg1, (_walkflag(x, y, 1) ? 10000 : 0));
}

void do_mapdataissolid()
{
	if ( ri->mapsref == LONG_MAX  )
	{
		Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","isSolid()");
		set_register(sarg1,10000);
	}
	else
	{
		//mapscr *m = GetMapscr(ri->mapsref); 
		int x = int(ri->d[0] / 10000);
		int y = int(ri->d[1] / 10000);
		switch(ri->mapsref)
		{
			case MAPSCR_TEMP0:
				set_register(sarg1, (_walkflag(x, y, 1)) ? 10000 : 0);
				break;
			case MAPSCR_SCROLL0:
				set_register(sarg1, (_walkflag(x, y, 1, FFCore.ScrollingScreens[0], FFCore.ScrollingScreens[1], FFCore.ScrollingScreens[2])) ? 10000 : 0);
				break;
			default:
				set_register(sarg1, (_walkflag(x, y, 1, GetMapscr(ri->mapsref)) ? 10000 : 0));
		}
	}
}

void do_mapdataissolid_layer()
{
	if ( ri->mapsref == LONG_MAX  )
	{
		Z_scripterrlog("Mapdata->%s pointer is either invalid or uninitialised","isSolidLayer()");
		set_register(sarg1,10000);
	}
	else
	{
		//mapscr *m = GetMapscr(ri->mapsref); 
		int x = int(ri->d[0] / 10000);
		int y = int(ri->d[1] / 10000);
		int layer = int(ri->d[2] / 10000);
		if(BC::checkBounds(layer, 0, 6, "mapdata->isSolidLayer()") != SH::_NoError)
		{
			set_register(sarg1,10000);
		}
		else
		{
			switch(ri->mapsref)
			{
				case MAPSCR_TEMP0:
					set_register(sarg1, (_walkflag_layer(x, y, 1, FFCore.tempScreens[layer])) ? 10000 : 0);
					break;
				case MAPSCR_SCROLL0:
					set_register(sarg1, (_walkflag_layer(x, y, 1, FFCore.ScrollingScreens[layer])) ? 10000 : 0);
					break;
				default:
					mapscr* m = GetMapscr(ri->mapsref);
					if(layer > 0)
					{
						if(m->layermap[layer] == 0)
						{
							set_register(sarg1,10000);
							break;
						}
						m = &TheMaps[(m->layermap[layer]*MAPSCRS + m->layerscreen[layer])];
					}
					set_register(sarg1, (_walkflag_layer(x, y, 1, m) ? 10000 : 0));
					break;
			}
		}
	}
}

void do_issolid_layer()
{
	int x = int(ri->d[0] / 10000);
	int y = int(ri->d[1] / 10000);
	int layer = int(ri->d[2] / 10000);
	if(BC::checkBounds(layer, 0, 6, "Screen->isSolidLayer()") != SH::_NoError)
	{
		set_register(sarg1,10000);
	}
	else
	{
		set_register(sarg1, (_walkflag_layer(x, y, 1, FFCore.tempScreens[layer])) ? 10000 : 0);
	}
}

void do_setsidewarp()
{
	long warp   = SH::read_stack(ri->sp + 3) / 10000;
	long scrn = SH::read_stack(ri->sp + 2) / 10000;
	long dmap   = SH::read_stack(ri->sp + 1) / 10000;
	long type   = SH::read_stack(ri->sp + 0) / 10000;
	
	if(BC::checkBounds(warp, -1, 3, "Screen->SetSideWarp") != SH::_NoError ||
			BC::checkBounds(scrn, -1, 0x87, "Screen->SetSideWarp") != SH::_NoError ||
			BC::checkBounds(dmap, -1, MAXDMAPS - 1, "Screen->SetSideWarp") != SH::_NoError ||
			BC::checkBounds(type, -1, wtMAX - 1, "Screen->SetSideWarp") != SH::_NoError)
		return;
		
	if(scrn > -1)
		tmpscr->sidewarpscr[warp] = scrn;
		
	if(dmap > -1)
		tmpscr->sidewarpdmap[warp] = dmap;
		
	if(type > -1)
		tmpscr->sidewarptype[warp] = type;
}

void do_settilewarp()
{
	long warp   = SH::read_stack(ri->sp + 3) / 10000;
	long scrn = SH::read_stack(ri->sp + 2) / 10000;
	long dmap   = SH::read_stack(ri->sp + 1) / 10000;
	long type   = SH::read_stack(ri->sp + 0) / 10000;
	
	if(BC::checkBounds(warp, -1, 3, "Screen->SetTileWarp") != SH::_NoError ||
			BC::checkBounds(scrn, -1, 0x87, "Screen->SetTileWarp") != SH::_NoError ||
			BC::checkBounds(dmap, -1, MAXDMAPS - 1, "Screen->SetTileWarp") != SH::_NoError ||
			BC::checkBounds(type, -1, wtMAX - 1, "Screen->SetTileWarp") != SH::_NoError)
		return;
		
	if(scrn > -1)
		tmpscr->tilewarpscr[warp] = scrn;
		
	if(dmap > -1)
		tmpscr->tilewarpdmap[warp] = dmap;
		
	if(type > -1)
		tmpscr->tilewarptype[warp] = type;
}

void do_getsidewarpdmap(const bool v)
{
	long warp = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkBounds(warp, -1, 3, "Screen->GetSideWarpDMap") != SH::_NoError)
	{
		set_register(sarg1, -10000);
		return;
	}
	
	set_register(sarg1, tmpscr->sidewarpdmap[warp]*10000);
}

void do_getsidewarpscr(const bool v)
{
	long warp = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkBounds(warp, -1, 3, "Screen->GetSideWarpScreen") != SH::_NoError)
	{
		set_register(sarg1, -10000);
		return;
	}
	
	set_register(sarg1, tmpscr->sidewarpscr[warp]*10000);
}

void do_getsidewarptype(const bool v)
{
	long warp = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkBounds(warp, -1, 3, "Screen->GetSideWarpType") != SH::_NoError)
	{
		set_register(sarg1, -10000);
		return;
	}
	
	set_register(sarg1, tmpscr->sidewarptype[warp]*10000);
}

void do_gettilewarpdmap(const bool v)
{
	long warp = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkBounds(warp, -1, 3, "Screen->GetTileWarpDMap") != SH::_NoError)
	{
		set_register(sarg1, -10000);
		return;
	}
	
	set_register(sarg1, tmpscr->tilewarpdmap[warp]*10000);
}

void do_gettilewarpscr(const bool v)
{
	long warp = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkBounds(warp, -1, 3, "Screen->GetTileWarpScreen") != SH::_NoError)
	{
		set_register(sarg1, -10000);
		return;
	}
	
	set_register(sarg1, tmpscr->tilewarpscr[warp]*10000);
}

void do_gettilewarptype(const bool v)
{
	long warp = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkBounds(warp, -1, 3, "Screen->GetTileWarpType") != SH::_NoError)
	{
		set_register(sarg1, -10000);
		return;
	}
	
	set_register(sarg1, tmpscr->tilewarptype[warp]*10000);
}

void do_layerscreen()
{
	long layer = (get_register(sarg2) / 10000) - 1;
	
	if(BC::checkBounds(layer, 0, 5, "Screen->LayerScreen") != SH::_NoError ||
			tmpscr->layermap[layer] == 0)
		set_register(sarg1, -10000);
	else
		set_register(sarg1, tmpscr->layerscreen[layer] * 10000);
}

void do_layermap()
{
	long layer = (get_register(sarg2) / 10000) - 1;
	
	if(BC::checkBounds(layer, 0, 5, "Screen->LayerMap") != SH::_NoError ||
			tmpscr->layermap[layer] == 0)
		set_register(sarg1, -10000);
	else
		set_register(sarg1, tmpscr->layermap[layer] * 10000);
}


	

void do_triggersecrets()
{
	hidden_entrance(0, true, false, -4);
	//hidden_entrance(0,true,single16,scombo); 
	//bool findentrance(int x, int y, int flag, bool setflag)
	//We need a variation on these that triggers any combos with a given flag. -Z
}




void do_getscreenflags()
{
	long map     = (ri->d[2] / 10000) - 1;
	long scrn  = ri->d[1] / 10000;
	long flagset = ri->d[0] / 10000;
	
	if(BC::checkMapID(map, "Game->GetScreenFlags") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetScreenFlags") != SH::_NoError ||
			BC::checkBounds(flagset, 0, 9, "Game->GetScreenFlags") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenflags(&TheMaps[map * MAPSCRS + scrn], flagset));
}

void do_getscreeneflags()
{
	long map     = (ri->d[2] / 10000) - 1;
	long scrn  = ri->d[1] / 10000;
	long flagset = ri->d[0] / 10000;
	
	if(BC::checkMapID(map, "Game->GetScreenEFlags") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetScreenEFlags") != SH::_NoError ||
			BC::checkBounds(flagset, 0, 9, "Game->GetScreenEFlags") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screeneflags(&TheMaps[map * MAPSCRS + scrn], flagset));
}

void FFScript::do_graphics_getpixel()
{
	int yoffset = 0;
	const bool brokenOffset= ( (get_bit(extra_rules, er_BITMAPOFFSET)!=0) || (get_bit(quest_rules,qr_BITMAPOFFSETFIX)!=0) );
	
	int ref = (ri->d[2]);
	//zprint2("ref is: %d\n", ri->d[2]);
	
	
	
	if ( ref == -10000 || ref == -20000 || ref >= 10000 ) //Bitmaps Loaded by LoadBitmapID have values of -10000 to 70000
	{
		ref /= 10000;
	}
	else ref -= 10; //Bitmaps other than those loaded by LoadBitmapID
	//zprint2("ref is now: %d\n", ref);
	
	BITMAP *bitty = FFCore.GetScriptBitmap(ref);
	long xpos  = ri->d[1] / 10000;
	
	
	
	
	if(!brokenOffset && ref == -1 )
	{
		yoffset = 56; //should this be -56?
	}
	else
	{
		yoffset = 0;
	}
	
	long ypos = (ri->d[0] / 10000)+yoffset;
	
	//zprint2("ypos: %d\n", ypos);
	//zprint2("xpos: %d\n", xpos);
	
	if(!bitty)
		{
		bitty = scrollbuf;
		//al_trace("Getpixel: Loaded ScrollBuf into bitty /n");
		//return -10000;
	}
	
	int ret =  getpixel(bitty, xpos, ypos); //This is a palette index value. 
	
	set_register(sarg1, ret);
}

//Some of these need to be reduced to two inputs. -Z

long get_screendoor(mapscr *m, int d)
{
	int f = m->door[d];
	return f*10000;
}



long get_screenlayeropacity(mapscr *m, int d)
{
	int f = m->layeropacity[d]; //6 of these
	return f*10000;
}

long get_screensecretcombo(mapscr *m, int d)
{
	int f = m->secretcombo[d]; //128 of these
	return f*10000;
}

long get_screensecretcset(mapscr *m, int d)
{
	int f = m->secretcset[d]; //128 of these
	return f*10000;
}

long get_screensecretflag(mapscr *m, int d)
{
	int f = m->secretflag[d]; //128 of these
	return f*10000;
}

long get_screenlayermap(mapscr *m, int d)
{
	int f = m->layermap[d]; //6 of these
	return f*10000;
}

long get_screenlayerscreen(mapscr *m, int d)
{
	int f = m->layerscreen[d]; //6 of these
	return f*10000;
}

long get_screenpath(mapscr *m, int d)
{
	int f = m->path[d]; //4 of these
	return f*10000;
}

long get_screenwarpReturnX(mapscr *m, int d)
{
	int f = m->warpreturnx[d]; //4 of these
	return f*10000;
}

long get_screenwarpReturnY(mapscr *m, int d)
{
	int f = m->warpreturny[d]; //4 of these
	return f*10000;
}
//One too many inputs here. -Z
long get_screenViewX(mapscr *m)
{
	int f = m->viewX;
	return f*10000;
}
//One too many inputs here. -Z
long get_screenGuy(mapscr *m)
{
	int f = m->guy;
	return f*10000;
}
//One too many inputs here. -Z
long get_screenString(mapscr *m)
{
	int f = m->str;
	return f*10000;
}
//One too many inputs here. -Z
long get_screenRoomtype(mapscr *m)
{
	int f = m->room;
	return f*10000;
}
//One too many inputs here. -Z
long get_screenViewY(mapscr *m)
{
	int f = m->viewY;
	return f*10000;
}
//One too many inputs here. -Z
long get_screenEntryX(mapscr *m)
{
	int f = m->entry_x;
	return f*10000;
}
//One too many inputs here. -Z
long get_screenEntryY(mapscr *m)
{
	int f = m->entry_y;
	return f*10000;
}
//One too many inputs here. -Z
long get_screenitem(mapscr *m)
{
	int f = m->item;
	return f*10000;
}
//One too many inputs here. -Z
long get_screenundercombo(mapscr *m)
{
	int f = m->undercombo;
	return f*10000;
}
//One too many inputs here. -Z
long get_screenundercset(mapscr *m)
{
	int f = m->undercset;
	return f*10000;
}
//One too many inputs here. -Z
long get_screenatchall(mapscr *m)
{
	int f = m->catchall;
	return f*10000;
}
void do_getscreenLayerOpacity()
{
	long map     = (ri->d[2] / 10000) - 1;
	long scrn  = ri->d[1] / 10000;
	long d = ri->d[0] / 10000;
	
	if(BC::checkMapID(map, "Game->GetLayerOpacity(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetLayerOpacity(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 6, "Game->GetLayerOpacity(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenlayeropacity(&TheMaps[map * MAPSCRS + scrn], d));
}
void do_getscreenSecretCombo()
{
	long map     = (ri->d[2] / 10000) - 1;
	long scrn  = ri->d[1] / 10000;
	long d = ri->d[0] / 10000;
	
	if(BC::checkMapID(map, "Game->GetSecretCombo(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetSecretCombo(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 127, "Game->GetSecretCombo(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screensecretcombo(&TheMaps[map * MAPSCRS + scrn], d));
}

void do_getscreenSecretCSet()
{
	long map     = (ri->d[2] / 10000) - 1;
	long scrn  = ri->d[1] / 10000;
	long d = ri->d[0] / 10000;
	
	if(BC::checkMapID(map, "Game->GetSecretCSet(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetSecretCSet(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 127, "Game->GetSecretCSet(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screensecretcset(&TheMaps[map * MAPSCRS + scrn], d));
}

void do_getscreenSecretFlag()
{
	long map     = (ri->d[2] / 10000) - 1;
	long scrn  = ri->d[1] / 10000;
	long d = ri->d[0] / 10000;
	
	if(BC::checkMapID(map, "Game->GetSecretFlag(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetSecretFlag(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0,127, "Game->GetSecretFlag(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screensecretflag(&TheMaps[map * MAPSCRS + scrn], d));
}
void do_getscreenLayerMap()
{
	long map     = (ri->d[2] / 10000) - 1;
	long scrn  = ri->d[1] / 10000;
	long d = ri->d[0] / 10000;
	
	if(BC::checkMapID(map, "Game->GetSreenLayerMap(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetSreenLayerMap(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 6, "Game->GetSreenLayerMap(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenlayermap(&TheMaps[map * MAPSCRS + scrn], d));
}
void do_getscreenLayerscreen()
{
	long map     = (ri->d[2] / 10000) - 1;
	long scrn  = ri->d[1] / 10000;
	long d = ri->d[0] / 10000;
	
	if(BC::checkMapID(map, "Game->GetSreenLayerScreen(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetSreenLayerScreen(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 6, "Game->GetSreenLayerScreen(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenlayerscreen(&TheMaps[map * MAPSCRS + scrn], d));
}
void do_getscreenPath()
{
	long map     = (ri->d[2] / 10000) - 1;
	long scrn  = ri->d[1] / 10000;
	long d = ri->d[0] / 10000;
	
	if(BC::checkMapID(map, "Game->GetSreenPath(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetSreenPath(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 3, "Game->GetSreenPath(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenpath(&TheMaps[map * MAPSCRS + scrn], d));
}
void do_getscreenWarpReturnX()
{
	long map     = (ri->d[2] / 10000) - 1;
	long scrn  = ri->d[1] / 10000;
	long d = ri->d[0] / 10000;
	
	if(BC::checkMapID(map, "Game->GetScreenWarpReturnX(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetScreenWarpReturnX(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 3, "Game->GetScreenWarpReturnX(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenwarpReturnX(&TheMaps[map * MAPSCRS + scrn], d));
}
void do_getscreenWarpReturnY()
{
	long map     = (ri->d[2] / 10000) - 1;
	long scrn  = ri->d[1] / 10000;
	long d = ri->d[0] / 10000;
	
	if(BC::checkMapID(map, "Game->GetScreenWarpReturnY(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetScreenWarpReturnY(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 3, "Game->GetScreenWarpReturnY(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenwarpReturnY(&TheMaps[map * MAPSCRS + scrn], d));
}

/*
//One too many inputs here. -Z
void do_getscreenatchall()
{
	long map     = (ri->d[2] / 10000) - 1;
	long scrn  = ri->d[1] / 10000;
	long d = ri->d[0] / 10000;
	
	if(BC::checkMapID(map, "Game->GetScreenCatchall(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetScreenCatchall(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 6, "Game->GetScreenCatchall(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenatchall(&TheMaps[map * MAPSCRS + scrn], d));
}


//One too many inputs here. -Z
void do_getscreenUndercombo()
{
	long map     = (ri->d[2] / 10000) - 1;
	long scrn  = ri->d[1] / 10000;
	long d = ri->d[0] / 10000;
	
	if(BC::checkMapID(map, "Game->GetcreenUndercombo(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetcreenUndercombo(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 6, "Game->GetcreenUndercombo(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenundercombo(&TheMaps[map * MAPSCRS + scrn], d));
}
//One too many inputs here. -Z
void do_getscreenUnderCSet()
{
	long map     = (ri->d[2] / 10000) - 1;
	long scrn  = ri->d[1] / 10000;
	long d = ri->d[0] / 10000;
	
	if(BC::checkMapID(map, "Game->GeScreenUnderCSet(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GeScreenUnderCSet(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 6, "Game->GeScreenUnderCSet(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenundercset(&TheMaps[map * MAPSCRS + scrn], d));
}

//One too many inputs here. -Z
void do_getscreenWidth()
{
	long map     = (ri->d[2] / 10000) - 1;
	long scrn  = ri->d[1] / 10000;
	long d = ri->d[0] / 10000;
	
	if(BC::checkMapID(map, "Game->GetScreenWidth(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetScreenWidth(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 214747, "Game->GetScreenWidth(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenWidth(&TheMaps[map * MAPSCRS + scrn], d));
}
//One too many inputs here. -Z
void do_getscreenHeight()
{
	long map     = (ri->d[2] / 10000) - 1;
	long scrn  = ri->d[1] / 10000;
	long d = ri->d[0] / 10000;
	
	if(BC::checkMapID(map, "Game->GetScreenHeight(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetScreenHeight(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 214747, "Game->GetScreenHeight(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenHeight(&TheMaps[map * MAPSCRS + scrn], d));
}
//One too many inputs here. -Z
void do_getscreenViewX()
{
	long map     = (ri->d[2] / 10000) - 1;
	long scrn  = ri->d[1] / 10000;
	long d = ri->d[0] / 10000;
	
	if(BC::checkMapID(map, "Game->GetScreenViewX(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetScreenViewX(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 214747, "Game->GetScreenViewX(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenViewX(&TheMaps[map * MAPSCRS + scrn], d));
}
//One too many inputs here. -Z
void do_getscreenViewY()
{
	long map     = (ri->d[2] / 10000) - 1;
	long scrn  = ri->d[1] / 10000;
	long d = ri->d[0] / 10000;
	
	if(BC::checkMapID(map, "Game->GetScreenViewY(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetScreenViewY(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 214747, "Game->GetScreenViewY(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenViewY(&TheMaps[map * MAPSCRS + scrn], d));
}
//One too many inputs here. -Z
void do_getscreenGuy()
{
	long map     = (ri->d[2] / 10000) - 1;
	long scrn  = ri->d[1] / 10000;
	long d = ri->d[0] / 10000;
	
	if(BC::checkMapID(map, "Game->GetScreenGuy(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetScreenGuy(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 214747, "Game->GetScreenGuy(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenGuy(&TheMaps[map * MAPSCRS + scrn], d));
}
//One too many inputs here. -Z
void do_getscreenString()
{
	long map     = (ri->d[2] / 10000) - 1;
	long scrn  = ri->d[1] / 10000;
	long d = ri->d[0] / 10000;
	
	if(BC::checkMapID(map, "Game->GetScreenString(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetScreenString(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 214747, "Game->GetScreenString(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenString(&TheMaps[map * MAPSCRS + scrn], d));
}
//One too many inputs here. -Z
void do_getscreenRoomType()
{
	long map     = (ri->d[2] / 10000) - 1;
	long scrn  = ri->d[1] / 10000;
	long d = ri->d[0] / 10000;
	
	if(BC::checkMapID(map, "Game->GetScreenRoomType(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetScreenRoomType(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 214747, "Game->GetScreenRoomType(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenRoomtype(&TheMaps[map * MAPSCRS + scrn], d));
}
//One too many inputs here. -Z
void do_getscreenEntryX()
{
	long map     = (ri->d[2] / 10000) - 1;
	long scrn  = ri->d[1] / 10000;
	long d = ri->d[0] / 10000;
	
	if(BC::checkMapID(map, "Game->GetScreenEntryX(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetScreenEntryX(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 214747, "Game->GetScreenEntryX(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenEntryX(&TheMaps[map * MAPSCRS + scrn], d));
}
//One too many inputs here. -Z
void do_getscreenEntryY()
{
	long map     = (ri->d[2] / 10000) - 1;
	long scrn  = ri->d[1] / 10000;
	long d = ri->d[0] / 10000;
	
	if(BC::checkMapID(map, "Game->GetScreenEntryY(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetScreenEntryY(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 214747, "Game->GetScreenEntryY(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenEntryY(&TheMaps[map * MAPSCRS + scrn], d));
}
//One too many inputs here. -Z
void do_getscreenItem()
{
	long map     = (ri->d[2] / 10000) - 1;
	long scrn  = ri->d[1] / 10000;
	long d = ri->d[0] / 10000;
	
	if(BC::checkMapID(map, "Game->GetScreenItem(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetScreenItem(...screen...)") != SH::_NoError ||
			BC::checkBounds(d, 0, 255, "Game->GetScreenItem(...val...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screenitem(&TheMaps[map * MAPSCRS + scrn], d));
}
*/
void do_getscreendoor()
{
	long map     = (ri->d[2] / 10000) - 1;
	long scrn  = ri->d[1] / 10000;
	long door = ri->d[0] / 10000;
	
	if(BC::checkMapID(map, "Game->GetScreenDoor(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetScreenDoor(...screen...)") != SH::_NoError ||
			BC::checkBounds(door, 0, 3, "Game->GetScreenDoor(...doorindex...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screendoor(&TheMaps[map * MAPSCRS + scrn], door));
}

long get_screennpc(mapscr *m, int index)
{
	int f = m->enemy[index];
	return f*10000;
}


void do_getscreennpc()
{
	long map     = (ri->d[2] / 10000) - 1;
	long scrn  = ri->d[1] / 10000;
	long enemy = ri->d[0] / 10000;
	
	if(BC::checkMapID(map, "Game->GetScreenEnemy(...map...)") != SH::_NoError ||
			BC::checkBounds(scrn, 0, 0x87, "Game->GetScreenEnemy(...screen...)") != SH::_NoError ||
			BC::checkBounds(enemy, 0, 9, "Game->GetScreenEnemy(...enemy...)") != SH::_NoError)
		return;
		
	set_register(sarg1, get_screennpc(&TheMaps[map * MAPSCRS + scrn], enemy));
}


///----------------------------------------------------------------------------------------------------//
//Pointer handling

void do_isvalidarray()
{
	long ptr = get_register(sarg1)/10000;
	
	
	if(ptr <= 0) //invalid pointer
	{
			set_register(sarg1,0); return;
	}
			
		if(ptr >= NUM_ZSCRIPT_ARRAYS) //check global
		{
			dword gptr = ptr - NUM_ZSCRIPT_ARRAYS;
			
			if(gptr > game->globalRAM.size())
		{
			set_register(sarg1,0); return;
		}
		else set_register(sarg1,(game->globalRAM[gptr].Size() == 0) ? 0 : 10000); return;
	}
		
		else
		{
		set_register(sarg1,(localRAM[ptr].Size() == 0) ? 0 : 10000); 
	}
}

void do_isvaliditem()
{
	long IID = get_register(sarg1);
	//int ct = items.Count();
  
	//for ( int j = items.Count()-1; j >= 0; --j )
	for(int j = 0; j < items.Count(); j++)
	//for(int j = 0; j < ct; j++)
		if(items.spr(j)->getUID() == IID)
		{
			set_register(sarg1, 10000);
			return;
		}
		
	set_register(sarg1, 0);
}

void do_isvalidnpc()
{
	long UID = get_register(sarg1);
	//for ( int j = guys.Count()-1; j >= 0; --j )
	//int ct = guys.Count(); 
	
	for(int j = 0; j < guys.Count(); j++)
	//for(int j = 0; j < ct; j++)
		if(guys.spr(j)->getUID() == UID)
		{
			set_register(sarg1, 10000);
			return;
		}
		
	set_register(sarg1, 0);
}

void do_isvalidlwpn()
{
	long WID = get_register(sarg1);
	//int ct = Lwpns.Count();
	
	//for ( int j = Lwpns.Count()-1; j >= 0; --j )
	for(int j = 0; j < Lwpns.Count(); j++)
	//for(int j = 0; j < ct; j++)
		if(Lwpns.spr(j)->getUID() == WID)
		{
			set_register(sarg1, 10000);
			return;
		}
		
	set_register(sarg1, 0);
}

void do_isvalidewpn()
{
	long WID = get_register(sarg1);
	// int ct = Ewpns.Count();
	
	// for ( int j = Ewpns.Count()-1; j >= 0; --j )
	for(int j = 0; j < Ewpns.Count(); j++)
	//for(int j = 0; j < ct; j++)
		if(Ewpns.spr(j)->getUID() == WID)
		{
			set_register(sarg1, 10000);
			return;
		}
		
	set_register(sarg1, 0);
}

void do_lwpnusesprite(const bool v)
{
	long ID = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkWeaponMiscSprite(ID, "lweapon->UseSprite") != SH::_NoError)
		return;
		
	if(LwpnH::loadWeapon(ri->lwpn, "lweapon->UseSprite") == SH::_NoError)
		LwpnH::getWeapon()->LOADGFX(ID);
}

void do_ewpnusesprite(const bool v)
{
	long ID = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkWeaponMiscSprite(ID, "eweapon->UseSprite") != SH::_NoError)
		return;
		
	if(EwpnH::loadWeapon(ri->ewpn, "eweapon->UseSprite") == SH::_NoError)
		EwpnH::getWeapon()->LOADGFX(ID);
}

void do_clearsprites(const bool v)
{
	long spritelist = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkBounds(spritelist, 0, 5, "Screen->ClearSprites") != SH::_NoError)
		return;
		
	switch(spritelist)
	{
		case 0:
			guys.clear();
			break;
			
		case 1:
			items.clear();
			break;
			
		case 2:
			Ewpns.clear();
			break;
			
		case 3:
			Lwpns.clear();
			Link.reset_hookshot();
			break;
			
		case 4:
			decorations.clear();
			break;
			
		case 5:
			particles.clear();
			break;
	}
}

void do_loadlweapon(const bool v)
{
	long index = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkLWeaponIndex(index, "Screen->LoadLWeapon") != SH::_NoError)
		ri->lwpn = 0; //LONG_MAX; //Now NULL
	else
	{
		ri->lwpn = Lwpns.spr(index)->getUID();
		// This is too trivial to log. -L
		//Z_eventlog("Script loaded lweapon with UID = %ld\n", ri->lwpn);
	}
}

void do_loadeweapon(const bool v)
{
	long index = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkEWeaponIndex(index, "Screen->LoadEWeapon") != SH::_NoError)
		ri->ewpn = 0; //LONG_MAX; //Now NULL
	else
	{
		ri->ewpn = Ewpns.spr(index)->getUID();
		//Z_eventlog("Script loaded eweapon with UID = %ld\n", ri->ewpn);
	}
}

void do_loaditem(const bool v)
{
	long index = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkItemIndex(index, "Screen->LoadItem") != SH::_NoError)
		ri->itemref = 0; //LONG_MAX; //Now NULL
	else
	{
		ri->itemref = items.spr(index)->getUID();
		//Z_eventlog("Script loaded item with UID = %ld\n", ri->itemref);
	}
}


void do_loaditemdata(const bool v)
{
	long ID = SH::get_arg(sarg1, v) / 10000;
	
	//I *think* this is the right check ~Joe
	if(BC::checkItemID(ID, "Game->LoadItemData") != SH::_NoError)
		return;
		
	ri->idata = ID;
	//Z_eventlog("Script loaded itemdata with ID = %ld\n", ri->idata);
}

void do_loadnpc(const bool v)
{
	long index = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkGuyIndex(index, "Screen->LoadNPC") != SH::_NoError)
		ri->guyref = 0; // LONG_MAX;
	else
	{
		ri->guyref = guys.spr(index)->getUID();
		//Z_eventlog("Script loaded NPC with UID = %ld\n", ri->guyref);
	}
}

/* script_UID is not yet part of sprite class. 

void FFScript::do_loaditem_by_script_uid(const bool v)
{
	long sUID = SH::get_arg(sarg1, v) / 10000; //script UID
	for(int j = 0; j < items.Count(); j++)
		if(items.spr(j)->script_UID == sUID)
		{
			ri->itemref = items.spr(j)->getUID();
		return;
		}
	ri->itemref = LONG_MAX;
	//error here.
	//Z_eventlog("Script loaded NPC with UID = %ld\n", ri->guyref);
}

void FFScript::do_loadnpc_by_script_uid(const bool v)
{
	long sUID = SH::get_arg(sarg1, v) / 10000; //script UID
	//int ct = guys.Count();
	for(int j = 0; j < guys.Count(); j++)
		if(guys.spr(j)->script_UID == sUID)
		{
			ri->guyref = guys.spr(j)->getUID();
		return;
		}
	ri->guyref = LONG_MAX;
	//error here.
	//Z_eventlog("Script loaded NPC with UID = %ld\n", ri->guyref);
}

*/

void FFScript::do_loaddmapdata(const bool v)
{
	long ID = SH::get_arg(sarg1, v) / 10000;
	
	if ( ID < 0 || ID > 511 )
	{
	Z_scripterrlog("Invalid DMap ID passed to Game->LoadDMapData(): %d\n", ID);
	ri->dmapsref = LONG_MAX;
	}
		
	else ri->dmapsref = ID;
	//Z_eventlog("Script loaded npcdata with ID = %ld\n", ri->idata);
}

void FFScript::do_loaddropset(const bool v)
{
	long ID = SH::get_arg(sarg1, v) / 10000;
	
	if ( ID < 0 || ID > MAXITEMDROPSETS )
	{
	Z_scripterrlog("Invalid Dropset ID passed to Game->LoadDropset(): %d\n", ID);
	ri->dropsetref = LONG_MAX;
	}
		
	else ri->dropsetref = ID;
}

void FFScript::do_getDMapData_dmapname(const bool v)
{
	//long ID = ri->zmsgref;
	long ID = ri->dmapsref;
	long arrayptr = get_register(sarg2) / 10000;
	
	if(BC::checkDMapID(ID, "dmapdata->GetName()") != SH::_NoError)
		return;
		
	if(ArrayH::setArray(arrayptr, string(DMaps[ID].name)) == SH::_Overflow)
		Z_scripterrlog("Array supplied to 'dmapdata->GetName()' not large enough\n");
}

void FFScript::do_setDMapData_dmapname(const bool v)
{
	//long ID = ri->zmsgref;
	long ID = ri->dmapsref;
	long arrayptr = get_register(sarg2) / 10000;

	string filename_str;
	
	if(BC::checkDMapID(ID, "dmapdata->SetName()") != SH::_NoError)
		return;
		
		
	ArrayH::getString(arrayptr, filename_str, 73);
	strncpy(DMaps[ID].name, filename_str.c_str(), 72);
	DMaps[ID].name[72]='\0';
}

void FFScript::do_getDMapData_dmaptitle(const bool v)
{
	//long ID = ri->zmsgref;
	long ID = ri->dmapsref;
	long arrayptr = get_register(sarg2) / 10000;
	
	if(BC::checkDMapID(ID, "dmapdata->GetIntro()") != SH::_NoError)
		return;
		
	if(ArrayH::setArray(arrayptr, string(DMaps[ID].title)) == SH::_Overflow)
		Z_scripterrlog("Array supplied to 'dmapdata->GetIntro()' not large enough\n");
}

void FFScript::do_setDMapData_dmaptitle(const bool v)
{
	//long ID = ri->zmsgref;
	long ID = ri->dmapsref;
	long arrayptr = get_register(sarg2) / 10000;
	string filename_str;
	
	if(BC::checkDMapID(ID, "dmapdata->SetTitle()") != SH::_NoError)
		return;
		
		
	ArrayH::getString(arrayptr, filename_str, 21);
	strncpy(DMaps[ID].title, filename_str.c_str(), 20);
	DMaps[ID].title[20]='\0';
}

void FFScript::do_getDMapData_dmapintro(const bool v)
{
	//long ID = ri->zmsgref;
	long ID = ri->dmapsref;
	long arrayptr = get_register(sarg2) / 10000;
	
	if(BC::checkDMapID(ID, "dmapdata->GetIntro()") != SH::_NoError)
		return;
		
	if(ArrayH::setArray(arrayptr, string(DMaps[ID].intro)) == SH::_Overflow)
		Z_scripterrlog("Array supplied to 'dmapdata->GetIntro()' not large enough\n");
}

void FFScript::do_setDMapData_dmapintro(const bool v)
{
	//long ID = ri->zmsgref;
	long ID = ri->dmapsref;
	long arrayptr = get_register(sarg2) / 10000;
	string filename_str;
	
	if(BC::checkDMapID(ID, "dmapdata->SetIntro()") != SH::_NoError)
		return;
		
		
	ArrayH::getString(arrayptr, filename_str, 73);
	strncpy(DMaps[ID].intro, filename_str.c_str(), 72);
	DMaps[ID].intro[72]='\0';
}

void FFScript::do_getDMapData_music(const bool v)
{
	//long ID = ri->zmsgref;
	long ID = ri->dmapsref;
	long arrayptr = get_register(sarg2) / 10000;
	
	if(BC::checkDMapID(ID, "dmapdata->GetMusic()") != SH::_NoError)
		return;
		
	if(ArrayH::setArray(arrayptr, string(DMaps[ID].tmusic)) == SH::_Overflow)
		Z_scripterrlog("Array supplied to 'dmapdata->GetMusic()' not large enough\n");
}

void FFScript::do_setDMapData_music(const bool v)
{
	//long ID = ri->zmsgref;
	long ID = ri->dmapsref;
	long arrayptr = get_register(sarg2) / 10000;
	string filename_str;
	
	if(BC::checkDMapID(ID, "dmapdata->SetMusic()") != SH::_NoError)
		return;
		
		
	ArrayH::getString(arrayptr, filename_str, 56);
	strncpy(DMaps[ID].tmusic, filename_str.c_str(), 55);
	DMaps[ID].tmusic[55]='\0';
}

void FFScript::do_loadnpcdata(const bool v)
{
	long ID = SH::get_arg(sarg1, v) / 10000;
	
	if ( ID < 1 || ID > (MAXGUYS-1) )
	{
		Z_scripterrlog("Invalid NPC ID passed to Game->LoadNPCData: %d\n", ID);
		ri->npcdataref = LONG_MAX;
	}
		
	else ri->npcdataref = ID;
	//Z_eventlog("Script loaded npcdata with ID = %ld\n", ri->idata);
}
void FFScript::do_loadmessagedata(const bool v)
{
	long ID = SH::get_arg(sarg1, v) / 10000;
	
	if ( ID < 1 || ID > (msg_count-1) )
	{
		Z_scripterrlog("Invalid Message ID passed to Game->LoadMessageData: %d\n", ID);
		ri->zmsgref = LONG_MAX;
	}
		
	else ri->zmsgref = ID;
	//Z_eventlog("Script loaded npcdata with ID = %ld\n", ri->idata);
}
//same syntax as loadmessage data
//the input is an array
void FFScript::do_messagedata_setstring(const bool v)
{
	long arrayptr = get_register(sarg1) / 10000;
	long ID = ri->zmsgref;
	if(BC::checkMessage(ID, "messagesata->Set()") != SH::_NoError)
		return;
	
	string filename_str;
		
	ArrayH::getString(arrayptr, filename_str, 73);
	strncpy(MsgStrings[ID].s, filename_str.c_str(), 72);
	MsgStrings[ID].s[72]='\0';
}
void FFScript::do_messagedata_getstring(const bool v)
{
	long ID = ri->zmsgref;
	long arrayptr = get_register(sarg1) / 10000;
	
	if(BC::checkMessage(ID, "messagedata->Get()") != SH::_NoError)
		return;
		
	if(ArrayH::setArray(arrayptr, string(MsgStrings[ID].s)) == SH::_Overflow)
		Z_scripterrlog("Array supplied to 'messagedata->Get()' not large enough\n");
}

void FFScript::do_loadcombodata(const bool v)
{
	long ID = SH::get_arg(sarg1, v) / 10000;
	
	if ( (unsigned)ID > (MAXCOMBOS-1) )
	{
		Z_scripterrlog("Invalid Combo ID passed to Game->LoadComboData: %d\n", ID);
		ri->combosref = 0;
	}

	else ri->combosref = ID;
	//Z_eventlog("Script loaded mapdata with ID = %ld\n", ri->idata);
}

void FFScript::do_loadmapdata(const bool v)
{
	long _map = SH::get_arg(sarg1, v) / 10000;
	
	long _scr = SH::get_arg(sarg2, v) / 10000;
	zprint("LoadMapData Map Value: %d\n", _map);
	zprint("LoadMapData Screen Value: %d\n", _scr);
	int indx = (_map * MAPSCRS + _scr);
	zprint("LoadMapData Indx Value: %d\n", indx);
	if ( _map < 1 || _map > (map_count-1) )
	{
		Z_scripterrlog("Invalid Map ID passed to Game->LoadMapData: %d\n", _map);
		ri->mapsref = 0;
	}
	else if ( (unsigned)_scr > 129 ) //0x00 to 0x81 -Z
	{
		Z_scripterrlog("Invalid Screen ID passed to Game->LoadMapData: %d\n", _scr);
		ri->mapsref = 0;
	}
	else ri->mapsref = indx;
	zprint("LoadMapData Screen set ri->mapsref to: %d\n", ri->mapsref);
	//zprint("Script loaded mapdata with ID = %ld\n", ri->idata);
}

void FFScript::do_loadmapdata_tempscr(const bool v)
{
	int layer = SH::get_arg(sarg1, v) / 10000;
	if(BC::checkBounds(layer, 0, 6, "Game->LoadTempScreen()") != SH::_NoError)
	{
		ri->mapsref = 0;
		return;
	}
	switch(layer)
	{
		case 0: ri->mapsref = MAPSCR_TEMP0; break;
		case 1: ri->mapsref = MAPSCR_TEMP1; break;
		case 2: ri->mapsref = MAPSCR_TEMP2; break;
		case 3: ri->mapsref = MAPSCR_TEMP3; break;
		case 4: ri->mapsref = MAPSCR_TEMP4; break;
		case 5: ri->mapsref = MAPSCR_TEMP5; break;
		case 6: ri->mapsref = MAPSCR_TEMP6; break;
	}
	set_register(sarg1, ri->mapsref);
}

void FFScript::do_loadmapdata_scrollscr(const bool v)
{
	int layer = SH::get_arg(sarg1, v) / 10000;
	if(BC::checkBounds(layer, 0, 6, "Game->LoadScrollingScreen()") != SH::_NoError)
	{
		ri->mapsref = 0;
		return;
	}
	switch(layer)
	{
		case 0: ri->mapsref = MAPSCR_SCROLL0; break;
		case 1: ri->mapsref = MAPSCR_SCROLL1; break;
		case 2: ri->mapsref = MAPSCR_SCROLL2; break;
		case 3: ri->mapsref = MAPSCR_SCROLL3; break;
		case 4: ri->mapsref = MAPSCR_SCROLL4; break;
		case 5: ri->mapsref = MAPSCR_SCROLL5; break;
		case 6: ri->mapsref = MAPSCR_SCROLL6; break;
	}
	set_register(sarg1, ri->mapsref);
}
	
void FFScript::do_loadshopdata(const bool v)
{
	long ID = SH::get_arg(sarg1, v) / 10000;
	
	if ( (unsigned)ID > 255 )
	{
		Z_scripterrlog("Invalid Shop ID passed to Game->LoadShopData: %d\n", ID);
		ri->shopsref = 0;
	}	
	else ri->shopsref = ID;
	//Z_eventlog("Script loaded npcdata with ID = %ld\n", ri->idata);
}


void FFScript::do_loadinfoshopdata(const bool v)
{
	long ID = SH::get_arg(sarg1, v) / 10000;
	
	if ( (unsigned)ID > 255 )
	{
		Z_scripterrlog("Invalid Shop ID passed to Game->LoadShopData: %d\n", ID);
		ri->shopsref = 0;
	}	
	else ri->shopsref = ID+NUMSHOPS;
	//Z_eventlog("Script loaded npcdata with ID = %ld\n", ri->idata);
}

/*
void FFScript::do_loadmapdata(const bool v)
{
	long ID = SH::get_arg(sarg1, v) / 10000;
	
	if ( ID < 0 || ID > (map_count-1) )
	{
		Z_scripterrlog("Invalid Map ID passed to Game->LoadMapData: %d\n", ID);
		ri->mapsref = LONG_MAX;
	}

	else ri->mapsref = ID;
	//Z_eventlog("Script loaded mapdata with ID = %ld\n", ri->idata);
}
*/

/*

void FFScript::do_loadmapdata(const bool v)
{
	long ID = get_register(sarg2) / 10000; 
	
	if ( ID < 0 || ID > (map_count-1) )
	{
		Z_scripterrlog("Invalid Map ID passed to Game->LoadMapData: %d\n", ID);
		return;
	}

	ri->mapsref = ID;
	set_register(sarg1, ri->mapsref); 
	//Z_eventlog("Script loaded mapdata with ID = %ld\n", ri->idata);
}

*/

void FFScript::do_loadspritedata(const bool v)
{
	long ID = SH::get_arg(sarg1, v) / 10000;
	
	if ( (unsigned)ID > (MAXWPNS-1) )
	{
		Z_scripterrlog("Invalid Sprite ID passed to Game->LoadSpriteData: %d\n", ID);
		ri->spritesref = 0; 
	}

	else ri->spritesref = ID;
	//Z_eventlog("Script loaded mapdata with ID = %ld\n", ri->idata);
}


void FFScript::do_loadscreendata(const bool v)
{
	long ID = SH::get_arg(sarg1, v) / 10000;
	
	if ( (unsigned)ID > (MAXSCREENS-1) )
	{
		Z_scripterrlog("Invalid Map ID passed to Game->LoadScreenData: %d\n", ID);
		ri->screenref = 0; 
	}

	else ri->screenref = ID;
	//Z_eventlog("Script loaded mapdata with ID = %ld\n", ri->idata);
}

void FFScript::do_loadbitmapid(const bool v)
{
	long ID = SH::get_arg(sarg1, v) / 10000;
	switch(ID)
	{
		case -1:
		case 0:
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
			ri->bitmapref = ID+10; break;
		default:
		{
			Z_scripterrlog("Invalid Bitmap ID passed to Game->Load BitmapID: %d\n", ID);
			ri->bitmapref = 0; break;
		}
	}
	
	//Z_eventlog("Script loaded mapdata with ID = %ld\n", ri->idata);
}

void do_createlweapon(const bool v)
{
	const long ID = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkWeaponID(ID, "Screen->CreateLWeapon") != SH::_NoError)
		return;
	
	if ( Lwpns.has_space() )
	{
		Lwpns.add
		(
			new weapon
			(
				(zfix)0, /*X*/
				(zfix)0, /*Y*/
				(zfix)0, /*Z*/
				ID,	 /*id*/
				0,	 /*type*/
				0,	 /*power*/
				0,	 /*dir*/
				-1,	 /*Parentid*/
				Link.getUID(), /*prntid*/
				false,	 /*isdummy*/
				1,	 /*script_gen*/
				1,  /*islwpn*/
				(ID==wWind?1:0)  /*special*/
			)
		);
		ri->lwpn = Lwpns.spr(Lwpns.Count() - 1)->getUID();
		//Lwpns.spr(Lwpns.Count() - 1)->LOADGFX(0);
		//Lwpns.spr(Lwpns.Count() - 1)->ScriptGenerated = 1;
		//Lwpns.spr(Lwpns.Count() - 1)->isLWeapon = 1;
		weapon *w = (weapon*)Lwpns.spr(Lwpns.Count()-1); //last created
		w->LOADGFX(FFCore.getDefWeaponSprite(ID));
		w->ScriptGenerated = 1;
		w->isLWeapon = 1;
		if(ID == wWind) w->specialinfo = 1;
		Z_eventlog("Script created lweapon %ld with UID = %ld\n", ID, ri->lwpn);
	}
	else
	{
		ri->lwpn = LONG_MAX;
		Z_scripterrlog("Couldn't create lweapon %ld, screen lweapon limit reached\n", ID);
	}
	return; //do not use the old code, below here. 
		//old version is below
	if ( Lwpns.has_space() )
	{
		Lwpns.add(new weapon((zfix)0,(zfix)0,(zfix)0,ID,0,0,0,-1,false,1,Link.getUID(),1));
		ri->lwpn = Lwpns.spr(Lwpns.Count() - 1)->getUID();
		Z_eventlog("Script created lweapon %ld with UID = %ld\n", ID, ri->lwpn);
	}
	else
	{
		ri->lwpn = 0;
		Z_scripterrlog("Couldn't create lweapon %ld, screen lweapon limit reached\n", ID);
	}
	//addLwpn(0, 0, 0, ID, 0, 0, 0, Link.getUID());
	/*
	if(Lwpns.Count() < 1)
	{
		ri->lwpn = LONG_MAX;
		Z_scripterrlog("Couldn't create lweapon %ld, screen lweapon limit reached\n", ID);
	}
	else
	{
		ri->lwpn = Lwpns.spr(Lwpns.Count() - 1)->getUID();
		Z_eventlog("Script created lweapon %ld with UID = %ld\n", ID, ri->lwpn);
	}
	*/
}

void do_createeweapon(const bool v)
{
	const long ID = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkWeaponID(ID, "Screen->CreateEWeapon") != SH::_NoError)
		return;
		
	if ( Ewpns.has_space() )
	{
		addEwpn(0, 0, 0, ID, 0, 0, 0, -1,1); //Param 9 marks it as script-generated.
		//Ewpns.spr(Ewpns.Count() - 1)->LOADGFX(0);
		//Ewpns.spr(Ewpns.Count() - 1)->ScriptGenerated = 1;
		//Ewpns.spr(Ewpns.Count() - 1)->isLWeapon = 0;
		if( ID > wEnemyWeapons || ( ID >= wScript1 && ID <= wScript10) )
		{
			weapon *w = (weapon*)Ewpns.spr(Ewpns.Count()-1); //last created
			w->LOADGFX(FFCore.getDefWeaponSprite(ID));
			w->ScriptGenerated = 1;
			w->isLWeapon = 0;
			ri->ewpn = Ewpns.spr(Ewpns.Count() - 1)->getUID();
			Z_eventlog("Script created eweapon %ld with UID = %ld\n", ID, ri->ewpn);
		}
		else
		{
			Z_scripterrlog("Couldn't create eweapon %ld: Invalid ID/Type (%d) specified.\n", ID);
			return;
		}
	}
	else
	{
		ri->ewpn = 0;
		Z_scripterrlog("Couldn't create eweapon %ld, screen eweapon limit reached\n", ID);
	}
	//addEwpn(0, 0, 0, ID, 0, 0, 0, -1);
	/*
	if(Ewpns.Count() < 1)
	{
		ri->ewpn = LONG_MAX;
		Z_scripterrlog("Couldn't create eweapon %ld, screen eweapon limit reached\n", ID);
	}
	else
	{
		ri->ewpn = Ewpns.spr(Ewpns.Count() - 1)->getUID();
		Z_eventlog("Script created eweapon %ld with UID = %ld\n", ID, ri->ewpn);
	}
	*/
}

void do_createitem(const bool v)
{
	const long ID = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkItemID(ID, "Screen->CreateItem") != SH::_NoError)
		return;

	if ( items.has_space() )
	{
		additem(0, (get_bit(quest_rules, qr_NOITEMOFFSET) ? 1: 0), ID, ipBIGRANGE);
		ri->itemref = items.spr(items.Count() - 1)->getUID();
		Z_eventlog("Script created item \"%s\" with UID = %ld\n", item_string[ID], ri->itemref);
	}
	else
	{
		ri->itemref = 0;
		Z_scripterrlog("Couldn't create item \"%s\", screen item limit reached\n", item_string[ID]);
	}
	/*
	if(items.Count() < 1)
	{
		ri->itemref = LONG_MAX;
		Z_scripterrlog("Couldn't create item \"%s\", screen item limit reached\n", item_string[ID]);
	}
	else
	{
		ri->itemref = items.spr(items.Count() - 1)->getUID();
		Z_eventlog("Script created item \"%s\" with UID = %ld\n", item_string[ID], ri->itemref);
	}
	*/
}

void do_createnpc(const bool v)
{
	const long ID = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkGuyID(ID, "Screen->CreateNPC") != SH::_NoError)
		return;
		
	//If we make a segmented enemy there'll be more than one sprite created
	word numcreated = addenemy(0, 0, ID, -10);
	
	if(numcreated == 0)
	{
		//ri->guyref = LONG_MAX;
		ri->guyref = 0;
		Z_scripterrlog("Couldn't create NPC \"%s\", screen NPC limit reached\n", guy_string[ID]);
	}
	else
	{
		word index = guys.Count() - numcreated; //Get the main enemy, not a segment
		ri->guyref = guys.spr(index)->getUID();
		
		for(; index<guys.Count(); index++)
			((enemy*)guys.spr(index))->script_spawned=true;
			
		Z_eventlog("Script created NPC \"%s\" with UID = %ld\n", guy_string[ID], ri->guyref);
	}
}

///----------------------------------------------------------------------------------------------------//
//Drawing & Sound

void do_message(const bool v)
{
	const long ID = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkMessage(ID, "Screen->Message") != SH::_NoError)
		return;
		
	if(ID == 0)
	{
		dismissmsg();
		msgfont = zfont;
		blockpath = false;
		Link.finishedmsg();
	}
	else
		donewmsg(ID);
}

INLINE void set_drawing_command_args(const int j, const word numargs)
{
	for(int k = 1; k <= numargs; k++)
		script_drawing_commands[j][k] = SH::read_stack(ri->sp + (numargs - k));
}

INLINE void set_user_bitmap_command_args(const int j, const word numargs)
{
	//ri->bitmapref = SH::read_stack(ri->sp+numargs);
	//zprint("Current drawing bitmap ref is: %d\n", ri->bitmapref );
	for(int k = 1; k <= numargs; k++)
		script_drawing_commands[j][k] = SH::read_stack(ri->sp + (numargs - k));
}

void do_drawing_command(const int script_command)
{
	int j = script_drawing_commands.GetNext();
	
	if(j == -1)  //out of drawing command space
	{
		Z_scripterrlog("Max draw primitive limit reached\n");
		return;
	}
	
	script_drawing_commands[j][0] = script_command;
	script_drawing_commands[j][18] = zscriptDrawingRenderTarget->GetCurrentRenderTarget(); // no fixed bs.
	
	switch(script_command)
	{
	case RECTR:
		set_drawing_command_args(j, 12);
		break;
		
	case CIRCLER:
		set_drawing_command_args(j, 11);
		break;
		
	case ARCR:
		set_drawing_command_args(j, 14);
		break;
		
	case ELLIPSER:
		set_drawing_command_args(j, 12);
		break;
		
	case LINER:
		set_drawing_command_args(j, 11);
		break;
		
	case PUTPIXELR:
		set_drawing_command_args(j, 8);
		break;
	
	case PIXELARRAYR:
	{
		set_drawing_command_args(j, 5);
		std::vector<long> *v = script_drawing_commands.GetVector();
		//for ( int q = 0; q < 6; q++ ) 
		//{ 
		//	zprint("PIXELARRAY script_drawing_commands[j][%d] is %d\n", q, script_drawing_commands[j][q]);
		//}
		int arrayptr = script_drawing_commands[j][2]/10000;
		if ( !arrayptr ) //Don't crash because of vector size.
		{
			Z_scripterrlog("Invalid array pointer %d passed to Screen->PutPixels(). Aborting.", arrayptr);
			break;
		}
		//zprint("Pixelarray array pointer is: %d\n", arrayptr);
		int sz = ArrayH::getSize(arrayptr);
		//FFCore.getSize(script_drawing_commands[j][2]/10000);
		//zprint("Pixelarray size is: %d\n", sz);
		v->resize(sz, 0);
		long* pos = &v->at(0);
		
		FFCore.getValues(script_drawing_commands[j][2] / 10000, pos, sz);
		script_drawing_commands[j].SetVector(v);
		break;
	}
	
	case TILEARRAYR:
	{
		set_drawing_command_args(j, 2);
		std::vector<long> *v = script_drawing_commands.GetVector();
		//for ( int q = 0; q < 6; q++ ) 
		//{ 
		//	zprint("PIXELARRAY script_drawing_commands[j][%d] is %d\n", q, script_drawing_commands[j][q]);
		//}
		int arrayptr = script_drawing_commands[j][2]/10000;
		if ( !arrayptr ) //Don't crash because of vector size.
		{
			Z_scripterrlog("Invalid array pointer %d passed to Screen->DrawTiles(). Aborting.", arrayptr);
			break;
		}
		//zprint("Pixelarray array pointer is: %d\n", arrayptr);
		int sz = ArrayH::getSize(arrayptr);
		//FFCore.getSize(script_drawing_commands[j][2]/10000);
		//zprint("Pixelarray size is: %d\n", sz);
		v->resize(sz, 0);
		long* pos = &v->at(0);
		
		FFCore.getValues(script_drawing_commands[j][2] / 10000, pos, sz);
		script_drawing_commands[j].SetVector(v);
		break;
		}
		
	case LINESARRAY:
	{
		set_drawing_command_args(j, 2);
		std::vector<long> *v = script_drawing_commands.GetVector();
		//for ( int q = 0; q < 6; q++ ) 
		//{ 
		//	zprint("PIXELARRAY script_drawing_commands[j][%d] is %d\n", q, script_drawing_commands[j][q]);
		//}
		int arrayptr = script_drawing_commands[j][2]/10000;
		if ( !arrayptr ) //Don't crash because of vector size.
		{
			Z_scripterrlog("Invalid array pointer %d passed to Screen->Lines(). Aborting.", arrayptr);
			break;
		}
		//zprint("Pixelarray array pointer is: %d\n", arrayptr);
		int sz = ArrayH::getSize(arrayptr);
		//FFCore.getSize(script_drawing_commands[j][2]/10000);
		//zprint("Pixelarray size is: %d\n", sz);
		v->resize(sz, 0);
		long* pos = &v->at(0);
		
		FFCore.getValues(script_drawing_commands[j][2] / 10000, pos, sz);
		script_drawing_commands[j].SetVector(v);
		break;
		}
	
		/*
		historical-old-master
		set_drawing_command_args(j, 6);
		int count = script_drawing_commands[j][2] / 10000; //todo: errcheck

		long* ptr = (long*)script_drawing_commands.AllocateDrawBuffer(3 * count * sizeof(long));
		long* p = ptr;

		FFCore.getValues(script_drawing_commands[j][3] / 10000, p, count); p += count;
		FFCore.getValues(script_drawing_commands[j][4] / 10000, p, count); p += count;
		FFCore.getValues(script_drawing_commands[j][5] / 10000, p, count);

		script_drawing_commands[j].SetPtr(ptr);
		*/
		// Unused
		//const int index = script_drawing_commands[j][19] = j;
		
		//std::array    *aptr = script_drawing_commands.GetString();
		//ArrayH::getString(script_drawing_commands[j][2] / 10000, *aptr);
		//script_drawing_commands[j].SetArray(aptr);
		//set_drawing_command_args(j, 2);
		//break;
		
	case COMBOARRAYR:
	{
		set_drawing_command_args(j, 2);
		std::vector<long> *v = script_drawing_commands.GetVector();
		//for ( int q = 0; q < 6; q++ ) 
		//{ 
		//	zprint("PIXELARRAY script_drawing_commands[j][%d] is %d\n", q, script_drawing_commands[j][q]);
		//}
		int arrayptr = script_drawing_commands[j][2]/10000;
		if ( !arrayptr ) //Don't crash because of vector size.
		{
			Z_scripterrlog("Invalid array pointer %d passed to Screen->DrawCombos(). Aborting.", arrayptr);
			break;
		}
		//zprint("Pixelarray array pointer is: %d\n", arrayptr);
		int sz = ArrayH::getSize(arrayptr);
		//FFCore.getSize(script_drawing_commands[j][2]/10000);
		//zprint("Pixelarray size is: %d\n", sz);
		v->resize(sz, 0);
		long* pos = &v->at(0);
		
		FFCore.getValues(script_drawing_commands[j][2] / 10000, pos, sz);
		script_drawing_commands[j].SetVector(v);
		break;
	}
	case POLYGONR:
	{
		set_drawing_command_args(j, 5);
			
		int arrayptr = script_drawing_commands[j][3]/10000;
		if ( !arrayptr ) //Don't crash because of vector size.
		{
			Z_scripterrlog("Invalid array pointer %d passed to Screen->Polygon(). Aborting.", arrayptr);
			break;
		}
		int sz = ArrayH::getSize(arrayptr);
			
		std::vector<long> *v = script_drawing_commands.GetVector();
		v->resize(sz, 0);
		
		long* pos = &v->at(0);
		
		
		FFCore.getValues(script_drawing_commands[j][3] / 10000, pos, sz);
		script_drawing_commands[j].SetVector(v);
	}
	break;
		
	case DRAWTILER:
		set_drawing_command_args(j, 15);
		break;
		
	case DRAWTILECLOAKEDR:
		set_drawing_command_args(j, 7);
		break;
		
	case DRAWCOMBOR:
		set_drawing_command_args(j, 16);
		break;
		
	case DRAWCOMBOCLOAKEDR:
		set_drawing_command_args(j, 7);
		break;
		
	case FASTTILER:
		set_drawing_command_args(j, 6);
		break;
		
	case FASTCOMBOR:
		set_drawing_command_args(j, 6);
		break;
		
	case DRAWCHARR:
		set_drawing_command_args(j, 10);
		break;
		
	case DRAWINTR:
		set_drawing_command_args(j, 11);
		break;
		
	case SPLINER:
		set_drawing_command_args(j, 11);
		break;
		
	case QUADR:
		set_drawing_command_args(j, 15);
		break;
		
	case TRIANGLER:
		set_drawing_command_args(j, 13);
		break;
		
	case BITMAPR:
		set_drawing_command_args(j, 12);
		break;
	
	case BITMAPEXR:
		set_drawing_command_args(j, 16);
		break;
		
	case DRAWLAYERR:
		set_drawing_command_args(j, 8);
		break;
		
	case DRAWSCREENR:
		set_drawing_command_args(j, 6);
		break;
		
	case QUAD3DR:
	{
		set_drawing_command_args(j, 8);
		int arrayptr = script_drawing_commands[j][2]/10000;
		int sz = ArrayH::getSize(arrayptr);
		arrayptr = script_drawing_commands[j][3]/10000;
		sz += ArrayH::getSize(arrayptr);
		arrayptr = script_drawing_commands[j][4]/10000;
		sz += ArrayH::getSize(arrayptr);
		arrayptr = script_drawing_commands[j][5]/10000;
		sz += ArrayH::getSize(arrayptr);
		std::vector<long> *v = script_drawing_commands.GetVector();
		v->resize(sz, 0);
		
		long* pos = &v->at(0);
		long* uv = &v->at(12);
		long* col = &v->at(20);
		long* size = &v->at(24);
		
		FFCore.getValues((script_drawing_commands[j][2] / 10000), pos, 12);
		FFCore.getValues((script_drawing_commands[j][3] / 10000), uv, 8);
		FFCore.getValues((script_drawing_commands[j][4] / 10000), col, 4);
		//FFCore.getValues2(script_drawing_commands[j][5] / 10000, size, 2);
		FFCore.getValues((script_drawing_commands[j][5] / 10000), size, 2);
		
		script_drawing_commands[j].SetVector(v);
	}
	break;
	
	case TRIANGLE3DR:
	{
		set_drawing_command_args(j, 8);
			
		int arrayptr = script_drawing_commands[j][2]/10000;
		int sz = ArrayH::getSize(arrayptr);
		arrayptr = script_drawing_commands[j][3]/10000;
		sz += ArrayH::getSize(arrayptr);
		arrayptr = script_drawing_commands[j][4]/10000;
		sz += ArrayH::getSize(arrayptr);
		arrayptr = script_drawing_commands[j][5]/10000;
		sz += ArrayH::getSize(arrayptr);
		
		std::vector<long> *v = script_drawing_commands.GetVector();
		v->resize(sz, 0);
		
		long* pos = &v->at(0);
		long* uv = &v->at(9);
		long* col = &v->at(15);
		long* size = &v->at(18);
		
		FFCore.getValues(script_drawing_commands[j][2] / 10000, pos, 8);
		FFCore.getValues(script_drawing_commands[j][3] / 10000, uv, 6);
		FFCore.getValues(script_drawing_commands[j][4] / 10000, col, 3);
		FFCore.getValues(script_drawing_commands[j][5] / 10000, size, 2);
		
		script_drawing_commands[j].SetVector(v);
	}
	break;
	
	case DRAWSTRINGR:
	{
		set_drawing_command_args(j, 9);
		// Unused
		//const int index = script_drawing_commands[j][19] = j;
		
		string *str = script_drawing_commands.GetString();
		ArrayH::getString(script_drawing_commands[j][8] / 10000, *str, 256);
		script_drawing_commands[j].SetString(str);
	}
	break;
	
	case DRAWSTRINGR2:
	{
		set_drawing_command_args(j, 11);
		// Unused
		//const int index = script_drawing_commands[j][19] = j;
		
		string *str = script_drawing_commands.GetString();
		ArrayH::getString(script_drawing_commands[j][8] / 10000, *str, 256);
		script_drawing_commands[j].SetString(str);
	}
	break;
	
	case BMPRECTR:	
		set_user_bitmap_command_args(j, 12); script_drawing_commands[j][17] = SH::read_stack(ri->sp+12); break;
		//Pop the args off the stack first. Then pop the pointer and push it to sdci[17]. 
		//The pointer for the bitmap variable (its literal value) is always ri->sp+numargs, so, with 12 args, it is sp+12. 
	case CLEARBITMAP:	
	{
		set_user_bitmap_command_args(j, 1);
		script_drawing_commands[j][17] = SH::read_stack(ri->sp+1); 
		break;
	}
	case BITMAPCLEARTOCOLOR:	
	{
		set_user_bitmap_command_args(j, 2);
		script_drawing_commands[j][17] = SH::read_stack(ri->sp+2); 
		break;
	}
	case REGENERATEBITMAP:	
	{
		set_user_bitmap_command_args(j, 3);
		script_drawing_commands[j][17] = SH::read_stack(ri->sp+3);
		break;
	}
	case BMPPOLYGONR:
	{
		set_user_bitmap_command_args(j, 5);
		script_drawing_commands[j][17] = SH::read_stack(ri->sp+5); 
		int arrayptr = script_drawing_commands[j][3]/10000;
		if ( !arrayptr ) //Don't crash because of vector size.
		{
			Z_scripterrlog("Invalid array pointer %d passed to Screen->Polygon(). Aborting.", arrayptr);
			break;
		}
		int sz = ArrayH::getSize(arrayptr);
			
		std::vector<long> *v = script_drawing_commands.GetVector();
		v->resize(sz, 0);
		
		long* pos = &v->at(0);
		
		
		FFCore.getValues(script_drawing_commands[j][3] / 10000, pos, sz);
		script_drawing_commands[j].SetVector(v);
	}
	break;
	case READBITMAP:	
	{
		//zprint("Calling %s\n","READBITMAP");
		set_user_bitmap_command_args(j, 2);
		script_drawing_commands[j][17] = SH::read_stack(ri->sp+2);
		string *str = script_drawing_commands.GetString();
		ArrayH::getString(script_drawing_commands[j][2] / 10000, *str, 256);
		
		//char cptr = new char[str->size()+1]; // +1 to account for \0 byte
		//strncpy(cptr, str->c_str(), str->size());
		
		if(get_bit(quest_rules, qr_BITMAP_AND_FILESYSTEM_PATHS_ALWAYS_RELATIVE))
		{
			char buf[2048] = {0};
			if(FFCore.get_scriptfile_path(buf, str->c_str()))
				(*str) = buf;
		}
		regulate_path(*str);
		
		//zprint("READBITMAP string is %s\n", cptr);
		
		script_drawing_commands[j].SetString(str);
		break;
	}
	case WRITEBITMAP:	
	{
		//zprint("Calling %s\n","WRITEBITMAP");
		set_user_bitmap_command_args(j, 3);
		script_drawing_commands[j][17] = SH::read_stack(ri->sp+3); 
		std::string *str = script_drawing_commands.GetString();
		ArrayH::getString(script_drawing_commands[j][2] / 10000, *str, 256);
		
		
		//char *cptr = new char[str->size()+1]; // +1 to account for \0 byte
		//strncpy(cptr, str->c_str(), str->size());
		
		if(get_bit(quest_rules, qr_BITMAP_AND_FILESYSTEM_PATHS_ALWAYS_RELATIVE))
		{
			char buf[2048] = {0};
			if(FFCore.get_scriptfile_path(buf, str->c_str()))
				(*str) = buf;
		}
		regulate_path(*str);
		
		//zprint("WRITEBITMAP string is %s\n", cptr);
		script_drawing_commands[j].SetString(str);
		break;
	}
	
	case BMPCIRCLER:	set_user_bitmap_command_args(j, 11); script_drawing_commands[j][17] = SH::read_stack(ri->sp+11);  break;
	case BMPARCR:	set_user_bitmap_command_args(j, 14); script_drawing_commands[j][17] = SH::read_stack(ri->sp+14);  break;
	case BMPELLIPSER:	set_user_bitmap_command_args(j, 12); script_drawing_commands[j][17] = SH::read_stack(ri->sp+12);  break;
	case BMPLINER:	set_user_bitmap_command_args(j, 11); script_drawing_commands[j][17] = SH::read_stack(ri->sp+11); break;
	case BMPSPLINER:	set_user_bitmap_command_args(j, 11); script_drawing_commands[j][17] = SH::read_stack(ri->sp+11); break;
	case BMPPUTPIXELR:	set_user_bitmap_command_args(j, 8); script_drawing_commands[j][17] = SH::read_stack(ri->sp+8); break;
	case BMPDRAWTILER:	set_user_bitmap_command_args(j, 15); script_drawing_commands[j][17] = SH::read_stack(ri->sp+15); break;
	case BMPDRAWTILECLOAKEDR:	set_user_bitmap_command_args(j, 7); script_drawing_commands[j][17] = SH::read_stack(ri->sp+7); break;
	case BMPDRAWCOMBOR:	set_user_bitmap_command_args(j, 16); script_drawing_commands[j][17] = SH::read_stack(ri->sp+16); break;
	case BMPDRAWCOMBOCLOAKEDR:	set_user_bitmap_command_args(j, 7); script_drawing_commands[j][17] = SH::read_stack(ri->sp+7); break;
	case BMPFASTTILER:	set_user_bitmap_command_args(j, 6); script_drawing_commands[j][17] = SH::read_stack(ri->sp+6); break;
	case BMPFASTCOMBOR:  set_user_bitmap_command_args(j, 6); script_drawing_commands[j][17] = SH::read_stack(ri->sp+6); break;
	case BMPDRAWCHARR:	set_user_bitmap_command_args(j, 10); script_drawing_commands[j][17] = SH::read_stack(ri->sp+10); break;
	case BMPDRAWINTR:	set_user_bitmap_command_args(j, 11); script_drawing_commands[j][17] = SH::read_stack(ri->sp+11); break;
	case BMPDRAWSTRINGR:	
	{
		set_user_bitmap_command_args(j, 9);
		script_drawing_commands[j][17] = SH::read_stack(ri->sp+9);
		// Unused
		//const int index = script_drawing_commands[j][19] = j;
		
		string *str = script_drawing_commands.GetString();
		ArrayH::getString(script_drawing_commands[j][8] / 10000, *str, 256);
		script_drawing_commands[j].SetString(str);
		
	}
	break;
	case BMPDRAWSTRINGR2:	
	{
		set_user_bitmap_command_args(j, 11);
		script_drawing_commands[j][17] = SH::read_stack(ri->sp+11);
		// Unused
		//const int index = script_drawing_commands[j][19] = j;
		
		string *str = script_drawing_commands.GetString();
		ArrayH::getString(script_drawing_commands[j][8] / 10000, *str, 256);
		script_drawing_commands[j].SetString(str);
		
	}
	break;
	case BMPQUADR:	set_user_bitmap_command_args(j, 16);  script_drawing_commands[j][17] = SH::read_stack(ri->sp+16); break;
	case BMPQUAD3DR:
	{
		set_drawing_command_args(j, 9);
		std::vector<long> *v = script_drawing_commands.GetVector();
		v->resize(26, 0);
		
		long* pos = &v->at(0);
		long* uv = &v->at(12);
		long* col = &v->at(20);
		long* size = &v->at(24);
		
		
		FFCore.getValues(script_drawing_commands[j][2] / 10000, pos, 12);
		FFCore.getValues(script_drawing_commands[j][3] / 10000, uv, 8);
		FFCore.getValues(script_drawing_commands[j][4] / 10000, col, 4);
		FFCore.getValues(script_drawing_commands[j][5] / 10000, size, 2);
		
		script_drawing_commands[j].SetVector(v);
		script_drawing_commands[j][17] = SH::read_stack(ri->sp+9);
		
	}
	break;
	case BMPTRIANGLER:	set_user_bitmap_command_args(j, 14); script_drawing_commands[j][17] = SH::read_stack(ri->sp+14); break;
	case BMPTRIANGLE3DR:
	{
		set_drawing_command_args(j, 9);
		
		std::vector<long> *v = script_drawing_commands.GetVector();
		v->resize(20, 0);
		
		long* pos = &v->at(0);
		long* uv = &v->at(9);
		long* col = &v->at(15);
		long* size = &v->at(18);
		
		
		FFCore.getValues(script_drawing_commands[j][2] / 10000, pos, 8);
		FFCore.getValues(script_drawing_commands[j][3] / 10000, uv, 6);
		FFCore.getValues(script_drawing_commands[j][4] / 10000, col, 3);
		FFCore.getValues(script_drawing_commands[j][5] / 10000, size, 2);
		
		script_drawing_commands[j].SetVector(v);
		script_drawing_commands[j][17] = SH::read_stack(ri->sp+9);
		break;
	}
	
	case BMPDRAWLAYERR:
	case BMPDRAWLAYERSOLIDR: 
	case BMPDRAWLAYERCFLAGR: 
	case BMPDRAWLAYERCTYPER: 
	case BMPDRAWLAYERCIFLAGR: 
	case BMPDRAWLAYERSOLIDITYR: set_user_bitmap_command_args(j, 9); script_drawing_commands[j][17] = SH::read_stack(ri->sp+9); break;
	case BMPDRAWSCREENR:
	case BMPDRAWSCREENSOLIDR:
	case BMPDRAWSCREENSOLID2R:
	case BMPDRAWSCREENCOMBOFR:
	case BMPDRAWSCREENCOMBOIR:
	case BMPDRAWSCREENCOMBOTR:
		set_user_bitmap_command_args(j, 6); script_drawing_commands[j][17] = SH::read_stack(ri->sp+6); break;
	case BITMAPGETPIXEL:
	{
		for(int q = 0; q < 20; q++)
		{
			Z_scripterrlog("getpixel SH::read_stack(ri->sp+%d) is: %d\n", q, SH::read_stack(ri->sp+q));
		}
		set_user_bitmap_command_args(j, 3); script_drawing_commands[j][17] = SH::read_stack(ri->sp+3); break;
	}
	case BMPBLIT:	
	{
		set_user_bitmap_command_args(j, 16); 
		//for(int q = 0; q < 8; ++q )
		//Z_scripterrlog("FFscript blit() ri->d[%d] is: %d\n", q, ri->d[q]);
		script_drawing_commands[j][17] = SH::read_stack(ri->sp+16);
		break;
	}
	case BMPBLITTO:	
	{
		set_user_bitmap_command_args(j, 16); 
		//for(int q = 0; q < 8; ++q )
		//Z_scripterrlog("FFscript blit() ri->d[%d] is: %d\n", q, ri->d[q]);
		script_drawing_commands[j][17] = SH::read_stack(ri->sp+16);
		break;
	}
	case BMPMODE7:	
	{
		set_user_bitmap_command_args(j, 13); 
		//for(int q = 0; q < 8; ++q )
		//Z_scripterrlog("FFscript blit() ri->d[%d] is: %d\n", q, ri->d[q]);
		script_drawing_commands[j][17] = SH::read_stack(ri->sp+13);
		break;
	}
	
	
	}
}

void do_set_rendertarget(bool)
{
	int target = int(SH::read_stack(ri->sp) / 10000);
	zscriptDrawingRenderTarget->SetCurrentRenderTarget(target);
}

void do_sfx(const bool v)
{
	long ID = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkSFXID(ID, "Game->PlaySound") != SH::_NoError)
		return;
		
	sfx(ID);
}

int FFScript::do_get_internal_uid_npc(int index)
{
	return ((int)guys.spr(index)->getUID());
}
int FFScript::do_get_internal_uid_item(int index)
{
	return ((int)items.spr(index)->getUID());
}
int FFScript::do_get_internal_uid_lweapon(int index)
{
	return ((int)Lwpns.spr(index)->getUID());
}
int FFScript::do_get_internal_uid_eweapon(int index)
{
	return ((int)Ewpns.spr(index)->getUID());
}

void FFScript::AlloffLimited(int flagset)
{
	clear_bitmap(msg_txt_display_buf);
	clear_bitmap(msg_bg_display_buf);
	clear_bitmap(msg_portrait_display_buf);
	set_clip_state(msg_txt_display_buf, 1);
	set_clip_state(msg_bg_display_buf, 1);
	set_clip_state(msg_portrait_display_buf, 1);
	
	
	clear_bitmap(pricesdisplaybuf);
	set_clip_state(pricesdisplaybuf, 1);
	
	if(items.idCount(iPile))
	{
		loadlvlpal(DMaps[currdmap].color);
	}
	
	/*
	
	#define warpFlagCLEARITEMS 0x200
	#define warpFlagCLEARGUYS 0x400
	#define warpFlagCLEARLWEAPONS 0x800
	#define warpFlagCLEAREWEAPONS 0x1000
	#define warpFlagCLEARHOOKSHOT 0x2000
	#define warpFlagCLEARDECORATIONS 0x4000
	#define warpFlagCLEARPARTICLES 0x8000
	*/
	
	if ( (flagset&warpFlagCLEARITEMS) ) items.clear();
	if ( (flagset&warpFlagCLEARGUYS) ) guys.clear();
	if ( (flagset&warpFlagCLEARLWEAPONS) ) Lwpns.clear();
	if ( (flagset&warpFlagCLEAREWEAPONS) ) Ewpns.clear();
	if ( (flagset&warpFlagCLEARHOOKSHOT) ) 
	{
		chainlinks.clear();
		Link.reset_hookshot();
	}
	if ( (flagset&warpFlagCLEARDECORATIONS) ) decorations.clear();
	if ( (flagset&warpFlagCLEARPARTICLES) ) particles.clear();
	clearScriptHelperData();
	
	
	
	clearScriptHelperData();
	
	lensclk = 0;
	lensid=-1;
	drawguys=Udown=Ddown=Ldown=Rdown=Adown=Bdown=Sdown=true;
	
	if(watch && !cheat_superman)
	{
		Link.setClock(false);
	}
	
	//  if(watch)
	//    Link.setClock(false);
	watch=freeze_guys=loaded_guys=loaded_enemies=blockpath=false;
	
	for(int i=0; i<176; i++)
		guygrid[i]=0;
		
	sle_clk=0;
	
	if(usebombpal)
	{
		memcpy(RAMpal, tempbombpal, PAL_SIZE*sizeof(RGB));
		refreshpal=true;
		usebombpal=false;
	}
	
	
}

//enum { warpFlagDONTKILLSCRIPTDRAWS, warpFlagDONTKILLSOUNDS, warpFlagDONTKILLMUSIC };
//enum { warpEffectNONE, warpEffectZap, warpEffectWave, warpEffectInstant, warpEffectMozaic, warpEffectOpen }; 
//valid warpTypes: tile, side, exit, cancel, instant
bool FFScript::warp_link(int warpType, int dmapID, int scrID, int warpDestX, int warpDestY, int warpEffect, int warpSound, int warpFlags, int linkFacesDir)
{
	zprint("FFScript::warp_link() arg %s is: %d \n", "warpType", warpType);
	zprint("FFScript::warp_link() arg %s is: %d \n", "dmapID", dmapID);
	zprint("FFScript::warp_link() arg %s is: %d \n", "scrID", scrID);
	zprint("FFScript::warp_link() arg %s is: %d \n", "warpDestX", warpDestX);
	zprint("FFScript::warp_link() arg %s is: %d \n", "warpDestY", warpDestY);
	zprint("FFScript::warp_link() arg %s is: %d \n", "warpEffect", warpEffect);
	zprint("FFScript::warp_link() arg %s is: %d \n", "warpSound", warpSound);
	zprint("FFScript::warp_link() arg %s is: %d \n", "warpFlags", warpFlags);
	zprint("FFScript::warp_link() arg %s is: %d \n", "linkFacesDir", linkFacesDir);
	if ( ((unsigned)dmapID) >= MAXDMAPS ) 
	{
		Z_scripterrlog("Invalid DMap ID (%d) passed to WarpEx(). Aborting.\n", dmapID);
		return false;
	}
	if ( ((unsigned)scrID) >= MAPSCRS ) 
	{
		Z_scripterrlog("Invalid Screen ID (%d) passed to WarpEx(). Aborting.\n", scrID);
		return false;
	}
	//Extra sanity guard. 
	if ( DMaps[dmapID].map*MAPSCRS+DMaps[dmapID].xoff+scrID >= (int)TheMaps.size() )
	{
		Z_scripterrlog("Invalid destination passed to WarpEx(). Aborting.\n");
		return false;
	}
	byte t = 0;
	t=(currscr<128)?0:1;
	bool overlay=false;
	bool intradmap = (dmapID == currdmap);
	int olddmap = currdmap;
	//if ( intradmap ) 
	//{
	//	initZScriptDMapScripts();    //Not needed.
	//}

	if ( warpType == wtNOWARP ) { Z_eventlog("Used a Cancel Warped to DMap %d: %s, screen %d", currdmap, DMaps[currdmap].name,currscr); return false; }
	int mapID = (DMaps[dmapID].map+1);
	int warp_return_index = -1;
	int dest_dmap_xoff = DMaps[dmapID].xoff;	
	//mapscr *m = &TheMaps[mapID * MAPSCRS + scrID]; 
	mapscr *m = &TheMaps[(zc_max((mapID)-1,0) * MAPSCRS + dest_dmap_xoff + scrID)];
	if ( warpFlags&warpFlagNOSTEPFORWARD ) FFCore.temp_no_stepforward = 1;
	int wx = 0, wy = 0;
	if ( warpDestX < 0 )
	{
		zprint("WarpEx() was set to warp return point:%d\n", warpDestY); 
		if ( (unsigned)warpDestY < 4 )
		{
			wx = m->warpreturnx[warpDestY];
			wy = m->warpreturny[warpDestY];
			zprint("WarpEx Return Point X is: %d\n",wx);
			zprint("WarpEx Return Point Y is: %d\n",wy);
		}
		else
		{
			if ( (unsigned)warpDestY == 5 )
			{
				//Pit warp
				wx = Link.getX();
				wy = Link.getY();
			}
			else
			{
				Z_scripterrlog("Invalid Warp Return Square Type (%d) provided as an arg to Link->WarpEx().\n",warpDestY);
				return false;
			}
		}
	}
	else 
	{
		if ( (unsigned)warpDestX < 256 && (unsigned)warpDestY < 176 )
		{
			wx = warpDestX;
			wy = warpDestY;
		}
		else
		{
			Z_scripterrlog("Invalid pixel coordinates of x = %d, y = %d, supplied to Link->WarpEx()\n",warpDestX,warpDestY);
			return false;
		}
		
	} 
	//zprint("FFCore.warp_link reached line: %d \n", 15918);
	//warp coordinates are wx, wy, not x, y! -Z
	if ( !(warpFlags&warpFlagDONTKILLSCRIPTDRAWS) ) script_drawing_commands.Clear();
	int wrindex = 0;
	//we also need to check if dmaps are sideview here! -Z
	//Likewise, we need to add that check to the normal Link:;dowarp(0
	bool wasSideview = isSideViewGravity(t); //((tmpscr[t].flags7 & fSIDEVIEW)!=0 || DMaps[currdmap].sideview) && !ignoreSideview;
	//zprint("FFCore.warp_link reached line: %d \n", 15925);
	//zprint("FFCore.warp_link war type is: %d \n", warpType);
	
	//int last_entr_scr = -1;
	//int last_entr_dmap = -1;
	
	if ( warpType < wtEXIT ) warpType = wtIWARP; //Sanity check. We can't use wtCave, or wtPassage, with scritped warps at present.
	
	switch(warpType)
	{
		
		//wtCAVE, wtPASS, wtEXIT, wtSCROLL, wtIWARP, wtIWARPBLK, wtIWARPOPEN,
		//wtIWARPZAP, wtIWARPWAVE, wtNOWARP, wtWHISTLE, wtMAX
			
		
		case wtIWARP:
		case wtIWARPBLK:
		case wtIWARPOPEN:
		case wtIWARPZAP:
		case wtIWARPWAVE: 
		{
			//zprint("FFCore.warp_link reached line: %d \n", 15936);
			bool wasswimming = (Link.getAction()==swimming);
			int olddiveclk = Link.diveclk;
			if ( !(warpFlags&warpFlagDONTCLEARSPRITES) )
			{
				ALLOFF();
			}
			else FFCore.AlloffLimited(warpFlags);
			if ( !(warpFlags&warpFlagDONTKILLMUSIC) ) music_stop();
			if ( !(warpFlags&warpFlagDONTKILLSOUNDS) ) kill_sfx();
			sfx(warpSound);
			if(wasswimming)
			{
				Link.setAction(swimming); FFCore.setLinkAction(swimming);
				Link.diveclk = olddiveclk;
			}
			//zprint("FFCore.warp_link reached line: %d \n", 15948);
			switch(warpEffect)
			{
				case warpEffectZap: zapout(); break;
				case warpEffectWave: wavyout(false); break;
				case warpEffectInstant: 
				{
					//bool b2 = COOLSCROLL&&cavewarp;
					//blackscr(30,b2?false:true);
					blackscr(30,true);
					break;
				}
				case warpEffectMozaic: 
				{
					
					break;
				}
				case warpEffectOpen:
				{
					
					break;
				}
				case warpEffectNONE:
				default: break;
			}
			//zprint("FFCore.warp_link reached line: %d \n", 15973);
			int c = DMaps[currdmap].color;
			currdmap = dmapID;
			dlevel = DMaps[currdmap].level;
			currmap = DMaps[currdmap].map;
			init_dmap();
			update_subscreens(dmapID);
			
			ringcolor(false);
			
			if(DMaps[currdmap].color != c)
				loadlvlpal(DMaps[currdmap].color);
				
			homescr = currscr = scrID + DMaps[currdmap].xoff;
			
			lightingInstant(); // Also sets naturaldark
			
			loadscr(0,currdmap,currscr,-1,overlay);
			
			Link.x = (zfix)wx;
			Link.y = (zfix)wy;
			
			switch(linkFacesDir)
			{
				case up:
				case down:
				case left:
				case right:
					Link.dir = linkFacesDir;
					break;
				default:
					if((int)Link.x==(zfix)0)  
					{
						Link.dir=right;
					}
					if((int)Link.x==(zfix)240) 
					{
						Link.dir=left;
					}
					
					if((int)Link.y==(zfix)0)   
					{
						Link.dir=down;
					}
					
					if((int)Link.y==(zfix)160) 
					{
						Link.dir=up;
					}
			}
			
			markBmap(Link.dir^1);
			
			if(iswater(MAPCOMBO((int)Link.x,(int)Link.y+8)) && _walkflag((int)Link.x,(int)Link.y+8,0) && current_item(itype_flippers))
			{
				Link.hopclk=0xFF;
				Link.attackclk = Link.charging = Link.spins = 0;
				Link.setAction(swimming); FFCore.setLinkAction(swimming);
			}
			else
			{
				Link.setAction(none); FFCore.setLinkAction(none);
			}
				
			//preloaded freeform combos
			ffscript_engine(true);
			
			putscr(scrollbuf,0,0,tmpscr);
			putscrdoors(scrollbuf,0,0,tmpscr);
			
			switch(warpEffect)
			{
				case warpEffectZap:  zapin(); break;
				case warpEffectWave: wavyin(); break;
				case warpEffectMozaic: 
				{
					
					break;
				}
				case warpEffectOpen:
				{
					openscreen();
					break;
				}
				case warpEffectNONE:
				default: break;
			}
			show_subscreen_life=true;
			show_subscreen_numbers=true;
			if ( !(warpFlags&warpFlagDONTKILLMUSIC) ) Play_Level_Music();
			currcset=DMaps[currdmap].color;
			dointro();
			Link.setEntryPoints((int)Link.x,(int)Link.y);
			
			break;
		}
		
		
		case wtEXIT:
		{
			//zprint("%s was called with a warp type of Entrance/Exit\n", "Link->WarpEx()");
			lighting(false,false,pal_litRESETONLY);//Reset permLit, and do nothing else; lighting was not otherwise called on a wtEXIT warp.
			ALLOFF();
			if ( !(warpFlags&warpFlagDONTKILLMUSIC) ) music_stop();
			if ( !(warpFlags&warpFlagDONTKILLSOUNDS) ) kill_sfx();
			sfx(warpSound);
			blackscr(30,false);
			currdmap = dmapID;
			dlevel=DMaps[currdmap].level;
			currmap=DMaps[currdmap].map;
			init_dmap();
			update_subscreens(dmapID);
			loadfullpal();
			ringcolor(false);
			loadlvlpal(DMaps[currdmap].color);
			//lastentrance_dmap = currdmap;
			homescr = currscr = scrID + DMaps[currdmap].xoff;
			loadscr(0,currdmap,currscr,-1,overlay);
			
			if(tmpscr->flags&fDARK)
			{
				if(get_bit(quest_rules,qr_FADE))
				{
				interpolatedfade();
				}
				else
				{
				loadfadepal((DMaps[currdmap].color)*pdLEVEL+poFADE3);
				}
				
				darkroom=naturaldark=true;
			}
			else
			{
				darkroom=naturaldark=false;
			}
				
			
			//Move Link's coordinates
			Link.x = (zfix)wx;
			Link.y = (zfix)wy;
			//set his dir
			switch(linkFacesDir)
			{
				case up:
				case down:
				case left:
				case right:
					Link.dir = linkFacesDir;
					break;
				default:
					Link.dir=down;
					if((int)Link.x==(zfix)0)  
					{
						Link.dir=right;
					}
					if((int)Link.x==(zfix)240) 
					{
						Link.dir=left;
					}
					
					if((int)Link.y==(zfix)0)   
					{
						Link.dir=down;
					}
					
					if((int)Link.y==(zfix)160) 
					{
						Link.dir=up;
					}
			}
			
			if(dlevel)
			{
				// reset enemy kill counts
				for(int i=0; i<128; i++)
				{
				game->guys[(currmap*MAPSCRSNORMAL)+i] = 0;
				game->maps[(currmap*MAPSCRSNORMAL)+i] &= ~mTMPNORET;
				}
			}
			
			markBmap(Link.dir^1);
			//preloaded freeform combos
			ffscript_engine(true);
			Link.reset_hookshot();
			
			if(isdungeon())
			{
				openscreen();
				if(get_bit(extra_rules, er_SHORTDGNWALK)==0)
				Link.stepforward(Link.diagonalMovement?11:12, false);
				else
				// Didn't walk as far pre-1.93, and some quests depend on that
				Link.stepforward(8, false);
			}
			else
			{
				openscreen();
			}
			
			show_subscreen_life=true;
			show_subscreen_numbers=true;
			Play_Level_Music();
			currcset=DMaps[currdmap].color;
			dointro();
			Link.setEntryPoints((int)Link.x,(int)Link.y);
			
			for(int i=0; i<6; i++)
				visited[i]=-1;
				
			//last_entr_scr = scrID;
			//last_entr_dmap = dmapID;
			
			break;
			
		}
		case wtSCROLL:                                          // scrolling warp
		{
			int c = DMaps[currdmap].color;
			scrolling_map = currmap;
			currmap = DMaps[dmapID].map;
			update_subscreens(dmapID);
			
			dlevel = DMaps[dmapID].level;
				//check if Link has the map for the new location before updating the subscreen. ? -Z
				//This works only in one direction, if Link had a map, to not having one.
				//If Link does not have a map, and warps somewhere where he does, then the map still briefly shows. 
			update_subscreens(dmapID);
				
			if ( has_item(itype_map, dlevel) ) 
			{
				//Blank the map during an intra-dmap scrolling warp. 
				dlevel = -1; //a hack for the minimap. This works!! -Z
			}
				
			// fix the scrolling direction, if it was a tile or instant warp
			Link.sdir = vbound(Link.dir,0,3);
			
			
			Link.scrollscr(Link.sdir, scrID+DMaps[dmapID].xoff, dmapID);
			dlevel = DMaps[dmapID].level; //Fix dlevel and draw the map (end hack). -Z
			
			Link.reset_hookshot();
			
			if(!intradmap)
			{
				currdmap = dmapID;
				dlevel = DMaps[currdmap].level;
				homescr = currscr = scrID + DMaps[dmapID].xoff;
				init_dmap();
				
				
				if(((wx>0||wy>0)||(get_bit(quest_rules,qr_WARPSIGNOREARRIVALPOINT)))&&(!get_bit(quest_rules,qr_NOSCROLLCONTINUE))&&(!(tmpscr->flags6&fNOCONTINUEHERE)))
				{
					if(dlevel)
					{
						lastentrance = currscr;
					}
					else
					{
						lastentrance = DMaps[currdmap].cont + DMaps[currdmap].xoff;
					}
					
					lastentrance_dmap = dmapID;
				}
			}
			
			if(DMaps[currdmap].color != c)
			{
				lighting(false, true);
			}
			
			Play_Level_Music();
			currcset=DMaps[currdmap].color;
			dointro();
			break;
		}
		//Cannot use these types with scripts, or with strings. 
		case wtCAVE:
		case wtPASS:
		case wtWHISTLE:
		default: 
		{
			Z_scripterrlog("Invalid warp type (%d) supplied to Hero->WarpEx()!. Cannot warp!!\n", warpType);
			return false;
		}
	}
	// Stop Link from drowning!
	if(Link.getAction()==drowning)
	{
		Link.drownclk=0;
		Link.setAction(none); FFCore.setLinkAction(none);
	}
		
	// But keep him swimming if he ought to be!
	if(Link.getAction()!=rafting && iswater(MAPCOMBO((int)Link.x,(int)Link.y+8)) && (_walkflag((int)Link.x,(int)Link.y+8,0) || get_bit(quest_rules,qr_DROWN))
			&& (current_item(itype_flippers)) && (Link.getAction()!=inwind))
	{
		Link.hopclk=0xFF;
		Link.setAction(swimming); FFCore.setLinkAction(swimming);
	}
		
	newscr_clk=frame;
	activated_timed_warp=false;
	eat_buttons();
		
	if(warpType!=wtIWARP) { Link.attackclk=0; }
		
	Link.didstuff=0;
	map_bkgsfx(true);
	loadside=Link.dir^1;
	whistleclk=-1;
		
	if((int)Link.z>0 && isSideViewLink())
	{
		Link.y-=Link.z;
		Link.z=0;
	}
	else if(!isSideViewLink())
	{
		Link.fall=0;
	}
		
	// If warping between top-down and sideview screens,
	// fix enemies that are carried over by Full Screen Warp
	const bool tmpscr_is_sideview = isSideViewGravity();
		
	if(!wasSideview && tmpscr_is_sideview)
	{
		for(int i=0; i<guys.Count(); i++)
		{
			if(guys.spr(i)->z > 0)
			{
			guys.spr(i)->y -= guys.spr(i)->z;
			guys.spr(i)->z = 0;
			}
			
			if(((enemy*)guys.spr(i))->family!=eeTRAP && ((enemy*)guys.spr(i))->family!=eeSPINTILE)
			guys.spr(i)->yofs += 2;
		}
	}
	else if(wasSideview && !tmpscr_is_sideview)
	{
		for(int i=0; i<guys.Count(); i++)
		{
			if(((enemy*)guys.spr(i))->family!=eeTRAP && ((enemy*)guys.spr(i))->family!=eeSPINTILE)
			guys.spr(i)->yofs -= 2;
		}
	}
	if ( warpType == wtEXIT )
	{
		//game->set_continue_scrn(DMaps[currdmap].cont + DMaps[currdmap].xoff);
		game->set_continue_scrn(scrID);
		game->set_continue_dmap(dmapID);
		lastentrance = scrID;
		//zprint("Setting Last Entrance to: %d\n", scrID);
		//zprint("lastentrance = %d\n",lastentrance);
		lastentrance_dmap = dmapID;
		//zprint("Setting Last Entrance DMap to: %d\n", dmapID);
		//zprint("lastentrance_dmap = %d\n",lastentrance_dmap);
		//lastentrance_dmap = currdmap;
		//lastentrance = game->get_continue_scrn();
	}
	else
	{
		if ( (warpFlags&warpFlagSETENTRANCESCREEN) ) lastentrance = scrID;
		if ( (warpFlags&warpFlagSETENTRANCEDMAP) ) lastentrance_dmap = dmapID;
		if ( (warpFlags&warpFlagSETCONTINUESCREEN) ) game->set_continue_scrn(scrID);
		if ( (warpFlags&warpFlagSETCONTINUEDMAP) ) game->set_continue_dmap(dmapID);
		
		
	}
	if(tmpscr->flags4&fAUTOSAVE)
	{
		save_game(true,0);
	}
		
	if(tmpscr->flags6&fCONTINUEHERE)
	{
		lastentrance_dmap = currdmap;
		lastentrance = homescr;
	}
		
	update_subscreens();
	verifyBothWeapons();
	Z_eventlog("Warped to DMap %d: %s, screen %d, via %s.\n", currdmap, DMaps[currdmap].name,currscr,
						warpType==wtEXIT ? "Entrance/Exit" :
						warpType==wtSCROLL ? "Scrolling Warp" :
						warpType==wtNOWARP ? "Cancel Warp" :
						"Insta-Warp");
						
	eventlog_mapflags();
	if ( !(warpFlags&warpFlagDONTRESTARTDMAPSCRIPT) || olddmap != currdmap) //Changed DMaps, or needs to reset the script
	{
		FFScript::deallocateAllArrays(SCRIPT_DMAP, olddmap);
		initZScriptDMapScripts();
	}
	return true;
	
	
	
}

void FFScript::do_adjustvolume(const bool v)
{
	long perc = (SH::get_arg(sarg1, v) / 10000);
	float pct = perc / 100.0;
	zprint("pct is: %f\n",pct);
	float temp_midi = 0;
	float temp_digi = 0;
	float temp_mus = 0;
	if ( !(coreflags&FFCORE_SCRIPTED_MIDI_VOLUME) ) 
	{
		zprint("FFCORE_SCRIPTED_MIDI_VOLUME: wasn't set\n");
		temp_midi = do_getMIDI_volume();
		zprint("temp_midi is %f\n", temp_midi);
		usr_midi_volume = do_getMIDI_volume();
		zprint("usr_midi_volume stored as %d\n", usr_midi_volume);
		SetFFEngineFlag(FFCORE_SCRIPTED_MIDI_VOLUME,true);
	}
	else 
	{
		temp_midi = (float)usr_midi_volume;
	}
	if ( !(coreflags&FFCORE_SCRIPTED_DIGI_VOLUME) ) 
	{
		temp_digi = do_getDIGI_volume();
		usr_digi_volume = do_getDIGI_volume();
		zprint("usr_music_volume stored as %d\n", usr_digi_volume);
		SetFFEngineFlag(FFCORE_SCRIPTED_DIGI_VOLUME,true);
	}
	else
	{
		temp_digi = (float)usr_digi_volume;
	}
	if ( !(coreflags&FFCORE_SCRIPTED_MUSIC_VOLUME) ) 
	{
		temp_mus = do_getMusic_volume();
		usr_music_volume = do_getMusic_volume();
		zprint("usr_music_volume stored as %d\n", usr_music_volume);
		SetFFEngineFlag(FFCORE_SCRIPTED_MUSIC_VOLUME,true);
	}
	else
	{
		temp_mus = (float)usr_music_volume;
	}
	
	temp_midi *= pct;
	temp_digi *= pct;
	temp_mus *= pct;
	zprint("temp_midi is: %f\n",temp_midi);
	zprint("temp_digi is: %f\n",temp_digi);
	zprint("temp_mus is: %f\n",temp_mus);
	do_setMIDI_volume((int)temp_midi);
	do_setDIGI_volume((int)temp_digi);
	do_setMusic_volume((int)temp_mus);
}

void FFScript::do_adjustsfxvolume(const bool v)
{
	long perc = (SH::get_arg(sarg1, v) / 10000);
	float pct = perc / 100.0;
	float temp_sfx = 0;
	if ( !(coreflags&FFCORE_SCRIPTED_SFX_VOLUME) ) 
	{
		temp_sfx = do_getSFX_volume();
		usr_sfx_volume = (int)temp_sfx;
		zprint("usr_sfx_volume stored as %d\n", usr_sfx_volume);
		SetFFEngineFlag(FFCORE_SCRIPTED_SFX_VOLUME,true);
	}
	else 
	{
		temp_sfx = (float)usr_sfx_volume;
	}
	temp_sfx *= pct;
	do_setSFX_volume((int)temp_sfx);
}
	

void do_midi(bool v)
{
	long MIDI = SH::get_arg(sarg1, v) / 10000;
	
	if(MIDI == 0)
		music_stop();
	else
		jukebox(MIDI + (ZC_MIDI_COUNT - 1));
}


void stop_sfx(const bool v)
{
	long ID = SH::get_arg(sarg1, v) / 10000;
	int sfx = (int)ID;
	if(BC::checkSFXID(ID, "Game->EndSound") != SH::_NoError)
		return;
	stop_sfx(sfx);
}

void pause_sfx(const bool v)
{
	long ID = SH::get_arg(sarg1, v) / 10000;
	int sfx = (int)ID;
	if(BC::checkSFXID(ID, "Game->PauseSound") != SH::_NoError)
		return;
	pause_sfx(sfx);
}

void resume_sfx(const bool v)
{
	long ID = SH::get_arg(sarg1, v) / 10000;
	int sfx = (int)ID;
	if(BC::checkSFXID(ID, "Game->ResumeSound") != SH::_NoError)
		return;
	resume_sfx(sfx);
}



void do_enh_music(bool v)
{
	long arrayptr = SH::get_arg(sarg1, v) / 10000;
	long track = (SH::get_arg(sarg2, v) / 10000)-1;
	
	if(arrayptr == 0)
		music_stop();
	else // Pointer to a string..
	{
		string filename_str;
		char filename_char[256];
		bool ret;
		ArrayH::getString(arrayptr, filename_str, 256);
		strncpy(filename_char, filename_str.c_str(), 255);
		filename_char[255]='\0';
		ret=try_zcmusic(filename_char, track, -1000);
		set_register(sarg2, ret ? 10000 : 0);
	}
}

void FFScript::do_playogg_ex(const bool v)
{
	long arrayptr = SH::get_arg(sarg1, v) / 10000;
	long track = (SH::get_arg(sarg2, v) / 10000)-1;
	
	if(arrayptr == 0)
		music_stop();
	else // Pointer to a string..
	{
		string filename_str;
		char filename_char[256];
		bool ret;
		ArrayH::getString(arrayptr, filename_str, 256);
		strncpy(filename_char, filename_str.c_str(), 255);
		filename_char[255]='\0';
		ret=try_zcmusic_ex(filename_char, track, -1000);
		set_register(sarg2, ret ? 10000 : 0);
	}
}

void FFScript::do_set_oggex_position(const bool v)
{
	long newposition = SH::get_arg(sarg1, v) / 10;
	
	set_zcmusicpos(newposition);
}

void FFScript::go_get_oggex_position()
{
	int pos = get_zcmusicpos()*10;
	zprint("ZC OGG Position is %d\n", pos);
	set_register(sarg1, pos);
}

void FFScript::do_set_oggex_speed(const bool v)
{
	long newspeed = SH::get_arg(sarg1, v) / 10;
	
	set_zcmusicspeed(newspeed);
}

void do_get_enh_music_filename(const bool v)
{
	long ID = SH::get_arg(sarg1, v) / 10000;
	long arrayptr = get_register(sarg2) / 10000;
	
	if(BC::checkDMapID(ID, "Game->GetDMapMusicFilename") != SH::_NoError)
		return;
		
	if(ArrayH::setArray(arrayptr, string(DMaps[ID].tmusic)) == SH::_Overflow)
		Z_scripterrlog("Array supplied to 'Game->GetDMapMusicFilename' not large enough\n");
}

void do_get_enh_music_track(const bool v)
{
	long ID = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkDMapID(ID, "Game->GetDMapMusicTrack") != SH::_NoError)
		return;
		
	set_register(sarg1, (DMaps[ID].tmusictrack+1)*10000);
}

void do_set_dmap_enh_music(const bool v)
{
	long ID   = SH::read_stack(ri->sp + 2) / 10000;
	long arrayptr = SH::read_stack(ri->sp + 1) / 10000;
	long track = (SH::read_stack(ri->sp + 0) / 10000)-1;
	string filename_str;
	
	if(BC::checkDMapID(ID, "Game->SetDMapEnhancedMusic") != SH::_NoError)
		return;
		
	ArrayH::getString(arrayptr, filename_str, 56);
	strncpy(DMaps[ID].tmusic, filename_str.c_str(), 55);
	DMaps[ID].tmusic[55]='\0';
	DMaps[ID].tmusictrack=track;
}






///----------------------------------------------------------------------------------------------------//
//Array & string related

void do_arraysize()
{
	long arrayptr = get_register(sarg1) / 10000;
	set_register(sarg1, ArrayH::getSize(arrayptr) * 10000);
}

void do_tobyte()
{
	int b1 = get_register(sarg1) / 10000;
	byte b2 = b1;
	set_register(sarg1, b2 * 10000);
}

void do_tosignedbyte()
{
	int b1 = get_register(sarg1) / 10000;
	signed char b2 = b1;
	set_register(sarg1, b2 * 10000);
}

void do_tointeger()
{
	int b1 = get_register(sarg1) / 10000;
	set_register(sarg1, b1 * 10000);
}

void do_floor()
{
	double b1 = get_register(sarg1) / 10000.0;
	int b2 = floor(b1);
	set_register(sarg1, b2 * 10000);
}

void do_ceiling()
{
	double b1 = get_register(sarg1) / 10000.0;
	int b2 = ceil(b1);
	set_register(sarg1, b2 * 10000);
}

void do_toword()
{
	int b1 = get_register(sarg1) / 10000;
	word b2 = b1;
	set_register(sarg1, b2 * 10000);
}

void do_toshort()
{
	int b1 = get_register(sarg1) / 10000;
	signed short b2 = b1;
	set_register(sarg1, b2 * 10000);
}

void do_getsavename()
{
	long arrayptr = get_register(sarg1) / 10000;
	
	if(ArrayH::setArray(arrayptr, string(game->get_name())) == SH::_Overflow)
		Z_scripterrlog("Array supplied to 'Game->GetSaveName' not large enough\n");
}

void do_setsavename()
{
	long arrayptr = get_register(sarg1) / 10000;
	
	string str;
	ArrayH::getString(arrayptr, str);
	byte j;
	
	for(j = 0; str[j] != '\0'; j++)
	{
		if(j >= 8)
		{
			Z_scripterrlog("String supplied to 'Game->GetSaveName' too large\n");
			break;
		}
		
		game->get_name()[j] = str[j];
	}
	
	game->get_name()[j] = '\0';
}

void do_getmessage(const bool v)
{
	long ID = SH::get_arg(sarg1, v) / 10000;
	long arrayptr = get_register(sarg2) / 10000;
	
	if(BC::checkMessage(ID, "Game->GetMessage") != SH::_NoError)
		return;
		
	if(ArrayH::setArray(arrayptr, string(MsgStrings[ID].s)) == SH::_Overflow)
		Z_scripterrlog("Array supplied to 'Game->GetMessage' not large enough\n");
}



void do_setmessage(const bool v)
{
	long ID = SH::get_arg(sarg1, v) / 10000;
	long arrayptr = get_register(sarg2) / 10000;
	
	if(BC::checkMessage(ID, "Game->SetMessage") != SH::_NoError)
		return;
	
	string filename_str;
	
	ArrayH::getString(arrayptr, filename_str, 73);
	strncpy(MsgStrings[ID].s, filename_str.c_str(), 72);
	MsgStrings[ID].s[72]='\0';
}


void do_getdmapname(const bool v)
{
	long ID = SH::get_arg(sarg1, v) / 10000;
	long arrayptr = get_register(sarg2) / 10000;
	
	if(BC::checkDMapID(ID, "Game->GetDMapName") != SH::_NoError)
		return;
		
	if(ArrayH::setArray(arrayptr, string(DMaps[ID].name)) == SH::_Overflow)
		Z_scripterrlog("Array supplied to 'Game->GetDMapName' not large enough\n");
}

void do_setdmapname(const bool v)
{
	long ID = SH::get_arg(sarg1, v) / 10000;
	long arrayptr = get_register(sarg2) / 10000;

	string filename_str;
	
	if(BC::checkDMapID(ID, "Game->Game->SetDMapName") != SH::_NoError)
		return;
		
	ArrayH::getString(arrayptr, filename_str, 73);
	strncpy(DMaps[ID].name, filename_str.c_str(), 72);
	DMaps[ID].name[72]='\0';
}

void do_getdmaptitle(const bool v)
{
	long ID = SH::get_arg(sarg1, v) / 10000;
	long arrayptr = get_register(sarg2) / 10000;
	
	if(BC::checkDMapID(ID, "Game->GetDMapTitle") != SH::_NoError)
		return;
		
	if(ArrayH::setArray(arrayptr, string(DMaps[ID].title)) == SH::_Overflow)
		Z_scripterrlog("Array supplied to 'Game->GetDMapTitle' not large enough\n");
}


void do_setdmaptitle(const bool v)
{
	long ID = SH::get_arg(sarg1, v) / 10000;
	long arrayptr = get_register(sarg2) / 10000;
	string filename_str;
	
	if(BC::checkDMapID(ID, "Game->Game->SetDMapTitle") != SH::_NoError)
		return;
		
	ArrayH::getString(arrayptr, filename_str, 21);
	strncpy(DMaps[ID].title, filename_str.c_str(), 20);
	DMaps[ID].title[20]='\0';
}

void do_getdmapintro(const bool v)
{
	long ID = SH::get_arg(sarg1, v) / 10000;
	long arrayptr = get_register(sarg2) / 10000;
	
	if(BC::checkDMapID(ID, "Game->GetDMapIntro") != SH::_NoError)
		return;
		
	if(ArrayH::setArray(arrayptr, string(DMaps[ID].intro)) == SH::_Overflow)
		Z_scripterrlog("Array supplied to 'Game->GetDMapIntro' not large enough\n");
}


void do_setdmapintro(const bool v)
{
	long ID = SH::get_arg(sarg1, v) / 10000;
	long arrayptr = get_register(sarg2) / 10000;
	string filename_str;
	
	if(BC::checkDMapID(ID, "Game->Game->SetDMapIntro") != SH::_NoError)
		return;
		
	ArrayH::getString(arrayptr, filename_str, 73);
	strncpy(DMaps[ID].intro, filename_str.c_str(), 72);
	DMaps[ID].intro[72]='\0';
}

//Set npc and item names t.b.a. -Z

void do_getitemname()
{
	long arrayptr = get_register(sarg1) / 10000;
	
	if(ArrayH::setArray(arrayptr, item_string[ri->idata]) == SH::_Overflow)
		Z_scripterrlog("Array supplied to 'itemdata->GetName' not large enough\n");
}

void do_getnpcname()
{
	long arrayptr = get_register(sarg1) / 10000;
	
	if(GuyH::loadNPC(ri->guyref, "npc->GetName") != SH::_NoError)
		return;
		
	word ID = (GuyH::getNPC()->id & 0xFFF);
	
	if(ArrayH::setArray(arrayptr, guy_string[ID]) == SH::_Overflow)
		Z_scripterrlog("Array supplied to 'npc->GetName' not large enough\n");
}

//npcdata->GetName
void FFScript::do_getnpcdata_getname()
{
	long arrayptr = get_register(sarg1) / 10000;
	int npc_id = ri->npcdataref;
	if((unsigned)npc_id > 511)
	{
		Z_scripterrlog("Invalid npc ID (%d) passed to npcdata->GetName().\n", npc_id);
		return;
	}
		
	if(ArrayH::setArray(arrayptr, guy_string[npc_id]) == SH::_Overflow)
		Z_scripterrlog("Array supplied to 'npcdata->GetName()' not large enough\n");
}

void do_getffcscript()
{
	long arrayptr = get_register(sarg1) / 10000;
	string name;
	int num=-1;
	ArrayH::getString(arrayptr, name, 256); // What's the limit on name length?
	
	for(int i=0; i<NUMSCRIPTFFC; i++)
	{
		if(strcmp(name.c_str(), ffcmap[i].scriptname.c_str())==0)
		{
			num=i+1;
			break;
		}
	}
	
	set_register(sarg1, num * 10000);
}

void do_npc_link_in_range()
{
	int dist = get_register(sarg1) / 10000;
	zprint("LinkInrange dist is: %d\n", dist);
	//bool in_range = false;
	if(GuyH::loadNPC(ri->guyref, "npc->LinedUp()") == SH::_NoError)
	{
		//long range = (ri->d[0] / 10000);
		//bool dir8 = (ri->d[1]);
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		//in_range = (e->LinkInRange(dist));
		zprint("LinkInRange returned: %s\n", (GuyH::getNPC()->LinkInRange(dist) ? "true" : "false"));
		bool in_range = GuyH::getNPC()->LinkInRange(dist);
		//set_register(sarg2, in_range ? 10000 : 0); //This isn't setting the right value, it seems. 
		//set_register(sarg1, (in_range ? 10000 : 0));
		set_register(sarg1, 0);
	}
	else set_register(sarg1, 0);
}

void do_getitemscript()
{
	 long arrayptr = get_register(sarg1) / 10000;
	string name;
	int num=-1;
	ArrayH::getString(arrayptr, name, 256); // What's the limit on name length?
	
	for(int i=0; i<512; i++)
	{
		if(strcmp(name.c_str(), itemmap[i].scriptname.c_str())==0)
		{
			num=i+1;
			break;
		}
	}
	
	set_register(sarg1, num * 10000);
}

///----------------------------------------------------------------------------------------------------//
//Tile Manipulation

void do_copytile(const bool v, const bool v2)
{
	long tile = SH::get_arg(sarg1, v) / 10000;
	long tile2 = SH::get_arg(sarg2, v2) / 10000;
	
	copy_tile(newtilebuf, tile, tile2, false);
}

int FFScript::IsBlankTile(int i)
{
	if( ((unsigned)i) > NEWMAXTILES )
	{
		Z_scripterrlog("Invalid tile ID (%d) passed to Graphics->IsBlankTile[]\n");
		return -1;
	}
	    
	byte *tilestart=newtilebuf[i].data;
	qword *di=(qword*)tilestart;
	int parts=tilesize(newtilebuf[i].format)>>3;
    
	for(int j=0; j<parts; ++j, ++di)
	{
		if(*di!=0)
		{
			return 0;
		}
	}
    
	return 1;
}

void do_swaptile(const bool v, const bool v2)
{
	long tile = SH::get_arg(sarg1, v) / 10000;
	long tile2 = SH::get_arg(sarg2, v2) / 10000;
	
	copy_tile(newtilebuf, tile, tile2, true);
}

void do_overlaytile(const bool v, const bool v2)
{
	long tile = SH::get_arg(sarg1, v) / 10000;
	long tile2 = SH::get_arg(sarg2, v2) / 10000;
	
	if(BC::checkTile(tile, "OverlayTile") != SH::_NoError ||
			BC::checkTile(tile2, "OverlayTile") != SH::_NoError)
		return;
		
	//Could add an arg for the CSet or something instead of just passing 0, currently only 8-bit is supported
	overlay_tile(newtilebuf, tile, tile2, 0, false);
}

void do_fliprotatetile(const bool v, const bool v2)
{
	long tile = SH::get_arg(sarg1, v) / 10000;
	long tile2 = SH::get_arg(sarg2, v2) / 10000;
	
	if(BC::checkTile(tile, "FlipRotateTile") != SH::_NoError ||
			BC::checkTile(tile2, "FlipRotateTile") != SH::_NoError)
		return;
		
	//fliprotatetile
}

void do_settilepixel(const bool v)
{
	long tile = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkTile(tile, "SetTilePixel") != SH::_NoError)
		return;
		
	//settilepixel
}

void do_gettilepixel(const bool v)
{
	long tile = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkTile(tile, "GetTilePixel") != SH::_NoError)
		return;
		
	//gettilepixel
}

void do_shifttile(const bool v, const bool v2)
{
	long tile = SH::get_arg(sarg1, v) / 10000;
	long tile2 = SH::get_arg(sarg2, v2) / 10000;
	
	if(BC::checkTile(tile, "ShiftTile") != SH::_NoError ||
			BC::checkTile(tile2, "ShiftTile") != SH::_NoError)
		return;
		
	//shifttile
}

void do_cleartile(const bool v)
{
	long tile = SH::get_arg(sarg1, v) / 10000;
	
	if(BC::checkTile(tile, "ClearTile") != SH::_NoError)
		return;
		
	reset_tile(newtilebuf, tile, newtilebuf[tile].format);
}

void do_combotile(const bool v)
{
	long combo = SH::get_arg(sarg2, v) / 10000;
	
	if(BC::checkCombo(combo, "Game->ComboTile") != SH::_NoError)
		return;
		
	set_register(sarg1, combobuf[combo].tile * 10000);
}

void do_readpod(const bool v)
{
	long indx = SH::get_arg(sarg2, v) / 10000;
	set_register(sarg1, ArrayH::getElement(ri->d[0] / 10000, indx));
}
void do_writepod(const bool v1, const bool v2)
{
	long indx = SH::get_arg(sarg1, v1) / 10000;
	long val = SH::get_arg(sarg2, v2);
	ArrayH::setElement(ri->d[0] / 10000, indx, val);
}

bool zasm_advance()
{
	if( zc_readrawkey(KEY_INSERT, true) )
	{
		if(zc_getrawkey(KEY_LSHIFT, true) || zc_getrawkey(KEY_RSHIFT, true))
		{
			if(zc_getrawkey(KEY_LCONTROL, true) || zc_getrawkey(KEY_RCONTROL, true))
			{
				FFCore.zasm_break_mode = ZASM_BREAK_SKIP_SCRIPT;
			}
			else FFCore.zasm_break_mode = ZASM_BREAK_ADVANCE_SCRIPT;
		}
		else if(zc_getrawkey(KEY_ALT, true) || zc_getrawkey(KEY_ALTGR, true))
		{
			if(zc_getrawkey(KEY_LCONTROL, true) || zc_getrawkey(KEY_RCONTROL, true))
			{
				FFCore.zasm_break_mode = ZASM_BREAK_SKIP;
			}
			else FFCore.zasm_break_mode = ZASM_BREAK_NONE;
		}
		else if(zc_getrawkey(KEY_LCONTROL, true) || zc_getrawkey(KEY_RCONTROL, true))
		{
			FFCore.ZASMPrint(false); //Close debugger
			FFCore.zasm_break_mode = ZASM_BREAK_NONE;
		}
		return true;
	}
	if(!zasm_debugger)
	{
		FFCore.zasm_break_mode = ZASM_BREAK_NONE;
		return true;
	}
	return false;
}

///----------------------------------------------------------------------------------------------------//
//                                       Run the script                                                //
///----------------------------------------------------------------------------------------------------//

// Let's do this
int run_script(const byte type, const word script, const long i)
{
	if(Quit==qRESET || Quit==qEXIT) // In case an earlier script hung
		return RUNSCRIPT_ERROR;
	
	curScriptType=type;
	curScriptNum=script;
	numInstructions=0;
#ifdef _SCRIPT_COUNTER
	dword script_timer[NUMCOMMANDS];
	dword script_execount[NUMCOMMANDS];
	
	for(int j = 0; j < NUMCOMMANDS; j++)
	{
		script_timer[j]=0;
		script_execount[j]=0;
	}
	
	dword start_time, end_time;
	
	script_counter = 0;
#endif
	
	switch(type)
	{
		//Z_scripterrlog("The script type is: %d\n", type);
		case SCRIPT_FFC:
		{
			ri = &(ffcScriptData[i]);
			
			curscript = ffscripts[script];
			stack = &(ffc_stack[i]);
			
			if(!tmpscr->initialized[i])
			{
				memcpy(ri->d, tmpscr->initd[i], 8 * sizeof(long));
				memcpy(ri->a, tmpscr->inita[i], 2 * sizeof(long));
			}
			
			ri->ffcref = i; //'this' pointer
		}
		break;
		case SCRIPT_NPC:
		{
			int npc_index = GuyH::getNPCIndex(i);
			enemy *w = (enemy*)guys.spr(npc_index);
			
			ri = &(guys.spr(GuyH::getNPCIndex(i))->scriptData);
			
			curscript = guyscripts[guys.spr(GuyH::getNPCIndex(i))->script];
			
			stack = &(guys.spr(GuyH::getNPCIndex(i))->stack);
			
			enemy *wa = (enemy*)guys.spr(GuyH::getNPCIndex(i));
			ri->guyref = wa->getUID();
			
			if (!(guys.spr(GuyH::getNPCIndex(i))->initialised))
			{
				al_trace("(guys.spr(GuyH::getNPCIndex(i))->initialised) is %d\n",(guys.spr(GuyH::getNPCIndex(i))->initialised));
				
				for ( int q = 0; q < 8; q++ ) 
				{
					ri->d[q] = wa->initD[q];
				}
				guys.spr(GuyH::getNPCIndex(i))->initialised = 1;
			}
		}
		break;
		
		case SCRIPT_LWPN:
		{
			int lwpn_index = LwpnH::getLWeaponIndex(i);
			weapon *w = (weapon*)Lwpns.spr(lwpn_index);
			ri = &(Lwpns.spr(LwpnH::getLWeaponIndex(i))->scriptData);
			
			curscript = lwpnscripts[Lwpns.spr(LwpnH::getLWeaponIndex(i))->weaponscript];
		
			stack = &(Lwpns.spr(LwpnH::getLWeaponIndex(i))->stack);
			
			weapon *wa = (weapon*)Lwpns.spr(LwpnH::getLWeaponIndex(i));
			ri->lwpn = wa->getUID();
			
			if (!(Lwpns.spr(LwpnH::getLWeaponIndex(i))->initialised))
			{
				al_trace("(Lwpns.spr(LwpnH::getLWeaponIndex(i))->initialised) is %d\n",(Lwpns.spr(LwpnH::getLWeaponIndex(i))->initialised));
				for ( int q = 0; q < 8; q++ ) 
				{
	
					ri->d[q] = Lwpns.spr(LwpnH::getLWeaponIndex(i))->weap_initd[q]; //w->initiald[q];
				}
				Lwpns.spr(LwpnH::getLWeaponIndex(i))->initialised = 1;
			}
			
		}
		break;
		
		case SCRIPT_EWPN:
		{
			int ewpn_index = EwpnH::getEWeaponIndex(i);

			weapon *w = (weapon*)Ewpns.spr(ewpn_index);
			ri = &(Ewpns.spr(EwpnH::getEWeaponIndex(i))->scriptData);
			
			curscript = ewpnscripts[Ewpns.spr(EwpnH::getEWeaponIndex(i))->weaponscript];
			
			
			stack = &(Ewpns.spr(EwpnH::getEWeaponIndex(i))->stack);
			
			weapon *wa = (weapon*)Ewpns.spr(EwpnH::getEWeaponIndex(i));
			ri->ewpn = wa->getUID();
			if (!(Ewpns.spr(EwpnH::getEWeaponIndex(i))->initialised))
			{
				al_trace("(Ewpns.spr(EwpnH::getEWeaponIndex(i))->initialised) is %d\n",(Ewpns.spr(EwpnH::getEWeaponIndex(i))->initialised));
				for ( int q = 0; q < 8; q++ ) 
				{
					
					ri->d[q] = Ewpns.spr(EwpnH::getEWeaponIndex(i))->weap_initd[q]; //w->initiald[q];
				}
				Ewpns.spr(EwpnH::getEWeaponIndex(i))->initialised = 1;
			}
			
		}
		break;
		
		case SCRIPT_ITEMSPRITE:
		{
			int the_index = ItemH::getItemIndex(i);
			
			item *w = (item*)items.spr(the_index);
			ri = &(items.spr(ItemH::getItemIndex(i))->scriptData);
		
			curscript = itemspritescripts[items.spr(ItemH::getItemIndex(i))->script]; //Set the editor sprite script field to 'script'
				
			stack = &(items.spr(ItemH::getItemIndex(i))->stack);
			
			item *wa = (item*)items.spr(ItemH::getItemIndex(i));
			ri->itemref = wa->getUID();
			if (!(items.spr(ItemH::getItemIndex(i))->initialised))
			{
				al_trace("(items.spr(ItemH::getItemIndex(i))->initialised) is %d\n",(items.spr(ItemH::getItemIndex(i))->initialised));
				for ( int q = 0; q < 8; q++ ) 
				{
					
					ri->d[q] = items.spr(ItemH::getItemIndex(i))->initD[q]; //w->initiald[q];
				}
				items.spr(ItemH::getItemIndex(i))->initialised = 1;
			}
			
		}
		break;
		
		case SCRIPT_ITEM:
		{
			int new_i = 0;
			bool collect = ( ( i < 1 ) || (i == COLLECT_SCRIPT_ITEM_ZERO) );
			new_i = ( collect ) ? (( i != COLLECT_SCRIPT_ITEM_ZERO ) ? (i * -1) : 0) : i;
			
			ri = ( collect ) ? &(itemCollectScriptData[new_i]) : &(itemScriptData[i]);
			
			curscript = itemscripts[script];
			stack = ( collect ) ?  &(item_collect_stack[new_i]) : &(item_stack[i]);
			
			if ( !(itemscriptInitialised[new_i]) )
			{
				al_trace("itemscriptInitialised[new_i] is %d\n",itemscriptInitialised[new_i]);
				memcpy(ri->d, ( collect ) ? itemsbuf[new_i].initiald : itemsbuf[i].initiald, 8 * sizeof(long));
				memcpy(ri->a, ( collect ) ? itemsbuf[new_i].initiala : itemsbuf[i].initiala, 2 * sizeof(long));
				itemscriptInitialised[new_i] = 1;
			}			
			ri->idata = ( collect ) ? new_i : i; //'this' pointer
			
		}
		break;
		
		case SCRIPT_GLOBAL:
		{
			ri = &globalScriptData[script];
			
			curscript = globalscripts[script];
			stack = &global_stack[script];
			//
		}
		break;
		
		case SCRIPT_LINK:
		{
			ri = &linkScriptData;
			
			curscript = linkscripts[script];
			stack = &link_stack;
			//
		}
		break;
		
		case SCRIPT_DMAP:
		{
			ri = &dmapScriptData;
			curscript = dmapscripts[script];
			stack = &dmap_stack;
			ri->dmapsref = i;
			//how do we clear initialised on dmap change?
			if ( !dmapscriptInitialised )
			{
				for ( int q = 0; q < 8; q++ ) 
				{
					ri->d[q] = DMaps[ri->dmapsref].initD[q];// * 10000;
				}
				dmapscriptInitialised = 1;
			}
		}
		break;
		
		case SCRIPT_ACTIVESUBSCREEN:
		{
			ri = &activeSubscreenScriptData;
			curscript = dmapscripts[script];
			stack = &active_subscreen_stack;
			ri->dmapsref = i;
			if ( !activeSubscreenInitialised )
			{
				for ( int q = 0; q < 8; q++ ) 
				{
					ri->d[q] = DMaps[ri->dmapsref].sub_initD[q];
				}
				activeSubscreenInitialised = 1;
			}
		}
		break;
		
		case SCRIPT_PASSIVESUBSCREEN:
		{
			ri = &passiveSubscreenScriptData;
			curscript = dmapscripts[script];
			stack = &passive_subscreen_stack;
			ri->dmapsref = i;
			if ( !passiveSubscreenInitialised )
			{
				for ( int q = 0; q < 8; q++ ) 
				{
					ri->d[q] = DMaps[ri->dmapsref].sub_initD[q];
				}
				passiveSubscreenInitialised = 1;
			}
		}
		break;
		
		case SCRIPT_SCREEN:
		{
			ri = &(screenScriptData);
			curscript = screenscripts[script];
			stack = &(screen_stack);
			if ( !tmpscr->screendatascriptInitialised )
			{
				al_trace("tmpscr->screendatascriptInitialised is %d\n",tmpscr->screendatascriptInitialised);
				for ( int q = 0; q < 8; q++ ) 
				{
					ri->d[q] = tmpscr->screeninitd[q];// * 10000;
				}
				tmpscr->screendatascriptInitialised = 1;
			}
			
		}
		break;
		
		case SCRIPT_COMBO:
		{
			ri = &(comboScriptData[i]);

			curscript = comboscripts[script];
			stack = &(combo_stack[i]);
			int pos = ((i%176));
			int lyr = i/176;
			int id = comboscript_combo_ids[i]; 

			if(!(combo_initialised[pos] & (1<<lyr)))
			{
				memset(ri->d, 0, 8 * sizeof(long));
				for ( int q = 0; q < 2; q++ )
					ri->d[q] = combobuf[id].initd[q];
				combo_initialised[pos] |= 1<<lyr;
			}

			ri->combosref = id; //'this' pointer
			ri->comboposref = i; //used for X(), Y(), Layer(), and so forth.
			break;
		}
		
		default:
		{
			al_trace("No other scripts are currently supported\n");
			return RUNSCRIPT_ERROR;
		}
	}
	
	//dword pc = ri->pc; //this is (marginally) quicker than dereferencing ri each time
	word scommand = curscript->zasm[ri->pc].command;
	sarg1 = curscript->zasm[ri->pc].arg1;
	sarg2 = curscript->zasm[ri->pc].arg2;
	
	
#ifdef _FFDISSASSEMBLY
	
	if(scommand != 0xFFFF)
	{
#ifdef _FFONESCRIPTDISSASSEMBLY
		zc_trace_clear();
#endif
		
		switch(type)
		{
		case SCRIPT_FFC:
			al_trace("\nStart of FFC script %i processing on FFC %i:\n", script, i);
			break;
			
		case SCRIPT_ITEM:
			al_trace("\nStart of item script %i processing:\n", script);
			break;
			
		case SCRIPT_GLOBAL:
			al_trace("\nStart of global script %I processing:\n", script);
			break;
		}
	}
	
#endif
	
	bool increment = true;
	
	if( FFCore.zasm_break_mode == ZASM_BREAK_ADVANCE_SCRIPT || FFCore.zasm_break_mode == ZASM_BREAK_SKIP_SCRIPT )
	{
		if( zasm_debugger )
		{
			//Halt on new script if set to advance to next script
			FFCore.zasm_break_mode = ZASM_BREAK_HALT;
			FFCore.TraceScriptIDs(true);
			#ifdef _WIN32
			coloured_console.cprintf((CConsoleLoggerEx::COLOR_RED | 
				CConsoleLoggerEx::COLOR_BACKGROUND_BLACK),"Breaking for script start\n");
			#endif
		}
		else FFCore.zasm_break_mode = ZASM_BREAK_NONE;
	}
	else if( zasm_debugger && !(SKIPZASMPRINT()))
	{
		//Print new script metadata when starting script
		FFCore.TraceScriptIDs(true);
		#ifdef _WIN32
		coloured_console.cprintf((CConsoleLoggerEx::COLOR_RED | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK),"Start of script\n");
		#endif
	}
	
	while(scommand != 0xFFFF && scommand != WAITFRAME && scommand != WAITDRAW)
	{
		numInstructions++;
		if(numInstructions==hangcount) // No need to check frequently
		{
			numInstructions=0;
			checkQuitKeys();
			if(Quit)
				scommand=0xFFFF;
		}
		
		//Handle manual breaking
		if( zasm_debugger && zc_readrawkey(KEY_INSERT, true))
			FFCore.zasm_break_mode = ZASM_BREAK_HALT;
		//Break
		while( FFCore.zasm_break_mode == ZASM_BREAK_HALT )
		{
			if(zasm_advance()) break;
			checkQuitKeys();
			if(Quit)
			{
				scommand=0xFFFF;
				break;
			}
		}
#ifdef _FFDEBUG
#ifdef _FFDISSASSEMBLY
		ffdebug::print_dissassembly(scommand);
#endif
#ifdef _SCRIPT_COUNTER
		start_time = script_counter;
#endif
#endif
	  
		if ( zasm_debugger ) FFCore.ZASMPrintCommand(scommand);
		switch(scommand)
		{
			//always first
			case 0xFFFF:  //invalid command
			{
				switch(type)
				{
					case SCRIPT_FFC:
						zprint("%s Script %s has exited.\n", script_types[type], ffcmap[i].scriptname.c_str()); break;
					case SCRIPT_NPC:
						zprint("%s Script %s has exited.\n", script_types[type], npcmap[i].scriptname.c_str()); break;
					case SCRIPT_LWPN:
						zprint("%s Script %s has exited.\n", script_types[type], lwpnmap[i].scriptname.c_str()); break;
					case SCRIPT_EWPN:
						zprint("%s Script %s has exited.\n", script_types[type], ewpnmap[i].scriptname.c_str()); break;
					case SCRIPT_ITEMSPRITE:
						zprint("%s Script %s has exited.\n", script_types[type], itemspritemap[i].scriptname.c_str()); break;
					case SCRIPT_ITEM:
						zprint("%s Script %s has exited.\n", script_types[type], itemmap[i].scriptname.c_str()); break;
					case SCRIPT_GLOBAL:
						zprint("%s Script %s has exited.\n", script_types[type], globalmap[i].scriptname.c_str()); break;
					case SCRIPT_LINK:
						zprint("%s Script %s has exited.\n", script_types[type], linkmap[i].scriptname.c_str()); break;
					case SCRIPT_SCREEN:
						zprint("%s Script %s has exited.\n", script_types[type], screenmap[i].scriptname.c_str()); break;
					case SCRIPT_DMAP:
					case SCRIPT_ACTIVESUBSCREEN:
					case SCRIPT_PASSIVESUBSCREEN:
						zprint("%s Script %s has exited.\n", script_types[type], dmapmap[i].scriptname.c_str()); break;
					case SCRIPT_COMBO: zprint("%s Script %s has exited.\n", script_types[type], comboscriptmap[i].scriptname.c_str()); break;
					
					default: break;					
				}
				break;
			}
			case QUIT:
				scommand = 0xFFFF;
				break;
				
			case GOTO:
			{
				unsigned char invalid = 0;
				if(sarg1 < 0 )
				{
					switch(type)
					{
						
						case SCRIPT_FFC:
							Z_scripterrlog("%s Script %s attempted to GOTO an invalid jump to (%d).\n", script_types[type], ffcmap[i].scriptname.c_str(), sarg1); break;
						case SCRIPT_NPC:
							Z_scripterrlog("%s Script %s attempted to GOTO an invalid jump to (%d).\n", script_types[type], npcmap[i].scriptname.c_str(), sarg1); break;
						case SCRIPT_LWPN:
							Z_scripterrlog("%s Script %s attempted to GOTO an invalid jump to (%d).\n", script_types[type], lwpnmap[i].scriptname.c_str(), sarg1); break;
						case SCRIPT_EWPN:
							Z_scripterrlog("%s Script %s attempted to GOTO an invalid jump to (%d).\n", script_types[type], ewpnmap[i].scriptname.c_str(), sarg1); break;
						case SCRIPT_ITEMSPRITE:
							Z_scripterrlog("%s Script %s attempted to GOTO an invalid jump to (%d).\n", script_types[type], itemspritemap[i].scriptname.c_str(), sarg1); break;
						case SCRIPT_ITEM:
							Z_scripterrlog("%s Script %s attempted to GOTO an invalid jump to (%d).\n", script_types[type], itemmap[i].scriptname.c_str(), sarg1); break;
						case SCRIPT_GLOBAL:
							Z_scripterrlog("%s Script %s attempted to GOTO an invalid jump to (%d).\n", script_types[type], globalmap[i].scriptname.c_str(), sarg1); break;
						case SCRIPT_LINK:
							Z_scripterrlog("%s Script %s attempted to GOTO an invalid jump to (%d).\n", script_types[type], linkmap[i].scriptname.c_str(), sarg1); break;
						case SCRIPT_SCREEN:
							Z_scripterrlog("%s Script %s attempted to GOTO an invalid jump to (%d).\n", script_types[type], screenmap[i].scriptname.c_str(), sarg1); break;
						case SCRIPT_DMAP:
						case SCRIPT_ACTIVESUBSCREEN:
						case SCRIPT_PASSIVESUBSCREEN:
							Z_scripterrlog("%s Script %s attempted to GOTO an invalid jump to (%d).\n", script_types[type], dmapmap[i].scriptname.c_str(), sarg1); break;
						case SCRIPT_COMBO: Z_scripterrlog("%s Script %s attempted to GOTO an invalid jump to (%d).\n", script_types[type], comboscriptmap[i].scriptname.c_str(), sarg1); break;
						
						default: break;						
					}
					invalid = 1; scommand = 0xFFFF;
				}
				if ( invalid ) break;
				ri->pc = sarg1;
				increment = false;
				break;
			}
			case GOTOR:
			{
				unsigned char invalid = 0;
				if(sarg1 < 0 )
				{
					switch(type)
					{
						
						case SCRIPT_FFC:
							Z_scripterrlog("%s Script %s attempted to GOTOR an invalid jump to (%d).\n", script_types[type], ffcmap[i].scriptname.c_str() ,sarg1); break;
						case SCRIPT_NPC:
							Z_scripterrlog("%s Script %s attempted to GOTOR an invalid jump to (%d).\n", script_types[type], npcmap[i].scriptname.c_str(), sarg1); break;
						case SCRIPT_LWPN:
							Z_scripterrlog("%s Script %s attempted to GOTOR an invalid jump to (%d).\n", script_types[type], lwpnmap[i].scriptname.c_str(), sarg1); break;
						case SCRIPT_EWPN:
							Z_scripterrlog("%s Script %s attempted to GOTOR an invalid jump to (%d).\n", script_types[type], ewpnmap[i].scriptname.c_str(), sarg1); break;
						case SCRIPT_ITEMSPRITE:
							Z_scripterrlog("%s Script %s attempted to GOTOR an invalid jump to (%d).\n", script_types[type], itemspritemap[i].scriptname.c_str(), sarg1); break;
						case SCRIPT_ITEM:
							Z_scripterrlog("%s Script %s attempted to GOTOR an invalid jump to (%d).\n", script_types[type], itemmap[i].scriptname.c_str(), sarg1); break;
						case SCRIPT_GLOBAL:
							Z_scripterrlog("%s Script %s attempted to GOTOR an invalid jump to (%d).\n", script_types[type], globalmap[i].scriptname.c_str(), sarg1); break;
						case SCRIPT_LINK:
							Z_scripterrlog("%s Script %s attempted to GOTOR an invalid jump to (%d).\n", script_types[type], linkmap[i].scriptname.c_str(), sarg1); break;
						case SCRIPT_SCREEN:
							Z_scripterrlog("%s Script %s attempted to GOTOR an invalid jump to (%d).\n", script_types[type], screenmap[i].scriptname.c_str(), sarg1); break;
						case SCRIPT_DMAP:
						case SCRIPT_ACTIVESUBSCREEN:
						case SCRIPT_PASSIVESUBSCREEN:
							Z_scripterrlog("%s Script %s attempted to GOTOR an invalid jump to (%d).\n", script_types[type], dmapmap[i].scriptname.c_str(), sarg1); break;
						case SCRIPT_COMBO: Z_scripterrlog("%s Script %s attempted to GOTOR an invalid jump to (%d).\n", script_types[type], comboscriptmap[i].scriptname.c_str(), sarg1); break;
						
						default: break;						
					}
					invalid = 1; scommand = 0xFFFF;
				}
				if ( invalid ) break;
				ri->pc = (get_register(sarg1) / 10000) - 1;
				increment = false;
			}
			break;
			
			case GOTOTRUE:
				if(ri->scriptflag & TRUEFLAG)
				{
					unsigned char invalid = 0;
					if(sarg1 < 0 )
					{
						switch(type)
						{
							
							case SCRIPT_FFC:
								Z_scripterrlog("%s Script %s attempted to GOTOTRUE an invalid jump to (%d).\n", script_types[type], ffcmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_NPC:
								Z_scripterrlog("%s Script %s attempted to GOTOTRUE an invalid jump to (%d).\n", script_types[type], npcmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_LWPN:
								Z_scripterrlog("%s Script %s attempted to GOTOTRUE an invalid jump to (%d).\n", script_types[type], lwpnmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_EWPN:
								Z_scripterrlog("%s Script %s attempted to GOTOTRUE an invalid jump to (%d).\n", script_types[type], ewpnmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_ITEMSPRITE:
								Z_scripterrlog("%s Script %s attempted to GOTOTRUE an invalid jump to (%d).\n", script_types[type], itemspritemap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_ITEM:
								Z_scripterrlog("%s Script %s attempted to GOTOTRUE an invalid jump to (%d).\n", script_types[type], itemmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_GLOBAL:
								Z_scripterrlog("%s Script %s attempted to GOTOTRUE an invalid jump to (%d).\n", script_types[type], globalmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_LINK:
								Z_scripterrlog("%s Script %s attempted to GOTOTRUE an invalid jump to (%d).\n", script_types[type], linkmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_SCREEN:
								Z_scripterrlog("%s Script %s attempted to GOTOTRUE an invalid jump to (%d).\n", script_types[type], screenmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_DMAP:
							case SCRIPT_ACTIVESUBSCREEN:
							case SCRIPT_PASSIVESUBSCREEN:
								Z_scripterrlog("%s Script %s attempted to GOTOTRUE an invalid jump to (%d).\n", script_types[type], dmapmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_COMBO: Z_scripterrlog("%s Script %s attempted to GOTOTRUE an invalid jump to (%d).\n", script_types[type], comboscriptmap[i].scriptname.c_str(), sarg1); break;
							
							default: break;						
						}
						invalid = 1; scommand = 0xFFFF;
					}
					if ( invalid ) break;
					ri->pc = sarg1;
					increment = false;
				}
				
				break;
				
			case GOTOFALSE:
				if(!(ri->scriptflag & TRUEFLAG))
				{
					unsigned char invalid = 0;
					if(sarg1 < 0 )
					{
						switch(type)
						{
							
							case SCRIPT_FFC:
								Z_scripterrlog("%s Script %s attempted to GOTOFALSE an invalid jump to (%d).\n", script_types[type], ffcmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_NPC:
								Z_scripterrlog("%s Script %s attempted to GOTOFALSE an invalid jump to (%d).\n", script_types[type], npcmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_LWPN:
								Z_scripterrlog("%s Script %s attempted to GOTOFALSE an invalid jump to (%d).\n", script_types[type], lwpnmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_EWPN:
								Z_scripterrlog("%s Script %s attempted to GOTOFALSE an invalid jump to (%d).\n", script_types[type], ewpnmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_ITEMSPRITE:
								Z_scripterrlog("%s Script %s attempted to GOTOFALSE an invalid jump to (%d).\n", script_types[type], itemspritemap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_ITEM:
								Z_scripterrlog("%s Script %s attempted to GOTOFALSE an invalid jump to (%d).\n", script_types[type], itemmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_GLOBAL:
								Z_scripterrlog("%s Script %s attempted to GOTOFALSE an invalid jump to (%d).\n", script_types[type], globalmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_LINK:
								Z_scripterrlog("%s Script %s attempted to GOTOFALSE an invalid jump to (%d).\n", script_types[type], linkmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_SCREEN:
								Z_scripterrlog("%s Script %s attempted to GOTOFALSE an invalid jump to (%d).\n", script_types[type], screenmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_DMAP:
							case SCRIPT_ACTIVESUBSCREEN:
							case SCRIPT_PASSIVESUBSCREEN:
								Z_scripterrlog("%s Script %s attempted to GOTOFALSE an invalid jump to (%d).\n", script_types[type], dmapmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_COMBO: Z_scripterrlog("%s Script %s attempted to GOTOFALSE an invalid jump to (%d).\n", script_types[type], comboscriptmap[i].scriptname.c_str(), sarg1); break;
							
							default: break;						
						}
						invalid = 1; scommand = 0xFFFF;
					}
					if ( invalid ) break;
					ri->pc = sarg1;
					increment = false;
				}
				
				break;
				
			case GOTOMORE:
				if(ri->scriptflag & MOREFLAG)
				{
					unsigned char invalid = 0;
					if(sarg1 < 0 )
					{
						switch(type)
						{
							
							case SCRIPT_FFC:
								Z_scripterrlog("%s Script %s attempted to GOTOMORE an invalid jump to (%d).\n", script_types[type], ffcmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_NPC:
								Z_scripterrlog("%s Script %s attempted to GOTOMORE an invalid jump to (%d).\n", script_types[type], npcmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_LWPN:
								Z_scripterrlog("%s Script %s attempted to GOTOMORE an invalid jump to (%d).\n", script_types[type], lwpnmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_EWPN:
								Z_scripterrlog("%s Script %s attempted to GOTOMORE an invalid jump to (%d).\n", script_types[type], ewpnmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_ITEMSPRITE:
								Z_scripterrlog("%s Script %s attempted to GOTOMORE an invalid jump to (%d).\n", script_types[type], itemspritemap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_ITEM:
								Z_scripterrlog("%s Script %s attempted to GOTOMORE an invalid jump to (%d).\n", script_types[type], itemmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_GLOBAL:
								Z_scripterrlog("%s Script %s attempted to GOTOMORE an invalid jump to (%d).\n", script_types[type], globalmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_LINK:
								Z_scripterrlog("%s Script %s attempted to GOTOMORE an invalid jump to (%d).\n", script_types[type], linkmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_SCREEN:
								Z_scripterrlog("%s Script %s attempted to GOTOMORE an invalid jump to (%d).\n", script_types[type], screenmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_DMAP:
							case SCRIPT_ACTIVESUBSCREEN:
							case SCRIPT_PASSIVESUBSCREEN:
								Z_scripterrlog("%s Script %s attempted to GOTOMORE an invalid jump to (%d).\n", script_types[type], dmapmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_COMBO: Z_scripterrlog("%s Script %s attempted to GOTOMORE an invalid jump to (%d).\n", script_types[type], comboscriptmap[i].scriptname.c_str(), sarg1); break;
							
							default: break;						
						}
						invalid = 1; scommand = 0xFFFF;
					}
					if ( invalid ) break;
					ri->pc = sarg1;
					increment = false;
				}
				
				break;
				
			case GOTOLESS:
				if(!(ri->scriptflag & MOREFLAG) || (!get_bit(quest_rules,qr_GOTOLESSNOTEQUAL) && (ri->scriptflag & TRUEFLAG)))
				{
					unsigned char invalid = 0;
					if(sarg1 < 0 )
					{
						switch(type)
						{
							
							case SCRIPT_FFC:
								Z_scripterrlog("%s Script %s attempted to GOTOLESS an invalid jump to (%d).\n", script_types[type], ffcmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_NPC:
								Z_scripterrlog("%s Script %s attempted to GOTOLESS an invalid jump to (%d).\n", script_types[type], npcmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_LWPN:
								Z_scripterrlog("%s Script %s attempted to GOTOLESS an invalid jump to (%d).\n", script_types[type], lwpnmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_EWPN:
								Z_scripterrlog("%s Script %s attempted to GOTOLESS an invalid jump to (%d).\n", script_types[type], ewpnmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_ITEMSPRITE:
								Z_scripterrlog("%s Script %s attempted to GOTOLESS an invalid jump to (%d).\n", script_types[type], itemspritemap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_ITEM:
								Z_scripterrlog("%s Script %s attempted to GOTOLESS an invalid jump to (%d).\n", script_types[type], itemmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_GLOBAL:
								Z_scripterrlog("%s Script %s attempted to GOTOLESS an invalid jump to (%d).\n", script_types[type], globalmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_LINK:
								Z_scripterrlog("%s Script %s attempted to GOTOLESS an invalid jump to (%d).\n", script_types[type], linkmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_SCREEN:
								Z_scripterrlog("%s Script %s attempted to GOTOLESS an invalid jump to (%d).\n", script_types[type], screenmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_DMAP:
							case SCRIPT_ACTIVESUBSCREEN:
							case SCRIPT_PASSIVESUBSCREEN:
								Z_scripterrlog("%s Script %s attempted to GOTOLESS an invalid jump to (%d).\n", script_types[type], dmapmap[i].scriptname.c_str(), sarg1); break;
							case SCRIPT_COMBO: Z_scripterrlog("%s Script %s attempted to GOTOLESS an invalid jump to (%d).\n", script_types[type], comboscriptmap[i].scriptname.c_str(), sarg1); break;
							
							default: break;						
						}
						invalid = 1; scommand = 0xFFFF;
					}
					if ( invalid ) break;
					ri->pc = sarg1;
					increment = false;
				}
				
				break;
				
			case LOOP:
			{
				if(get_register(sarg2) > 0)
				{
					ri->pc = sarg1;
					increment = false;
				}
				else
				{
					set_register(sarg1, sarg1 - 1);
				}
			}
			break;

			case RETURN:
			{
				ri->pc = SH::read_stack(ri->sp) - 1;
				++ri->sp;
				increment = false;
				break;
			}
			
			case SETTRUE:
				set_register(sarg1, (ri->scriptflag & TRUEFLAG) ? 1 : 0);
				break;
				
			case SETFALSE:
				set_register(sarg1, (ri->scriptflag & TRUEFLAG) ? 0 : 1);
				break;
				
			case SETMORE:
				set_register(sarg1, (ri->scriptflag & MOREFLAG) ? 1 : 0);
				break;
				
			case SETLESS:
				set_register(sarg1, (!(ri->scriptflag & MOREFLAG)
						 || (ri->scriptflag & TRUEFLAG)) ? 1 : 0);
				break;
			
			case SETTRUEI:
				set_register(sarg1, (ri->scriptflag & TRUEFLAG) ? 10000 : 0);
				break;
				
			case SETFALSEI:
				set_register(sarg1, (ri->scriptflag & TRUEFLAG) ? 0 : 10000);
				break;
				
			case SETMOREI:
				set_register(sarg1, (ri->scriptflag & MOREFLAG) ? 10000 : 0);
				break;
				
			case SETLESSI:
				set_register(sarg1, (!(ri->scriptflag & MOREFLAG)
						 || (ri->scriptflag & TRUEFLAG)) ? 10000 : 0);
				break;
	
			case READPODARRAYR:
			{
				do_readpod(false);
				break;
			}
			case READPODARRAYV:
			{
				do_readpod(true);
				break;
			}
			case WRITEPODARRAYRR:
			{
				do_writepod(false,false);
				break;
			}
			case WRITEPODARRAYRV:
			{
				do_writepod(false,true);
				break;
			}
			case WRITEPODARRAYVR:
			{
				do_writepod(true,false);
				break;
			}
			case WRITEPODARRAYVV:
			{
				do_writepod(true,true);
				break;
			}
				
			case NOT:
				do_not(false);
				break;
				
			case COMPAREV:
				do_comp(true);
				break;
				
			case COMPARER:
				do_comp(false);
				break;
			
			case STRCMPR:
				do_internal_strcmp();
				break;
			
			case STRICMPR:
				do_internal_stricmp();
				break;
				
			case SETV:
				do_set(true, type, i);
				break;
				
			case SETR:
				do_set(false, type, i);
				break;
				
			case PUSHR:
				do_push(false);
				break;
				
			case PUSHV:
				do_push(true);
				break;
				
			case POP:
				do_pop();
				break;
			
			case POPARGS:
				do_pops();
				break;
				
			case LOADI:
				do_loadi();
				break;
				
			case STOREI:
				do_storei();
				break;
				
			case LOAD1:
				do_loada(0);
				break;
				
			case LOAD2:
				do_loada(1);
				break;
				
			case SETA1:
				do_seta(0);
				break;
				
			case SETA2:
				do_seta(1);
				break;
				
			case ALLOCATEGMEMR:
				if(type == SCRIPT_GLOBAL) do_allocatemem(false, false, type, i);
				
				break;
				
			case ALLOCATEGMEMV:
				if(type == SCRIPT_GLOBAL) do_allocatemem(true, false, type, i);
				
				break;
				
			case ALLOCATEMEMR:
				do_allocatemem(false, true, type, i);
				break;
				
			case ALLOCATEMEMV:
				do_allocatemem(true, true, type, i);
				break;
				
			case DEALLOCATEMEMR:
				do_deallocatemem();
				break;
				
			case SAVEGAMESTRUCTS:
				FFCore.do_savegamestructs(false,false);
				break;
			case READGAMESTRUCTS:
				FFCore.do_loadgamestructs(false,false);
				break;
			case ARRAYSIZE:
				do_arraysize();
				break;
			 case ARRAYSIZEB:
				do_arraysize();
				break;
			case ARRAYSIZEF:
				do_arraysize();
				break;
			case ARRAYSIZEN:
				do_arraysize();
				break;
			case ARRAYSIZEI:
				do_arraysize();
				break;
			case ARRAYSIZEID:
				do_arraysize();
				break;
			case ARRAYSIZEL:
				do_arraysize();
				break;
			case ARRAYSIZEE:
				do_arraysize();
				break;
			
			case GETFFCSCRIPT:
				do_getffcscript();
				break;
			case GETITEMSCRIPT:
				do_getitemscript();
				break;
				
			case CASTBOOLI:
				do_boolcast(false);
				break;
				
			case CASTBOOLF:
				do_boolcast(true);
				break;
				
			case ADDV:
				do_add(true);
				break;
				
			case ADDR:
				do_add(false);
				break;
				
			case SUBV:
				do_sub(true);
				break;
				
			case SUBR:
				do_sub(false);
				break;
				
			case MULTV:
				do_mult(true);
				break;
				
			case MULTR:
				do_mult(false);
				break;
				
			case DIVV:
				do_div(true);
				break;
				
			case DIVR:
				do_div(false);
				break;
				
			case MODV:
				do_mod(true);
				break;
				
			case MODR:
				do_mod(false);
				break;
				
			case SINV:
				do_trig(true, 0);
				break;
				
			case SINR:
				do_trig(false, 0);
				break;
				
			case COSV:
				do_trig(true, 1);
				break;
				
			case COSR:
				do_trig(false, 1);
				break;
				
			case TANV:
				do_trig(true, 2);
				break;
				
			case TANR:
				do_trig(false, 2);
				break;
			
			case STRINGLENGTH:
				FFCore.do_strlen(false);
				break;
				
			case ARCSINR:
				do_asin(false);
				break;
				
			case ARCCOSR:
				do_acos(false);
				break;
				
			case ARCTANR:
				do_arctan();
				break;
			
			//Text ptr functions
			case FONTHEIGHTR:
				do_fontheight();
				break;
			case STRINGWIDTHR:
				do_strwidth();
				break;
			case CHARWIDTHR:
				do_charwidth();
				break;
			case MESSAGEWIDTHR:
				ri->d[2] = 10000* do_msgwidth(get_register(sarg1)/10000, "Text->MessageWidth()");
				break;
			case MESSAGEHEIGHTR:
				ri->d[2] = 10000* do_msgheight(get_register(sarg1)/10000, "Text->MessageHeight()");
				break;
			//
			
			//String.h functions 2.55 Alpha 23
			case STRINGCOMPARE: FFCore.do_strcmp(); break;
			case STRINGICOMPARE: FFCore.do_stricmp(); break;
			case STRINGCOPY: FFCore.do_strcpy(false,false); break;
			case ARRAYCOPY: FFCore.do_arraycpy(false,false); break;
			case STRINGNCOMPARE: FFCore.do_strncmp(); break;
			case STRINGNICOMPARE: FFCore.do_strnicmp(); break;
			
			//More string.h functions, 19th May, 2019 
			case XLEN: FFCore.do_xlen(false); break;
			case XTOI: FFCore.do_xtoi(false); break;
			case ILEN: FFCore.do_ilen(false); break;
			case ATOI: FFCore.do_atoi(false); break;
			case STRCSPN: FFCore.do_strcspn(); break;
			case STRSTR: FFCore.do_strstr(); break;
			case XTOA: FFCore.do_xtoa(); break;
			case ITOA: FFCore.do_itoa(); break;
			case STRCAT: FFCore.do_strcat(); break;
			case STRSPN: FFCore.do_strspn(); break;
			case STRCHR: FFCore.do_strchr(); break;
			case STRRCHR: FFCore.do_strrchr(); break;
			case XLEN2: FFCore.do_xlen2(); break;
			case XTOI2: FFCore.do_xtoi2(); break;
			case ILEN2: FFCore.do_ilen2(); break;
			case ATOI2: FFCore.do_atoi2(); break;
			case REMCHR2: FFCore.do_remchr2(); break;
			case UPPERTOLOWER: FFCore.do_UpperToLower(false); break;
			case LOWERTOUPPER: FFCore.do_LowerToUpper(false); break;
			case CONVERTCASE: FFCore.do_ConvertCase(false); break;
				
			case GETNPCSCRIPT:	FFCore.do_getnpcscript(); break;
			case GETLWEAPONSCRIPT:	FFCore.do_getlweaponscript(); break;
			case GETEWEAPONSCRIPT:	FFCore.do_geteweaponscript(); break;
			case GETHEROSCRIPT:	FFCore.do_getheroscript(); break;
			case GETGLOBALSCRIPT:	FFCore.do_getglobalscript(); break;
			case GETDMAPSCRIPT:	FFCore.do_getdmapscript(); break;
			case GETSCREENSCRIPT:	FFCore.do_getscreenscript(); break;
			case GETSPRITESCRIPT:	FFCore.do_getitemspritescript(); break;
			case GETUNTYPEDSCRIPT:	FFCore.do_getuntypedscript(); break;
			case GETSUBSCREENSCRIPT:FFCore.do_getsubscreenscript(); break;
			case GETNPCBYNAME:	FFCore.do_getnpcbyname(); break;
			case GETITEMBYNAME:	FFCore.do_getitembyname(); break;
			case GETCOMBOBYNAME:	FFCore.do_getcombobyname(); break;
			case GETDMAPBYNAME:	FFCore.do_getdmapbyname(); break;
				
			case ABSR:
				do_abs(false);
				break;
				
			case MINR:
				do_min(false);
				break;
				
			case MINV:
				do_min(true);
				break;
				
			case MAXR:
				do_max(false);
				break;
				
			case MAXV:
				do_max(true);
				break;
				
			case RNDR:
				do_rnd(false);
				break;
				
			case RNDV:
				do_rnd(true);
				break;
				
			case SRNDR:
				do_srnd(false);
				break;
				
			case SRNDV:
				do_srnd(true);
				break;
				
			case SRNDRND:
				do_srndrnd();
				break;
			
			case GETRTCTIMER:
				FFCore.getRTC(false);
				break;
			case GETRTCTIMEV:
				FFCore.getRTC(true);
				break;
				
			case FACTORIAL:
				do_factorial(false);
				break;
				
			case SQROOTV:
				do_sqroot(true);
				break;
				
			case SQROOTR:
				do_sqroot(false);
				break;
				
			case POWERR:
				do_power(false);
				break;
				
			case POWERV:
				do_power(true);
				break;
				
			case IPOWERR:
				do_ipower(false);
				break;
				
			case IPOWERV:
				do_ipower(true);
				break;
				
			case LOG10:
				do_log10(false);
				break;
				
			case LOGE:
				do_naturallog(false);
				break;
				
			case ANDR:
				do_and(false);
				break;
				
			case ANDV:
				do_and(true);
				break;
				
			case ORR:
				do_or(false);
				break;
				
			case ORV:
				do_or(true);
				break;
				
			case XORR:
				do_xor(false);
				break;
				
			case XORV:
				do_xor(true);
				break;
				
			case NANDR:
				do_nand(false);
				break;
				
			case NANDV:
				do_nand(true);
				break;
				
			case NORR:
				do_nor(false);
				break;
				
			case NORV:
				do_nor(true);
				break;
				
			case XNORR:
				do_xnor(false);
				break;
				
			case XNORV:
				do_xnor(true);
				break;
				
			case BITNOT:
				do_bitwisenot(false);
				break;
				
			case LSHIFTR:
				do_lshift(false);
				break;
				
			case LSHIFTV:
				do_lshift(true);
				break;
				
			case RSHIFTR:
				do_rshift(false);
				break;
				
			case RSHIFTV:
				do_rshift(true);
				break;
				
			case ANDR32:
				do_and32(false);
				break;
				
			case ANDV32:
				do_and32(true);
				break;
				
			case ORR32:
				do_or32(false);
				break;
				
			case ORV32:
				do_or32(true);
				break;
				
			case XORR32:
				do_xor32(false);
				break;
				
			case XORV32:
				do_xor32(true);
				break;
				
			case BITNOT32:
				do_bitwisenot32(false);
				break;
				
			case LSHIFTR32:
				do_lshift32(false);
				break;
				
			case LSHIFTV32:
				do_lshift32(true);
				break;
				
			case RSHIFTR32:
				do_rshift32(false);
				break;
				
			case RSHIFTV32:
				do_rshift32(true);
				break;
				
			case TRACER:
				FFCore.do_trace(false);
				break;
				
			case TRACEV:
				FFCore.do_trace(true);
				break;
				
			case TRACE2R:
				FFCore.do_tracebool(false);
				break;
			
			//Zap and Wavy Effects
			case FXWAVYR:
				FFCore.do_fx_wavy(false);
				break;
			case FXZAPR:
				FFCore.do_fx_zap(false);
				break;
			//Zap and Wavy Effects
			case FXWAVYV:
				FFCore.do_fx_wavy(true);
				break;
			case FXZAPV:
				FFCore.do_fx_zap(true);
				break;
			case GREYSCALER:
				FFCore.do_greyscale(false);
				break;
			case GREYSCALEV:
				FFCore.do_greyscale(true);
				break;
			case MONOCHROMER:
				FFCore.do_monochromatic(false);
				break;
			case MONOCHROMEV:
				FFCore.do_monochromatic(true);
				break;
				
			case TRACE2V:
				FFCore.do_tracebool(true);
				break;
				
			case TRACE3:
				FFCore.do_tracenl();
				break;
				
			case TRACE4:
				FFCore.do_cleartrace();
				break;
				
			case TRACE5:
				FFCore.do_tracetobase();
				break;
				
			case TRACE6:
				FFCore.do_tracestring();
				break;
			
			case PRINTFV:
				FFCore.do_printf(true);
				break;
			
			case SPRINTFV:
				FFCore.do_sprintf(true);
				break;
			
			case BREAKPOINT:
				if( zasm_debugger )
				{
					FFCore.do_breakpoint();
				}
				break;
				
			case WARP:
				do_warp(true);
				break;
				
			case WARPR:
				do_warp(false);
				break;
				
			case PITWARP:
				do_pitwarp(true);
				break;
				
			case PITWARPR:
				do_pitwarp(false);
				break;
				
			case BREAKSHIELD:
				do_breakshield();
				break;
				
			case SELECTAWPNV:
				do_selectweapon(true, true);
				break;
				
			case SELECTAWPNR:
				do_selectweapon(false, true);
				break;
				
			case SELECTBWPNV:
				do_selectweapon(true, false);
				break;
				
			case SELECTBWPNR:
				do_selectweapon(false, false);
				break;
				
			case PLAYSOUNDR:
				do_sfx(false);
				break;
				
			case PLAYSOUNDV:
				do_sfx(true);
				break;
			
			case ADJUSTSFXVOLUMER: FFCore.do_adjustsfxvolume(false); break;
			case ADJUSTSFXVOLUMEV: FFCore.do_adjustsfxvolume(true); break;	
			case ADJUSTVOLUMER: FFCore.do_adjustvolume(false); break;
			case ADJUSTVOLUMEV: FFCore.do_adjustvolume(true); break;
				
			case TRIGGERSECRETR:
				FFScript::do_triggersecret(false);
				break;
				
			case TRIGGERSECRETV:
				FFScript::do_triggersecret(true);
				break;
				
			case PLAYMIDIR:
				do_midi(false);
				break;
				
			case PLAYMIDIV:
				do_midi(true);
				break;
				
			case PLAYENHMUSIC:
				do_enh_music(false);
				break;
				
			case GETMUSICFILE:
				do_get_enh_music_filename(false);
				break;
				
			case GETMUSICTRACK:
				do_get_enh_music_track(false);
				break;
				
			case SETDMAPENHMUSIC:
				do_set_dmap_enh_music(false);
				break;
			
			// Audio->
			
			case ENDSOUNDR:
				stop_sfx(false);
				break;
				
			case ENDSOUNDV:
				stop_sfx(true);
				break;
			
			case PAUSESOUNDR:
				pause_sfx(false);
				break;
				
			case PAUSESOUNDV:
				pause_sfx(true);
				break;
			
			case RESUMESOUNDR:
				resume_sfx(false);
				break;
				
			case RESUMESOUNDV:
				resume_sfx(true);
				break;
			
			
			
			case PAUSESFX:
			{
				int sound = ri->d[0]/10000;
				pause_sfx(sound);
				
			}
			break;

			case RESUMESFX:
			{
				int sound = ri->d[0]/10000;
				resume_sfx(sound);
			}
			break;

			case ADJUSTSFX:
			{
				int sound = ri->d[2]/10000;
				int pan = ri->d[1];
				// control_state[6]=((value/10000)!=0)?true:false;
				bool loop = ((ri->d[0]/10000)!=0)?true:false;
				//SFXBackend.adjust_sfx(sound,pan,loop);
				
				//! adjust_sfx was not ported to the new back end!!! -Z
			}
			break;


			case CONTINUESFX:
			{
				int sound = ri->d[0]/10000;
				//Backend::sfx->cont_sfx(sound);
				
				//! cont_sfx was not ported to the new back end!!!
				// I believe this restarted the loop. 
				resume_sfx(sound);
				//What was the old instruction, again? Did it exist? -Z
				//continue_sfx(sound);
			}
			break;	

			
			/*
			case STOPITEMSOUND:
				void stop_item_sfx(int family)
			*/
			
			case PAUSEMUSIC:
				//What was the instruction prior to adding backends?
				//! The pauseAll() function pauses sfx, not music, so this instruction is not doing what I intended. -Z
				//Check AllOff() -Z
				//zcmusic_pause(ZCMUSIC* zcm, int pause); is in zcmusic.h
				midi_paused = true; 
				//pause_all_sfx();
			
				//Backend::sfx->pauseAll();
				break;
			case RESUMEMUSIC:
				//What was the instruction prior to adding backends?
				//Check AllOff() -Z
				//resume_all_sfx();
				midi_paused = false; 
				//Backend::sfx->resumeAll();
				break;
			
			//!!! typecasting
			case LWPNARRPTR:
			case EWPNARRPTR:
			case ITEMARRPTR:
			case IDATAARRPTR:
			case FFCARRPTR:
			case BOOLARRPTR:
			case NPCARRPTR:
				
			case LWPNARRPTR2:
			case EWPNARRPTR2:
			case ITEMARRPTR2:
			case IDATAARRPTR2:
			case FFCARRPTR2:
			case BOOLARRPTR2:
			case NPCARRPTR2:
				FFScript::do_typedpointer_typecast(false);
				break;
				
			case MSGSTRR:
				do_message(false);
				break;
				
			case MSGSTRV:
				do_message(true);
				break;
				
			case ITEMNAME:
				do_getitemname();
				break;
				
			case NPCNAME:
				do_getnpcname();
				break;
			
			case NPCDATAGETNAME:
				FFCore.do_getnpcdata_getname();
				break;
				
			case GETSAVENAME:
				do_getsavename();
				break;
				
			case SETSAVENAME:
				do_setsavename();
				break;
				
			case GETMESSAGE:
				do_getmessage(false);
				break;
			case SETMESSAGE:
				do_setmessage(false);
				break;
				
			case GETDMAPNAME:
				do_getdmapname(false);
				break;
				
			case GETDMAPTITLE:
				do_getdmaptitle(false);
				break;
				
			case GETDMAPINTRO:
				do_getdmapintro(false);
				break;
				
			case SETDMAPNAME:
				do_setdmapname(false);
				break;
				
			case SETDMAPTITLE:
				do_setdmaptitle(false);
				break;
			
			case SETDMAPINTRO:
				do_setdmapintro(false);
				break;
			
			case LOADLWEAPONR:
				do_loadlweapon(false);
				break;
				
			case LOADLWEAPONV:
				do_loadlweapon(true);
				break;
				
			case LOADEWEAPONR:
				do_loadeweapon(false);
				break;
				
			case LOADEWEAPONV:
				do_loadeweapon(true);
				break;
				
			case LOADITEMR:
				do_loaditem(false);
				break;
				
			case LOADITEMV:
				do_loaditem(true);
				break;
				
			case LOADITEMDATAR:
				do_loaditemdata(false);
				break;
			
			//New Datatypes
			case LOADSHOPR:
				FFScript::do_loadshopdata(false);
				break;
			case LOADSHOPV:
				FFScript::do_loadshopdata(true);
				break;
			
			case LOADINFOSHOPR:
				FFScript::do_loadinfoshopdata(false);
				break;
			case LOADINFOSHOPV:
				FFScript::do_loadinfoshopdata(true);
				break;
			case LOADNPCDATAR:
				FFScript::do_loadnpcdata(false);
				break;
			case LOADNPCDATAV:
				FFScript::do_loadnpcdata(true);
				break;
			
			case LOADCOMBODATAR:
				FFScript::do_loadcombodata(false);
				break;
			case LOADCOMBODATAV:
				FFScript::do_loadcombodata(true);
				break;
			
			case LOADMAPDATAR:
				FFScript::do_loadmapdata(false);
				break;
			case LOADMAPDATAV:
				FFScript::do_loadmapdata(true);
				break;
			case LOADTMPSCR:
				FFScript::do_loadmapdata_tempscr(false);
				break;
			case LOADSCROLLSCR:
				FFScript::do_loadmapdata_scrollscr(false);
				break;
			
			case LOADSPRITEDATAR:
				FFScript::do_loadspritedata(false);
				break;
			case LOADSPRITEDATAV:
				FFScript::do_loadspritedata(true);
				break;
			
			case LOADSCREENDATAR:
				FFScript::do_loadscreendata(false);
				break;
			case LOADSCREENDATAV:
				FFScript::do_loadscreendata(true);
				break;
			
			case LOADBITMAPDATAR:
				FFScript::do_loadbitmapid(false);
				break;
			
			
			case LOADBITMAPDATAV:
				FFScript::do_loadbitmapid(true);
				break;
			
			//functions
			case LOADDMAPDATAR: //command
				FFScript::do_loaddmapdata(false); break;
			case LOADDMAPDATAV: //command
				FFScript::do_loaddmapdata(true); break;
			case LOADDROPSETR: //command
				FFScript::do_loaddropset(false); break;


			case DMAPDATAGETNAMER: //command
				FFScript::do_getDMapData_dmapname(false); break;
			case DMAPDATAGETNAMEV: //command
				FFScript::do_getDMapData_dmapname(true); break;

			case DMAPDATASETNAMER: //command
				FFScript::do_setDMapData_dmapname(false); break;
			case DMAPDATASETNAMEV: //command
				FFScript::do_setDMapData_dmapname(true); break;



			case DMAPDATAGETTITLER: //command
				FFScript::do_getDMapData_dmaptitle(false); break;
			case DMAPDATAGETTITLEV: //command
				FFScript::do_getDMapData_dmaptitle(true); break;
			case DMAPDATASETTITLER: //command
				FFScript::do_setDMapData_dmaptitle(false); break;
			case DMAPDATASETTITLEV: //command
				FFScript::do_setDMapData_dmaptitle(true); break;


			case DMAPDATAGETINTROR: //command
				FFScript::do_getDMapData_dmapintro(false); break;
			case DMAPDATAGETINTROV: //command
				FFScript::do_getDMapData_dmapintro(true); break;
			case DMAPDATANSETITROR: //command
				FFScript::do_setDMapData_dmapintro(false); break;
			case DMAPDATASETINTROV: //command
				FFScript::do_setDMapData_dmapintro(true); break;


			case DMAPDATAGETMUSICR: //command, string to load a music file
				FFScript::do_getDMapData_music(false); break;
			case DMAPDATAGETMUSICV: //command, string to load a music file
				FFScript::do_getDMapData_music(true); break;
			case DMAPDATASETMUSICR: //command, string to load a music file
				FFScript::do_setDMapData_music(false); break;
			case DMAPDATASETMUSICV: //command, string to load a music file
				FFScript::do_setDMapData_music(true); break;

			case LOADMESSAGEDATAR: //COMMAND
				FFScript::do_loadmessagedata(false);
				break;
			case LOADMESSAGEDATAV: //COMMAND
				FFScript::do_loadmessagedata(false);
				break;
			

			case MESSAGEDATASETSTRINGR: //command
				FFScript::do_messagedata_setstring(false);
				break;
			case MESSAGEDATASETSTRINGV: //command
				FFScript::do_messagedata_setstring(false);
				break;
			
			case MESSAGEDATAGETSTRINGR: //command
				FFScript::do_messagedata_getstring(false);
				break;
			case MESSAGEDATAGETSTRINGV: //command
				FFScript::do_messagedata_getstring(false);
				break;	
			case LOADITEMDATAV:
				do_loaditemdata(true);
				break;
				
			case LOADNPCBYSUID:
				FFCore.do_loadnpc_by_script_uid(false);
				break;
			
			case LOADLWEAPONBYSUID:
				FFCore.do_loadlweapon_by_script_uid(false);
				break;
			
			case LOADWEAPONCBYSUID:
				FFCore.do_loadeweapon_by_script_uid(false);
				break;
			
			case LOADNPCR:
				do_loadnpc(false);
				break;
				
			case LOADNPCV:
				do_loadnpc(true);
				break;
				
			case CREATELWEAPONR:
				do_createlweapon(false);
				break;
				
			case CREATELWEAPONV:
				do_createlweapon(true);
				break;
				
			case CREATEEWEAPONR:
				do_createeweapon(false);
				break;
				
			case CREATEEWEAPONV:
				do_createeweapon(true);
				break;
				
			case CREATEITEMR:
				do_createitem(false);
				break;
				
			case CREATEITEMV:
				do_createitem(true);
				break;
				
			case CREATENPCR:
				do_createnpc(false);
				break;
				
			case CREATENPCV:
				do_createnpc(true);
				break;
				
			case ISVALIDARRAY:
				do_isvalidarray();
				break;
				
			case ISVALIDITEM:
				do_isvaliditem();
				break;
			
			case ISVALIDBITMAP:
				FFCore.do_isvalidbitmap();
				break;
			
			case ISALLOCATEDBITMAP:
				FFCore.do_isallocatedbitmap();
				break;
				
			case ISVALIDNPC:
				do_isvalidnpc();
				break;
				
			case ISVALIDLWPN:
				do_isvalidlwpn();
				break;
				
			case ISVALIDEWPN:
				do_isvalidewpn();
				break;
				
			case LWPNUSESPRITER:
				do_lwpnusesprite(false);
				break;
				
			case LWPNUSESPRITEV:
				do_lwpnusesprite(true);
				break;
				
			case EWPNUSESPRITER:
				do_ewpnusesprite(false);
				break;
				
			case EWPNUSESPRITEV:
				do_ewpnusesprite(true);
				break;
				
			case CLEARSPRITESR:
				do_clearsprites(false);
				break;
				
			case CLEARSPRITESV:
				do_clearsprites(true);
				break;
				
			case ISSOLID:
				do_issolid();
				break;
			
			case MAPDATAISSOLID:
				do_mapdataissolid();
				break;
				
			case MAPDATAISSOLIDLYR:
				do_mapdataissolid_layer();
				break;
				
			case ISSOLIDLAYER:
				do_issolid_layer();
				break;
				
			case SETSIDEWARP:
				do_setsidewarp();
				break;
				
			case SETTILEWARP:
				do_settilewarp();
				break;
				
			case GETSIDEWARPDMAP:
				do_getsidewarpdmap(false);
				break;
				
			case GETSIDEWARPSCR:
				do_getsidewarpscr(false);
				break;
				
			case GETSIDEWARPTYPE:
				do_getsidewarptype(false);
				break;
				
			case GETTILEWARPDMAP:
				do_gettilewarpdmap(false);
				break;
				
			case GETTILEWARPSCR:
				do_gettilewarpscr(false);
				break;
				
			case GETTILEWARPTYPE:
				do_gettilewarptype(false);
				break;
				
			case LAYERSCREEN:
				do_layerscreen();
				break;
				
			case LAYERMAP:
				do_layermap();
				break;
				
			case SECRETS:
				do_triggersecrets();
				break;
				
			case GETSCREENFLAGS:
				do_getscreenflags();
				break;
				
			case GETSCREENEFLAGS:
				do_getscreeneflags();
				break;
			
			case GRAPHICSGETPIXEL:
				FFCore.do_graphics_getpixel();
				break;
			
			case GETSCREENDOOR:
				do_getscreendoor();
				break;
			
			case GETSCREENENEMY:
				do_getscreennpc();
				break;
			
			//screendata and mapdata
			case SETSCREENENEMY:
			{ //void SetScreenEnemy(int map, int screen, int index, int value);
				long map     = (ri->d[1] / 10000) - 1; 
				long scrn  = ri->d[2] / 10000; 
				long index = ri->d[0] / 10000; 
				int nn = ri->d[3]/10000; 
			
				// int x;
				
				// zprint("ri->d[3] is (%i), trying to use for '%s'\n", nn, "nn");
				// zprint("ri->d[2] is (%i), trying to use for '%s'\n", scrn, "scrn");
				// zprint("ri->d[1] is (%i), trying to use for '%s'\n", map, "map");
				// zprint("ri->d[0] is (%i), trying to use for '%s'\n", index, "index");
				
				if(BC::checkMapID(map, "Game->SetScreenEnemy(...map...)") != SH::_NoError ||
					BC::checkBounds(scrn, 0, 0x87, "Game->SetScreenEnemy(...screen...)") != SH::_NoError ||
					BC::checkBounds(index, 0, 9, "Game->SetScreenEnemy(...index...)") != SH::_NoError)
					return RUNSCRIPT_ERROR;
				
				//	if ( BC::checkBounds(nn, 0, 2, "Game->SetScreenEnemy(...enemy...)") != SH::_NoError) x = 1;
				//	if ( BC::checkBounds(map, 20, 21, "Game->SetScreenEnemy(...map...)") != SH::_NoError) x = 2;
				FFScript::set_screenenemy(&TheMaps[map * MAPSCRS + scrn], index, nn); 
			}
			break;
			
			case SETSCREENDOOR:
			{ //void SetScreenDoor(int map, int screen, int index, int value);
				long map     = (ri->d[1] / 10000) - 1; 
				long scrn  = ri->d[2] / 10000; 
				long index = ri->d[0] / 10000; 
				int nn = ri->d[3]/10000; 
				
				if(BC::checkMapID(map, "Game->SetScreenDoor(...map...)") != SH::_NoError ||
					BC::checkBounds(scrn, 0, 0x87, "Game->SetScreenDoor(...screen...)") != SH::_NoError ||
					BC::checkBounds(index, 0, 3, "Game->SetScreenDoor(...doorindex...)") != SH::_NoError)
				{
					return RUNSCRIPT_ERROR; break;
				}
				else
				{
					FFScript::set_screendoor(&TheMaps[map * MAPSCRS + scrn], index, nn); 
					break;
				}
				
			}
				
			case GETSCREENLAYOP:
				do_getscreenLayerOpacity();
				break;
			case GETSCREENSECCMB:
				do_getscreenSecretCombo();
				break;
			case GETSCREENSECCST:
				do_getscreenSecretCSet();
				break;
			case GETSCREENSECFLG:
				do_getscreenSecretFlag();
				break;
			case GETSCREENLAYMAP:
				do_getscreenLayerMap();
				break;
			case GETSCREENLAYSCR:
				do_getscreenLayerscreen();
				break;
			case GETSCREENPATH:
				do_getscreenPath();
				break;
			case GETSCREENWARPRX:
				do_getscreenWarpReturnX();
				break;
			case GETSCREENWARPRY:
				do_getscreenWarpReturnY();
				break;

			case COMBOTILE:
				do_combotile(false);
				break;
				
			case RECTR:
			case CIRCLER:
			case ARCR:
			case ELLIPSER:
			case LINER:
			case PUTPIXELR:
			case PIXELARRAYR:
			case TILEARRAYR:
			case LINESARRAY:
			case COMBOARRAYR:
			case DRAWTILER:
			case DRAWTILECLOAKEDR:
			case DRAWCOMBOR:
			case DRAWCOMBOCLOAKEDR:
			case DRAWCHARR:
			case DRAWINTR:
			case QUADR:
			case TRIANGLER:
			case QUAD3DR:
			case TRIANGLE3DR:
			case FASTTILER:
			case FASTCOMBOR:
			case DRAWSTRINGR:
			case DRAWSTRINGR2:
			case BMPDRAWSTRINGR2:
			case SPLINER:
			case BITMAPR:
			case BITMAPEXR:
			case DRAWLAYERR:
			case DRAWSCREENR:
			case POLYGONR:
				do_drawing_command(scommand);
				break;
			
			case BMPRECTR:	
			case BMPCIRCLER:
			case BMPARCR:
			case BMPELLIPSER:
			case BMPLINER:
			case BMPSPLINER:
			case BMPPUTPIXELR:
			case BMPDRAWTILER:
			case BMPDRAWTILECLOAKEDR:
			case BMPDRAWCOMBOR:
			case BMPDRAWCOMBOCLOAKEDR:
			case BMPFASTTILER:
			case BMPFASTCOMBOR:
			case BMPDRAWCHARR:
			case BMPDRAWINTR:
			case BMPDRAWSTRINGR:
			case BMPQUADR:
			case BMPQUAD3DR:
			case BMPTRIANGLER:
			case BMPTRIANGLE3DR:
			case BMPPOLYGONR:
			case BMPDRAWLAYERR: 
			case BMPDRAWLAYERSOLIDR: 
			case BMPDRAWLAYERCFLAGR: 
			case BMPDRAWLAYERCTYPER: 
			case BMPDRAWLAYERCIFLAGR: 
			case BMPDRAWLAYERSOLIDITYR: 
			case BMPDRAWSCREENR:
			case BMPDRAWSCREENSOLIDR:
			case BMPDRAWSCREENSOLID2R:
			case BMPDRAWSCREENCOMBOFR:
			case BMPDRAWSCREENCOMBOIR:
			case BMPDRAWSCREENCOMBOTR:
			case BITMAPGETPIXEL:
			case BMPBLIT:
			case BMPBLITTO:
			case BMPMODE7:
			case WRITEBITMAP:
			case CLEARBITMAP:
			case BITMAPCLEARTOCOLOR:
				do_drawing_command(scommand);
				break;
			case READBITMAP:
			{
				int bitref = SH::read_stack(ri->sp+2);
				if(user_bitmap* b = checkBitmap(bitref,"Read()",false,true))
					do_drawing_command(scommand);
				else //If the pointer isn't allocated, attempt to allocate it first
				{
					bitref = FFCore.get_free_bitmap();
					ri->d[3] = bitref; //Return to ptr
					if(bitref) SH::write_stack(ri->sp+2,bitref); //Write the ref, for the drawing command to read
					else break; //No ref allocated; don't enqueue the drawing command.
					do_drawing_command(scommand);
				}
				break;
			}
			case REGENERATEBITMAP:
			{
				ri->d[3] = SH::read_stack(ri->sp+3);
				if(user_bitmap* b = checkBitmap(ri->d[3],"Create()",false,true))
					do_drawing_command(scommand);
				else //If the pointer isn't allocated
				{
					long w = SH::read_stack(ri->sp+1) / 10000;
					long h = SH::read_stack(ri->sp) / 10000;
					if ( get_bit(quest_rules, qr_OLDCREATEBITMAP_ARGS) )
					{
						//flip height and width
						h = h ^ w;
						w = h ^ w; 
						h = h ^ w;
					}
					
					ri->d[3] = FFCore.create_user_bitmap_ex(h,w,8); //Return to ptr
				}
				break;
			}
			
			case BITMAPFREE:
			{
				FFCore.do_deallocate_bitmap();
				break;
			}
				
			case COPYTILEVV:
				do_copytile(true, true);
				break;
				
			case COPYTILEVR:
				do_copytile(true, false);
				break;
				
			case COPYTILERV:
				do_copytile(false, true);
				break;
				
			case COPYTILERR:
				do_copytile(false, false);
				break;
				
			case SWAPTILEVV:
				do_swaptile(true, true);
				break;
				
			case SWAPTILEVR:
				do_swaptile(true, false);
				break;
				
			case SWAPTILERV:
				do_swaptile(false, true);
				break;
				
			case SWAPTILERR:
				do_swaptile(false, false);
				break;
				
			case CLEARTILEV:
				do_cleartile(true);
				break;
				
			case CLEARTILER:
				do_cleartile(false);
				break;
				
			case OVERLAYTILEVV:
				do_overlaytile(true, true);
				break;
				
			case OVERLAYTILEVR:
				do_overlaytile(true, false);
				break;
				
			case OVERLAYTILERV:
				do_overlaytile(false, true);
				break;
				
			case OVERLAYTILERR:
				do_overlaytile(false, false);
				break;
				
			case FLIPROTTILEVV:
				do_fliprotatetile(true, true);
				break;
				
			case FLIPROTTILEVR:
				do_fliprotatetile(true, false);
				break;
				
			case FLIPROTTILERV:
				do_fliprotatetile(false, true);
				break;
				
			case FLIPROTTILERR:
				do_fliprotatetile(false, false);
				break;
				
			case GETTILEPIXELV:
				do_gettilepixel(true);
				break;
				
			case GETTILEPIXELR:
				do_gettilepixel(false);
				break;
				
			case SETTILEPIXELV:
				do_settilepixel(true);
				break;
				
			case SETTILEPIXELR:
				do_settilepixel(false);
				break;
				
			case SHIFTTILEVV:
				do_shifttile(true, true);
				break;
				
			case SHIFTTILEVR:
				do_shifttile(true, false);
				break;
				
			case SHIFTTILERV:
				do_shifttile(false, true);
				break;
				
			case SHIFTTILERR:
				do_shifttile(false, false);
				break;
				
			case SETRENDERTARGET:
				do_set_rendertarget(true);
				break;
				
			case GAMEEND:
				Quit = qQUIT;
				skipcont = 1;
				scommand = 0xFFFF;
				break;
			case GAMERELOAD:
				Quit = qRELOAD;
				skipcont = 1;
				scommand = 0xFFFF;
				break;
			
			case GAMECONTINUE:
				reset_combo_animations();
				reset_combo_animations2();
			
				Quit = qCONT;
				skipcont = 1;
				//cont_game();
				scommand = 0xFFFF;
				break;
				
			case GAMESAVEQUIT:
				Quit = qSAVE;
				skipcont = 1;
				scommand =0xFFFF;
				break;
				
			case GAMESAVECONTINUE:
				Quit = qSAVECONT;
				skipcont = 1;
				scommand =0xFFFF;
				break;
				
			case SAVE:
				if(scriptCanSave)
				{
					save_game(false);
					scriptCanSave=false;
				}
				break;
				
			case SAVESCREEN:
				do_showsavescreen();
				break;
			
			case SHOWF6SCREEN:
				onTryQuit();
				break;
				
			case SAVEQUITSCREEN:
				save_game(false, 1);
				break;
				
				//Not Implemented
			case ELLIPSE2:
			case FLOODFILL:
				break;
				
			case SETCOLORB:
			case SETDEPTHB:
			case GETCOLORB:
			case GETDEPTHB:
				break;
				
			case ENQUEUER:
				do_enqueue(false);
				break;
				
			case ENQUEUEV:
				do_enqueue(true);
				break;
				
			case DEQUEUE:
				do_dequeue(false);
				break;
			
			//Visual Effects
			case WAVYIN:
				FFScript::do_wavyin();
				break;
			case WAVYOUT:
				FFScript::do_wavyout();
				break;
			case ZAPIN:
				FFScript::do_zapin();
				break;
			case ZAPOUT:
				FFScript::do_zapout();
				break;
			case OPENWIPE:
			{
				FFScript::do_openscreen();
				break;
			}
			case CLOSEWIPE:
			{
				FFScript::do_closescreen();
				break;
			}
			case OPENWIPESHAPE:
			{
				FFScript::do_openscreenshape();
				break;
			}
			case CLOSEWIPESHAPE:
			{
				FFScript::do_closescreenshape();
				break;
			}
			
			//Monochrome
			case GREYSCALEON:
				setMonochrome(true);
				break;
			case GREYSCALEOFF:
				setMonochrome(false);
				break;
			
			case TINT:
			{
				FFCore.Tint();
				break;
			}
			
			case CLEARTINT:
			{
				FFCore.clearTint();
				break;
			}
			
			case MONOHUE:
			{
				FFCore.gfxmonohue();
				break;
			}
			
			case LINKWARPEXR:
			{
				
				FFCore.do_warp_ex(false);
				//terminate sprite scripts
				//switch(type)
				//{
				//	case SCRIPT_NPC:
				//	case SCRIPT_LWPN:
				//	case SCRIPT_EWPN:
				//	case SCRIPT_ITEMSPRITE:
				//	{
				//		Z_scripterrlog("Hero->WarpEx() cannot be called from script type %s. Ignoring the call.\n", scripttypenames[type]);
				//		break;
				//	}
				//	default: 
				//	{
				//		FFCore.do_warp_ex(false);
				//		break;
				//	}
				//}
				break;
				
			}
			
			case LINKEXPLODER:
			{
				int mode = get_register(sarg1) / 10000;
				if ( (unsigned) mode > 2 ) 
				{
					Z_scripterrlog("Invalid mode (%d) passed to Link->Explode(int mode)\n",mode);
				}
				else Link.explode(mode);
				break;
			}
			case NPCEXPLODER:
			{
				
				int mode = get_register(sarg1) / 10000;
				al_trace("Called npc->Explode(%d), for enemy index %ld\n", mode, ri->guyref);
				if ( (unsigned) mode > 2 ) 
				{
					Z_scripterrlog("Invalid mode (%d) passed to npc->Explode(int mode)\n",mode);
				}
				else
				{
					if(GuyH::loadNPC(ri->guyref, "npc->Explode()") == SH::_NoError)
					{
						al_trace("npc->Explode() is loading the npc into a pointer.\n");
						//enemy *e = (enemy*)guys.spr(ri->guyref);
						al_trace("npc->Explode() is calling enemy::explode.\n");
						//(enemy *) guys.explode(eid);
						//e->explode(mode);
						//enemy *en=GuyH::getNPC();
						//en->stop_bgsfx(GuyH::getNPCIndex(ri->guyref));
						guys.spr(GuyH::getNPCIndex(ri->guyref))->explode(mode);
					}
				}
				break;
			}
			
			case ITEMEXPLODER:
			{
				
				int mode = get_register(sarg1) / 10000;
				al_trace("Called item->Explode(%d), for item index %ld\n", mode, ri->itemref);
				if ( (unsigned) mode > 2 ) 
				{
					Z_scripterrlog("Invalid mode (%d) passed to item->Explode(int mode)\n",mode);
				}
				else
				{
					if(ItemH::loadItem(ri->itemref, "item->Explode()") == SH::_NoError)
					{
						items.spr(ItemH::getItemIndex(ri->itemref))->explode(mode);
					}
				}
				break;
			}
			case LWEAPONEXPLODER:
			{
				
				int mode = get_register(sarg1) / 10000;
				al_trace("Called lweapon->Explode(%d), for lweapon index %ld\n", mode, ri->lwpn);
				if ( (unsigned) mode > 2 ) 
				{
					Z_scripterrlog("Invalid mode (%d) passed to lweapon->Explode(int mode)\n",mode);
				}
				else
				{
					if(LwpnH::loadWeapon(ri->itemref, "lweapon->Explode()") == SH::_NoError)
					{
						Lwpns.spr(LwpnH::getLWeaponIndex(ri->lwpn))->explode(mode);
					}
				}
				break;
			}
			case EWEAPONEXPLODER:
			{
				
				int mode = get_register(sarg1) / 10000;
				al_trace("Called eweapon->Explode(%d), for eweapon index %ld\n", mode, ri->ewpn);
				if ( (unsigned) mode > 2 ) 
				{
					Z_scripterrlog("Invalid mode (%d) passed to eweapon->Explode(int mode)\n",mode);
				}
				else
				{
					if(EwpnH::loadWeapon(ri->ewpn, "eweapon->Explode()") == SH::_NoError)
					{
						Ewpns.spr(EwpnH::getEWeaponIndex(ri->lwpn))->explode(mode);
					}
				}
				break;
			}
			
			case RUNITEMSCRIPT:
			{
				int itemid = ri->idata;
				int mode = get_register(sarg1) / 10000;
				zprint("Trying to run the script on item: %d\n",itemid);
				zprint("The script ID is: %d\n",itemsbuf[itemid].script);
				zprint("Runitemscript mode is: %d\n", mode);
				switch(mode)
				{
					case 0:
					{
						item_doscript[itemid] = 4;
						break;
					}
					case 1:
					{
						if ( itemsbuf[itemid].script != 0 ) //&& !item_doscript[itemid] )
						{
							if ( !item_doscript[itemid] ) 
							{
								for ( int q = 0; q < 1024; q++ ) item_stack[itemid][q] = 0xFFFF;
								itemScriptData[itemid].Clear();
								item_doscript[itemid] = 1;
								//ZScriptVersion::RunScript(SCRIPT_ITEM, itemsbuf[itemid].script, itemid);
							}
							else
							{
								//Rob, clear the stack here, clear refinfo, and set up to run again on the next frame from the beginning.
							}
						}
						break;
					}
					case 2:
					default:
					{
						if ( itemsbuf[itemid].script != 0 ) //&& !item_doscript[itemid] )
						{
							if (item_doscript[itemid] != 2 )item_doscript[itemid] = 2;
						}
						break;
					}
					/*
					case 0:
					{
						item_doscript[itemid] = 0;
						break;
					}
					default:
					{
					
						if ( itemsbuf[itemid].script != 0 ) //&& !item_doscript[itemid] )
						{
							//itemScriptData[itemid].Clear();
							//for ( int q = 0; q < 1024; q++ ) item_stack[itemid][q] = 0;
							//ZScriptVersion::RunScript(SCRIPT_ITEM, itemsbuf[itemid].script, itemid & 0xFFF);
							item_doscript[itemid] = 2;
						}
						break;
					}
					*/
				}
				break;
			}
			
			//case NPCData
			
			case GETNPCDATATILE: FFScript::getNPCData_tile(); break;
			case GETNPCDATAEHEIGHT: FFScript::getNPCData_e_height(); break;
			case GETNPCDATAFLAGS: FFScript::getNPCData_flags(); break;
			case GETNPCDATAFLAGS2: FFScript::getNPCData_flags2(); break;
			case GETNPCDATAWIDTH: FFScript::getNPCData_flags2(); break;
			case GETNPCDATAHEIGHT: FFScript::getNPCData_flags2(); break;
			case GETNPCDATASTILE: FFScript::getNPCData_s_tile(); break;
			case GETNPCDATASWIDTH: FFScript::getNPCData_s_width(); break;
			case GETNPCDATASHEIGHT: FFScript::getNPCData_s_height(); break;
			case GETNPCDATAETILE: FFScript::getNPCData_e_tile(); break;
			case GETNPCDATAEWIDTH: FFScript::getNPCData_e_width(); break;
			case GETNPCDATAHP: FFScript::getNPCData_hp(); break;
			case GETNPCDATAFAMILY: FFScript::getNPCData_family(); break;
			case GETNPCDATACSET: FFScript::getNPCData_cset(); break;
			case GETNPCDATAANIM: FFScript::getNPCData_anim(); break;
			case GETNPCDATAEANIM: FFScript::getNPCData_e_anim(); break;
			case GETNPCDATAFRAMERATE: FFScript::getNPCData_frate(); break;
			case GETNPCDATAEFRAMERATE: FFScript::getNPCData_e_frate(); break;
			case GETNPCDATATOUCHDMG: FFScript::getNPCData_dp(); break;
			case GETNPCDATAWPNDAMAGE: FFScript::getNPCData_wdp(); break;
			case GETNPCDATAWEAPON: FFScript::getNPCData_wdp(); break;
			case GETNPCDATARANDOM: FFScript::getNPCData_rate(); break;
			case GETNPCDATAHALT: FFScript::getNPCData_hrate(); break;
			case GETNPCDATASTEP: FFScript::getNPCData_step(); break;
			case GETNPCDATAHOMING: FFScript::getNPCData_homing(); break;
			case GETNPCDATAHUNGER: FFScript::getNPCData_grumble(); break;
			case GETNPCDATADROPSET: FFScript::getNPCData_item_set(); break;
			case GETNPCDATABGSFX: FFScript::getNPCData_bgsfx(); break;
			case GETNPCDATADEATHSFX: FFScript::getNPCData_deadsfx(); break; 
			case GETNPCDATAXOFS: FFScript::getNPCData_xofs(); break;
			case GETNPCDATAYOFS: FFScript::getNPCData_yofs(); break;
			case GETNPCDATAZOFS: FFScript::getNPCData_zofs(); break;
			case GETNPCDATAHXOFS: FFScript::getNPCData_hxofs(); break;
			case GETNPCDATAHYOFS: FFScript::getNPCData_hyofs(); break;
			case GETNPCDATAHITWIDTH: FFScript::getNPCData_hxsz(); break;
			case GETNPCDATAHITHEIGHT: FFScript::getNPCData_hysz(); break;
			case GETNPCDATAHITZ: FFScript::getNPCData_hzsz(); break;
			case GETNPCDATATILEWIDTH: FFScript::getNPCData_txsz(); break;
			case GETNPCDATATILEHEIGHT: FFScript::getNPCData_tysz(); break;
			case GETNPCDATAWPNSPRITE: FFScript::getNPCData_wpnsprite(); break;
			//case GETNPCDATASCRIPTDEF: FFScript::getNPCData_scriptdefence(); break; //2.future cross-compat. 
			case GETNPCDATADEFENSE: FFScript::getNPCData_defense(); break; 
			case GETNPCDATASIZEFLAG: FFScript::getNPCData_SIZEflags(); break;
			case GETNPCDATAATTRIBUTE: FFScript::getNPCData_misc(); break;
			case GETNPCDATAHITSFX: FFScript::getNPCData_hitsfx(); break;
				
			case SETNPCDATAFLAGS: FFScript::setNPCData_flags(); break;
			case SETNPCDATAFLAGS2: FFScript::setNPCData_flags2(); break;
			case SETNPCDATAWIDTH: FFScript::setNPCData_width(); break;
			case SETNPCDATAHEIGHT: FFScript::setNPCData_height(); break;
			case SETNPCDATASTILE: FFScript::setNPCData_s_tile(); break;
			case SETNPCDATASWIDTH: FFScript::setNPCData_s_width(); break;
			case SETNPCDATASHEIGHT: FFScript::setNPCData_s_height(); break;
			case SETNPCDATAETILE: FFScript::setNPCData_e_tile(); break;
			case SETNPCDATAEWIDTH: FFScript::setNPCData_e_width(); break;
			case SETNPCDATAHP: FFScript::setNPCData_hp(); break;
			case SETNPCDATAFAMILY: FFScript::setNPCData_family(); break;
			case SETNPCDATACSET: FFScript::setNPCData_cset(); break;
			case SETNPCDATAANIM: FFScript::setNPCData_anim(); break;
			case SETNPCDATAEANIM: FFScript::setNPCData_e_anim(); break;
			case SETNPCDATAFRAMERATE: FFScript::setNPCData_frate(); break;
			case SETNPCDATAEFRAMERATE: FFScript::setNPCData_e_frate(); break;
			case SETNPCDATATOUCHDMG: FFScript::setNPCData_dp(); break;
			case SETNPCDATAWPNDAMAGE: FFScript::setNPCData_wdp(); break;
			case SETNPCDATAWEAPON: FFScript::setNPCData_weapon(); break;
			case SETNPCDATARANDOM: FFScript::setNPCData_rate(); break;
			case SETNPCDATAHALT: FFScript::setNPCData_hrate(); break;
			case SETNPCDATASTEP: FFScript::setNPCData_step(); break;
			case SETNPCDATAHOMING: FFScript::setNPCData_homing(); break;
			case SETNPCDATAHUNGER: FFScript::setNPCData_grumble(); break;
			case SETNPCDATADROPSET: FFScript::setNPCData_item_set(); break;
			case SETNPCDATABGSFX: FFScript::setNPCData_bgsfx(); break;
			case SETNPCDATADEATHSFX: FFScript::setNPCData_hitsfx(); break;
			case SETNPCDATAXOFS: FFScript::setNPCData_xofs(); break;
			case SETNPCDATAYOFS: FFScript::setNPCData_yofs(); break;
			case SETNPCDATAZOFS: FFScript::setNPCData_zofs(); break;
			case SETNPCDATAHXOFS: FFScript::setNPCData_hxofs(); break;
			case SETNPCDATAHYOFS: FFScript::setNPCData_hyofs(); break;
			case SETNPCDATAHITWIDTH: FFScript::setNPCData_hxsz(); break;
			case SETNPCDATAHITHEIGHT: FFScript::setNPCData_hysz(); break;
			case SETNPCDATAHITZ: FFScript::setNPCData_hzsz(); break;
			case SETNPCDATATILEWIDTH: FFScript::setNPCData_txsz(); break;
			case SETNPCDATATILEHEIGHT: FFScript::setNPCData_tysz(); break;
			case SETNPCDATAWPNSPRITE: FFScript::setNPCData_wpnsprite(); break;
			case SETNPCDATAHITSFX: FFScript::setNPCData_hitsfx(); break;
			case SETNPCDATATILE: FFScript::setNPCData_tile(); break;
			case SETNPCDATAEHEIGHT: FFScript::setNPCData_e_height(); break;
			
			
			
			

				
			//case SETNPCDATASCRIPTDEF  : FFScript::setNPCData_scriptdefence(); break;
			case SETNPCDATADEFENSE : FFScript::setNPCData_defense(ri->d[2]); break;
			case SETNPCDATASIZEFLAG : FFScript::setNPCData_SIZEflags(ri->d[2]); break;
			case SETNPCDATAATTRIBUTE : FFScript::setNPCData_misc(ri->d[2]); break;
			
			
			//ComboData
			
			case GCDBLOCKENEM:  FFScript::getComboData_block_enemies(); break;
			case GCDBLOCKHOLE:  FFScript::getComboData_block_hole(); break;
			case GCDBLOCKTRIG:  FFScript::getComboData_block_trigger(); break;
			case GCDCONVEYSPDX:  FFScript::getComboData_conveyor_x_speed(); break;
			case GCDCONVEYSPDY:  FFScript::getComboData_conveyor_y_speed(); break;
			case GCDCREATEENEM:  FFScript::getComboData_create_enemy(); break;
			case GCDCREATEENEMWH:  FFScript::getComboData_create_enemy_when(); break;
			case GCDCREATEENEMCH:  FFScript::getComboData_create_enemy_change(); break;
			case GCDDIRCHTYPE:  FFScript::getComboData_directional_change_type(); break;
			case GCDDISTCHTILES:  FFScript::getComboData_distance_change_tiles(); break;
			case GCDDIVEITEM:  FFScript::getComboData_dive_item(); break;
			case GCDDOCK:  FFScript::getComboData_dock(); break;
			case GCDFAIRY:  FFScript::getComboData_fairy(); break;
			case GCDFFCOMBOATTRIB:  FFScript::getComboData_ff_combo_attr_change(); break;
			case GCDFOOTDECOTILE:  FFScript::getComboData_foot_decorations_tile(); break;
			case GCDFOOTDECOTYPE:  FFScript::getComboData_foot_decorations_type(); break;
			case GCDHOOKSHOTGRAB:  FFScript::getComboData_hookshot_grab_point(); break;
			case GCDLADDERPASS:  FFScript::getComboData_ladder_pass(); break;
			case GCDLOCKBLOCKTYPE:  FFScript::getComboData_lock_block_type(); break;
			case GCDLOCKBLOCKCHANGE:  FFScript::getComboData_lock_block_change(); break;
			case GCDMAGICMIRRORTYPE:  FFScript::getComboData_magic_mirror_type(); break;
			case GCDMODIFYHPAMOUNT:  FFScript::getComboData_modify_hp_amount(); break;
			case GCDMODIFYHPDELAY:  FFScript::getComboData_modify_hp_delay(); break;
			case GCDMODIFYHPTYPE:  FFScript::getComboData_modify_hp_type(); break;
			case GCDMODIFYMPAMOUNT:  FFScript::getComboData_modify_mp_amount(); break;
			case GCDMODIFYMPDELAY:  FFScript::getComboData_modify_mp_delay(); break;
			case GCDMODIFYMPTYPE:  FFScript::getComboData_modify_mp_type(); break;
			case GCDNOPUSHBLOCKS:  FFScript::getComboData_no_push_blocks(); break;
			case GCDOVERHEAD:  FFScript::getComboData_overhead(); break;
			case GCDPLACEENEMY:  FFScript::getComboData_place_enemy(); break;
			case GCDPUSHDIR:  FFScript::getComboData_push_direction(); break;
			case GCDPUSHWEIGHT:  FFScript::getComboData_push_weight(); break;
			case GCDPUSHWAIT:  FFScript::getComboData_push_wait(); break;
			case GCDPUSHED:  FFScript::getComboData_pushed(); break;
			case GCDRAFT:  FFScript::getComboData_raft(); break;
			case GCDRESETROOM:  FFScript::getComboData_reset_room(); break;
			case GCDSAVEPOINT:  FFScript::getComboData_save_point_type(); break;
			case GCDSCREENFREEZE:  FFScript::getComboData_screen_freeze_type(); break;
			case GCDSECRETCOMBO:  FFScript::getComboData_secret_combo(); break;
			case GCDSINGULAR:  FFScript::getComboData_singular(); break;
			case GCDSLOWMOVE:  FFScript::getComboData_slow_movement(); break;
			case GCDSTATUE:  FFScript::getComboData_statue_type(); break;
			case GCDSTEPTYPE:  FFScript::getComboData_step_type(); break;
			case GCDSTEPCHANGETO:  FFScript::getComboData_step_change_to(); break;
			case GCDSTRIKEREMNANTS:  FFScript::getComboData_strike_remnants(); break;
			case GCDSTRIKEREMNANTSTYPE:  FFScript::getComboData_strike_remnants_type(); break;
			case GCDSTRIKECHANGE:  FFScript::getComboData_strike_change(); break;
			case GCDSTRIKECHANGEITEM:  FFScript::getComboData_strike_item(); break;
			case GCDTOUCHITEM:  FFScript::getComboData_touch_item(); break;
			case GCDTOUCHSTAIRS:  FFScript::getComboData_touch_stairs(); break;
			case GCDTRIGGERTYPE:  FFScript::getComboData_trigger_type(); break;
			case GCDTRIGGERSENS:  FFScript::getComboData_trigger_sensitive(); break;
			case GCDWARPTYPE:  FFScript::getComboData_warp_type(); break;
			case GCDWARPSENS:  FFScript::getComboData_warp_sensitive(); break;
			case GCDWARPDIRECT:  FFScript::getComboData_warp_direct(); break;
			case GCDWARPLOCATION:  FFScript::getComboData_warp_location(); break;
			case GCDWATER:  FFScript::getComboData_water(); break;
			case GCDWHISTLE:  FFScript::getComboData_whistle(); break;
			case GCDWINGAME:  FFScript::getComboData_win_game(); break;
			case GCDBLOCKWEAPLVL:  FFScript::getComboData_block_weapon_lvl(); break;
			case GCDTILE:  FFScript::getComboData_tile(); break;
			case GCDFLIP:  FFScript::getComboData_flip(); break;
			case GCDWALK:  FFScript::getComboData_walk(); break;
			case GCDTYPE:  FFScript::getComboData_type(); break;
			case GCDCSETS:  FFScript::getComboData_csets(); break;
			case GCDFOO:  FFScript::getComboData_foo(); break;
			case GCDFRAMES:  FFScript::getComboData_frames(); break;
			case GCDSPEED:  FFScript::getComboData_speed(); break;
			case GCDNEXTCOMBO:  FFScript::getComboData_nextcombo(); break;
			case GCDNEXTCSET:  FFScript::getComboData_nextcset(); break;
			case GCDFLAG:  FFScript::getComboData_flag(); break;
			case GCDSKIPANIM:  FFScript::getComboData_skipanim(); break;
			case GCDNEXTTIMER:  FFScript::getComboData_nexttimer(); break;
			case GCDSKIPANIMY:  FFScript::getComboData_skipanimy(); break;
			case GCDANIMFLAGS:  FFScript::getComboData_animflags(); break;
			case GCDBLOCKWEAPON:  FFScript::getComboData_block_weapon(); break;
			case GCDEXPANSION:  FFScript::getComboData_expansion(); break;
			case GCDSTRIKEWEAPONS:  FFScript::getComboData_strike_weapons(); break;
			case SCDBLOCKENEM:  FFScript::setComboData_block_enemies(); break;
			case SCDBLOCKHOLE:  FFScript::setComboData_block_hole(); break;
			case SCDBLOCKTRIG:  FFScript::setComboData_block_trigger(); break;
			case SCDCONVEYSPDX:  FFScript::setComboData_conveyor_x_speed(); break;
			case SCDCONVEYSPDY:  FFScript::setComboData_conveyor_y_speed(); break;
			case SCDCREATEENEM:  FFScript::setComboData_create_enemy(); break;
			case SCDCREATEENEMWH:  FFScript::setComboData_create_enemy_when(); break;
			case SCDCREATEENEMCH:  FFScript::setComboData_create_enemy_change(); break;
			case SCDDIRCHTYPE:  FFScript::setComboData_directional_change_type(); break;
			case SCDDISTCHTILES:  FFScript::setComboData_distance_change_tiles(); break;
			case SCDDIVEITEM:  FFScript::setComboData_dive_item(); break;
			case SCDDOCK:  FFScript::setComboData_dock(); break;
			case SCDFAIRY:  FFScript::setComboData_fairy(); break;
			case SCDFFCOMBOATTRIB:  FFScript::setComboData_ff_combo_attr_change(); break;
			case SCDFOOTDECOTILE:  FFScript::setComboData_foot_decorations_tile(); break;
			case SCDFOOTDECOTYPE:  FFScript::setComboData_foot_decorations_type(); break;
			case SCDHOOKSHOTGRAB:  FFScript::setComboData_hookshot_grab_point(); break;
			case SCDLADDERPASS:  FFScript::setComboData_ladder_pass(); break;
			case SCDLOCKBLOCKTYPE:  FFScript::setComboData_lock_block_type(); break;
			case SCDLOCKBLOCKCHANGE:  FFScript::setComboData_lock_block_change(); break;
			case SCDMAGICMIRRORTYPE:  FFScript::setComboData_magic_mirror_type(); break;
			case SCDMODIFYHPAMOUNT:  FFScript::setComboData_modify_hp_amount(); break;
			case SCDMODIFYHPDELAY:  FFScript::setComboData_modify_hp_delay(); break;
			case SCDMODIFYHPTYPE:  FFScript::setComboData_modify_hp_type(); break;
			case SCDMODIFYMPAMOUNT:  FFScript::setComboData_modify_mp_amount(); break;
			case SCDMODIFYMPDELAY:  FFScript::setComboData_modify_mp_delay(); break;
			case SCDMODIFYMPTYPE:  FFScript::setComboData_modify_mp_type(); break;
			case SCDNOPUSHBLOCKS:  FFScript::setComboData_no_push_blocks(); break;
			case SCDOVERHEAD:  FFScript::setComboData_overhead(); break;
			case SCDPLACEENEMY:  FFScript::setComboData_place_enemy(); break;
			case SCDPUSHDIR:  FFScript::setComboData_push_direction(); break;
			case SCDPUSHWEIGHT:  FFScript::setComboData_push_weight(); break;
			case SCDPUSHWAIT:  FFScript::setComboData_push_wait(); break;
			case SCDPUSHED:  FFScript::setComboData_pushed(); break;
			case SCDRAFT:  FFScript::setComboData_raft(); break;
			case SCDRESETROOM:  FFScript::setComboData_reset_room(); break;
			case SCDSAVEPOINT:  FFScript::setComboData_save_point_type(); break;
			case SCDSCREENFREEZE:  FFScript::setComboData_screen_freeze_type(); break;
			case SCDSECRETCOMBO:  FFScript::setComboData_secret_combo(); break;
			case SCDSINGULAR:  FFScript::setComboData_singular(); break;
			case SCDSLOWMOVE:  FFScript::setComboData_slow_movement(); break;
			case SCDSTATUE:  FFScript::setComboData_statue_type(); break;
			case SCDSTEPTYPE:  FFScript::setComboData_step_type(); break;
			case SCDSTEPCHANGETO:  FFScript::setComboData_step_change_to(); break;
			case SCDSTRIKEREMNANTS:  FFScript::setComboData_strike_remnants(); break;
			case SCDSTRIKEREMNANTSTYPE:  FFScript::setComboData_strike_remnants_type(); break;
			case SCDSTRIKECHANGE:  FFScript::setComboData_strike_change(); break;
			case SCDSTRIKECHANGEITEM:  FFScript::setComboData_strike_item(); break;
			case SCDTOUCHITEM:  FFScript::setComboData_touch_item(); break;
			case SCDTOUCHSTAIRS:  FFScript::setComboData_touch_stairs(); break;
			case SCDTRIGGERTYPE:  FFScript::setComboData_trigger_type(); break;
			case SCDTRIGGERSENS:  FFScript::setComboData_trigger_sensitive(); break;
			case SCDWARPTYPE:  FFScript::setComboData_warp_type(); break;
			case SCDWARPSENS:  FFScript::setComboData_warp_sensitive(); break;
			case SCDWARPDIRECT:  FFScript::setComboData_warp_direct(); break;
			case SCDWARPLOCATION:  FFScript::setComboData_warp_location(); break;
			case SCDWATER:  FFScript::setComboData_water(); break;
			case SCDWHISTLE:  FFScript::setComboData_whistle(); break;
			case SCDWINGAME:  FFScript::setComboData_win_game(); break;
			case SCDBLOCKWEAPLVL:  FFScript::setComboData_block_weapon_lvl(); break;
			case SCDTILE:  FFScript::setComboData_tile(); break;
			case SCDFLIP:  FFScript::setComboData_flip(); break;
			case SCDWALK:  FFScript::setComboData_walk(); break;
			case SCDTYPE:  FFScript::setComboData_type(); break;
			case SCDCSETS:  FFScript::setComboData_csets(); break;
			case SCDFOO:  FFScript::setComboData_foo(); break;
			case SCDFRAMES:  FFScript::setComboData_frames(); break;
			case SCDSPEED:  FFScript::setComboData_speed(); break;
			case SCDNEXTCOMBO:  FFScript::setComboData_nextcombo(); break;
			case SCDNEXTCSET:  FFScript::setComboData_nextcset(); break;
			case SCDFLAG:  FFScript::setComboData_flag(); break;
			case SCDSKIPANIM:  FFScript::setComboData_skipanim(); break;
			case SCDNEXTTIMER:  FFScript::setComboData_nexttimer(); break;
			case SCDSKIPANIMY:  FFScript::setComboData_skipanimy(); break;
			case SCDANIMFLAGS:  FFScript::setComboData_animflags(); break;
			case SCDBLOCKWEAPON:  FFScript::setComboData_block_weapon(ri->d[2]); break;
			case SCDEXPANSION:  FFScript::setComboData_expansion(ri->d[2]); break;
			case SCDSTRIKEWEAPONS:  FFScript::setComboData_strike_weapons(ri->d[2]); break;

			//SpriteData
			
			//case GETSPRITEDATASTRING: 
			case GETSPRITEDATATILE: FFScript::getSpriteDataTile(); break;
			case GETSPRITEDATAMISC: FFScript::getSpriteDataCSets(); break;
			case GETSPRITEDATACGETS: FFScript::getSpriteDataCSets(); break;
			case GETSPRITEDATAFRAMES: FFScript::getSpriteDataFrames(); break;
			case GETSPRITEDATASPEED: FFScript::getSpriteDataSpeed(); break;
			case GETSPRITEDATATYPE: FFScript::getSpriteDataType(); break;

			//case SETSPRITEDATASTRING:
			case SETSPRITEDATATILE: FFScript::setSpriteDataTile(); break;
			case SETSPRITEDATAMISC: FFScript::setSpriteDataMisc(); break;
			case SETSPRITEDATACSETS: FFScript::setSpriteDataCSets(); break;
			case SETSPRITEDATAFRAMES: FFScript::setSpriteDataFrames(); break;
			case SETSPRITEDATASPEED: FFScript::setSpriteDataSpeed(); break;
			case SETSPRITEDATATYPE: FFScript::setSpriteDataType(); break;
			
			//Game over Screen
			case SETCONTINUESCREEN: FFScript::FFChangeSubscreenText(); break;
			case SETCONTINUESTRING: FFScript::FFSetSaveScreenSetting(); break;
			
			//new npc functions for npc scripts
			
			case NPCDEAD:
				FFCore.do_isdeadnpc();
				break;
			
			case NPCCANSLIDE:
				FFCore.do_canslidenpc();
				break;
			
			case NPCSLIDE:
				FFCore.do_slidenpc();
				break;
			
			case NPCKICKBUCKET:
				FFScript::deallocateAllArrays(SCRIPT_NPC, ri->guyref);
				if(type == SCRIPT_NPC && ri->guyref == i)
				{
					FFCore.do_npckickbucket();
					return RUNSCRIPT_SELFDELETE;
				}
				FFCore.do_npckickbucket();
				break;
			
			case NPCSTOPBGSFX:
				FFCore.do_npc_stopbgsfx();
				break;
			
			case NPCATTACK:
				FFCore.do_npcattack();
				break;
			
			case NPCNEWDIR:
				FFCore.do_npc_newdir();
				break;
			
			case NPCCONSTWALK:
				FFCore.do_npc_constwalk();
				break;
			
			
			
			case NPCVARWALK:
				FFCore.do_npc_varwalk();
				break;
			
			case NPCVARWALK8:
				FFCore.do_npc_varwalk8();
				break;
			
			case NPCCONSTWALK8:
				FFCore.do_npc_constwalk8();
				break;
			
			case NPCHALTWALK:
				FFCore.do_npc_haltwalk();
				break;
			
			case NPCHALTWALK8:
				FFCore.do_npc_haltwalk8();
				break;
			
			case NPCFLOATWALK:
				FFCore.do_npc_floatwalk();
				break;
			
			case NPCFIREBREATH:
				FFCore.do_npc_breathefire();
				break;
			
			case NPCNEWDIR8:
				FFCore.do_npc_newdir8();
				break;
			
			case NPCLINKINRANGE:
				FFCore.do_npc_link_in_range(false);
				break;
			
			case NPCCANMOVE:
				FFCore.do_npc_canmove(false);
				break;
			
			case NPCHITWITH:
				FFCore.do_npc_simulate_hit(false);
				break;
				
			case NPCKNOCKBACK:
				FFCore.do_npc_knockback(false);
				break;
			
			case NPCGETINITDLABEL:
				FFCore.get_npcdata_initd_label(false);
				break;
			
			case NPCADD:
				FFCore.do_npc_add(false);
				break;
			
			case PLAYENHMUSICEX:
				FFCore.do_playogg_ex(false);
				break;
				
			case GETENHMUSICPOS:
				FFCore.go_get_oggex_position();
				break;
				
			case SETENHMUSICPOS:
				FFCore.do_set_oggex_position(false);
				break;
				
			case SETENHMUSICSPEED:
				FFCore.do_set_oggex_speed(false);
				break;
			
			case DIREXISTS:
				FFCore.do_checkdir(true);
				break;
			
			case FILEEXISTS:
				FFCore.do_checkdir(false);
				break;
			
			case FILESYSREMOVE:
				FFCore.do_fs_remove();
				break;
			
			case TOBYTE:
				do_tobyte();
				break;
			case TOWORD:
				do_toword();
				break;
			case TOSHORT: do_toshort(); break;
			case TOSIGNEDBYTE: do_tosignedbyte(); break;
			case TOINTEGER: do_tointeger(); break;
			case CEILING: do_ceiling(); break;
			case FLOOR: do_floor(); break;
			
			case FILECLOSE:
			{
				FFCore.do_fclose();
				break;
			}
			case FILEFREE:
			{
				FFCore.do_deallocate_file();
				break;
			}
			case FILEISALLOCATED:
			{
				FFCore.do_file_isallocated();
				break;
			}
			case FILEISVALID:
			{
				FFCore.do_file_isvalid();
				break;
			}
			case FILEALLOCATE:
			{
				FFCore.do_allocate_file();
				break;
			}
			case FILEFLUSH:
			{
				FFCore.do_fflush();
				break;
			}
			case FILEREMOVE:
			{
				FFCore.do_fremove();
				break;
			}
			case FILEGETCHAR:
			{
				FFCore.do_file_getchar();
				break;
			}
			case FILEREWIND:
			{
				FFCore.do_file_rewind();
				break;
			}
			case FILECLEARERR:
			{
				FFCore.do_file_clearerr();
				break;
			}
			
			case FILEOPEN:
			{
				FFCore.do_fopen(false, "rb+");
				break;
			}
			case FILECREATE:
			{
				FFCore.do_fopen(false, "wb+");
				break;
			}
			case FILEOPENMODE:
			{
				long arrayptr = get_register(sarg2) / 10000;
				string mode;
				ArrayH::getString(arrayptr, mode, 16);
				FFCore.do_fopen(false, mode.c_str());
				break;
			}
			case FILEREADSTR:
			{
				FFCore.do_file_readstring();
				break;
			}
			case FILEWRITESTR:
			{
				FFCore.do_file_writestring();
				break;
			}
			case FILEPUTCHAR:
			{
				FFCore.do_file_putchar();
				break;
			}
			case FILEUNGETCHAR:
			{
				FFCore.do_file_ungetchar();
				break;
			}
			
			case FILEREADCHARS:
			{
				FFCore.do_file_readchars();
				break;
			}
			case FILEREADINTS:
			{
				FFCore.do_file_readints();
				break;
			}
			case FILEWRITECHARS:
			{
				FFCore.do_file_writechars();
				break;
			}
			case FILEWRITEINTS:
			{
				FFCore.do_file_writeints();
				break;
			}
			case FILESEEK:
			{
				FFCore.do_file_seek();
				break;
			}
			case FILEGETERROR:
			{
				FFCore.do_file_geterr();
				break;
			}
			
			case MODULEGETIC:
			{
				
				int buf_pointer = SH::get_arg(sarg1, false) / 10000;
				int element = SH::get_arg(sarg2, false) / 10000;
				
				//zprint2("element is: %d, string is: %s\n", element, moduledata.item_editor_type_names[element]);
				
				if ( ((unsigned)element) > 511 )
				{
					Z_scripterrlog("Illegal itemclass supplied to Module->GetItemClass().\nLegal values are 1 to 511.\n");
				}
				else
				{
					char buffer[256] = {0};
					strcpy(buffer,moduledata.item_editor_type_names[element]);
					buffer[255] = '\0';
					if(ArrayH::setArray(buf_pointer, buffer) == SH::_Overflow)
					{
						Z_scripterrlog("Dest string supplied to 'Module->GetItemClass()' is not large enough\n");
					}
				}
			
				break;
			}
			
			case NOP: //No Operation. Do nothing. -V
				break;
			
			default:
			{
				Z_scripterrlog("Invalid ZASM command %lu reached\n", scommand);
				break;
			}
		}
		
#ifdef _SCRIPT_COUNTER
		end_time = script_counter;
		script_timer[*command] += end_time - start_time;
		++script_execount[*command];
#endif
		
		if(increment)	ri->pc++;
		else			increment = true;
		if ( ri->pc < 0 ) //rolled over from overflow
		{
			switch(type)
			{
			
				case SCRIPT_FFC:
						Z_scripterrlog("%s Script %s Programme Counter Overflowed due to too many ZASM instructions.\n", script_types[type], ffcmap[i].scriptname.c_str()); break;
					case SCRIPT_NPC:
						Z_scripterrlog("%s Script %s Programme Counter Overflowed due to too many ZASM instructions.\n", script_types[type], npcmap[i].scriptname.c_str()); break;
					case SCRIPT_LWPN:
						Z_scripterrlog("%s Script %s Programme Counter Overflowed due to too many ZASM instructions.\n", script_types[type], lwpnmap[i].scriptname.c_str()); break;
					case SCRIPT_EWPN:
						Z_scripterrlog("%s Script %s Programme Counter Overflowed due to too many ZASM instructions.\n", script_types[type], ewpnmap[i].scriptname.c_str()); break;
					case SCRIPT_ITEMSPRITE:
						Z_scripterrlog("%s Script %s Programme Counter Overflowed due to too many ZASM instructions.\n", script_types[type], itemspritemap[i].scriptname.c_str()); break;
					case SCRIPT_ITEM:
						Z_scripterrlog("%s Script %s Programme Counter Overflowed due to too many ZASM instructions.\n", script_types[type], itemmap[i].scriptname.c_str()); break;
					case SCRIPT_GLOBAL:
						Z_scripterrlog("%s Script %s Programme Counter Overflowed due to too many ZASM instructions.\n", script_types[type], globalmap[i].scriptname.c_str()); break;
					case SCRIPT_LINK:
						Z_scripterrlog("%s Script %s Programme Counter Overflowed due to too many ZASM instructions.\n", script_types[type], linkmap[i].scriptname.c_str()); break;
					case SCRIPT_SCREEN:
						Z_scripterrlog("%s Script %s Programme Counter Overflowed due to too many ZASM instructions.\n", script_types[type], screenmap[i].scriptname.c_str()); break;
					case SCRIPT_DMAP:
					case SCRIPT_ACTIVESUBSCREEN:
					case SCRIPT_PASSIVESUBSCREEN:
						Z_scripterrlog("%s Script %s Programme Counter Overflowed due to too many ZASM instructions.\n", script_types[type], dmapmap[i].scriptname.c_str()); break;
					case SCRIPT_COMBO: Z_scripterrlog("%s Script %s Programme Counter Overflowed due to too many ZASM instructions.\n", script_types[type], comboscriptmap[i].scriptname.c_str()); break;
					default:
						ri->pc = 1; scommand = 0xFFFF; break;
				
			}
		}
		
		if(scommand != 0xFFFF)
		{
			scommand = curscript->zasm[ri->pc].command;
			sarg1 = curscript->zasm[ri->pc].arg1;
			sarg2 = curscript->zasm[ri->pc].arg2;
		}
	}
	
	if(!scriptCanSave)
		scriptCanSave=true;
	
	//Decide if item scripts called from idata->RunScript should still run:
	/*
	for ( int q = 0; q < 256; q++ )
	{
	switch(runningItemScripts[q])
	{
		case 2: //stop running
		{
			item_doscript[i] = 0;
			
			itemScriptData[i].Clear();
			memset(item_stack[i], 0xFFFF, MAX_SCRIPT_REGISTERS * sizeof(long));
			
			break; 
		}
		case 3: //keep running
			break;
	}
		
	}
	*/
	/* NOT NEEDED
	if(scommand == WAITFRAME)
	{
		switch(type)
		{
		case SCRIPT_ITEM:
		{
			if ( !get_bit(quest_rules, qr_ITEMSCRIPTSKEEPRUNNING) )
			{
				scommand = QUIT;
				item_doscript[i] = 0;
				itemScriptData[i].Clear();
				memset(item_stack[i], 0xFFFF, MAX_SCRIPT_REGISTERS * sizeof(long));
				break;
			}
		}
		default: break;
	}
	}
	*/
	if(scommand == WAITDRAW)
	{
		switch(type)
		{
			case SCRIPT_GLOBAL:
				global_wait |= (1<<i);
				break;
				
			case SCRIPT_LINK:
				link_waitdraw = true;
				break;
			
			case SCRIPT_DMAP:
				dmap_waitdraw = true;
				break;
				
			case SCRIPT_PASSIVESUBSCREEN:
				passive_subscreen_waitdraw = true;
				break;
				
			case SCRIPT_ACTIVESUBSCREEN:
				active_subscreen_waitdraw = true;
				break;
			
			case SCRIPT_SCREEN:
				tmpscr->screen_waitdraw = 1;
				break;
			
			
			case SCRIPT_ITEM:
			{
				if ( !get_bit(quest_rules, qr_NOITEMWAITDRAW) ) { itemScriptsWaitdraw[i] = 1; }
				break;
			}
			
			case SCRIPT_NPC:
			{
				//enemy *wp = (enemy*)guys.spr(i);
				//wp->waitdraw = 1;
				guys.spr(GuyH::getNPCIndex(i))->waitdraw = 1;
				break;
			}
			case SCRIPT_LWPN:
			{
				Lwpns.spr(LwpnH::getLWeaponIndex(i))->waitdraw = 1;
				break;
			}
			
			case SCRIPT_EWPN:
			{
			
				Ewpns.spr(EwpnH::getEWeaponIndex(i))->waitdraw = 1;
				break;
			}
			case SCRIPT_ITEMSPRITE:
			{
				items.spr(ItemH::getItemIndex(i))->waitdraw = 1;
				break;
			}
			
			case SCRIPT_FFC:
			{
				if ( !(get_bit(quest_rules, qr_NOFFCWAITDRAW)) )
				{
				//zprint("FFScript: FFC (%d) issued WAITDRAW\n", i);
					tmpscr->ffcswaitdraw |= (1<<i);
				//set_bitl(tmpscr->ffcswaitdraw, i, 1);
				}
				else
				{
					Z_scripterrlog("Waitdraw cannot be used in script type: %s\n", "ffc, with Script Rule 'No FFC Waitdraw() enabled!");
				}
				break;
			}
			
			case SCRIPT_COMBO: 
			{
				int l = 0; //get the layer
				for (int q = 176; q < 1232; q+= 176 )
				{
					if ( i < q )
					{
						break;
					}
					++l;
				}
				int pos = ((i%176));
				combo_waitdraw[pos] |= (1<<l);
				break;
			}
		
			default:
				Z_scripterrlog("Waitdraw cannot be used in script type: %s\n", script_types[type]);
				break;
		}
	}
	
	if(scommand == 0xFFFF) //Quit/command list end reached/bad command
	{
	
		switch(type)
		{
		case SCRIPT_FFC:
			tmpscr->ffscript[i] = 0;
			FFScript::deallocateAllArrays(type, i);
			break;
			
		case SCRIPT_GLOBAL:
			g_doscript &= ~(1<<i);
			FFScript::deallocateAllArrays(type, i);
			break;
		
		case SCRIPT_LINK:
			link_doscript = 0;
			FFScript::deallocateAllArrays(type, i);
			break;
		
		case SCRIPT_DMAP:
			dmap_doscript = 0; //Can't do this, as warping will need to start the script again! -Z
			dmapscriptInitialised = 0;
			FFScript::deallocateAllArrays(type, i);
			break;
		
		case SCRIPT_ACTIVESUBSCREEN:
			active_subscreen_doscript = 0;
			activeSubscreenInitialised = 0;
			FFScript::deallocateAllArrays(type, i);
			break;
		
		case SCRIPT_PASSIVESUBSCREEN:
			passive_subscreen_doscript = 0;
			passiveSubscreenInitialised = 0;
			FFScript::deallocateAllArrays(type, i);
			break;
			
		case SCRIPT_ITEM:
		{
			zprint("Item script reached quit/end of scope\n");
			int new_i = 0;
			bool collect = ( ( i < 1 ) || (i == COLLECT_SCRIPT_ITEM_ZERO) );
			new_i = ( collect ) ? (( i != COLLECT_SCRIPT_ITEM_ZERO ) ? (i * -1) : 0) : i;
			
			if ( !collect )
			{
				if ( (itemsbuf[i].flags&ITEM_FLAG16) && game->item[i] ) itemsbuf[i].script = 0; //Quit perpetual scripts, too.
				item_doscript[new_i] = 0;
				for ( int q = 0; q < 1024; q++ ) item_stack[new_i][q] = 0xFFFF;
				itemScriptData[new_i].Clear();
			}
			else
			{
				item_collect_doscript[new_i] = 0;
				for ( int q = 0; q < 1024; q++ ) item_collect_stack[new_i][q] = 0xFFFF;
				itemCollectScriptData[new_i].Clear();
			}
			FFScript::deallocateAllArrays(SCRIPT_ITEM, new_i);
			zprint("Item script reached quit/end of scope for new_i: %d\n",new_i);
			itemscriptInitialised[new_i] = 0;
			
			break; //item scripts aren't gonna go again anyway
		}
		case SCRIPT_NPC:
		{
			guys.spr(GuyH::getNPCIndex(i))->doscript = 0;
			guys.spr(GuyH::getNPCIndex(i))->weaponscript = 0;
			guys.spr(GuyH::getNPCIndex(i))->initialised = 0;
			FFScript::deallocateAllArrays(type, i);

			break;
		}
		case SCRIPT_LWPN:
		{
			Lwpns.spr(LwpnH::getLWeaponIndex(i))->doscript = 0;
			Lwpns.spr(LwpnH::getLWeaponIndex(i))->weaponscript = 0;
			Lwpns.spr(LwpnH::getLWeaponIndex(i))->initialised = 0;
			FFScript::deallocateAllArrays(type, i);
			
			break;
		}
		case SCRIPT_EWPN:
		{
		
			Ewpns.spr(EwpnH::getEWeaponIndex(i))->doscript = 0;
			Ewpns.spr(EwpnH::getEWeaponIndex(i))->weaponscript = 0;
			Ewpns.spr(EwpnH::getEWeaponIndex(i))->initialised = 0;
			FFScript::deallocateAllArrays(type, i);
			
			break;
		}
		case SCRIPT_ITEMSPRITE:
		{
		
			items.spr(ItemH::getItemIndex(i))->doscript = 0;
			items.spr(ItemH::getItemIndex(i))->script = 0;
			items.spr(ItemH::getItemIndex(i))->initialised = 0;
			FFScript::deallocateAllArrays(type, i);
			
			break;
		}
		case SCRIPT_SCREEN:
		{
			tmpscr->script = 0;
			tmpscr->screendatascriptInitialised = 0;
			tmpscr->doscript = 0;
			FFScript::deallocateAllArrays(SCRIPT_SCREEN, 0);
			break;
		} 
		
		case SCRIPT_COMBO:
		{
			int pos = i%176;
			int lyr = i/176;
			combo_doscript[i] = 0;
			combo_initialised[pos] &= ~(1<<lyr);
			
			FFScript::deallocateAllArrays(type, i); //need to add combo arrays
			break;
		}
		
		}
	}
	else
		ri->pc++;
		
	//ri->pc = pc; //Put it back where we got it from
	
#ifdef _SCRIPT_COUNTER
	
	for(int j = 0; j < NUMCOMMANDS; j++)
	{
		if(script_execount[j] != 0)
			al_trace("Command %s took %ld ticks in all to complete in %ld executions.\n",
					 command_list[j].name, script_timer[j], script_execount[j]);
	}
	
	remove_int(update_script_counter);
#endif
	
	
	return RUNSCRIPT_OK;
}

//This keeps ffc scripts running beyond the first frame. 
int ffscript_engine(const bool preload)
{
	//run screen script, first
	//zprint("Screen Script Preload? %s \n", ( tmpscr->preloadscript ? "true" : "false"));
	if(( preload && tmpscr->preloadscript) || !preload )
	{
		if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) 
		{
			if ( tmpscr->script > 0 && tmpscr->doscript )
			{
				ZScriptVersion::RunScript(SCRIPT_SCREEN, tmpscr->script, 0);
			}
			
		}
	}
	for(byte i = 0; i < MAXFFCS; i++)
	{
		if(tmpscr->ffscript[i] == 0)
			continue;
			
		if(preload && !(tmpscr->ffflags[i]&ffPRELOAD))
			continue;
			
		if((tmpscr->ffflags[i]&ffIGNOREHOLDUP)==0 && Link.getHoldClk()>0)
			continue;
			
		ZScriptVersion::RunScript(SCRIPT_FFC, tmpscr->ffscript[i], i);
		tmpscr->initialized[i] = true;
	}
	
	
	return 0;
}



///----------------------------------------------------------------------------------------------------

void FFScript::user_files_init()
{
	for(int q = 0; q < MAX_USER_FILES; ++q)
	{
		script_files[q].clear();
	}
}

int FFScript::get_free_file(bool skipError)
{
	for(int q = 0; q < MAX_USER_FILES; ++q)
	{
		if(!script_files[q].reserved)
		{
			script_files[q].reserved = true;
			return q+1; //1-indexed; 0 is null value
		}
	}
	if(!skipError) Z_scripterrlog("get_free_file() could not find a valid free file pointer!\n");
	return 0;
}
#ifdef _WIN32
static string windows_exe_extensions[] = {".xlm",".caction",".8ck", ".actc",".a6p", ".m3g",".run",".workflow",".otm",".apk",".fxp",".73k",".0xe",".exe",".cmd",".jsx",".scar",".wcm",".jar",".ebs2",".ipa",".xap",".ba_",".ac",".bin",".vlx",".icd",".elf",".xbap",".89k",".widget",".a7r",".ex_",".zl9",".cgi",".scr",".coffee",".ahk",".plsc",".air",".ear",".app",".scptd",".xys",".hms",".cyw",".ebm",".pwc",".xqt",".msl",".seed",".vexe",".ebs",".mcr",".gpu",".celx",".wsh",".frs",".vxp",".action",".com",".out",".gadget",".command",".script",".rfu",".tcp",".widget",".ex4",".bat",".cof",".phar",".rxe",".scb",".ms",".isu",".fas",".mlx",".gpe",".mcr",".mrp",".u3p",".js",".acr",".epk",".exe1",".jsf",".rbf",".rgs",".vpm",".ecf",".hta",".dld",".applescript",".prg",".pyc",".spr",".nexe",".server",".appimage",".pyo",".dek",".mrc",".fpi",".rpj",".iim",".vbs",".pif",".mel",".scpt",".csh",".paf",".ws",".mm",".acc",".ex5",".mac",".plx",".snap",".ps1",".vdo",".mxe",".gs",".osx",".sct",".wiz",".x86",".e_e",".fky",".prg",".fas",".azw2",".actm",".cel",".tiapp",".thm",".kix",".wsf",".vbe",".lo",".ls",".tms",".ezs",".ds",".n",".esh",".vbscript",".arscript",".qit",".pex",".dxl",".wpm",".s2a",".sca",".prc",".shb",".rbx",".jse",".beam",".udf",".mem",".kx",".ksh",".rox",".upx",".ms",".mam",".btm",".es",".asb",".ipf",".mio",".sbs",".hpf",".ita",".eham",".ezt",".dmc",".qpx",".ore",".ncl",".exopc",".smm",".pvd",".ham",".wpk",""};
// Gotten from 'https://fileinfo.com/filetypes/executable'
#endif
bool validate_userfile_extension(string const& path)
{
#ifdef _WIN32
	string ext = get_ext(path);
	for(int q = 0; windows_exe_extensions[q].length()>1; ++q)
	{
		if(ext == windows_exe_extensions[q]) return false;
	}
	return true; //Any other extension, including no extension, is allowed
#else
	return true; //All extensions valid
#endif
}

bool FFScript::get_scriptfile_path(char* buf, const char* path)
{
	while((path[0] == '/' || path[0] == '\\') && path[0]) ++path;
	if(!path[0]) return false;
	sprintf(buf, "%s%s", qst_files_path, path);
	return true;
}

void check_file_error(long ref)
{
	if(user_file* f = checkFile(ref, "", true, true))
	{
		int err = ferror(f->file);
		if(err != 0)
		{
			Z_scripterrlog("File with UID '%ld' encountered an error.\n", ref);
			Z_scripterrlog("File error: %s\n", strerror(err));
		}
	}
}

void FFScript::do_fopen(const bool v, const char* f_mode)
{
	long arrayptr = SH::get_arg(sarg1, v) / 10000;
	string filename_str;
	ArrayH::getString(arrayptr, filename_str, 512);
	regulate_path(filename_str);
	ri->d[2] = 0L; //Presume failure; update to 10000L on success
	if(!valid_file(filename_str))
	{
		Z_scripterrlog("Path '%s' empty or points to a directory; must point to a file!\n",filename_str.c_str());
		return;
	}
	if(!validate_userfile_extension(filename_str))
	{
		Z_scripterrlog("Cannot open/create file with extension '%s'.\n", get_ext(filename_str).c_str());
		return;
	}
	if(filename_str.find("../") != string::npos
		|| filename_str.find("..\\") != string::npos)
	{
		Z_scripterrlog("Error: Script attempted to go up a directory in file load '%s'\n", filename_str.c_str());
		return;
	}
	char buf[2048] = {0};
	FFCore.get_scriptfile_path(buf, filename_str.c_str());
	user_file* f = checkFile(ri->fileref, "Open()", false, true);
	if(!f) //auto-allocate
	{
		ri->fileref = get_free_file();
		f = checkFile(ri->fileref, "Open()", false, true);
	}
	ri->d[3] = ri->fileref; //Returns to the variable!
	if(f)
	{
		f->close(); //Close the old FILE* before overwriting it!
		bool create = false;
		for(int q = 0; f_mode[q]; ++q)
		{
			if(f_mode[q] == 'w')
			{
				create = true;
				break;
			}
		}
		if(!create || create_path(buf))
		{
			f->file = fopen(buf, f_mode);
			fflush(f->file);
			zc_chmod(buf, SCRIPT_FILE_MODE);
			f->setPath(buf);
			//r+; read-write, will not create if does not exist, will not delete content if does exist.
			//w+; read-write, will create if does not exist, will delete all content if does exist.
			if(f->file)
			{
				ri->d[2] = 10000L; //Success
				return;
			}
		}
		else
		{
			Z_scripterrlog("Script failed to create directories for file path '%s'.\n", filename_str.c_str());
			return;
		}
	}
}

void FFScript::do_fremove()
{
	if(user_file* f = checkFile(ri->fileref, "Remove()", true))
	{
		zprint2("Removing file %d\n", ri->fileref);
		ri->d[2] = f->do_remove() ? 0L : 10000L;
	}
	else ri->d[2] = 0L;
}

void FFScript::do_fclose()
{
	if(user_file* f = checkFile(ri->fileref, "Close()", false, true))
	{
		f->close();
	}
	//No else. If invalid, no error is thrown.
}

void FFScript::do_allocate_file()
{
	//Get a file and return it
	ri->fileref = get_free_file();
	ri->d[3] = ri->fileref; //Return to ptr
	ri->d[2] = (ri->d[3] == 0 ? 0L : 10000L);
}

void FFScript::do_deallocate_file()
{
	user_file* f = checkFile(ri->fileref, "Free()", false, true);
	if(f) f->clear();
}

void FFScript::do_file_isallocated() //Returns true if file is allocated
{
	user_file* f = checkFile(ri->fileref, "isAllocated()", false, true);
	ri->d[2] = (f) ? 10000L : 0L;
}

void FFScript::do_file_isvalid() //Returns true if file is allocated and has an open FILE*
{
	user_file* f = checkFile(ri->fileref, "isValid()", true, true);
	ri->d[2] = (f) ? 10000L : 0L;
}

void FFScript::do_fflush()
{
	ri->d[2] = 0L;
	if(user_file* f = checkFile(ri->fileref, "Flush()", true))
	{
		if(!fflush(f->file))
			ri->d[2] = 10000L;
		check_file_error(ri->fileref);
	}
}

void FFScript::do_file_readchars()
{
	if(user_file* f = checkFile(ri->fileref, "ReadChars()", true))
	{
		unsigned int pos = zc_max(ri->d[0] / 10000,0);
		int count = get_register(sarg2) / 10000;
		if(count == 0) return;
		long arrayptr = get_register(sarg1) / 10000;
		ZScriptArray& a = getArray(arrayptr);
		if(a == INVALIDARRAY)
		{
			return;
		}
		if(pos >= a.Size()) return;
		if(count < 0 || unsigned(count) > a.Size()-pos) count = a.Size()-pos;
		int limit = pos+count;
		char c;
		word q;
		ri->d[2] = 0;
		for(q = pos; q < limit; ++q)
		{
			c = fgetc(f->file);
			if(feof(f->file) || ferror(f->file))
				break;
			if(c <= 0)
				break;
			a[q] = c * 10000L;
			++ri->d[2]; //Don't count nullchar towards length
		}
		if(q >= limit)
		{
			--q;
			--ri->d[2];
			ungetc(a[q], f->file); //Put the character back before overwriting it
		}
		a[q] = 0; //Force null-termination
		ri->d[2] *= 10000L;
		check_file_error(ri->fileref);
		return;
	}
	ri->d[2] = 0L;
}
void FFScript::do_file_readstring()
{
	if(user_file* f = checkFile(ri->fileref, "ReadString()", true))
	{
		long arrayptr = get_register(sarg1) / 10000;
		ZScriptArray& a = getArray(arrayptr);
		if(a == INVALIDARRAY)
		{
			return;
		}
		int limit = a.Size();
		int c;
		word q;
		ri->d[2] = 0;
		for(q = 0; q < limit; ++q)
		{
			c = fgetc(f->file);
			if(feof(f->file) || ferror(f->file))
				break;
			if(c <= 0)
				break;
			a[q] = c * 10000L;
			++ri->d[2]; //Don't count nullchar towards length
			if(c == '\n')
			{
				++q;
				break;
			}
		}
		if(q >= limit)
		{
			--q;
			--ri->d[2];
			ungetc(a[q], f->file); //Put the character back before overwriting it
		}
		a[q] = 0; //Force null-termination
		ri->d[2] *= 10000L;
		check_file_error(ri->fileref);
		return;
	}
	ri->d[2] = 0L;
}
void FFScript::do_file_readints()
{
	if(user_file* f = checkFile(ri->fileref, "ReadInts()", true))
	{
		unsigned int pos = zc_max(ri->d[0] / 10000,0);
		int count = get_register(sarg2) / 10000;
		if(count == 0) return;
		long arrayptr = get_register(sarg1) / 10000;
		ZScriptArray& a = getArray(arrayptr);
		if(a == INVALIDARRAY)
		{
			return;
		}
		if(pos >= a.Size()) return;
		if(count < 0 || unsigned(count) > a.Size()-pos) count = a.Size()-pos;
		
		/*
		fseek(f->file, 0L, SEEK_END);
		int foo = ftell(f->file);
		zprint("File size: %ld\n", foo);
		rewind(f->file);
		//*/
		
		std::vector<long> data(count);
		ri->d[2] = 10000L * fread((void*)&(data[0]), 4, count, f->file);
		for(int q = 0; q < count; ++q)
		{
			a[q+pos] = data[q];
		}
		check_file_error(ri->fileref);
		return;
	}
	ri->d[2] = 0L;
}
void FFScript::do_file_writechars()
{
	if(user_file* f = checkFile(ri->fileref, "WriteChars()", true))
	{
		int pos = zc_max(ri->d[0] / 10000,0);
		int count = get_register(sarg2) / 10000;
		if(count == 0) return;
		if(count == -1 || count > (MAX_ZC_ARRAY_SIZE-pos)) count = MAX_ZC_ARRAY_SIZE-pos;
		long arrayptr = get_register(sarg1) / 10000;
		string output;
		ArrayH::getString(arrayptr, output, count, pos);
		//const char* out = output.c_str();
		//ri->d[2] = 10000L * fwrite((const void*)output.c_str(), 1, output.length(), f->file);
		unsigned int q = 0;
		for(; q < output.length(); ++q)
		{
			if(fputc(output[q], f->file)<0)
				break;
		}
		ri->d[2] = q * 10000L;
		check_file_error(ri->fileref);
		return;
	}
	ri->d[2] = 0L;
}
void FFScript::do_file_writestring()
{
	if(user_file* f = checkFile(ri->fileref, "WriteString()", true))
	{
		long arrayptr = get_register(sarg1) / 10000;
		string output;
		ArrayH::getString(arrayptr, output, ZSCRIPT_MAX_STRING_CHARS);
		//const char* out = output.c_str();
		//ri->d[2] = 10000L * fwrite((const void*)output.data, sizeof(char), output.length(), f->file);
		unsigned int q = 0;
		for(; q < output.length(); ++q)
		{
			if(fputc(output[q], f->file)<0)
				break;
		}
		ri->d[2] = q * 10000L;
		check_file_error(ri->fileref);
		return;
	}
	ri->d[2] = 0L;
}
void FFScript::do_file_writeints()
{
	if(user_file* f = checkFile(ri->fileref, "WriteInts()", true))
	{
		unsigned int pos = zc_max(ri->d[0] / 10000,0);
		int count = get_register(sarg2) / 10000;
		if(count == 0) return;
		long arrayptr = get_register(sarg1) / 10000;
		ZScriptArray& a = getArray(arrayptr);
		if(a == INVALIDARRAY)
		{
			return;
		}
		if(pos >= a.Size()) return;
		if(count < 0 || unsigned(count) > a.Size()-pos) count = a.Size()-pos;
		std::vector<long> data(count);
		for(int q = 0; q < count; ++q)
		{
			data[q] = a[q+pos];
		}
		ri->d[2] = 10000L * fwrite((const void*)&(data[0]), 4, count, f->file);
		check_file_error(ri->fileref);
		return;
	}
	ri->d[2] = 0L;
}

void FFScript::do_file_getchar()
{
	if(user_file* f = checkFile(ri->fileref, "GetChar()", true))
	{
		ri->d[2] = fgetc(f->file) * 10000L;
		check_file_error(ri->fileref);
		return;
	}
	ri->d[2] = -10000L; //-1 == EOF; error value
}
void FFScript::do_file_putchar()
{
	if(user_file* f = checkFile(ri->fileref, "PutChar()", true))
	{
		int c = get_register(sarg1) / 10000;
		if(char(c) != c)
		{
			Z_scripterrlog("Invalid character val %d passed to PutChar(); value will overflow.", c);
			c = char(c);
		}
		ri->d[2] = fputc(c, f->file) * 10000L;
		check_file_error(ri->fileref);
		return;
	}
	ri->d[2] = -10000L; //-1 == EOF; error value
}
void FFScript::do_file_ungetchar()
{
	if(user_file* f = checkFile(ri->fileref, "UngetChar()", true))
	{
		int c = get_register(sarg1) / 10000;
		if(char(c) != c)
		{
			Z_scripterrlog("Invalid character val %d passed to UngetChar(); value will overflow.", c);
			c = char(c);
		}
		ri->d[2] = ungetc(c,f->file) * 10000L;
		check_file_error(ri->fileref);
		return;
	}
	ri->d[2] = -10000L; //-1 == EOF; error value
}

void FFScript::do_file_seek()
{
	if(user_file* f = checkFile(ri->fileref, "Seek()", true))
	{
		int pos = get_register(sarg1); //NOT /10000 -V
		int origin = get_register(sarg2) ? SEEK_CUR : SEEK_SET;
		ri->d[2] = fseek(f->file, pos, origin) ? 0L : 10000L;
		check_file_error(ri->fileref);
		return;
	}
	ri->d[2] = 0;
}
void FFScript::do_file_rewind()
{
	if(user_file* f = checkFile(ri->fileref, "Rewind()", true))
	{
		//fseek(f->file, 0L, SEEK_END);
		rewind(f->file);
		check_file_error(ri->fileref);
	}
}
void FFScript::do_file_clearerr()
{
	if(user_file* f = checkFile(ri->fileref, "ClearError()", true))
	{
		clearerr(f->file);
	}
}

void FFScript::do_file_geterr()
{
	if(user_file* f = checkFile(ri->fileref, "GetError()", true))
	{
		int err = ferror(f->file);
		long arrayptr = get_register(sarg1) / 10000;
		if(err)
		{
			string error = strerror(err);
			ArrayH::setArray(arrayptr, error);
		}
		else
		{
			ArrayH::setArray(arrayptr, "\0");
		}
	}
}
///----------------------------------------------------------------------------------------------------


void FFScript::do_write_bitmap()
{
	for ( int q = 0; q < 16; q++)
	zprint("do_write_bitmap stack sp+%d: %d\n", q, SH::read_stack(ri->sp+q));
	long arrayptr = get_register(sarg2) / 10000;
	string filename_str;

	ArrayH::getString(arrayptr, filename_str, 512);
	int ref = ri->bitmapref-10;
	zprint("WriteBitmap() filename is %s\n",filename_str.c_str());
	zprint("WriteBitmap ri->bitmapref is: %d\n",ref );
	if ( ref <= 0 )
	{
		if (ref == -2 )
		{
			save_bitmap(filename_str.c_str(), framebuf, RAMpal);
			zprint("Wrote image file %s\n",filename_str.c_str());
		}
		else
		{
			Z_scripterrlog("WriteBitmap() failed to write image file %s\n",filename_str.c_str());
		}
	}
	else if ( ref >= 7 )
	{
		if ( scb.script_created_bitmaps[ref].u_bmp ) 
		{
			save_bitmap(filename_str.c_str(), scb.script_created_bitmaps[ri->bitmapref-10].u_bmp, RAMpal);
			zprint("Wrote image file %s\n",filename_str.c_str());
		}
		else
		{
			Z_scripterrlog("WriteBitmap() failed to write image file %s\n",filename_str.c_str());
		}
	}
	else
	{
		if ( zscriptDrawingRenderTarget->GetBitmapPtr(ref) ) 
		{
			save_bitmap(filename_str.c_str(), zscriptDrawingRenderTarget->GetBitmapPtr(ref), RAMpal);
			zprint("Wrote image file %s\n",filename_str.c_str());
		}
		else
		{
			Z_scripterrlog("WriteBitmap() failed to write image file %s\n",filename_str.c_str());
		}
	}
}

void FFScript::set_sarg1(int v)
{
	set_register(sarg1, v);
}

//script_bitmaps scb;

long FFScript::do_allocate_bitmap()
{	
	return FFCore.get_free_bitmap();
}
void FFScript::do_isvalidbitmap()
{
	long UID = get_register(sarg1);
	//zprint("isValidBitmap() bitmap pointer value is %d\n", UID);
	if ( UID <= 0 ) set_register(sarg1, 0); 
	else if ( scb.script_created_bitmaps[UID-10].u_bmp ) 
		set_register(sarg1, 10000);
	else set_register(sarg1, 0);
}
void FFScript::do_isallocatedbitmap()
{
	long UID = get_register(sarg1);
	//zprint("isAllocatedBitmap() bitmap pointer value is %d\n", UID);
	if ( UID <= 0 ) set_register(sarg1, 0); 
	else
	{
		set_register(sarg1, (scb.script_created_bitmaps[UID-10].reserved()) ? 10000L : 0L);
		/*
		UID-=10;
		if ( UID <= highest_valid_user_bitmap() || UID < firstUserGeneratedBitmap)
			set_register(sarg1, 10000);
		else set_register(sarg1, 0);
		*/
		
	}
}

void FFScript::user_bitmaps_init()
{
	scb.clear();
}

long FFScript::do_create_bitmap()
{
	//zprint("Begin running FFCore.do_create_bitmap()\n");
	//CreateBitmap(h,w)
	long w = (ri->d[1] / 10000);
	long h = (ri->d[0]/10000);
	if ( get_bit(quest_rules, qr_OLDCREATEBITMAP_ARGS) )
	{
		//flip height and width
		h = h ^ w;
		w = h ^ w; 
		h = h ^ w;
	}
	
	return create_user_bitmap_ex(h,w,8);
}

long FFScript::create_user_bitmap_ex(int w, int h, int d = 8)
{
	int id = get_free_bitmap();
	if ( id > 0 )
	{
		user_bitmap* bmp = &(scb.script_created_bitmaps[id-10]);
		bmp->width = w;
		bmp->height = h;
		bmp->depth = d;
		bmp->u_bmp = create_bitmap_ex(d,w,h);
		clear_bitmap(bmp->u_bmp);
	}
	return id;
}

BITMAP* FFScript::GetScriptBitmap(int id)
{
	switch(id)
	{
		case rtSCREEN:
		case rtBMP0:
		case rtBMP1:
		case rtBMP2:
		case rtBMP3:
		case rtBMP4:
		case rtBMP5:
		case rtBMP6: //old system bitmaps (render targets)
		{
			return zscriptDrawingRenderTarget->GetBitmapPtr(id);
		}
		default: 
		{
			if(user_bitmap* b = checkBitmap(id+10, NULL, true))
			{
				return b->u_bmp;
			}
			else return NULL;
		}
	}
}

int FFScript::get_free_bitmap(bool skipError)
{
	user_bitmap* bmps = scb.script_created_bitmaps;
	for(int q = MIN_USER_BITMAPS; q < MAX_USER_BITMAPS; ++q)
	{
		if(!bmps[q].reserved())
		{
			bmps[q].reserve();
			return q+10;
		}
	}
	if(!skipError) Z_scripterrlog("get_free_bitmap() could not find a valid free bitmap pointer!\n");
	return 0;
}

void FFScript::do_deallocate_bitmap()
{
	if(isSystemBitref(ri->bitmapref))
	{
		return; //Don't attempt to deallocate system bitmaps!
	}
	user_bitmap* b = checkBitmap(ri->bitmapref, "Free()", false, true);
	if(b)
	{
		b->free();
	}
}

bool FFScript::isSystemBitref(long ref)
{
	switch(ref-10)
	{
		case rtSCREEN:
		case rtBMP0:
		case rtBMP1:
		case rtBMP2:
		case rtBMP3:
		case rtBMP4:
		case rtBMP5:
		case rtBMP6:
			return true;
	}
	return false;
}

///----------------------------------------------------------------------------------------------------

void FFScript::set_screenwarpReturnY(mapscr *m, int d, int value)
{
	int y = vbound(value, 0, 255); //should be screen hight max, except that we may be able to move the subscreen.
	m->warpreturny[d] = y;
}

void FFScript::set_screendoor(mapscr *m, int d, int value)
{
	int dr = vbound(d,0,3);
	int doortype = vbound(value,0,14);
	m->door[dr] = doortype;
}


void FFScript::set_screenenemy(mapscr *m, int index, int value)
{
	int enem_indx = vbound(index,0,9);
	m->enemy[enem_indx] = vbound(value,0,511);
}
void FFScript::set_screenlayeropacity(mapscr *m, int d, int value)
{
	int layer = vbound(d,0,6); int op;
	if ( value <= 64 ) op = 64; 
	else op = 128;
	m->layeropacity[layer] = op;
}
void FFScript::set_screensecretcombo(mapscr *m, int d, int value)
{
	int indx = vbound(value,0,127);
	int cmb = vbound(value,0,MAXCOMBOS);
	m->secretcombo[indx] = cmb;
}
void FFScript::set_screensecretcset(mapscr *m, int d, int value)
{
	int indx = vbound(value,0,127);
	int cs = vbound(value,0,15);
	m->secretcset[indx] = cs;
}
void FFScript::set_screensecretflag(mapscr *m, int d, int value)
{
	int indx = vbound(d,0,127);
	int flag = vbound(value,0,MAX_FLAGS);
	m->secretflag[indx] = flag;
}
void FFScript::set_screenlayermap(mapscr *m, int d, int value)
{
	int layer = vbound(d, MIN_ZQ_LAYER, MAX_ZQ_LAYER);
	int mp = vbound(value,0, (map_count-1));
	m->layermap[layer] = mp;
}
void FFScript::set_screenlayerscreen(mapscr *m, int d, int value)
{
	int layer = vbound(d, MIN_ZQ_LAYER, MAX_ZQ_LAYER);
	int sc = vbound(value,0, 0x87);
	m->layerscreen[layer] = sc;
}
void FFScript::set_screenpath(mapscr *m, int d, int value)
{
	int indx = vbound(d,0,3);
	m->path[indx] = value;
}
void FFScript::set_screenwarpReturnX(mapscr *m, int d, int value)
{
	int x = vbound(value,0,255);
	m->warpreturnx[d] = x;
}


//Use as SetScreenD:
void FFScript::set_screenWidth(mapscr *m, int value)
{
	int w = vbound(value,0,255); //value is char
	m->scrWidth = w;
}
void FFScript::set_screenHeight(mapscr *m, int value)
{
	int h = vbound(value,0,255); //value is char
	m->scrHeight = h;
}
void FFScript::set_screenViewX(mapscr *m, int value)
{
	int x = vbound(value, 0, 255); //value is char
	m->viewX = x;
}
void FFScript::set_screenViewY(mapscr *m, int value)
{
	int y = vbound(value, 0, 255); //value is char
	m->viewY = y;
}
void FFScript::set_screenGuy(mapscr *m, int value)
{
	int bloke = vbound(value,0,9); 
	m->guy = bloke ;
}
void FFScript::set_screenString(mapscr *m, int value)
{
	int string = vbound(value, 0, msg_count-1); //Sanity check to keep it within the legal string IDs.
	m->str = string;
}
void FFScript::set_screenRoomtype(mapscr *m, int value)
{
	int r = vbound(value, rNONE, (rMAX-1)); 
	m->room = r;
}
void FFScript::set_screenEntryX(mapscr *m, int value)
{
	int x = vbound(value,0,255);
	m->entry_x = x;
}
void FFScript::set_screenEntryY(mapscr *m, int value)
{
	int y = vbound(value,0,255);
	m->entry_y = y;
}
void FFScript::set_screenitem(mapscr *m, int value)
{
	int itm = vbound(value,0,MAXITEMS);
	m->item = itm;
}
void FFScript::set_screenundercombo(mapscr *m, int value)
{
	int cmb = vbound(value,0,MAXCOMBOS);
	m->undercombo = cmb;
}
void FFScript::set_screenundercset(mapscr *m, int value)
{
	int cs = vbound(value,0,15);
	m->undercset = cs;
}
void FFScript::set_screenatchall(mapscr *m, int value)
{
	//What are ALL of the catchalls and their max (used) values?
	int ctch = vbound(value, 0, 65535); //It is a word type. 
	m->catchall = ctch;
}


//One too many inputs here. -Z
long FFScript::get_screenWidth(mapscr *m)
{
	long f = m->scrWidth;
	return f*10000;
}
//One too many inputs here. -Z
long FFScript::get_screenHeight(mapscr *m)
{
	int f = m->scrHeight;
	return f*10000;
}

int FFScript::GetQuestVersion()
{
	return ZCheader.zelda_version;
}
int FFScript::GetQuestBuild()
{
	return ZCheader.build;
}
int FFScript::GetQuestSectionVersion(int section)
{
	return ZCheader.zelda_version;
}

int FFScript::GetDefaultWeaponSprite(int wpn_id)
{
	switch (wpn_id)
	{
		case wNone:
			return 0; 
		
		case wSword: return 0;
		case wBeam: return 1;
		case wBrang: return 4;
		case wBomb: return 9;
		case wSBomb: return 75;
		case wLitBomb: return 7;
		case wLitSBomb: return 8;
		case wArrow: return 10;
		case wFire: return 12;
		case wWhistle: return 45; //blank, unused misc sprite
		case wBait: return 14;
		case wWand: return 15;
		case wMagic: return 16;
		case wCatching: return 45; //blank, unused misc sprite
		case wWind: return 13;
		case wRefMagic: return 16;
		case wRefFireball: return 17;
		case wRefRock: return 18;
		case wHammer: return 25;
		case wHookshot: return 26;
		case wHSHandle: return 28;
		case wHSChain: return 27;
		case wSSparkle: return 29;
		case wFSparkle: return 32;
		case wSmack: return 33;
		case wPhantom: return -1;
		case wCByrna: return 87;
		case wRefBeam: return 1;
		case wStomp: return 45; //blank, unused misc sprite
		case lwMax: return 45; //blank, unused misc sprite
		case wScript1: { if ( get_bit(quest_rules, qr_WRITING_NPC_WEAPON_UNIQUE_SPRITES ) ) return 246; else return 0; }
		case wScript2: { if ( get_bit(quest_rules, qr_WRITING_NPC_WEAPON_UNIQUE_SPRITES ) ) return 247; else return 0; }
		case wScript3: { if ( get_bit(quest_rules, qr_WRITING_NPC_WEAPON_UNIQUE_SPRITES ) ) return 248; else return 0; }
		case wScript4: { if ( get_bit(quest_rules, qr_WRITING_NPC_WEAPON_UNIQUE_SPRITES ) ) return 249; else return 0; }
		case wScript5: { if ( get_bit(quest_rules, qr_WRITING_NPC_WEAPON_UNIQUE_SPRITES ) ) return 250; else return 0; }
		case wScript6: { if ( get_bit(quest_rules, qr_WRITING_NPC_WEAPON_UNIQUE_SPRITES ) ) return 251; else return 0; }
		case wScript7: { if ( get_bit(quest_rules, qr_WRITING_NPC_WEAPON_UNIQUE_SPRITES ) ) return 252; else return 0; }
		case wScript8: { if ( get_bit(quest_rules, qr_WRITING_NPC_WEAPON_UNIQUE_SPRITES ) ) return 253; else return 0; }
		case wScript9: { if ( get_bit(quest_rules, qr_WRITING_NPC_WEAPON_UNIQUE_SPRITES ) ) return 254; else return 0; }
		case wScript10: { if ( get_bit(quest_rules, qr_WRITING_NPC_WEAPON_UNIQUE_SPRITES ) ) return 255; else return 0; }

		case wIce: return 83;
			//Cannot use any of these weapons yet. 
			//return -1;
		
		case wEnemyWeapons:
		case ewFireball: return 17;
		
		case ewArrow: return 19; 
		case ewBrang: return 4; 
		case ewSword: return 20; 
		case ewRock: return 18; 
		case ewMagic: return 21; 
		case ewBomb: return 78; 
		case ewSBomb: return 79; 
		case ewLitBomb: return 76; 
		case ewLitSBomb: return 77; 
		case ewFireTrail: return 80; 
		case ewFlame: return 35; 
		case ewWind: return 36; 
		case ewFlame2: return 81; 
		case ewFlame2Trail: return 82; 
		case ewIce: return 83; 
		case ewFireball2: return 17;  //fireball (rising)
		
			
		default:  return -1; //No assign.
		
	}
}

//bitmap->GetPixel()


int FFScript::do_getpixel()
{

	int xoffset = 0, yoffset = 0;
	int xoff = 0; int yoff = 0; //IDR where these are normally read off-hand. 
	//Sticking this here to do initial tests. Will fix later. 
	//They're for the subscreen offsets. 
	const bool brokenOffset= ( (get_bit(extra_rules, er_BITMAPOFFSET)!=0) || (get_bit(quest_rules,qr_BITMAPOFFSETFIX)!=0) );
	
	//bool isTargetOffScreenBmp = false;
	//al_trace("Getpixel: The current bitmap ID is: %d /n",ri->bitmapref);
	//zscriptDrawingRenderTarget->SetCurrentRenderTarget(ri->bitmapref);
	//BITMAP *bitty = zscriptDrawingRenderTarget->GetBitmapPtr(ri->bitmapref);
	BITMAP *bitty = FFCore.GetScriptBitmap(ri->bitmapref-10);
	zprint("Getpixel pointer is: %d\n", ri->bitmapref-10);
	//bmp = targetBitmap;
	if(!bitty)
		{
		bitty = scrollbuf;
		//al_trace("Getpixel: Loaded ScrollBuf into bitty /n");
		//return -10000;
	}
	// draw to screen with subscreen offset
	if(!brokenOffset && ri->bitmapref == 10-1 )
	{
				xoffset = xoff;
				yoffset = 56; //should this be -56?
	}
	else
	{
		xoffset = 0;
		yoffset = 0;
	}
	//sdci[1]=x
	//sdci[2]=y
	//sdci[3]= return val?
	//al_trace("Getpixel: ri->d[0] is: %d /n",ri->d[0]);
	//al_trace("Getpixel: ri->d[1] is: %d /n",ri->d[1]);
	//int x1=ri->d[0]/10000;
	//int y1=ri->d[1]/10000;
	
	//al_trace("Getpixel: X is: %d /n",x1);
	//al_trace("Getpixel: Y is: %d /n",y1);
	//al_trace("Getpixel: X is: %d /n",ri->d[0]/10000);
	//al_trace("Getpixel: Y is: %d /n",ri->d[1]/10000);
	
	int yv = ri->d[1]/10000 + yoffset;
	//int ret =  getpixel(bitty, x1+xoffset, y1+yoffset); //This is a palette index value. 
	int ret =  getpixel(bitty, ri->d[0]/10000, yv	); //This is a palette index value. 
	
	//al_trace("Getpixel: Returning a palette index value of: %d /n",ret);
	//al_trace("I'm not yet sure if the PALETTE type will use a value div/mult by 10000. /n");
	
	return ret;
}


long FFScript::loadMapData()
{
	long _map = (ri->d[0] / 10000);
	long _scr = (ri->d[1]/10000);
	int indx = (zc_max((_map)-1,0) * MAPSCRS + _scr);
	//zprint("LoadMapData Map Value: %d\n", _map);
	//zprint("LoadMapData Screen Value: %d\n", _scr);
	//zprint("LoadMapData Indx Value: %d\n", indx);
	 if ( _map < 1 || _map > map_count )
	{
		Z_scripterrlog("Invalid Map ID passed to Game->LoadMapData: %d\n", _map);
		ri->mapsref = LONG_MAX;
		return LONG_MAX;
	}
	else if ( _scr < 0 || _scr > 129 ) //0x00 to 0x81 -Z
	{
		Z_scripterrlog("Invalid Screen ID passed to Game->LoadMapData: %d\n", _scr);
		ri->mapsref = LONG_MAX;
		return LONG_MAX;
	}
	else ri->mapsref = indx;
	//zprint("LoadMapData Screen set ri->mapsref to: %d\n", ri->mapsref);
	return ri->mapsref;
}


// Called when leaving a screen; deallocate arrays created by FFCs that aren't carried over
void FFScript::deallocateZScriptArray(const long ptrval)
{
	if(ptrval<=0 || ptrval >= NUM_ZSCRIPT_ARRAYS)
		Z_scripterrlog("Script tried to deallocate memory at invalid address %ld\n", ptrval);
	else
	{
		arrayOwner[ptrval].clear();
		
		if(localRAM[ptrval].Size() == 0)
			Z_scripterrlog("Script tried to deallocate memory that was not allocated at address %ld\n", ptrval);
		else
		{
			word size = localRAM[ptrval].Size();
			localRAM[ptrval].Clear();
			
			// If this happens once per frame, it can drown out every other message. -L
			//Z_eventlog("Deallocated local array with address %ld, size %d\n", ptrval, size);
			size = size;
		}
	}
}

int FFScript::get_screen_d(long index1, long index2)
{
	if(index2 < 0 || index2 > 7)
	{
		Z_scripterrlog("You were trying to reference an out-of-bounds array index for a screen's D[] array (%ld); valid indices are from 0 to 7.\n", index1);
		return 0;
	}
	
	return game->screen_d[index1][index2];
}

void FFScript::set_screen_d(long index1, long index2, int val)
{
	if(index2 < 0 || index2 > 7)
	{
		Z_scripterrlog("You were trying to reference an out-of-bounds array index for a screen's D[] array (%ld); valid indices are from 0 to 7.\n", index1);
		return;
	}
	
	game->screen_d[index1][index2] = val;
}

// If scr is currently being used as a layer, return that layer no.
int FFScript::whichlayer(long scr)
{
	for(int i = 0; i < 6; i++)
	{
		if(scr == (tmpscr->layermap[i] - 1) * MAPSCRS + tmpscr->layerscreen[i])
			return i;
	}
	
	return -1;
}

void FFScript::clear_ffc_stack(const byte i)
{
	memset(ffc_stack[i], 0, MAX_SCRIPT_REGISTERS * sizeof(long));
}

void FFScript::clear_global_stack(const byte i)
{
	memset(global_stack[i], 0, MAX_SCRIPT_REGISTERS * sizeof(long));
}

void FFScript::do_zapout()
{
	zapout();
}

void FFScript::do_zapin(){ zapin(); }

void FFScript::do_openscreen() { openscreen(); }
void FFScript::do_closescreen() { closescreen(); }
void FFScript::do_openscreenshape()
{
	int shape = get_register(sarg1) / 10000;
	if(shape < 0 || shape >= bosMAX)
	{
		Z_scripterrlog("Invalid shape passed to %s! Valid range %d to %d. Using 'Circle' shape.\n", "Screen->OpeningWipe(int)", 0, bosMAX-1);
		shape = bosCIRCLE;
	}
	openscreen(shape);
}
void FFScript::do_closescreenshape()
{
	int shape = get_register(sarg1) / 10000;
	if(shape < 0 || shape >= bosMAX)
	{
		Z_scripterrlog("Invalid shape passed to %s! Valid range %d to %d. Using 'Circle' shape.\n", "Screen->ClosingWipe(int)", 0, bosMAX-1);
		shape = bosCIRCLE;
	}
	closescreen(shape);
}
void FFScript::do_wavyin() { wavyin(); }
void FFScript::do_wavyout() { wavyout(false); }


void FFScript::do_triggersecret(const bool v)
{
	long ID = vbound((SH::get_arg(sarg1, v) / 10000), 0, 255);
	mapscr *s = tmpscr;
	int ft=0, checkflag; //Flag trigger, checked flag temp. 
	bool putit = true;  //Is set false with a mismatch (illegal value input).
	//Convert a flag type to a secret type. -Z
	switch(ID)
	{
		case mfBCANDLE:
			ft=sBCANDLE;
			break;
			
		case mfRCANDLE:
			ft=sRCANDLE;
			break;
			
		case mfWANDFIRE:
			ft=sWANDFIRE;
			break;
			
		case mfDINSFIRE:
			ft=sDINSFIRE;
			break;
			
		case mfARROW:
			ft=sARROW;
			break;
			
		case mfSARROW:
			ft=sSARROW;
			break;
			
		case mfGARROW:
			ft=sGARROW;
			break;
			
		case mfSBOMB:
			ft=sSBOMB;
			break;
			
		case mfBOMB:
			ft=sBOMB;
			break;
			
		case mfBRANG:
			ft=sBRANG;
			break;
			
		case mfMBRANG:
			ft=sMBRANG;
			break;
			
		case mfFBRANG:
			ft=sFBRANG;
			break;
			
		case mfWANDMAGIC:
			ft=sWANDMAGIC;
			break;
			
		case mfREFMAGIC:
			ft=sREFMAGIC;
			break;
			
		case mfREFFIREBALL:
			ft=sREFFIREBALL;
			break;
			
		case mfSWORD:
			ft=sSWORD;
			break;
			
		case mfWSWORD:
			ft=sWSWORD;
			break;
			
		case mfMSWORD:
			ft=sMSWORD;
			break;
			
		case mfXSWORD:
			ft=sXSWORD;
			break;
			
		case mfSWORDBEAM:
			ft=sSWORDBEAM;
			break;
			
		case mfWSWORDBEAM:
			ft=sWSWORDBEAM;
			break;
			
		case mfMSWORDBEAM:
			ft=sMSWORDBEAM;
			break;
			
		case mfXSWORDBEAM:
			ft=sXSWORDBEAM;
			break;
			
		case mfHOOKSHOT:
			ft=sHOOKSHOT;
			break;
			
		case mfWAND:
			ft=sWAND;
			break;
			
		case mfHAMMER:
			ft=sHAMMER;
			break;
			
		case mfSTRIKE:
			ft=sSTRIKE;
			break;
			
		default:
			putit = false;
			break;
	}
	if ( putit )
	{		
		for(int iter=0; iter<2; ++iter)
		{
			for ( int q = 0; q < 176; q++ ) 
			{		
				if(iter==1) checkflag=s->sflag[q]; //Placed
				else checkflag=combobuf[s->data[q]].flag; //Inherent
				Z_message("checkflag is: %d\n", checkflag);
				al_trace("checkflag is: %d\n", checkflag);
				
				Z_message("ID is: %ld\n", ID);
				al_trace("ID is: %ld\n", ID);
				//cmbx = COMBOX(q);
				////cmby = COMBOY(q);
				
				//Placed flags
				if ( iter == 1 )
				{
					if ( s->sflag[q] == ID ) {
						screen_combo_modify_preroutine(s,q);
						s->data[q] = s->secretcombo[ft];
						s->cset[q] = s->secretcset[ft];
						s->sflag[q] = s->secretflag[ft];
						// newflag = s->secretflag[ft];
						screen_combo_modify_postroutine(s,q);
					}
				}
				//Inherent flags
				else
				{
					if ( combobuf[s->data[q]].flag == ID ) {
						screen_combo_modify_preroutine(s,q);
						s->data[q] = s->secretcombo[ft];
						s->cset[q] = s->secretcset[ft];
						//s->sflag[q] = s->secretflag[ft];
						screen_combo_modify_postroutine(s,q);
					}
					
				}
			}
		}
	}
	
}

//Get rid of this pile of rubbish. it does not work! -Z
void FFScript::do_changeffcscript(const bool v)
{
	long ID = vbound((SH::get_arg(sarg1, v) / 10000), 0, 255);
	/*
	for(long i = 1; i < NUM_ZSCRIPT_ARRAYS; i++)
	{
		if(arrayOwner[i]==ri->ffcref)
		FFScript::deallocateZScriptArray(i);
	}
	
	tmpscr->ffscript[ri->ffcref] = vbound(ID/10000, 0, scripts.ffscripts.size()-1);
	
	for(int i=0; i<16; i++)
		ffmisc[ri->ffcref][i] = 0;
		
	for(int i=0; i<2; i++)
		tmpscr->inita[ri->ffcref][i] = 0;
		
	for(int i=0; i<8; i++)
		tmpscr->initd[ri->ffcref][i] = 0;
		
	ffcScriptData[ri->ffcref].Clear();
	tmpscr->initialized[ri->ffcref] = true;
	*/
}




//NPCData

//NPCData Getter Macros


	

//NPCData-> Function
#define GET_NPCDATA_FUNCTION_VAR_INT(member) \
{ \
	long ID = get_register(sarg2) / 10000; \
	if(ID < 1 || ID > (MAXGUYS-1)) \
		set_register(sarg1, -10000); \
	else \
		set_register(sarg1, guysbuf[ID].member * 10000); \
}

#define GET_NPCDATA_FUNCTION_VAR_INDEX(member, indexbound) \
{ \
	int ID = int(ri->d[0] / 10000);\
	int indx = vbound((ri->d[1] / 10000), 0, indexbound); \
	if(ID < 1 || ID > (MAXGUYS-1)) \
		set_register(sarg1, -10000); \
	else \
		set_register(sarg1, guysbuf[ID].member[indx] * 10000); \
}

#define GET_NPCDATA_FUNCTION_VAR_FLAG(member) \
{ \
	int ID = int(ri->d[0] / 10000);\
	int flag = int(ri->d[1] / 10000);\
	if(ID < 1 || ID > (MAXGUYS-1)) \
		set_register(sarg1, -10000); \
	else \
		set_register(sarg1, (guysbuf[ID].member&flag) ? 10000 : 0); \
}

void FFScript::getNPCData_tile(){ GET_NPCDATA_FUNCTION_VAR_INT(tile); } //word
void FFScript::getNPCData_e_height(){ GET_NPCDATA_FUNCTION_VAR_INT(e_height); } 
void FFScript::getNPCData_flags(){ GET_NPCDATA_FUNCTION_VAR_INT(flags); } //word
void FFScript::getNPCData_flags2(){ GET_NPCDATA_FUNCTION_VAR_INT(flags2); } 
void FFScript::getNPCData_width(){ GET_NPCDATA_FUNCTION_VAR_INT(width); } 
void FFScript::getNPCData_height(){ GET_NPCDATA_FUNCTION_VAR_INT(height); } 
void FFScript::getNPCData_s_tile(){ GET_NPCDATA_FUNCTION_VAR_INT(s_tile); } 
void FFScript::getNPCData_s_width(){ GET_NPCDATA_FUNCTION_VAR_INT(s_width); } 
void FFScript::getNPCData_s_height(){ GET_NPCDATA_FUNCTION_VAR_INT(s_height); } 
void FFScript::getNPCData_e_tile(){ GET_NPCDATA_FUNCTION_VAR_INT(e_tile); } 
void FFScript::getNPCData_e_width(){ GET_NPCDATA_FUNCTION_VAR_INT(e_width); } 
void FFScript::getNPCData_hp(){ GET_NPCDATA_FUNCTION_VAR_INT(hp); } 
void FFScript::getNPCData_family(){ GET_NPCDATA_FUNCTION_VAR_INT(family); } 
void FFScript::getNPCData_cset(){ GET_NPCDATA_FUNCTION_VAR_INT(cset); } 
void FFScript::getNPCData_anim(){ GET_NPCDATA_FUNCTION_VAR_INT(anim); } 
void FFScript::getNPCData_e_anim(){ GET_NPCDATA_FUNCTION_VAR_INT(e_anim); } 
void FFScript::getNPCData_frate(){ GET_NPCDATA_FUNCTION_VAR_INT(frate); } 
void FFScript::getNPCData_e_frate(){ GET_NPCDATA_FUNCTION_VAR_INT(e_frate); } 
void FFScript::getNPCData_dp(){ GET_NPCDATA_FUNCTION_VAR_INT(dp); } 
void FFScript::getNPCData_wdp(){ GET_NPCDATA_FUNCTION_VAR_INT(wdp); } 
void FFScript::getNPCData_weapon(){ GET_NPCDATA_FUNCTION_VAR_INT(weapon); } 
void FFScript::getNPCData_rate(){ GET_NPCDATA_FUNCTION_VAR_INT(rate); } 
void FFScript::getNPCData_hrate(){ GET_NPCDATA_FUNCTION_VAR_INT(hrate); } 
void FFScript::getNPCData_step(){ GET_NPCDATA_FUNCTION_VAR_INT(step); } 
void FFScript::getNPCData_homing(){ GET_NPCDATA_FUNCTION_VAR_INT(homing); } 
void FFScript::getNPCData_grumble(){ GET_NPCDATA_FUNCTION_VAR_INT(grumble); } 
void FFScript::getNPCData_item_set(){ GET_NPCDATA_FUNCTION_VAR_INT(item_set); } 
void FFScript::getNPCData_bgsfx(){ GET_NPCDATA_FUNCTION_VAR_INT(bgsfx); } 
void FFScript::getNPCData_hitsfx(){ GET_NPCDATA_FUNCTION_VAR_INT(hitsfx); } 
void FFScript::getNPCData_deadsfx(){ GET_NPCDATA_FUNCTION_VAR_INT(deadsfx); } 
void FFScript::getNPCData_xofs(){ GET_NPCDATA_FUNCTION_VAR_INT(xofs); } 
void FFScript::getNPCData_yofs(){ GET_NPCDATA_FUNCTION_VAR_INT(yofs); } 
void FFScript::getNPCData_zofs(){ GET_NPCDATA_FUNCTION_VAR_INT(zofs); } 
void FFScript::getNPCData_hxofs(){ GET_NPCDATA_FUNCTION_VAR_INT(hxofs); } 
void FFScript::getNPCData_hyofs(){ GET_NPCDATA_FUNCTION_VAR_INT(hyofs); } 
void FFScript::getNPCData_hxsz(){ GET_NPCDATA_FUNCTION_VAR_INT(hxsz); } 
void FFScript::getNPCData_hysz(){ GET_NPCDATA_FUNCTION_VAR_INT(hysz); } 
void FFScript::getNPCData_hzsz(){ GET_NPCDATA_FUNCTION_VAR_INT(hzsz); } 
void FFScript::getNPCData_txsz(){ GET_NPCDATA_FUNCTION_VAR_INT(txsz); } 
void FFScript::getNPCData_tysz(){ GET_NPCDATA_FUNCTION_VAR_INT(tysz); } 
void FFScript::getNPCData_wpnsprite(){ GET_NPCDATA_FUNCTION_VAR_INT(wpnsprite); } 

//NPCData Getters, two inputs, one return, similar to ISSolid

/*

void do_issolid()
{
	int x = int(ri->d[0] / 10000);
	int y = int(ri->d[1] / 10000);
	
	set_register(sarg1, (_walkflag(x, y, 1) ? 10000 : 0));
}

*/






//void FFScript::getNPCData_scriptdefence(){GET_NPCDATA_FUNCTION_VAR_INDEX(scriptdefence)};


void FFScript::getNPCData_defense(){GET_NPCDATA_FUNCTION_VAR_INDEX(defense,(edefLAST255))};


void FFScript::getNPCData_SIZEflags(){GET_NPCDATA_FUNCTION_VAR_FLAG(SIZEflags);}


void FFScript::getNPCData_misc()
{
	int ID = int(ri->d[0] / 10000); //the enemy ID value
	int indx = int(ri->d[1] / 10000); //the misc index ID
	if ((ID < 1 || ID > 511) || ( indx < 0 || indx > 15 ))
		set_register(sarg1, -10000); 
	switch ( indx )
	{
		case 0: set_register(sarg1, guysbuf[ID].misc1 * 10000); break;
		case 1: set_register(sarg1, guysbuf[ID].misc2 * 10000); break;
		case 2: set_register(sarg1, guysbuf[ID].misc3 * 10000); break;
		case 3: set_register(sarg1, guysbuf[ID].misc4 * 10000); break;
		case 4: set_register(sarg1, guysbuf[ID].misc5 * 10000); break;
		case 5: set_register(sarg1, guysbuf[ID].misc6 * 10000); break;
		case 6: set_register(sarg1, guysbuf[ID].misc7 * 10000); break;
		case 7: set_register(sarg1, guysbuf[ID].misc8 * 10000); break;
		case 8: set_register(sarg1, guysbuf[ID].misc9 * 10000); break;
		case 9: set_register(sarg1, guysbuf[ID].misc10 * 10000); break;
		case 10: set_register(sarg1, guysbuf[ID].misc11 * 10000); break;
		case 11: set_register(sarg1, guysbuf[ID].misc12 * 10000); break;
		case 12: set_register(sarg1, guysbuf[ID].misc13 * 10000); break;
		case 13: set_register(sarg1, guysbuf[ID].misc14 * 10000); break;
		case 14: set_register(sarg1, guysbuf[ID].misc15 * 10000); break;
		default: set_register(sarg1, -10000); break;
	}
}

//NPCData Setters, two inputs, no return; similar to void GetDMapIntro(int DMap, int buffer[]);

/*

void do_getdmapintro(const bool v)
{
	long ID = SH::get_arg(sarg1, v) / 10000;
	long arrayptr = get_register(sarg2) / 10000;
	
	if(BC::checkDMapID(ID, "Game->GetDMapIntro") != SH::_NoError)
		return;
		
	if(ArrayH::setArray(arrayptr, string(DMaps[ID].intro)) == SH::_Overflow)
		Z_scripterrlog("Array supplied to 'Game->GetDMapIntro' not large enough\n");
}

*/

//NPCData Setter Macros

//Variables for spritedata sp->member
	
	

//Functions for NPCData->

#define SET_NPCDATA_FUNCTION_VAR_INT(member, bound) \
{ \
	long ID = get_register(sarg1) / 10000; \
	long val = get_register(sarg2) / 10000; \
	if(ID < 1 || ID > (MAXGUYS-1)) \
		set_register(sarg1, -10000); \
	else \
		guysbuf[ID].member = vbound(val,0,bound); \
}



#define SET_NPCDATA_FUNCTION_VAR_INT_NOBOUND(member) \
{ \
	long ID = get_register(sarg1) / 10000; \
	long val = get_register(sarg2) / 10000; \
	if(ID < 1 || ID > (MAXGUYS-1)) \
		set_register(sarg1, -10000); \
	else \
		guysbuf[ID].member = val; \
}


//SET_NPC_VAR_INDEX(member,value)
#define SET_NPCDATA_FUNCTION_VAR_INDEX(member, val, bound, indexbound) \
{ \
	long ID = (ri->d[0]/10000);  \
	long indx =  vbound((ri->d[1]/10000),0,indexbound);  \
	if(ID < 1 || ID > (MAXGUYS-1)) \
		return; \
	else \
		guysbuf[ID].member[indx] = vbound(val,0,bound); \
}

//Special case for flags, three inputs one return
#define SET_NPCDATA_FUNCTION_VAR_FLAG(member, val) \
{ \
	long ID = (ri->d[0]/10000);  \
	long flag =  (ri->d[1]/10000);  \
	if(ID < 1 || ID > (MAXGUYS-1)) \
		return; \
	else \
	{ \
		if ( val != 0 ) guysbuf[ID].member|=flag; \
		else guysbuf[ID].member|= ~flag; \
	}\
}

void FFScript::setNPCData_flags(){SET_NPCDATA_FUNCTION_VAR_INT(flags,ZS_DWORD);} //word
void FFScript::setNPCData_flags2(){SET_NPCDATA_FUNCTION_VAR_INT(flags2,ZS_DWORD);}
void FFScript::setNPCData_width(){SET_NPCDATA_FUNCTION_VAR_INT(width,ZS_BYTE);}
void FFScript::setNPCData_tile(){SET_NPCDATA_FUNCTION_VAR_INT(tile,ZS_WORD);}
void FFScript::setNPCData_e_height(){SET_NPCDATA_FUNCTION_VAR_INT(e_height,ZS_BYTE);}
void FFScript::setNPCData_height(){SET_NPCDATA_FUNCTION_VAR_INT(height,ZS_BYTE);}
void FFScript::setNPCData_s_tile(){SET_NPCDATA_FUNCTION_VAR_INT(s_tile,ZS_WORD);}
void FFScript::setNPCData_s_width(){SET_NPCDATA_FUNCTION_VAR_INT(s_width,ZS_BYTE);}
void FFScript::setNPCData_s_height(){SET_NPCDATA_FUNCTION_VAR_INT(s_height,ZS_BYTE);}
void FFScript::setNPCData_e_tile(){SET_NPCDATA_FUNCTION_VAR_INT(e_tile,ZS_WORD);}
void FFScript::setNPCData_e_width(){SET_NPCDATA_FUNCTION_VAR_INT(e_width,ZS_BYTE);}
void FFScript::setNPCData_hp(){SET_NPCDATA_FUNCTION_VAR_INT(hp,ZS_SHORT);}
void FFScript::setNPCData_family(){SET_NPCDATA_FUNCTION_VAR_INT(family,ZS_SHORT);}
void FFScript::setNPCData_cset(){SET_NPCDATA_FUNCTION_VAR_INT(cset,ZS_SHORT);}
void FFScript::setNPCData_anim(){SET_NPCDATA_FUNCTION_VAR_INT(anim,ZS_SHORT);}
void FFScript::setNPCData_e_anim(){SET_NPCDATA_FUNCTION_VAR_INT(e_anim,ZS_SHORT);}
void FFScript::setNPCData_frate(){SET_NPCDATA_FUNCTION_VAR_INT(frate,ZS_SHORT);}
void FFScript::setNPCData_e_frate(){SET_NPCDATA_FUNCTION_VAR_INT(e_frate,ZS_SHORT);}
void FFScript::setNPCData_dp(){SET_NPCDATA_FUNCTION_VAR_INT(dp,ZS_SHORT);}
void FFScript::setNPCData_wdp(){SET_NPCDATA_FUNCTION_VAR_INT(wdp,ZS_SHORT);}
void FFScript::setNPCData_weapon(){SET_NPCDATA_FUNCTION_VAR_INT(weapon,ZS_SHORT);}
void FFScript::setNPCData_rate(){SET_NPCDATA_FUNCTION_VAR_INT(rate,ZS_SHORT);}
void FFScript::setNPCData_hrate(){SET_NPCDATA_FUNCTION_VAR_INT(hrate,ZS_SHORT);}
void FFScript::setNPCData_step(){SET_NPCDATA_FUNCTION_VAR_INT(step,ZS_SHORT);}
void FFScript::setNPCData_homing(){SET_NPCDATA_FUNCTION_VAR_INT(homing,ZS_SHORT);}
void FFScript::setNPCData_grumble(){SET_NPCDATA_FUNCTION_VAR_INT(grumble,ZS_SHORT);}
void FFScript::setNPCData_item_set(){SET_NPCDATA_FUNCTION_VAR_INT(item_set,ZS_SHORT);}
void FFScript::setNPCData_bgsfx(){SET_NPCDATA_FUNCTION_VAR_INT(bgsfx,ZS_SHORT);}
void FFScript::setNPCData_hitsfx(){SET_NPCDATA_FUNCTION_VAR_INT(hitsfx,ZS_BYTE);}
void FFScript::setNPCData_deadsfx(){SET_NPCDATA_FUNCTION_VAR_INT(deadsfx,ZS_BYTE);}
void FFScript::setNPCData_xofs(){SET_NPCDATA_FUNCTION_VAR_INT_NOBOUND(xofs);}
void FFScript::setNPCData_yofs(){SET_NPCDATA_FUNCTION_VAR_INT_NOBOUND(yofs);}
void FFScript::setNPCData_zofs(){SET_NPCDATA_FUNCTION_VAR_INT_NOBOUND(zofs);}
void FFScript::setNPCData_hxofs(){SET_NPCDATA_FUNCTION_VAR_INT_NOBOUND(hxofs);}
void FFScript::setNPCData_hyofs(){SET_NPCDATA_FUNCTION_VAR_INT_NOBOUND(hyofs);}
void FFScript::setNPCData_hxsz(){SET_NPCDATA_FUNCTION_VAR_INT_NOBOUND(hxsz);}
void FFScript::setNPCData_hysz(){SET_NPCDATA_FUNCTION_VAR_INT_NOBOUND(hysz);}
void FFScript::setNPCData_hzsz(){SET_NPCDATA_FUNCTION_VAR_INT_NOBOUND(hzsz);}
void FFScript::setNPCData_txsz(){SET_NPCDATA_FUNCTION_VAR_INT_NOBOUND(txsz);}
void FFScript::setNPCData_tysz(){SET_NPCDATA_FUNCTION_VAR_INT_NOBOUND(tysz);}
void FFScript::setNPCData_wpnsprite(){SET_NPCDATA_FUNCTION_VAR_INT(wpnsprite,511);}

//NPCData Setters, three inputs, no return. works as SetDMapScreenD function







//void FFScript::setNPCData_scriptdefence(){SET_NPCDATA_FUNCTION_VAR_INDEX(scriptdefence);}
void FFScript::setNPCData_defense(int v){SET_NPCDATA_FUNCTION_VAR_INDEX(defense,v, ZS_INT, (edefLAST255) );}
void FFScript::setNPCData_SIZEflags(int v){SET_NPCDATA_FUNCTION_VAR_FLAG(SIZEflags,v);}
void FFScript::setNPCData_misc(int val)
{
	int ID = int(ri->d[0] / 10000); //the enemy ID value
	int indx = int(ri->d[1] / 10000); //the misc index ID
	if ((ID < 1 || ID > 511) || ( indx < 0 || indx > 15 )) return;
	switch ( indx )
	{
		case 0: guysbuf[ID].misc1 = val; break;
		case 1: guysbuf[ID].misc2 = val; break;
		case 2: guysbuf[ID].misc3 = val; break;
		case 3: guysbuf[ID].misc4 = val; break;
		case 4: guysbuf[ID].misc5 = val; break;
		case 5: guysbuf[ID].misc6 = val; break;
		case 6: guysbuf[ID].misc7 = val; break;
		case 7: guysbuf[ID].misc8 = val; break;
		case 8: guysbuf[ID].misc9 = val; break;
		case 9: guysbuf[ID].misc10 = val; break;
		case 10: guysbuf[ID].misc11 = val; break;
		case 11: guysbuf[ID].misc12 = val; break;
		case 12: guysbuf[ID].misc13 = val; break;
		case 13: guysbuf[ID].misc14 = val; break;
		case 14: guysbuf[ID].misc15 = val; break;
		default: break;
	}
	
};

//ComboData

//Macros

//Are these right? newcombo is *combo_class_buf and the others are *combobuf

//Getters for ComboData 'Type' submembers. 
#define GET_COMBODATA_TYPE_INT(member) \
{ \
	long ID = vbound((get_register(sarg2) / 10000),0,MAXCOMBOS);\
	set_register(sarg1, combo_class_buf[combobuf[ID].type].member * 10000); \
}

//this may need additional macros. 
//for combo_class_buf[ID].member ?
//I'm not sure which it needs to be at present. 

#define GET_COMBODATA_TYPE_INDEX(member, bound) \
{ \
	int ID = int(vbound((ri->d[0] / 10000),0,MAXCOMBOS));\
	int indx = int(vbound((ri->d[1] / 10000), 0, bound));\
	set_register(sarg1, combo_class_buf[combobuf[ID].type].member[indx] * 10000); \
}

#define GET_COMBODATA_TYPE_FLAG(member) \
{ \
	int ID = int(vbound(ri->d[0] / 10000),0,MAXCOMBOS);\
	int flag = int(ri->d[1] / 10000);\
	set_register(sarg1, (combo_class_buf[combobuf[ID].type].member&flag) ? 10000 : 0); \
}



//Getters for ComboData main members. 
#define GET_COMBODATA_VAR_INT(member) \
{ \
	long ID = vbound( (get_register(sarg2) / 10000), 0, MAXCOMBOS);\
	set_register(sarg1, combobuf[ID].member * 10000); \
}

#define GET_COMBODATA_VAR_INDEX(member, bound) \
{ \
	int ID = int( vbound( (ri->d[0] / 10000),0,MAXCOMBOS) );\
	int indx = int ( vbound( (ri->d[1] / 10000),0,bound) );\
	set_register(sarg1, combobuf[ID].member[indx] * 10000); \
}

#define GET_COMBODATA_VAR_FLAG(member) \
{ \
	int ID = int( vbound( ( ri->d[0] / 10000),0,MAXCOMBOS) );\
	int flag = int(ri->d[1] / 10000);\
	set_register(sarg1, (combobuf[ID].member&flag) ? 10000 : 0); \
}



//ComboData Setter Macros

//Setters for ComboData 'type' submembers.
#define SET_COMBODATA_TYPE_INT(member, bound) \
{ \
	long ID = get_register(sarg1) / 10000; \
	long val = vbound( (get_register(sarg2) / 10000), 0, bound); \
	if(ID < 1 || ID > 511) \
		set_register(sarg1, -10000); \
	else \
		combo_class_buf[combobuf[ID].type].member = val; \
}

#define SET_COMBODATA_TYPE_INDEX(member, val, bound, indexbound) \
{ \
	long ID = vbound((ri->d[0]/10000),0,MAXCOMBOS);  \
	long indx =  vbound((ri->d[1]/10000),0,indexbound);  \
	combo_class_buf[combobuf[ID].type].member[indx] = vbound(val,0,bound); \
}

#define SET_COMBODATA_TYPE_FLAG(member, val, bound) \
{ \
	long ID = vbound((ri->d[0]/10000),0,MAXCOMBOS);  \
	long flag =  (ri->d[1]/10000);  \
	combo_class_buf[combobuf[ID].type].member&flag = ((vbound(val,0,bound))!=0); \
 \


//Setters for ComboData main members
#define SET_COMBODATA_VAR_INT(member, bound) \
{ \
	long ID = vbound( (get_register(sarg1) / 10000), 0, MAXCOMBOS); \
	long val = vbound((get_register(sarg2) / 10000),0,bound); \
	combobuf[ID].member = val; \
}

//SET_NPC_VAR_INDEX(member,value)
#define SET_COMBODATA_VAR_INDEX(member, val, bound, indexbound) \
{ \
	long ID = vbound((ri->d[0]/10000),0,MAXCOMBOS);  \
	long indx =  vbound((ri->d[1]/10000),0,indexbound);  \
	combobuf[ID].member[indx] = vbound(val,0,bound); \
}

//Special case for flags, three inputs one return
#define SET_COMBODATA_VAR_FLAG(member, val, bound) \
{ \
	long ID = vbound((ri->d[0]/10000),0,MAXCOMBOS);  \
	long flag =  (ri->d[1]/10000);  \
	else \
	{ \
		combobuf[ID].member&flag = ((bvound(val,0,bound))!=0); \
	}\
}

//Getters

//one input, one return
void FFScript::getComboData_block_enemies(){ GET_COMBODATA_TYPE_INT(block_enemies); } //byte a
void FFScript::getComboData_block_hole(){ GET_COMBODATA_TYPE_INT(block_hole); } //byte b
void FFScript::getComboData_block_trigger(){ GET_COMBODATA_TYPE_INT(block_trigger); } //byte c
void FFScript::getComboData_conveyor_x_speed(){ GET_COMBODATA_TYPE_INT(conveyor_x_speed); } //short e
void FFScript::getComboData_conveyor_y_speed(){ GET_COMBODATA_TYPE_INT(conveyor_y_speed); } //short f
void FFScript::getComboData_create_enemy(){ GET_COMBODATA_TYPE_INT(create_enemy); } //word g
void FFScript::getComboData_create_enemy_when(){ GET_COMBODATA_TYPE_INT(create_enemy_when); } //byte h
void FFScript::getComboData_create_enemy_change(){ GET_COMBODATA_TYPE_INT(create_enemy_change); } //long i
void FFScript::getComboData_directional_change_type(){ GET_COMBODATA_TYPE_INT(directional_change_type); } //byte j
void FFScript::getComboData_distance_change_tiles(){ GET_COMBODATA_TYPE_INT(distance_change_tiles); } //long k
void FFScript::getComboData_dive_item(){ GET_COMBODATA_TYPE_INT(dive_item); } //short l
void FFScript::getComboData_dock(){ GET_COMBODATA_TYPE_INT(dock); } //byte m
void FFScript::getComboData_fairy(){ GET_COMBODATA_TYPE_INT(fairy); } //byte n
void FFScript::getComboData_ff_combo_attr_change(){ GET_COMBODATA_TYPE_INT(ff_combo_attr_change); } //byte o
void FFScript::getComboData_foot_decorations_tile(){ GET_COMBODATA_TYPE_INT(foot_decorations_tile); } //long p
void FFScript::getComboData_foot_decorations_type(){ GET_COMBODATA_TYPE_INT(foot_decorations_type); } //byte q
void FFScript::getComboData_hookshot_grab_point(){ GET_COMBODATA_TYPE_INT(hookshot_grab_point); } //byte r
void FFScript::getComboData_ladder_pass(){ GET_COMBODATA_TYPE_INT(ladder_pass); } //byte s
void FFScript::getComboData_lock_block_type(){ GET_COMBODATA_TYPE_INT(lock_block_type); } //byte t
void FFScript::getComboData_lock_block_change(){ GET_COMBODATA_TYPE_INT(lock_block_change); } //long u
void FFScript::getComboData_magic_mirror_type(){ GET_COMBODATA_TYPE_INT(magic_mirror_type); } //byte v
void FFScript::getComboData_modify_hp_amount(){ GET_COMBODATA_TYPE_INT(modify_hp_amount); } //short w
void FFScript::getComboData_modify_hp_delay(){ GET_COMBODATA_TYPE_INT(modify_hp_delay); } //byte x
void FFScript::getComboData_modify_hp_type(){ GET_COMBODATA_TYPE_INT(modify_hp_type); } //byte y
void FFScript::getComboData_modify_mp_amount(){ GET_COMBODATA_TYPE_INT(modify_mp_amount); } //short z
void FFScript::getComboData_modify_mp_delay(){ GET_COMBODATA_TYPE_INT(modify_mp_delay); } //byte aa
void FFScript::getComboData_modify_mp_type(){ GET_COMBODATA_TYPE_INT(modify_mp_type); } //byte ab
void FFScript::getComboData_no_push_blocks(){ GET_COMBODATA_TYPE_INT(no_push_blocks); } //byte ac
void FFScript::getComboData_overhead(){ GET_COMBODATA_TYPE_INT(overhead); } //byte ad
void FFScript::getComboData_place_enemy(){ GET_COMBODATA_TYPE_INT(place_enemy); } //byte ae
void FFScript::getComboData_push_direction(){ GET_COMBODATA_TYPE_INT(push_direction); } //byte af
void FFScript::getComboData_push_weight(){ GET_COMBODATA_TYPE_INT(push_weight); } //byte ag  heavy or not
void FFScript::getComboData_push_wait(){ GET_COMBODATA_TYPE_INT(push_wait); } //byte ah
void FFScript::getComboData_pushed(){ GET_COMBODATA_TYPE_INT(pushed); } //byte ai
void FFScript::getComboData_raft(){ GET_COMBODATA_TYPE_INT(raft); } //byte aj
void FFScript::getComboData_reset_room(){ GET_COMBODATA_TYPE_INT(reset_room); } //byte ak
void FFScript::getComboData_save_point_type(){ GET_COMBODATA_TYPE_INT(save_point_type); } //byte al
void FFScript::getComboData_screen_freeze_type(){ GET_COMBODATA_TYPE_INT(screen_freeze_type); } //byte am

void FFScript::getComboData_secret_combo(){ GET_COMBODATA_TYPE_INT(secret_combo); } //byte an
void FFScript::getComboData_singular(){ GET_COMBODATA_TYPE_INT(singular); } //byte ao
void FFScript::getComboData_slow_movement(){ GET_COMBODATA_TYPE_INT(slow_movement); } //byte ap
void FFScript::getComboData_statue_type(){ GET_COMBODATA_TYPE_INT(statue_type); } //byte aq
void FFScript::getComboData_step_type(){ GET_COMBODATA_TYPE_INT(step_type); } //byte ar
void FFScript::getComboData_step_change_to(){ GET_COMBODATA_TYPE_INT(step_change_to); } //long as
void FFScript::getComboData_strike_remnants(){ GET_COMBODATA_TYPE_INT(strike_remnants); } //long au
void FFScript::getComboData_strike_remnants_type(){ GET_COMBODATA_TYPE_INT(strike_remnants_type); } //byte av
void FFScript::getComboData_strike_change(){ GET_COMBODATA_TYPE_INT(strike_change); } //long aw
void FFScript::getComboData_strike_item(){ GET_COMBODATA_TYPE_INT(strike_item); } //short ax
void FFScript::getComboData_touch_item(){ GET_COMBODATA_TYPE_INT(touch_item); } //short ay
void FFScript::getComboData_touch_stairs(){ GET_COMBODATA_TYPE_INT(touch_stairs); } //byte az
void FFScript::getComboData_trigger_type(){ GET_COMBODATA_TYPE_INT(trigger_type); } //byte ba
void FFScript::getComboData_trigger_sensitive(){ GET_COMBODATA_TYPE_INT(trigger_sensitive); } //byte bb
void FFScript::getComboData_warp_type(){ GET_COMBODATA_TYPE_INT(warp_type); } //byte bc
void FFScript::getComboData_warp_sensitive(){ GET_COMBODATA_TYPE_INT(warp_sensitive); } //byte bd
void FFScript::getComboData_warp_direct(){ GET_COMBODATA_TYPE_INT(warp_direct); } //byte be
void FFScript::getComboData_warp_location(){ GET_COMBODATA_TYPE_INT(warp_location); } //byte bf
void FFScript::getComboData_water(){ GET_COMBODATA_TYPE_INT(water); } //byte bg
void FFScript::getComboData_whistle(){ GET_COMBODATA_TYPE_INT(whistle); } //byte bh
void FFScript::getComboData_win_game(){ GET_COMBODATA_TYPE_INT(win_game); } //byte bi
void FFScript::getComboData_block_weapon_lvl(){ GET_COMBODATA_TYPE_INT(block_weapon_lvl); } //byte bj - max level of weapon to block

void FFScript::getComboData_tile(){ GET_COMBODATA_VAR_INT(tile); } //newcombo, word
void FFScript::getComboData_flip(){ GET_COMBODATA_VAR_INT(flip); } //newcombo byte

void FFScript::getComboData_walk(){ GET_COMBODATA_VAR_INT(walk); } //newcombo byte
void FFScript::getComboData_type(){ GET_COMBODATA_VAR_INT(type); } //newcombo byte
void FFScript::getComboData_csets(){ GET_COMBODATA_VAR_INT(csets); } //newcombo byte
void FFScript::getComboData_foo(){ GET_COMBODATA_VAR_INT(foo); } //newcombo word
void FFScript::getComboData_frames(){ GET_COMBODATA_VAR_INT(frames); } //newcombo byte
void FFScript::getComboData_speed(){ GET_COMBODATA_VAR_INT(speed); } //newcombo byte
void FFScript::getComboData_nextcombo(){ GET_COMBODATA_VAR_INT(nextcombo); } //newcombo word
void FFScript::getComboData_nextcset(){ GET_COMBODATA_VAR_INT(nextcset); } //newcombo byte
void FFScript::getComboData_flag(){ GET_COMBODATA_VAR_INT(flag); } //newcombo byte
void FFScript::getComboData_skipanim(){ GET_COMBODATA_VAR_INT(skipanim); } //newcombo byte
void FFScript::getComboData_nexttimer(){ GET_COMBODATA_VAR_INT(nexttimer); } //newcombo word
void FFScript::getComboData_skipanimy(){ GET_COMBODATA_VAR_INT(skipanimy); } //newcombo byte
void FFScript::getComboData_animflags(){ GET_COMBODATA_VAR_INT(animflags); } //newcombo byte


//two inputs, one return
void FFScript::getComboData_block_weapon(){ GET_COMBODATA_TYPE_INDEX(block_weapon,32); } //byte array[32] d (ID of LWeapon)
void FFScript::getComboData_expansion(){ GET_COMBODATA_VAR_INDEX(expansion,6); } //newcombo byte, arr[6]
void FFScript::getComboData_strike_weapons(){ GET_COMBODATA_TYPE_INDEX(strike_weapons,32); } //byte at, arr[32]

//Setters, two inputs no returns

void FFScript::setComboData_block_enemies(){ SET_COMBODATA_TYPE_INT(block_enemies,ZS_BYTE); } //byte a
void FFScript::setComboData_block_hole(){ SET_COMBODATA_TYPE_INT(block_hole,ZS_BYTE); } //byte b
void FFScript::setComboData_block_trigger(){ SET_COMBODATA_TYPE_INT(block_trigger,ZS_BYTE); } //byte c
void FFScript::setComboData_conveyor_x_speed(){ SET_COMBODATA_TYPE_INT(conveyor_x_speed,ZS_SHORT); } //short e
void FFScript::setComboData_conveyor_y_speed(){ SET_COMBODATA_TYPE_INT(conveyor_y_speed,ZS_SHORT); } //short f
void FFScript::setComboData_create_enemy(){ SET_COMBODATA_TYPE_INT(create_enemy,ZS_WORD); } //word g
void FFScript::setComboData_create_enemy_when(){ SET_COMBODATA_TYPE_INT(create_enemy_when,ZS_BYTE); } //byte h
void FFScript::setComboData_create_enemy_change(){ SET_COMBODATA_TYPE_INT(create_enemy_change,ZS_LONG); } //long i
void FFScript::setComboData_directional_change_type(){ SET_COMBODATA_TYPE_INT(directional_change_type,ZS_BYTE); } //byte j
void FFScript::setComboData_distance_change_tiles(){ SET_COMBODATA_TYPE_INT(distance_change_tiles,ZS_LONG); } //long k
void FFScript::setComboData_dive_item(){ SET_COMBODATA_TYPE_INT(dive_item,ZS_SHORT); } //short l
void FFScript::setComboData_dock(){ SET_COMBODATA_TYPE_INT(dock,ZS_BYTE); } //byte m
void FFScript::setComboData_fairy(){ SET_COMBODATA_TYPE_INT(fairy,ZS_BYTE); } //byte n
void FFScript::setComboData_ff_combo_attr_change(){ SET_COMBODATA_TYPE_INT(ff_combo_attr_change,ZS_BYTE); } //byte o
void FFScript::setComboData_foot_decorations_tile(){ SET_COMBODATA_TYPE_INT(foot_decorations_tile,ZS_LONG); } //long p
void FFScript::setComboData_foot_decorations_type(){ SET_COMBODATA_TYPE_INT(foot_decorations_type,ZS_BYTE); } //byte q
void FFScript::setComboData_hookshot_grab_point(){ SET_COMBODATA_TYPE_INT(hookshot_grab_point,ZS_BYTE); } //byte r
void FFScript::setComboData_ladder_pass(){ SET_COMBODATA_TYPE_INT(ladder_pass,ZS_BYTE); } //byte s
void FFScript::setComboData_lock_block_type(){ SET_COMBODATA_TYPE_INT(lock_block_type,ZS_BYTE); } //byte t
void FFScript::setComboData_lock_block_change(){ SET_COMBODATA_TYPE_INT(lock_block_change,ZS_LONG); } //long u
void FFScript::setComboData_magic_mirror_type(){ SET_COMBODATA_TYPE_INT(magic_mirror_type,ZS_BYTE); } //byte v
void FFScript::setComboData_modify_hp_amount(){ SET_COMBODATA_TYPE_INT(modify_hp_amount,ZS_SHORT); } //short w
void FFScript::setComboData_modify_hp_delay(){ SET_COMBODATA_TYPE_INT(modify_hp_delay,ZS_BYTE); } //byte x
void FFScript::setComboData_modify_hp_type(){ SET_COMBODATA_TYPE_INT(modify_hp_type,ZS_BYTE); } //byte y
void FFScript::setComboData_modify_mp_amount(){ SET_COMBODATA_TYPE_INT(modify_mp_amount,ZS_SHORT); } //short z
void FFScript::setComboData_modify_mp_delay(){ SET_COMBODATA_TYPE_INT(modify_mp_delay,ZS_BYTE); } //byte aa
void FFScript::setComboData_modify_mp_type(){ SET_COMBODATA_TYPE_INT(modify_mp_type,ZS_BYTE); } //byte ab
void FFScript::setComboData_no_push_blocks(){ SET_COMBODATA_TYPE_INT(no_push_blocks,ZS_BYTE); } //byte ac
void FFScript::setComboData_overhead(){ SET_COMBODATA_TYPE_INT(overhead,ZS_BYTE); } //byte ad
void FFScript::setComboData_place_enemy(){ SET_COMBODATA_TYPE_INT(place_enemy,ZS_BYTE); } //byte ae
void FFScript::setComboData_push_direction(){ SET_COMBODATA_TYPE_INT(push_direction,ZS_BYTE); } //byte af
void FFScript::setComboData_push_weight(){ SET_COMBODATA_TYPE_INT(push_weight,ZS_BYTE); } //byte ag  heavy or not
void FFScript::setComboData_push_wait(){ SET_COMBODATA_TYPE_INT(push_wait,ZS_BYTE); } //byte ah
void FFScript::setComboData_pushed(){ SET_COMBODATA_TYPE_INT(pushed,ZS_BYTE); } //byte ai
void FFScript::setComboData_raft(){ SET_COMBODATA_TYPE_INT(raft,ZS_BYTE); } //byte aj
void FFScript::setComboData_reset_room(){ SET_COMBODATA_TYPE_INT(reset_room,ZS_BYTE); } //byte ak
void FFScript::setComboData_save_point_type(){ SET_COMBODATA_TYPE_INT(save_point_type,ZS_BYTE); } //byte al
void FFScript::setComboData_screen_freeze_type(){ SET_COMBODATA_TYPE_INT(screen_freeze_type,ZS_BYTE); } //byte am

void FFScript::setComboData_secret_combo(){ SET_COMBODATA_TYPE_INT(secret_combo,ZS_BYTE); } //byte an
void FFScript::setComboData_singular(){ SET_COMBODATA_TYPE_INT(singular,ZS_BYTE); } //byte ao
void FFScript::setComboData_slow_movement(){ SET_COMBODATA_TYPE_INT(slow_movement,ZS_BYTE); } //byte ap
void FFScript::setComboData_statue_type(){ SET_COMBODATA_TYPE_INT(statue_type,ZS_BYTE); } //byte aq
void FFScript::setComboData_step_type(){ SET_COMBODATA_TYPE_INT(step_type,ZS_BYTE); } //byte ar
void FFScript::setComboData_step_change_to(){ SET_COMBODATA_TYPE_INT(step_change_to,ZS_LONG); } //long as

void FFScript::setComboData_strike_remnants(){ SET_COMBODATA_TYPE_INT(strike_remnants,ZS_LONG); } //long au
void FFScript::setComboData_strike_remnants_type(){ SET_COMBODATA_TYPE_INT(strike_remnants_type,ZS_BYTE); } //byte av
void FFScript::setComboData_strike_change(){ SET_COMBODATA_TYPE_INT(strike_change,ZS_LONG); } //long aw
void FFScript::setComboData_strike_item(){ SET_COMBODATA_TYPE_INT(strike_item,ZS_SHORT); } //short ax
void FFScript::setComboData_touch_item(){ SET_COMBODATA_TYPE_INT(touch_item,ZS_SHORT); } //short ay
void FFScript::setComboData_touch_stairs(){ SET_COMBODATA_TYPE_INT(touch_stairs,ZS_BYTE); } //byte az
void FFScript::setComboData_trigger_type(){ SET_COMBODATA_TYPE_INT(trigger_type,ZS_BYTE); } //byte ba
void FFScript::setComboData_trigger_sensitive(){ SET_COMBODATA_TYPE_INT(trigger_sensitive,ZS_BYTE); } //byte bb
void FFScript::setComboData_warp_type(){ SET_COMBODATA_TYPE_INT(warp_type,ZS_BYTE); } //byte bc
void FFScript::setComboData_warp_sensitive(){ SET_COMBODATA_TYPE_INT(warp_sensitive,ZS_BYTE); } //byte bd
void FFScript::setComboData_warp_direct(){ SET_COMBODATA_TYPE_INT(warp_direct,ZS_BYTE); } //byte be
void FFScript::setComboData_warp_location(){ SET_COMBODATA_TYPE_INT(warp_location,ZS_BYTE); } //byte bf
void FFScript::setComboData_water(){ SET_COMBODATA_TYPE_INT(water,ZS_BYTE); } //byte bg
void FFScript::setComboData_whistle(){ SET_COMBODATA_TYPE_INT(whistle,ZS_BYTE); } //byte bh
void FFScript::setComboData_win_game(){ SET_COMBODATA_TYPE_INT(win_game,ZS_BYTE); } //byte bi
void FFScript::setComboData_block_weapon_lvl(){ SET_COMBODATA_TYPE_INT(block_weapon_lvl,ZS_BYTE); } //byte bj - max level of weapon to block

//combobuf
void FFScript::setComboData_tile(){ SET_COMBODATA_VAR_INT(tile,ZS_WORD); } //newcombo, word
void FFScript::setComboData_flip(){ SET_COMBODATA_VAR_INT(flip,ZS_BYTE); } //newcombo byte

void FFScript::setComboData_walk(){ SET_COMBODATA_VAR_INT(walk,ZS_BYTE); } //newcombo byte
void FFScript::setComboData_type(){ SET_COMBODATA_VAR_INT(type,ZS_BYTE); } //newcombo byte
void FFScript::setComboData_csets(){ SET_COMBODATA_VAR_INT(csets,ZS_BYTE); } //newcombo byte
void FFScript::setComboData_foo(){ SET_COMBODATA_VAR_INT(foo,ZS_WORD); } //newcombo word
void FFScript::setComboData_frames(){ SET_COMBODATA_VAR_INT(frames,ZS_BYTE); } //newcombo byte
void FFScript::setComboData_speed(){ SET_COMBODATA_VAR_INT(speed,ZS_BYTE); } //newcombo byte
void FFScript::setComboData_nextcombo(){ SET_COMBODATA_VAR_INT(nextcombo,ZS_WORD); } //newcombo word
void FFScript::setComboData_nextcset(){ SET_COMBODATA_VAR_INT(nextcset,ZS_BYTE); } //newcombo byte
void FFScript::setComboData_flag(){ SET_COMBODATA_VAR_INT(flag,ZS_BYTE); } //newcombo byte
void FFScript::setComboData_skipanim(){ SET_COMBODATA_VAR_INT(skipanim,ZS_BYTE); } //newcombo byte
void FFScript::setComboData_nexttimer(){ SET_COMBODATA_VAR_INT(nexttimer,ZS_WORD); } //newcombo word
void FFScript::setComboData_skipanimy(){ SET_COMBODATA_VAR_INT(skipanimy,ZS_BYTE); } //newcombo byte
void FFScript::setComboData_animflags(){ SET_COMBODATA_VAR_INT(animflags,ZS_BYTE); } //newcombo byte

//three inputs, no returns
void FFScript::setComboData_block_weapon(int v){ SET_COMBODATA_TYPE_INDEX(block_weapon,v,ZS_BYTE,32); } //byte array[32] d (ID of LWeapon)
void FFScript::setComboData_strike_weapons(int v){ SET_COMBODATA_TYPE_INDEX(strike_weapons,v,ZS_BYTE,32); } //byte at, arr[32]
void FFScript::setComboData_expansion(int v){ SET_COMBODATA_VAR_INDEX(expansion,v,ZS_BYTE,6); } //newcombo byte, arr[6]

//SpriteData Macros
#define GET_SPRITEDATA_TYPE_INT(member) \
{ \
	long ID = vbound((get_register(sarg2) / 10000),0,255);\
	set_register(sarg1, wpnsbuf[ID].member * 10000); \
}

#define SET_SPRITEDATA_TYPE_INT(member, bound) \
{ \
	long ID = get_register(sarg1) / 10000; \
	long val = vbound( (get_register(sarg2) / 10000), 0, bound); \
	if(ID < 1 || ID > 255) \
		set_register(sarg1, -10000); \
	else \
		wpnsbuf[ID].member = val; \
}

#define SET_SPRITEDATA_TYPE_INT_NOBOUND(member) \
{ \
	long ID = get_register(sarg1) / 10000; \
	long val = get_register(sarg2) / 10000; \
	if(ID < 1 || ID > 255) \
		set_register(sarg1, -10000); \
	else \
		wpnsbuf[ID].member = val; \
}


void FFScript::getSpriteDataTile(){GET_SPRITEDATA_TYPE_INT(tile);}
void FFScript::getSpriteDataMisc(){GET_SPRITEDATA_TYPE_INT(misc);}
void FFScript::getSpriteDataCSets(){GET_SPRITEDATA_TYPE_INT(csets);}
void FFScript::getSpriteDataFrames(){GET_SPRITEDATA_TYPE_INT(frames);}
void FFScript::getSpriteDataSpeed(){GET_SPRITEDATA_TYPE_INT(speed);}
void FFScript::getSpriteDataType(){GET_SPRITEDATA_TYPE_INT(type);}
//void FFScript::getSpriteDataString();



void FFScript::setSpriteDataTile(){SET_SPRITEDATA_TYPE_INT(tile,ZS_WORD);}
void FFScript::setSpriteDataMisc(){SET_SPRITEDATA_TYPE_INT(misc,ZS_CHAR);}
void FFScript::setSpriteDataCSets(){SET_SPRITEDATA_TYPE_INT(csets,ZS_CHAR);}
void FFScript::setSpriteDataFrames(){SET_SPRITEDATA_TYPE_INT(frames,ZS_CHAR);}
void FFScript::setSpriteDataSpeed(){SET_SPRITEDATA_TYPE_INT(speed,ZS_CHAR);}
void FFScript::setSpriteDataType(){SET_SPRITEDATA_TYPE_INT(type,ZS_CHAR);}
//void FFScript::setSpriteDataString();


void FFScript::do_setMIDI_volume(int m)
{
	master_volume(-1,(vbound(m,0,255)));
}
void FFScript::do_setMusic_volume(int m)
{
	emusic_volume = vbound(m,0,255);
}
void FFScript::do_setDIGI_volume(int m)
{
	master_volume((vbound(m,0,255)),-1);
}
void FFScript::do_setSFX_volume(int m)
{
	sfx_volume = m;
}
void FFScript::do_setSFX_pan(int m)
{
	pan_style = vbound(m,0,3);
}
int FFScript::do_getMIDI_volume()
{
	return ((int)midi_volume);
}
int FFScript::do_getMusic_volume()
{
	return ((int)emusic_volume);
}
int FFScript::do_getDIGI_volume()
{
	return ((int)digi_volume);
}
int FFScript::do_getSFX_volume()
{
	return ((int)sfx_volume);
}
int FFScript::do_getSFX_pan()
{
	return ((int)pan_style);
}


//Change Game Over Screen Values
void FFScript::FFSetSaveScreenSetting() 
{
	
	long indx = get_register(sarg1) / 10000; 
	long value = get_register(sarg2) / 10000; //bounded in zelda.cpp 
	if(indx < 0 || indx > 11) 
		set_register(sarg1, -10000); 
	else 
		SetSaveScreenSetting(indx, value); 
}
	
	
	
void FFScript::FFChangeSubscreenText() 
{ 
	
	long index = get_register(sarg1) / 10000;
	long arrayptr = get_register(sarg2) / 10000;
	
	if ( index < 0 || index > 3 ) 
	{
		al_trace("The index supplied to Game->SetSubscreenText() is invalid. The index specified was: %ld /n", index);
		return;
	}

	string filename_str;

		
		
	ArrayH::getString(arrayptr, filename_str, 73);
	ChangeSubscreenText(index,filename_str.c_str());
	
	//newtext[32]='\0';
	
	
	
}

void FFScript::do_typedpointer_typecast(const bool v)
{
	 long ptr = SH::get_arg(sarg1, v);
	 set_register(sarg1, ptr);
}


void FFScript::setFFRules()
{
	for ( int q = 0; q < QUESTRULES_NEW_SIZE; q++ )
	{
		FF_rules[q] = getQRBit(q);
	}
	for ( int q = QUESTRULES_NEW_SIZE; q < QUESTRULES_NEW_SIZE+EXTRARULES_SIZE; q++ ) 
	{
		FF_rules[q] = extra_rules[q-QUESTRULES_SIZE];
	}
	for ( int q = QUESTRULES_NEW_SIZE+EXTRARULES_SIZE; q < FFRULES_SIZE; q++ )
	{
		FF_rules[q] = 0; //wipe the rest.
	}
	for ( int q = 0; q < 2; q++ )
	{
		passive_subscreen_offsets[q] = 0;
	}
	active_subscreen_scrollspeed_adjustment = 0;
	//zinit.terminalv
	FF_gravity = zinit.gravity;
	FF_terminalv = zinit.terminalv;
	FF_msg_speed = zinit.msg_speed;
	FF_transition_type = zinit.transition_type; // Can't edit, yet.
	FF_jump_link_layer_threshold = zinit.jump_link_layer_threshold; // Link is drawn above layer 3 if z > this.
	FF_link_swim_speed = zinit.link_swim_speed;
	FFCore.zasm_break_mode = ZASM_BREAK_NONE;
	for ( int q = 0; q < MAXITEMS; q++ )
	{
		item_messages_played[q] = 0;
	}
}

void FFScript::SetItemMessagePlayed(int itm)
{
	item_messages_played[itm] = 1;
}
bool FFScript::GetItemMessagePlayed(int itm)
{
	return (( item_messages_played[itm] ) ? true : false);
}

void FFScript::setRule(int rule, bool s)
{
	FF_rules[rule] = ( s ? 1 : 0 );
}

bool FFScript::getRule(int rule)
{
	return ( FF_rules[rule] != 0 );
}

int FFScript::getQRBit(int rule)
{
	return ( get_bit(quest_rules,rule) ? 1 : 0 );
}

void FFScript::setLinkTile(int t)
{
	FF_link_tile = vbound(t, 0, NEWMAXTILES);
}

void FFScript::setLinkAction(int a)
{
	FF_link_action = vbound(a, 0, 255);
}

int FFScript::getLinkTile()
{
	return FF_link_tile;
}

int FFScript::getLinkAction()
{
	int special_action = Link.getAction2();
	if ( special_action != -1 ) return special_action; //spin, dive, charge
	else return FF_link_action; //everything else
}
//get_bit

int FFScript::GetScriptObjectUID(int type)
{
	++script_UIDs[type];
	return script_UIDs[type];
}

/*
FFScript::FFScript()
{
	init();
}
*/
void FFScript::init()
{
	for ( int q = 0; q < wexLast; q++ ) warpex[q] = 0;
	print_ZASM = zasm_debugger;
	if ( zasm_debugger )
	{
		ZASMPrint(true);
		zasm_break_mode = ZASM_BREAK_HALT;
	}
	
	temp_no_stepforward = 0;
	nostepforward = 0;
	
	numscriptdraws = 0;
	max_ff_rules = qr_MAX;
	coreflags = 0;
	skip_ending_credits = 0;
	//quest_format : is this properly initialised?
	for ( int q = 0; q < susptLAST; q++ ) { system_suspend[q] = 0; }
	for ( int q = 0; q < UID_TYPES; ++q ) { script_UIDs[q] = 0; }
	//for ( int q = 0; q < 512; q++ ) FF_rules[q] = 0;
	setFFRules(); //copy the quest rules over. 
	long usr_midi_volume = midi_volume;
	usr_digi_volume = digi_volume;
	usr_sfx_volume = sfx_volume;
	usr_music_volume = emusic_volume;
	usr_panstyle = pan_style;
	FF_link_tile = 0; FF_link_action = 0;
	enemy_removal_point[spriteremovalY1] = -32767;
	enemy_removal_point[spriteremovalY2] = 32767;
	enemy_removal_point[spriteremovalX1] = -32767;
	enemy_removal_point[spriteremovalX2] = 32767;
	enemy_removal_point[spriteremovalZ1] = -32767;
	enemy_removal_point[spriteremovalZ2] = 32767;
	for ( int q = 0; q < 4; q++ ) 
	{
		FF_screenbounds[q] = 0;
		FF_screen_dimensions[q] = 0;
		FF_subscreen_dimensions[q] = 0;
		FF_eweapon_removal_bounds[q] = 0; 
		FF_lweapon_removal_bounds[q] = 0;
	}
	for ( int q = 0; q < FFSCRIPTCLASS_CLOCKS; q++ )
	{
		FF_clocks[q] = 0;
	}
	for ( int q = 0; q < SCRIPT_DRAWING_RULES; q++ )
	{
		ScriptDrawingRules[q] = 0;
	}
	for ( int q = 0; q < NUM_USER_MIDI_OVERRIDES; q++ ) 
	{
		FF_UserMidis[q] = 0;
	}
	subscreen_scroll_speed = 0; //make a define for a default and read quest override! -Z
	kb_typing_mode = false;
	memset(emulation,0,sizeof(emulation));
	initIncludePaths();
	initRunString();
	//clearRunningItemScripts();
	tempScreens[0] = tmpscr;
	ScrollingScreens[0] = tmpscr+1;
	for(int q = 0; q < 6; ++q)
	{
		tempScreens[q+1] = tmpscr2+q;
		ScrollingScreens[q+1] = tmpscr3+q;
	}
	ScrollingData[SCROLLDATA_DIR] = -1;
	ScrollingData[SCROLLDATA_NX] = 0;
	ScrollingData[SCROLLDATA_NY] = 0;
	ScrollingData[SCROLLDATA_OX] = 0;
	ScrollingData[SCROLLDATA_OY] = 0;
}


void FFScript::SetFFEngineFlag(int flag, bool state)
{
	if ( state ) { coreflags |= flag; }
	else coreflags &= ~flag;
}

void FFScript::setSubscreenScrollSpeed(byte n)
{
	subscreen_scroll_speed = n;
}

int FFScript::getSubscreenScrollSpeed()
{
	return (int)subscreen_scroll_speed;
}

void FFScript::do_greyscale(const bool v)
{
	bool on = (SH::get_arg(sarg1, v)) != 0;
	setMonochrome(on);
}

void FFScript::do_monochromatic(const bool v)
{
	int colour = SH::get_arg(sarg1, v)/10000;
	setMonochromatic(colour);
}

void FFScript::gfxmonohue()
{
	long _r   = SH::read_stack(ri->sp + 3) / 10000;
	long _g = SH::read_stack(ri->sp + 2) / 10000;
	long _b   = SH::read_stack(ri->sp + 1) / 10000;
	bool m   = (SH::read_stack(ri->sp + 0) / 10000);
	doGFXMonohue(_r,_g,_b,m);
}

void FFScript::clearTint()
{
	doClearTint();
}

void FFScript::Tint()
{
	long _r   = SH::read_stack(ri->sp + 2) / 10000;
	long _g = SH::read_stack(ri->sp + 1) / 10000;
	long _b   = SH::read_stack(ri->sp + 0) / 10000;
	doTint(_r,_g,_b);
}

void FFScript::do_fx_zap(const bool v)
{
	long out = SH::get_arg(sarg1, v);

	if ( out ) { FFScript::do_zapout(); } 
	else FFScript::do_zapin();
}

void FFScript::do_fx_wavy(const bool v)
{
	long out = SH::get_arg(sarg1, v);

	if ( out ) { FFScript::do_wavyout(); } 
	else FFScript::do_wavyin();
}
/*
void FFScript::init()
{
	for ( int q = 0; q < FFRULES_SIZE; q++ ) FF_rules[q] = 0;
	FF_link_tile = 0;
	FF_link_action = 0;
	for ( int q = 0; q < 4; q++ ) 
	{
		FF_screenbounds[q] = 0;
		FF_screen_dimensions[q] = 0;
		FF_subscreen_dimensions[q] = 0;
		FF_eweapon_removal_bounds[q] = 0;
		FF_lweapon_removal_bounds[q] = 0;
		
	}
	for ( int q = 0; q < FFSCRIPTCLASS_CLOCKS; q++ ) FF_clocks[q] = 0;
	for ( int q = 0; q < SCRIPT_DRAWING_RULES; q++ ) ScriptDrawingRules[q] = 0;
	for ( int q = 0; q < NUM_USER_MIDI_OVERRIDES; q++ ) FF_UserMidis[q] = 0;
}
*/

long FFScript::getQuestHeaderInfo(int type)
{
	return quest_format[type];
}

string get_filestr(const bool relative) //Used for 'FileSystem' functions.
{
	int strptr = get_register(sarg1)/10000;
	string the_string;
	ArrayH::getString(strptr, the_string, 512);
	the_string = the_string.substr(the_string.find_first_not_of('/'),string::npos); //Kill leading '/'
	size_t last = the_string.find_last_not_of('/');
	if(last!=string::npos)++last;
	the_string = the_string.substr(0,last); //Kill trailing '/'
	if(relative)
	{
		char buf[2048] = {0};
		if(FFCore.get_scriptfile_path(buf, the_string.c_str()))
			the_string = buf;
	}
	return the_string;
}

void FFScript::do_checkdir(const bool is_dir)
{
	string the_string = get_filestr(get_bit(quest_rules, qr_BITMAP_AND_FILESYSTEM_PATHS_ALWAYS_RELATIVE));
	set_register(sarg1, checkPath(the_string.c_str(), is_dir) ? 10000 : 0);
}

void FFScript::do_fs_remove()
{
	string the_string = get_filestr(true);
	set_register(sarg1, remove(the_string.c_str()) ? 0 : 10000);
}

//Modules
//Putting this here, for now.

const char * select_screen_tile_cats[sels_tile_LAST] =
{
	"sels_tile_frame", "sels_tile_questicon_1A", "sels_tile_questicon_1B", "sels_tile_questicon_2A",
	"sels_tile_questicon_2B", "sels_tile_questicon_3A", "sels_tile_questicon_3B", "sels_tile_questicon_4A",
	"sels_tile_questicon_4B", "sels_tile_questicon_5A", "sels_tile_questicon_5B", "sels_tile_questicon_6A",
	"sels_tile_questicon_6B", "sels_tile_questicon_7A", "sels_tile_questicon_7B", "sels_tile_questicon_8A",
	"sels_tile_questicon_8B", "sels_tile_questicon_9A", "sels_tile_questicon_9B", "sels_tile_questicon_10A",
	"sels_tile_questicon_10B",
		//x positions
	"sels_tile_questicon_1A_X", "sels_tile_questicon_1B_X", "sels_tile_questicon_2A_X", "sels_tile_questicon_2B_X",
	"sels_tile_questicon_3A_X", "sels_tile_questicon_3B_X", "sels_tile_questicon_4A_X", "sels_tile_questicon_4B_X",
	"sels_tile_questicon_5A_X", "sels_tile_questicon_5B_X", "sels_tile_questicon_6A_X", "sels_tile_questicon_6B_X",
	"sels_tile_questicon_7A_X", "sels_tile_questicon_7B_X", "sels_tile_questicon_8A_X", "sels_tile_questicon_8B_X",
	"sels_tile_questicon_9A_X", "sels_tile_questicon_9B_X", "sels_tile_questicon_10A_X", "sels_tile_questicon_10B_X",
	"sels_cursor_tile", "sels_heart_tile", "sels_linktile", "draw_link_first"
	
};

const char * select_screen_tile_cset_cats[sels_tile_LAST] =
{
	"sels_tile_frame_cset", "sels_tile_questicon_1A_cset", "sels_tile_questicon_1B_cset", "sels_tile_questicon_2A_cset",
	"sels_tile_questicon_2B_cset", "sels_tile_questicon_3A_cset", "sels_tile_questicon_3B_cset", "sels_tile_questicon_4A_cset",
	"sels_tile_questicon_4B_cset", "sels_tile_questicon_5A_cset", "sels_tile_questicon_5B_cset", "sels_tile_questicon_6A_cset",
	"sels_tile_questicon_6B_cset", "sels_tile_questicon_7A_cset", "sels_tile_questicon_7B_cset", "sels_tile_questicon_8A_cset",
	"sels_tile_questicon_8B_cset", "sels_tile_questicon_9A_cset", "sels_tile_questicon_9B_cset", "sels_tile_questicon_10A_cset",
	"sels_tile_questicon_10B_cset", "change_cset_on_quest_3", 
	"sels_cusror_cset", "sels_heart_tilettile_cset", "sels_link_cset"
};

static const char months[13][13] =
{ 
	"Nonetober", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
};

static std::string dayextension(int dy)
{ 
	char temp[6]; 
	switch(dy)
	{
		
		
		//st
		case 1:
		case 21:
		case 31:
			sprintf(temp,"%d%s",dy,"st"); 
			break;
		//nd
		case 2:
		case 22:
			sprintf(temp,"%d%s",dy,"nd"); 
			break;
		//rd
		case 3:
		case 23:
			sprintf(temp,"%d%s",dy,"rd"); 
			break;
		//th
		default:
			sprintf(temp,"%d%s",dy,"th");
			break;
	}
	
	return std::string(temp); 
} 


bool ZModule::init(bool d) //bool default
{
	
	
	memset(moduledata.module_name, 0, sizeof(moduledata.module_name));
	memset(moduledata.quests, 0, sizeof(moduledata.quests));
	memset(moduledata.skipnames, 0, sizeof(moduledata.skipnames));
	memset(moduledata.datafiles, 0, sizeof(moduledata.datafiles));
	memset(moduledata.enem_type_names, 0, sizeof(moduledata.enem_type_names));
	memset(moduledata.enem_anim_type_names, 0, sizeof(moduledata.enem_anim_type_names));
	memset(moduledata.item_editor_type_names, 0, sizeof(moduledata.enem_anim_type_names));
	memset(moduledata.combo_type_names, 0, sizeof(moduledata.combo_type_names));
	memset(moduledata.combo_flag_names, 0, sizeof(moduledata.combo_flag_names));
	
	memset(moduledata.startingdmap, 0, sizeof(moduledata.startingdmap));
	memset(moduledata.startingscreen, 0, sizeof(moduledata.startingscreen));
	
	memset(moduledata.roomtype_names, 0, sizeof(moduledata.roomtype_names));
	memset(moduledata.walkmisc7_names, 0, sizeof(moduledata.walkmisc7_names));
	memset(moduledata.walkmisc9_names, 0, sizeof(moduledata.walkmisc9_names));
	memset(moduledata.guy_type_names, 0, sizeof(moduledata.guy_type_names));
	memset(moduledata.enemy_weapon_names, 0, sizeof(moduledata.enemy_weapon_names));
	memset(moduledata.enemy_weapon_names, 0, sizeof(moduledata.enemy_scriptweaponweapon_names));
	memset(moduledata.player_weapon_names, 0, sizeof(moduledata.player_weapon_names));
	memset(moduledata.counter_names, 0, sizeof(moduledata.counter_names));
	memset(moduledata.itemclass_help_strings, 0, sizeof(moduledata.itemclass_help_strings));
	memset(moduledata.delete_quest_data_on_wingame, 0, sizeof(moduledata.delete_quest_data_on_wingame));
	memset(moduledata.base_NSF_file, 0, sizeof(moduledata.base_NSF_file));
	memset(moduledata.copyright_strings, 0, sizeof(moduledata.copyright_strings));
	memset(moduledata.copyright_string_vars, 0, sizeof(moduledata.copyright_string_vars));
	memset(moduledata.select_screen_tiles, 0, sizeof(moduledata.select_screen_tiles));
	memset(moduledata.select_screen_tile_csets, 0, sizeof(moduledata.select_screen_tile_csets));
	moduledata.old_quest_serial_flow = 0;
	moduledata.max_quest_files = 0;
	moduledata.animate_NES_title = 0;
	moduledata.title_track = moduledata.tf_track = moduledata.gameover_track = moduledata.ending_track = moduledata.dungeon_track = moduledata.overworld_track = moduledata.lastlevel_track = 0;
	moduledata.refresh_title_screen = 0;
	
	memset(moduledata.moduletitle, 0, sizeof(moduledata.moduletitle));
	memset(moduledata.moduleauthor, 0, sizeof(moduledata.moduleauthor));
	memset(moduledata.moduleinfo0, 0, sizeof(moduledata.moduleinfo0));
	memset(moduledata.moduleinfo1, 0, sizeof(moduledata.moduleinfo1));	
	memset(moduledata.moduleinfo2, 0, sizeof(moduledata.moduleinfo2));
	memset(moduledata.moduleinfo3, 0, sizeof(moduledata.moduleinfo3));
	memset(moduledata.moduleinfo4, 0, sizeof(moduledata.moduleinfo4));
	memset(moduledata.moduletimezone, 0, sizeof(moduledata.moduletimezone));
	memset(moduledata.combotypeCustomAttributes, 0, sizeof(moduledata.combotypeCustomAttributes));
	memset(moduledata.combotypeCustomAttribytes, 0, sizeof(moduledata.combotypeCustomAttribytes));
	memset(moduledata.combotypeCustomFlags, 0, sizeof(moduledata.combotypeCustomFlags));
	//memset(moduledata.module_base_nsf, 0, sizeof(moduledata.module_base_nsf));
		
	moduledata.modver_1 = 0;
	moduledata.modver_2 = 0;	
	moduledata.modver_3 = 0;
	moduledata.modver_4 = 0;
	moduledata.modbuild = 0;
	moduledata.modbeta = 0;
	moduledata.modmonth = 0;
	moduledata.modday = 0;
	moduledata.modyear = 0;
	moduledata.modhour = 0;
	moduledata.modminute = 0;

	
	//strcpy(moduledata.module_name,"default.zmod");
	//al_trace("Module name set to %s\n",moduledata.module_name);
	//We load the current module name from zc.cfg or zquest.cfg!
	//Otherwise, we don't know what file to access to load the module vars! 
	
	strcpy(moduledata.module_name,get_config_string("ZCMODULE","current_module","modules/default.zmod"));
	al_trace("The Current ZQuest Player Module is: %s\n",moduledata.module_name); 
	if(!fileexists((char*)moduledata.module_name))
	{
		al_trace("ZC Player I/O Error: No module definitions found. Please check your settings in %s.cfg.\n", "zc");
		return false;
	}	
	
	set_config_file(moduledata.module_name);
	if ( d )
	{
		
		//zcm path
		set_config_file(moduledata.module_name); //Switch to the module to load its config properties.
		//al_trace("Module name set to %s\n",moduledata.module_name);
		
		//Metadata
		strcpy(moduledata.moduletitle,get_config_string("METADATA","title",""));
		strcpy(moduledata.moduleauthor,get_config_string("METADATA","author",""));
		strcpy(moduledata.moduleinfo0,get_config_string("METADATA","info_0",""));
		strcpy(moduledata.moduleinfo1,get_config_string("METADATA","info_1",""));
		strcpy(moduledata.moduleinfo2,get_config_string("METADATA","info_2",""));
		strcpy(moduledata.moduleinfo3,get_config_string("METADATA","info_3",""));
		strcpy(moduledata.moduleinfo4,get_config_string("METADATA","info_4",""));
		strcpy(moduledata.moduletimezone,get_config_string("METADATA","timezone","GMT"));
		//strcpy(moduledata.module_base_nsf,get_config_string("METADATA","nsf",""));
		moduledata.modver_1 = get_config_int("METADATA","version_first",0);
		moduledata.modver_2 = get_config_int("METADATA","version_second",0);	
		moduledata.modver_3 = get_config_int("METADATA","version_third",0);
		moduledata.modver_4 = get_config_int("METADATA","version_fourth",0);
		moduledata.modbuild = get_config_int("METADATA","version_build",0);
		moduledata.modbeta = get_config_int("METADATA","version_beta",0);
		moduledata.modmonth = get_config_int("METADATA","version_month",0);
		moduledata.modday = get_config_int("METADATA","version_day",0);
		moduledata.modyear = get_config_int("METADATA","version_year",0);
		moduledata.modhour = get_config_int("METADATA","version_hour",0);
		moduledata.modminute = get_config_int("METADATA","version_minute",0); 
		
		//quests
		moduledata.old_quest_serial_flow = get_config_int("QUESTS","quest_flow",1);
		moduledata.max_quest_files = get_config_int("QUESTS","num_quest_files",10);
		moduledata.max_quest_files = vbound(moduledata.max_quest_files,1,10); //Clamp to maximum valid quests and 1.
		
		//al_trace("Module flow set to %d\n",moduledata.old_quest_serial_flow);
		//al_trace("Module number of serial quests set to %d\n",moduledata.max_quest_files);
		strcpy(moduledata.quests[0],get_config_string("QUESTS","first_qst","1st.qst"));
		//al_trace("Module quest 1 set to %s\n",moduledata.quests[0]);
		strcpy(moduledata.quests[1],get_config_string("QUESTS","second_qst","2nd.qst"));
		//al_trace("Module quest 2 set to %s\n",moduledata.quests[1]);
		strcpy(moduledata.quests[2],get_config_string("QUESTS","third_qst","3rd.qst"));
		//al_trace("Module quest 3 set to %s\n",moduledata.quests[2]);
		strcpy(moduledata.quests[3],get_config_string("QUESTS","fourth_qst","4th.qst"));
		//al_trace("Module quest 4 set to %s\n",moduledata.quests[3]);
		strcpy(moduledata.quests[4],get_config_string("QUESTS","fifth_qst","5th.qst"));
		//al_trace("Module quest 5 set to %s\n",moduledata.quests[4]);
		strcpy(moduledata.quests[5],get_config_string("QUESTS","sixth_qst",""));
		//al_trace("Module quest 6 set to %s\n",moduledata.quests[5]);
		strcpy(moduledata.quests[6],get_config_string("QUESTS","seventh_qst",""));
		//al_trace("Module quest 6 set to %s\n",moduledata.quests[6]);
		strcpy(moduledata.quests[7],get_config_string("QUESTS","eighth_qst",""));
		//al_trace("Module quest 8 set to %s\n",moduledata.quests[7]);
		strcpy(moduledata.quests[8],get_config_string("QUESTS","ninth_qst",""));
		//al_trace("Module quest 9 set to %s\n",moduledata.quests[8]);
		strcpy(moduledata.quests[9],get_config_string("QUESTS","tenth_qst",""));
		//al_trace("Module quest 10 set to %s\n",moduledata.quests[9]);
		for ( int q = 0; q < 10; q++ )
		{
			if ( moduledata.quests[q][0] == '-' ) strcpy(moduledata.quests[q],"");
		}
		
		//quest skip names
		strcpy(moduledata.skipnames[0],get_config_string("NAMEENTRY","first_qst_skip"," "));
		//al_trace("Module quest skip 1 set to %s\n",moduledata.skipnames[0]);
		strcpy(moduledata.skipnames[1],get_config_string("NAMEENTRY","second_qst_skip","ZELDA"));
		//al_trace("Module quest skip 2 set to %s\n",moduledata.skipnames[1]);
		strcpy(moduledata.skipnames[2],get_config_string("NAMEENTRY","third_qst_skip","ALPHA"));
		//al_trace("Module quest skip 3 set to %s\n",moduledata.skipnames[2]);
		strcpy(moduledata.skipnames[3],get_config_string("NAMEENTRY","fourth_qst_skip","GANON"));
		//al_trace("Module quest skip 4 set to %s\n",moduledata.skipnames[3]);
		strcpy(moduledata.skipnames[4],get_config_string("NAMEENTRY","fifth_qst_skip","JEAN"));
		//al_trace("Module quest skip 5 set to %s\n",moduledata.skipnames[4]);
		strcpy(moduledata.skipnames[5],get_config_string("NAMEENTRY","sixth_qst_skip",""));
		//al_trace("Module quest skip 6 set to %s\n",moduledata.skipnames[5]);
		strcpy(moduledata.skipnames[6],get_config_string("NAMEENTRY","seventh_qst_skip",""));
		//al_trace("Module quest skip 7 set to %s\n",moduledata.skipnames[6]);
		strcpy(moduledata.skipnames[7],get_config_string("NAMEENTRY","eighth_qst_skip",""));
		//al_trace("Module quest skip 8 set to %s\n",moduledata.skipnames[7]);
		strcpy(moduledata.skipnames[8],get_config_string("NAMEENTRY","ninth_qst_skip",""));
		//al_trace("Module quest skip 9 set to %s\n",moduledata.skipnames[8]);
		strcpy(moduledata.skipnames[9],get_config_string("NAMEENTRY","tenth_qst_skip",""));
		//al_trace("Module quest skip 10 set to %s\n",moduledata.skipnames[9]);
		
		//Quest starting screens and DMaps
	
		//dmaps
		moduledata.startingdmap[0] = get_config_int("QUESTS","first_startdmap",0);
		moduledata.startingdmap[1] = get_config_int("QUESTS","second_startdmap",0);
		moduledata.startingdmap[2] = get_config_int("QUESTS","third_startdmap",0);
		moduledata.startingdmap[3] = get_config_int("QUESTS","fourth_startdmap",0);
		moduledata.startingdmap[4] = get_config_int("QUESTS","fifth_startdmap",0);
		moduledata.startingdmap[5] = get_config_int("QUESTS","sixth_startdmap",0);
		moduledata.startingdmap[6] = get_config_int("QUESTS","seventh_startdmap",0);
		moduledata.startingdmap[7] = get_config_int("QUESTS","eighth_startdmap",0);
		moduledata.startingdmap[8] = get_config_int("QUESTS","ninth_startdmap",0);
		moduledata.startingdmap[9] = get_config_int("QUESTS","tenth_startdmap",0);
		//screens
		moduledata.startingscreen[0] = get_config_int("QUESTS","first_startscreen",0x77);
		moduledata.startingscreen[1] = get_config_int("QUESTS","second_startscreen",0x77);
		moduledata.startingscreen[2] = get_config_int("QUESTS","third_startscreen",0x77);
		moduledata.startingscreen[3] = get_config_int("QUESTS","fourth_startscreen",0x77);
		moduledata.startingscreen[4] = get_config_int("QUESTS","fifth_startscreen",0x77);
		moduledata.startingscreen[5] = get_config_int("QUESTS","sixth_startscreen",0x77);
		moduledata.startingscreen[6] = get_config_int("QUESTS","seventh_startscreen",0x77);
		moduledata.startingscreen[7] = get_config_int("QUESTS","eighth_startscreen",0x77);
		moduledata.startingscreen[8] = get_config_int("QUESTS","ninth_startscreen",0x77);
		moduledata.startingscreen[9] = get_config_int("QUESTS","tenth_startscreen",0x77);
	
		//name entry icons, tiles, and csets
		for ( int q = 0; q < sels_tile_LAST; q++ ) 
		{
			moduledata.select_screen_tiles[q] = get_config_int("NAMEENTRY",select_screen_tile_cats[q],0);
		}
		for ( int q = 0; q < sels_tile_cset_LAST; q++ ) 
		{
			
			moduledata.select_screen_tile_csets[q] = get_config_int("NAMEENTRY",select_screen_tile_cset_cats[q],( ( q == 0 || q == sels_heart_tilettile_cset || q == sels_cusror_cset )  ? 0 : 9 )); //the player icon csets are 9 by default, and the tile frame is 0
		}
		
		//datafiles
		strcpy(moduledata.datafiles[zelda_dat],get_config_string("DATAFILES","zcplayer_datafile","zelda.dat"));
		al_trace("Module zelda_dat set to %s\n",moduledata.datafiles[zelda_dat]);
		strcpy(moduledata.datafiles[zquest_dat],get_config_string("DATAFILES","zquest_datafile","zquest.dat"));
		al_trace("Module zquest_dat set to %s\n",moduledata.datafiles[zquest_dat]);
		strcpy(moduledata.datafiles[fonts_dat],get_config_string("DATAFILES","fonts_datafile","fonts.dat"));
		al_trace("Module fonts_dat set to %s\n",moduledata.datafiles[fonts_dat]);
		strcpy(moduledata.datafiles[sfx_dat],get_config_string("DATAFILES","sounds_datafile","sfx.dat"));
		al_trace("Module sfx_dat set to %s\n",moduledata.datafiles[sfx_dat]);
		strcpy(moduledata.datafiles[qst_dat],get_config_string("DATAFILES","quest_template_datafile","qst.dat"));
		al_trace("Module qst_dat set to %s\n",moduledata.datafiles[qst_dat]);
		
		strcpy(moduledata.base_NSF_file,get_config_string("DATAFILES","base_NSF_file","zelda.nsf"));
		al_trace("Base NSF file: %s\n", moduledata.base_NSF_file);
		
		moduledata.title_track = get_config_int("DATAFILES","title_track",0);
		moduledata.ending_track = get_config_int("DATAFILES","ending_track",1);
		moduledata.tf_track = get_config_int("DATAFILES","tf_track",5);
		moduledata.gameover_track = get_config_int("DATAFILES","gameover_track",0);
		moduledata.dungeon_track = get_config_int("DATAFILES","dungeon_track",0);
		moduledata.overworld_track = get_config_int("DATAFILES","overworld_track",0);
		moduledata.lastlevel_track = get_config_int("DATAFILES","lastlevel_track",0);
		
		strcpy(moduledata.copyright_strings[0],get_config_string("DATAFILES","copy_string_0","1986 NINTENDO"));
		if( moduledata.copyright_strings[0][0] == '-' ) strcpy(moduledata.copyright_strings[0],"");
		strcpy(moduledata.copyright_strings[1],get_config_string("DATAFILES","copy_string_1"," AG"));
		if( moduledata.copyright_strings[1][0] == '-' ) strcpy(moduledata.copyright_strings[1],"");
		//year
		strcpy(moduledata.copyright_strings[2],get_config_string("DATAFILES","copy_string_year",COPYRIGHT_YEAR));
		if( moduledata.copyright_strings[2][0] == '-' ) strcpy(moduledata.copyright_strings[1],"");
		
		
		moduledata.copyright_string_vars[titleScreen250+0] = get_config_int("DATAFILES","cpystr_5frame_var_font",0);//zfont);
		moduledata.copyright_string_vars[titleScreen250+1] = get_config_int("DATAFILES","cpystr_5frame_var_x",80);
		moduledata.copyright_string_vars[titleScreen250+2] = get_config_int("DATAFILES","cpystr_5frame_var_y",134);
		moduledata.copyright_string_vars[titleScreen250+3] = get_config_int("DATAFILES","cpystr_5frame_var_col",255);
		moduledata.copyright_string_vars[titleScreen250+4] = get_config_int("DATAFILES","cpystr_5frame_var_sz",-1);
		
		moduledata.copyright_string_vars[titleScreen250+5] = get_config_int("DATAFILES","cpystr_5frame_var_font2",0);//zfont);
		moduledata.copyright_string_vars[titleScreen250+6] = get_config_int("DATAFILES","cpystr_5frame_var_x2",80);
		moduledata.copyright_string_vars[titleScreen250+7] = get_config_int("DATAFILES","cpystr_5frame_var_y2",142);
		moduledata.copyright_string_vars[titleScreen250+8] = get_config_int("DATAFILES","cpystr_5frame_var_col2",255);
		moduledata.copyright_string_vars[titleScreen250+9] = get_config_int("DATAFILES","cpystr_5frame_var_sz2",-1);
		
		moduledata.copyright_string_vars[titleScreen210+0] = get_config_int("DATAFILES","cpystr_4frame_var_font",0);//zfont);
		moduledata.copyright_string_vars[titleScreen210+1] = get_config_int("DATAFILES","cpystr_4frame_var_x",46);
		moduledata.copyright_string_vars[titleScreen210+2] = get_config_int("DATAFILES","cpystr_4frame_var_y",138);
		moduledata.copyright_string_vars[titleScreen210+3] = get_config_int("DATAFILES","cpystr_4frame_var_col",255);
		moduledata.copyright_string_vars[titleScreen210+4] = get_config_int("DATAFILES","cpystr_4frame_var_sz",-1);
		
		moduledata.copyright_string_vars[titleScreen210+5] = get_config_int("DATAFILES","cpystr_4frame_var_font2",0);//zfont);
		moduledata.copyright_string_vars[titleScreen210+6] = get_config_int("DATAFILES","cpystr_4frame_var_x2",46);
		moduledata.copyright_string_vars[titleScreen210+7] = get_config_int("DATAFILES","cpystr_4frame_var_y2",146);
		moduledata.copyright_string_vars[titleScreen210+8] = get_config_int("DATAFILES","cpystr_4frame_var_col2",255);
		moduledata.copyright_string_vars[titleScreen210+9] = get_config_int("DATAFILES","cpystr_4frame_var_sz2",-1);
		
		moduledata.copyright_string_vars[titleScreenMAIN+0] = get_config_int("DATAFILES","cpystr_1frame_var_font",0);//zfont);
		moduledata.copyright_string_vars[titleScreenMAIN+1] = get_config_int("DATAFILES","cpystr_1frame_var_x",86);
		moduledata.copyright_string_vars[titleScreenMAIN+2] = get_config_int("DATAFILES","cpystr_1frame_var_y",128);
		moduledata.copyright_string_vars[titleScreenMAIN+3] = get_config_int("DATAFILES","cpystr_1frame_var_col",13);
		moduledata.copyright_string_vars[titleScreenMAIN+4] = get_config_int("DATAFILES","cpystr_1frame_var_sz",-1);
		
		moduledata.copyright_string_vars[titleScreenMAIN+5] = get_config_int("DATAFILES","cpystr_1frame_var_font2",0);//zfont);
		moduledata.copyright_string_vars[titleScreenMAIN+6] = get_config_int("DATAFILES","cpystr_1frame_var_x2",86);
		moduledata.copyright_string_vars[titleScreenMAIN+7] = get_config_int("DATAFILES","cpystr_1frame_var_y2",136);
		moduledata.copyright_string_vars[titleScreenMAIN+8] = get_config_int("DATAFILES","cpystr_1frame_var_col2",13);
		moduledata.copyright_string_vars[titleScreenMAIN+9] = get_config_int("DATAFILES","cpystr_1frame_var_sz2",-1);
		
		moduledata.animate_NES_title =  get_config_int("DATAFILES","disable_title_NES_animation",0);
		
		
		//item families
		const char default_itype_strings[itype_max][255] = 
		{ 
			"Swords", "Boomerangs", "Arrows", "Candles", "Whistles",
			"Bait", "Letters", "Potions", "Wands", "Rings", 
			"Wallets", "Amulets", "Shields", "Bows", "Rafts",
			"Ladders", "Books", "Magic Keys", "Bracelets", "Flippers", 
			"Boots", "Hookshots", "Lenses", "Hammers", "Din's Fire", 
			"Farore's Wind", "Nayru's Love", "Bombs", "Super Bombs", "Clocks", 
			"Keys", "Magic Containers", "Triforce Pieces", "Maps", "Compasses", 
			"Boss Keys", "Quivers", "Level Keys", "Canes of Byrna", "Rupees", 
			"Arrow Ammo", "Fairies", "Magic", "Hearts", "Heart Containers", 
			"Heart Pieces", "Kill All Enemies", "Bomb Ammo", "Bomb Bags", "Roc Items", 
			"Hover Boots", "Scroll: Spin Attack", "Scroll: Cross Beams", "Scroll: Quake Hammer","Whisp Rings", 
			"Charge Rings", "Scroll: Peril Beam", "Wealth Medals", "Heart Rings", "Magic Rings", 
			"Scroll: Hurricane Spin", "Scroll: Super Quake","Stones of Agony", "Stomp Boots", "Whimsical Rings", 
			"Peril Rings", "Non-gameplay Items", "Custom Itemclass 01", "Custom Itemclass 02", "Custom Itemclass 03",
			"Custom Itemclass 04", "Custom Itemclass 05", "Custom Itemclass 06", "Custom Itemclass 07", "Custom Itemclass 08", 
			"Custom Itemclass 09", "Custom Itemclass 10", "Custom Itemclass 11", "Custom Itemclass 12", "Custom Itemclass 13", 
			"Custom Itemclass 14", "Custom Itemclass 15", "Custom Itemclass 16", "Custom Itemclass 17", "Custom Itemclass 18", 
			"Custom Itemclass 19", "Custom Itemclass 20","Bow and Arrow (Subscreen Only)", "Letter or Potion (Subscreen Only)", "zz089"
		};
							 
		const char itype_fields[itype_max][255] =
		{
			"ic_sword","ic_brang", "ic_arrow","ic_cand","ic_whis",
			"ic_meat", "ic_rx", "ic_potion", 
			"ic_wand","ic_armour","ic_wallet","ic_amul","ic_shield",
			//10
			"ic_bow","ic_raft","ic_ladder","ic_spellbook","ic_mkey",
			"ic_glove","ic_flip","ic_boot","ic_grapple","ic_lens",
			//20
			"ic_hammer","ic_firespell","ic_exitspell","ic_shieldspell","ic_bomb",
			"ic_sbomb","ic_fobwatch","ic_key","ic_mcp","ic_mcguf",
			//30
			"ic_map","ic_compass","ic_bkey","ic_quiv","ic_lkey",
			"ic_cane","ic_money","ic_ammow_arrow","ic_faerie","ic_magic",
			//40
			"ic_health","ic_hc","ic_hcp","ic_killall","ic_ammo_bomb",
			"ic_bombbag","ic_feath","ic_hover","ic_spinat","ic_crossbeam",
			//50
			"ic_quakeham","ic_ring_whisp","ic_ring_charge","ic_perilbeam","ic_wmedal",
			"ic_ring_hp","ic_ring_mp","ic_multispin","ic_supquake","ic_dowse",
			//60
			"ic_stomp","ic_ring_crit","ic_ring_peril","ic_ngongameplay","ic_cic01",
			"ic_cic02","ic_cic03","ic_cic04","ic_cic05","ic_cic06",
			//70
			"ic_cic07","ic_cic08","ic_cic09","ic_cic10","ic_cic11",
			"ic_cic12","ic_cic13","ic_cic14","ic_cic15","ic_cic16",
			//80
			"ic_cic17","ic_cic18","ic_cic19","ic_cic20","ic_bowandarr","ic_bottle", "ic_last",
			"ic_89","ic_90","ic_91","ic_92","ic_93","ic_94","ic_95","ic_96","ic_97","ic_98","ic_99","ic_100","ic_101","ic_102","ic_103","ic_104",
			"ic_105","ic_106","ic_107","ic_108","ic_109","ic_111","ic_112","ic_113","ic_114","ic_115","ic_116","ic_117","ic_118","ic_119","ic_120","ic_121",
			"ic_122","ic_123","ic_124","ic_125","ic_126","ic_127","ic_128","ic_129","ic_130","ic_131","ic_132","ic_133","ic_134","ic_135","ic_136","ic_137",
			"ic_138","ic_139","ic_140","ic_141","ic_142","ic_143","ic_144","ic_145","ic_146","ic_147","ic_148","ic_149","ic_150","ic_151","ic_152","ic_153",
			"ic_154","ic_155","ic_156","ic_157","ic_158","ic_159","ic_160","ic_161","ic_162","ic_163","ic_164","ic_165","ic_166","ic_167","ic_168","ic_169",
			"ic_170","ic_171","ic_172","ic_173","ic_174","ic_175","ic_176","ic_177","ic_178","ic_179","ic_180","ic_181","ic_182","ic_183","ic_184","ic_185",
			"ic_186","ic_187","ic_188","ic_189","ic_190","ic_191","ic_192","ic_193","ic_194","ic_195","ic_196","ic_197","ic_198","ic_199","ic_200","ic_201",
			"ic_202","ic_203","ic_204","ic_205","ic_206","ic_207","ic_208","ic_209","ic_210","ic_211","ic_212","ic_213","ic_214","ic_215","ic_216","ic_217",
			"ic_218","ic_219","ic_220","ic_221","ic_222","ic_223","ic_224","ic_225","ic_226","ic_227","ic_228","ic_229","ic_230","ic_231","ic_232","ic_233",
			"ic_234","ic_235","ic_236","ic_237","ic_238","ic_239","ic_240","ic_241","ic_242","ic_243","ic_244","ic_245","ic_246","ic_247","ic_248","ic_249",
			"ic_250","ic_251","ic_252","ic_253","ic_254","ic_255","ic_256","ic_257","ic_258","ic_259","ic_260","ic_261","ic_262","ic_263","ic_264","ic_265",
			"ic_266","ic_267","ic_267","ic_269","ic_270","ic_271","ic_272","ic_273","ic_274","ic_275","ic_276","ic_277","ic_278","ic_279","ic_280","ic_281","ic_282","ic_283","ic_284","ic_285",
			"ic_286","ic_287","ic_288","ic_289","ic_290","ic_291","ic_292","ic_293","ic_294","ic_295","ic_296","ic_297","ic_298","ic_299","ic_300","ic_301","ic_302","ic_303","ic_304",
			"ic_305","ic_306","ic_307","ic_308","ic_309","ic_311","ic_312","ic_313","ic_314","ic_315","ic_316","ic_317","ic_318","ic_319","ic_320","ic_321",
			"ic_322","ic_323","ic_324","ic_325","ic_326","ic_327","ic_328","ic_329","ic_330","ic_331","ic_332","ic_333","ic_334","ic_335","ic_336","ic_337",
			"ic_338","ic_339","ic_340","ic_341","ic_342","ic_343","ic_344","ic_345","ic_346","ic_347","ic_348","ic_349","ic_350","ic_351","ic_352","ic_353",
			"ic_354","ic_355","ic_356","ic_357","ic_358","ic_359","ic_360","ic_361","ic_362","ic_363","ic_364","ic_365","ic_366","ic_367","ic_368","ic_369",
			"ic_370","ic_371","ic_372","ic_373","ic_374","ic_375","ic_376","ic_377","ic_378","ic_379","ic_380","ic_381","ic_382","ic_383","ic_384","ic_385",
			"ic_386","ic_387","ic_388","ic_389","ic_390","ic_391","ic_392","ic_393","ic_394","ic_395","ic_396","ic_397","ic_398","ic_399","ic_400","ic_401","ic_402","ic_403","ic_404",
			"ic_405","ic_406","ic_407","ic_408","ic_409","ic_411","ic_412","ic_413","ic_414","ic_415","ic_416","ic_417","ic_418","ic_419","ic_420","ic_421",
			"ic_422","ic_423","ic_424","ic_425","ic_426","ic_427","ic_428","ic_429","ic_430","ic_431","ic_432","ic_433","ic_434","ic_435","ic_436","ic_437",
			"ic_438","ic_439","ic_440","ic_441","ic_442","ic_443","ic_444","ic_445","ic_446","ic_447","ic_448","ic_449","ic_450","ic_451","ic_452","ic_453",
			"ic_454","ic_455","ic_456","ic_457","ic_458","ic_459","ic_460","ic_461","ic_462","ic_463","ic_464","ic_465","ic_466","ic_467","ic_468","ic_469",
			"ic_470","ic_471","ic_472","ic_473","ic_474","ic_475","ic_476","ic_477","ic_478","ic_479","ic_480","ic_481","ic_482","ic_483","ic_484","ic_485",
			"ic_486","ic_487","ic_488","ic_489","ic_490","ic_491","ic_492","ic_493","ic_494","ic_495","ic_496","ic_497","ic_498","ic_499","ic_500","ic_501","ic_502","ic_503","ic_504",
			"ic_505","ic_506","ic_507","ic_508","ic_509","ic_511"
		};
		for ( int q = 0; q < itype_max; q++ )
		{
			strcpy(moduledata.item_editor_type_names[q],get_config_string("ITEMS",itype_fields[q],default_itype_strings[q]));
			//al_trace("Item family ID %d is: %s\n", q, moduledata.item_editor_type_names[q]);
		}
		
		const char roomtype_cats[rMAX][256] =
		{
			"rNONE","rSP_ITEM","rINFO","rMONEY","rGAMBLE","rREPAIR","rRP_HC","rGRUMBLE",
			"rQUESTOBJ","rP_SHOP","rSHOP","rBOMBS","rSWINDLE","r10RUPIES","rWARP","rMAINBOSS","rWINGAME",
			"rITEMPOND","rMUPGRADE","rLEARNSLASH","rARROWS","rTAKEONE"
		};
		const char roomtype_defaults[rMAX][255] =
		{
			"(None)","Special Item","Pay for Info","Secret Money","Gamble",
			"Door Repair","Red Potion or Heart Container","Feed the Goriya","Level 9 Entrance",
			"Potion Shop","Shop","More Bombs","Leave Money or Life","10 Rupees",
			"3-Stair Warp","Ganon","Zelda", "-<item pond>", "1/2 Magic Upgrade", "Learn Slash", "More Arrows","Take One Item"
		};
		for ( int q = 0; q < rMAX; q++ )
		{
			strcpy(moduledata.roomtype_names[q],get_config_string("ROOMTYPES",roomtype_cats[q],roomtype_defaults[q]));
			//al_trace("Map Flag ID %d is: %s\n", q, moduledata.roomtype_names[q]);
		}
		const char lweapon_cats[wIce+1][255]=
		{
			"lwNone","lwSword","lwBeam","lwBrang","lwBomb","lwSBomb","lwLitBomb",
			"lwLitSBomb","lwArrow","lwFire","lwWhistle","lwMeat","lwWand","lwMagic","lwCatching",
			"lwWind","lwRefMagic","lwRefFireball","lwRefRock", "lwHammer","lwGrapple", "lwHSHandle", 
			"lwHSChain", "lwSSparkle","lwFSparkle", "lwSmack", "lwPhantom", 
			"lwCane","lwRefBeam", "lwStomp","lwScript1", "lwScript2", "lwScript3", 
			"lwScript4","lwScript5", "lwScript6", "lwScript7", "lwScript8","lwScript9", "lwScript10", "lwIce"
		};
		const char lweapon_default_names[wIce+1][255]=
		{
			"(None)","Sword","Sword Beam","Boomerang","Bomb","Super Bomb","Lit Bomb",
			"Lit Super Bomb","Arrow","Fire","Whistle","Bait","Wand","Magic","-Catching",
			"Wind","Reflected Magic","Reflected Fireball","Reflected Rock", "Hammer","Hookshit", "-HSHandle", 
			"-HSChain", "Sparkle","-FSparkle", "-Smack", "-Phantom", 
			"Cane of Byrna","Reflected Sword Beam", "-Stomp","Script1", "Script2", "Script3", 
			"Script4","Script5", "Script6", "Script7", "Script8","Script9", "Script10", "Ice"
		};
		for ( int q = 0; q < wIce+1; q++ )
		{
			strcpy(moduledata.player_weapon_names[q],get_config_string("LWEAPONS",lweapon_cats[q],lweapon_default_names[q]));
			//al_trace("LWeapon ID %d is: %s\n", q, moduledata.player_weapon_names[q]);
			//al_trace("LWEAPONS %d is: %s\n", q, moduledata.player_weapon_names[q]);
		}
		const char counter_cats[33][255]=
		{
			"crNONE","crLIFE","crMONEY","crBOMBS","crARROWS","crMAGIC","crKEYS",
			"crSBOMBS","crCUSTOM1","crCUSTOM2","crCUSTOM3","crCUSTOM4","crCUSTOM5","crCUSTOM6",
			"crCUSTOM7","crCUSTOM8","crCUSTOM9","crCUSTOM10","crCUSTOM11","crCUSTOM12","crCUSTOM13",
			"crCUSTOM14","crCUSTOM15","crCUSTOM16","crCUSTOM17","crCUSTOM18","crCUSTOM19",
			"crCUSTOM20","crCUSTOM21","crCUSTOM22","crCUSTOM23","crCUSTOM24","crCUSTOM25"
		};

		const char counter_default_names[33][255]=
		{
			"None","Life","Rupees", "Bombs","Arrows","Magic",
			"Keys","Super Bombs","Custom 1","Custom 2","Custom 3",
			"Custom 4","Custom 5","Custom 6","Custom 7","Custom 8",
			"Custom 9","Custom 10","Custom 11","Custom 12",
			"Custom 13","Custom 14","Custom 15","Custom 16","Custom 17",
			"Custom 18","Custom 19","Custom 20","Custom 21","Custom 22"
			"Custom 23","Custom 24","Custom 25"	
		};
		for ( int q = 0; q < 33; q++ )
		{
			strcpy(moduledata.counter_names[q],get_config_string("COUNTERS",counter_cats[q],counter_default_names[q]));
			//al_trace("Counter ID %d is: %s\n", q, moduledata.counter_names[q]);
		}
		
		al_trace("Module Title: %s\n", moduledata.moduletitle);
		al_trace("Module Author: %s\n", moduledata.moduleauthor);
		al_trace("Module Info: \n%s\n%s\n%s\n%s\n%s\n", moduledata.moduleinfo0, moduledata.moduleinfo1, moduledata.moduleinfo2, moduledata.moduleinfo3, moduledata.moduleinfo4);
		//al_trace("Module Base NSF: %s\n", moduledata.module_base_nsf);
		
		al_trace("Module Version: %d.%d.%d.%d\n", moduledata.modver_1,moduledata.modver_2,moduledata.modver_3, moduledata.modver_4);
		al_trace("Module Build: %d, %s: %d\n", moduledata.modbuild, (moduledata.modbeta<0) ? "Alpha" : "Beta", moduledata.modbeta );
		
		//al_trace("Build Day: %s\n",dayextension(moduledata.modday).c_str());
		//al_trace("Build Month: %s\n",(char*)months[moduledata.modmonth]);
		//al_trace("Build Year: %d\n",moduledata.modyear);
		al_trace("Build Date: %s %s, %d at @ %d:%d %s\n", dayextension(moduledata.modday).c_str(), 
			(char*)months[moduledata.modmonth], moduledata.modyear, moduledata.modhour, moduledata.modminute, moduledata.moduletimezone);
		
	}
	
	
	
	set_config_file("zc.cfg"); //shift back to the normal config file, when done
	
	moduledata.ignore = (get_config_int("zeldadx","ignore_module_quests",0) ? true : false); //ignore module values
	
	//int x = get_config_int("zeldadx","gui_colorset",0);
	//al_trace("Checking that we have reverted to zc.cfg: %d\n",x);
	return true;
}

//Prints out the current Module struct data to allegro.log
void ZModule::debug()
{
	//al_trace("Module field: %s, is: %s\n", "module_name", moduledata.module_name);
	//al_trace("Module field: %s, is: %s\n", "quest_flow",moduledata.old_quest_serial_flow);
	
	//quests
	/*
	al_trace("Module field: %s, is: %s\n", "quest_flow",moduledata.old_quest_serial_flow);
	al_trace("Module field: %s, is: %s\n", "quests[0]",moduledata.quests[0]);
	al_trace("Module field: %s, is: %s\n", "quests[1]",moduledata.quests[1]);
	al_trace("Module field: %s, is: %s\n", "quests[2]",moduledata.quests[2]);
	al_trace("Module field: %s, is: %s\n", "quests[3]",moduledata.quests[3]);
	al_trace("Module field: %s, is: %s\n", "quests[4]",moduledata.quests[4]);
	
	//skip codes
	al_trace("Module field: %s, is: %s\n", "skipnames[0]",moduledata.skipnames[0]);
	al_trace("Module field: %s, is: %s\n", "skipnames[1]",moduledata.skipnames[1]);
	al_trace("Module field: %s, is: %s\n", "skipnames[2]",moduledata.skipnames[2]);
	al_trace("Module field: %s, is: %s\n", "skipnames[3]",moduledata.skipnames[3]);
	al_trace("Module field: %s, is: %s\n", "skipnames[4]",moduledata.skipnames[4]);

	//datafiles
	al_trace("Module field: %s, is: %s\n", "datafiles[zelda_dat]",moduledata.datafiles[zelda_dat]);
	al_trace("Module field: %s, is: %s\n", "datafiles[zquest_dat]",moduledata.datafiles[zquest_dat]);
	al_trace("Module field: %s, is: %s\n", "datafiles[fonts_dat]",moduledata.datafiles[fonts_dat]);
	al_trace("Module field: %s, is: %s\n", "datafiles[sfx_dat]",moduledata.datafiles[sfx_dat]);
	al_trace("Module field: %s, is: %s\n", "datafiles[qst_dat]",moduledata.datafiles[qst_dat]);
	*/
}

bool ZModule::load(bool zquest)
{
	set_config_file(moduledata.module_name);
	//load config settings
	if ( zquest )
	{
		al_trace("ZModule::load() was called by: %s\n","ZQuest");
		//load ZQuest section data
		set_config_file("zquest.cfg"); //shift back when done
	}
	else
	{
		al_trace("ZModule::load() was called by: %s\n","ZC Player");
		//load ZC section data
		set_config_file("zc.cfg"); //shift back when done
	}
	return true;
}



void FFScript::Play_Level_Music()
{
	int m=tmpscr->screen_midi;
	
	switch(m)
	{
	case -2:
		music_stop();
		break;
		
	case -1:
		play_DmapMusic();
		break;
		
	case 1:
		jukebox(ZC_MIDI_OVERWORLD);
		break;
		
	case 2:
		jukebox(ZC_MIDI_DUNGEON);
		break;
		
	case 3:
		jukebox(ZC_MIDI_LEVEL9);
		break;
		
	default:
		if(m>=4 && m<4+MAXCUSTOMMIDIS)
			jukebox(m+MIDIOFFSET_MAPSCR);
		else
			music_stop();
	}
}

void FFScript::do_warp_ex(bool v)
{
	int zscript_array_ptr = SH::get_arg(sarg1, v) / 10000;
	int zscript_array_size = FFCore.getSize(zscript_array_ptr);
	bool success = false;
	switch(zscript_array_size)
	{
		case 8:
			// {int type, int dmap, int screen, int x, int y, int effect, int sound, int flags}
		{
			zprint("FFscript.cpp running do_warp_ex with %d args\n", 8);
			int tmpwarp[8]={0};
			for ( int q = 0; q < wexDir; q++ )
			{
				tmpwarp[q] = (getElement(zscript_array_ptr,q)/10000);
				//FFCore.warpex[q] = (getElement(zscript_array_ptr,q)/10000);
			}
			
			if ( ((unsigned)tmpwarp[1]) >= MAXDMAPS ) 
			{
				Z_scripterrlog("Invalid DMap ID (%d) passed to WarpEx(). Aborting.\n", tmpwarp[1]);
				return;
			}
			if ( ((unsigned)tmpwarp[2]) >= MAPSCRS ) 
			{
				Z_scripterrlog("Invalid Screen ID (%d) passed to WarpEx(). Aborting.\n", tmpwarp[2]);
				return;
			}
			//Extra sanity guard. 
			if ( DMaps[tmpwarp[1]].map*MAPSCRS+DMaps[tmpwarp[1]].xoff+tmpwarp[2] >= (int)TheMaps.size() )
			{
				Z_scripterrlog("Invalid destination passed to WarpEx(). Aborting.\n");
				return;
			}
			//If we passed the sanity checks, populate the FFCore array and begin the action!
			for ( int q = 0; q < wexDir; q++ )
			{
				FFCore.warpex[q] = tmpwarp[q];
			}
			FFCore.warpex[wexActive] = 1;
			FFCore.warpex[wexDir] = -1;
			
			break;
		}
		case 9:
			// {int type, int dmap, int screen, int x, int y, int effect, int sound, int flags, int dir}
		{
			zprint("FFscript.cpp running do_warp_ex with %d args\n", 9);
			int tmpwarp[9]={0};
			
			for ( int q = 0; q < wexActive; q++ )
			{
				tmpwarp[q] = (getElement(zscript_array_ptr,q)/10000);
				//FFCore.warpex[q] = (getElement(zscript_array_ptr,q)/10000);
			}
			
			if ( ((unsigned)tmpwarp[1]) >= MAXDMAPS ) 
			{
				Z_scripterrlog("Invalid DMap ID (%d) passed to WarpEx(). Aborting.\n", tmpwarp[1]);
				return;
			}
			if ( ((unsigned)tmpwarp[2]) >= MAPSCRS ) 
			{
				Z_scripterrlog("Invalid Screen ID (%d) passed to WarpEx(). Aborting.\n", tmpwarp[2]);
				return;
			}
			//Extra sanity guard. 
			if ( DMaps[tmpwarp[1]].map*MAPSCRS+DMaps[tmpwarp[1]].xoff+tmpwarp[2] >= (int)TheMaps.size() )
			{
				Z_scripterrlog("Invalid destination passed to WarpEx(). Aborting.\n");
				return;
			}
			//If we passed the sanity checks, populate the FFCore array and begin the action!
			for ( int q = 0; q < wexActive; q++ )
			{
				FFCore.warpex[q] = tmpwarp[q];
			}
			FFCore.warpex[wexActive] = 1; 
			
			for ( int q = 0; q < wexActive; q++ )
			{
				FFCore.warpex[q] = tmpwarp[q];
			}
			
			//for ( int q = 0; q < wexLast; q++ ) 
			//{
			//	zprint("FFCore.warpex[%d] is: %d\n", q, FFCore.warpex[q]);
			//}
			
			break;
			
		}
	
		default: 
		{
			Z_scripterrlog("Array supplied to Link->WarpEx() is the wrong size!\n The array size was: &d, and valid sizes are [8] and [9].\n",zscript_array_size);
			break;
		}
		
		
		
	}
}

///////////////////////////////
//* SCRIPT ENGINE FUNCTIONS *//
////////////////////////////////////////////////////////////////////////////

void FFScript::clearRunningItemScripts()
{
	//for ( byte q = 0; q < 256; q++ ) runningItemScripts[q] = 0;
}


bool FFScript::newScriptEngine()
{
	//itemScriptEngine();
	//lweaponScriptEngine();
	advanceframe(true);
	return false;
}

void FFScript::runWarpScripts(bool waitdraw)
{
	if(waitdraw)
	{
		if((!( FFCore.system_suspend[susptGLOBALGAME] )) && (global_wait & (1<<GLOBAL_SCRIPT_GAME)))
		{
			ZScriptVersion::RunScript(SCRIPT_GLOBAL, GLOBAL_SCRIPT_GAME, GLOBAL_SCRIPT_GAME);
			global_wait&= ~(1<<GLOBAL_SCRIPT_GAME);
		}
		if ( !FFCore.system_suspend[susptITEMSCRIPTENGINE] )
		{
			FFCore.itemScriptEngineOnWaitdraw();
		}
		if ( (!( FFCore.system_suspend[susptLINKACTIVE] )) && link_waitdraw && FFCore.getQuestHeaderInfo(vZelda) >= 0x255 )
		{
			ZScriptVersion::RunScript(SCRIPT_LINK, SCRIPT_LINK_ACTIVE, SCRIPT_LINK_ACTIVE);
			link_waitdraw = false;
		}
		if ( (!( FFCore.system_suspend[susptDMAPSCRIPT] )) && dmap_waitdraw && FFCore.getQuestHeaderInfo(vZelda) >= 0x255 )
		{
			ZScriptVersion::RunScript(SCRIPT_DMAP, DMaps[currdmap].script,currdmap);
			dmap_waitdraw = false;
		}
		if ( (!( FFCore.system_suspend[susptDMAPSCRIPT] )) && passive_subscreen_waitdraw && FFCore.getQuestHeaderInfo(vZelda) >= 0x255 )
		{
			ZScriptVersion::RunScript(SCRIPT_PASSIVESUBSCREEN, DMaps[currdmap].passive_sub_script,currdmap);
			passive_subscreen_waitdraw = false;
		}
		//if ( (!( FFCore.system_suspend[susptDMAPSCRIPT] )) && active_subscreen_waitdraw && FFCore.getQuestHeaderInfo(vZelda) >= 0x255 )
		//{
		//	ZScriptVersion::RunScript(SCRIPT_SUBSCREEN, DMaps[currdmap].activesubscript,currdmap);
		//	passive_subscreen_waitdraw = false;
		//}
		//no doscript check here, becauseb of preload? Do we want to write doscript here? -Z 13th July, 2019
		if ( (!( FFCore.system_suspend[susptSCREENSCRIPTS] )) && tmpscr->script != 0 && tmpscr->screen_waitdraw && tmpscr->preloadscript && FFCore.getQuestHeaderInfo(vZelda) >= 0x255 )
		{
			ZScriptVersion::RunScript(SCRIPT_SCREEN, tmpscr->script, 0);  
			tmpscr->screen_waitdraw = 0;		
		}
	}
	else
	{
		if((!( FFCore.system_suspend[susptGLOBALGAME] )) && (g_doscript & (1<<GLOBAL_SCRIPT_GAME)))
		{
			ZScriptVersion::RunScript(SCRIPT_GLOBAL, GLOBAL_SCRIPT_GAME, GLOBAL_SCRIPT_GAME);
		}
		if ( !FFCore.system_suspend[susptITEMSCRIPTENGINE] )
		{
			FFCore.itemScriptEngine();
		}
		if ((!( FFCore.system_suspend[susptLINKACTIVE] )) && link_doscript && FFCore.getQuestHeaderInfo(vZelda) >= 0x255)
		{
			ZScriptVersion::RunScript(SCRIPT_LINK, SCRIPT_LINK_ACTIVE, SCRIPT_LINK_ACTIVE);
		}
		if ( (!( FFCore.system_suspend[susptDMAPSCRIPT] )) && dmap_doscript && FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) 
		{
			ZScriptVersion::RunScript(SCRIPT_DMAP, DMaps[currdmap].script,currdmap);
		}
		if ( (!( FFCore.system_suspend[susptDMAPSCRIPT] )) && passive_subscreen_doscript && FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) 
		{
			ZScriptVersion::RunScript(SCRIPT_PASSIVESUBSCREEN, DMaps[currdmap].passive_sub_script,currdmap);
		}
		if ( (!( FFCore.system_suspend[susptSCREENSCRIPTS] )) && tmpscr->script != 0 && tmpscr->preloadscript && FFCore.getQuestHeaderInfo(vZelda) >= 0x255 )
		{
			ZScriptVersion::RunScript(SCRIPT_SCREEN, tmpscr->script, 0);
		}
	}
}

void FFScript::runF6Engine()
{
	if(!Quit && (GameFlags&GAMEFLAG_TRYQUIT) && !(GameFlags&GAMEFLAG_F6SCRIPT_ACTIVE))
	{
		if(globalscripts[GLOBAL_SCRIPT_F6]->valid())
		{
			//Incase this was called mid-another script, store ref data
			long tsarg1 = sarg1;
			long tsarg2 = sarg2;
			refInfo *tri = ri;
			script_data *tcurscript = curscript;
			//
			clear_bitmap(f6_menu_buf);
			blit(framebuf, f6_menu_buf, 0, 0, 0, 0, 256, 224);
			initZScriptGlobalScript(GLOBAL_SCRIPT_F6);
			int openingwipe = black_opening_count;
			int openingshape = black_opening_shape;
			black_opening_count = 0; //No opening wipe during F6 menu
			if(black_opening_shape==bosFADEBLACK) black_fade(0);
			GameFlags |= GAMEFLAG_F6SCRIPT_ACTIVE;
			pause_all_sfx();
			while(g_doscript & (1<<GLOBAL_SCRIPT_F6))
			{
				script_drawing_commands.Clear();
				load_control_state(); 
				ZScriptVersion::RunScript(SCRIPT_GLOBAL, GLOBAL_SCRIPT_F6, GLOBAL_SCRIPT_F6);
				if(global_wait & (1<<GLOBAL_SCRIPT_F6))
				{
					ZScriptVersion::RunScript(SCRIPT_GLOBAL, GLOBAL_SCRIPT_F6, GLOBAL_SCRIPT_F6);
					global_wait &= ~(1<<GLOBAL_SCRIPT_F6);
				}
				//Draw
				clear_bitmap(framebuf);
				if( !FFCore.system_suspend[susptCOMBOANIM] ) animate_combos();
				doScriptMenuDraws();
				//
				advanceframe(true,true,false);
				if(Quit) break; //Something quit, end script running
			}
			resume_all_sfx();
			script_drawing_commands.Clear();
			GameFlags &= ~GAMEFLAG_F6SCRIPT_ACTIVE;
			//Restore opening wipe
			black_opening_count = openingwipe;
			black_opening_shape = openingshape;
			if(openingshape == bosFADEBLACK)
			{
				refreshTints();
				memcpy(tempblackpal, RAMpal, PAL_SIZE*sizeof(RGB));
			}
			//Restore script refinfo
			sarg1 = tsarg1;
			sarg2 = tsarg2;
			ri = tri;
			curscript = tcurscript;
			//
		}
		if(!Quit)
		{
			if(!get_bit(quest_rules, qr_NOCONTINUE)) f_Quit(qQUIT);
		}
		zc_readkey(KEY_F6);
		GameFlags &= ~GAMEFLAG_TRYQUIT;
	}
}
void FFScript::runOnDeathEngine()
{
	if(!linkscripts[SCRIPT_LINK_DEATH]->valid()) return; //No script to run
	clear_bitmap(script_menu_buf);
	blit(framebuf, script_menu_buf, 0, 0, 0, 0, 256, 224);
	initZScriptLinkScripts();
	GameFlags |= GAMEFLAG_SCRIPTMENU_ACTIVE;
	kill_sfx(); //No need to pause/resume; the player is dead.
	while(link_doscript && !Quit)
	{
		script_drawing_commands.Clear();
		load_control_state();
		ZScriptVersion::RunScript(SCRIPT_LINK, SCRIPT_LINK_DEATH, SCRIPT_LINK_DEATH);
		if(link_waitdraw)
		{
			ZScriptVersion::RunScript(SCRIPT_LINK, SCRIPT_LINK_DEATH, SCRIPT_LINK_DEATH);
			link_waitdraw = false;
		}
		//Draw
		clear_bitmap(framebuf);
		if( !FFCore.system_suspend[susptCOMBOANIM] ) animate_combos();
		doScriptMenuDraws();
		//
		advanceframe(true);
	}
	script_drawing_commands.Clear();
	GameFlags &= ~GAMEFLAG_SCRIPTMENU_ACTIVE;
}
void FFScript::runOnLaunchEngine()
{
	if(!globalscripts[GLOBAL_SCRIPT_ONLAUNCH]->valid()) return; //No script to run
	//Do NOT blit the prior screen to this bitmap; that would be the TITLE SCREEN.
	clear_to_color(script_menu_buf,BLACK);
	initZScriptGlobalScript(GLOBAL_SCRIPT_ONLAUNCH);
	GameFlags |= GAMEFLAG_SCRIPTMENU_ACTIVE;
	while(g_doscript & (1<<GLOBAL_SCRIPT_ONLAUNCH) && !Quit)
	{
		script_drawing_commands.Clear();
		load_control_state();
		ZScriptVersion::RunScript(SCRIPT_GLOBAL, GLOBAL_SCRIPT_ONLAUNCH, GLOBAL_SCRIPT_ONLAUNCH);
		if(global_wait & (1<<GLOBAL_SCRIPT_ONLAUNCH))
		{
			ZScriptVersion::RunScript(SCRIPT_GLOBAL, GLOBAL_SCRIPT_ONLAUNCH, GLOBAL_SCRIPT_ONLAUNCH);
			global_wait &= ~(1<<GLOBAL_SCRIPT_ONLAUNCH);
		}
		//Draw
		clear_bitmap(framebuf);
		if( !FFCore.system_suspend[susptCOMBOANIM] ) animate_combos();
		
		doScriptMenuDraws();
		//
		advanceframe(true);
	}
	script_drawing_commands.Clear();
	GameFlags &= ~GAMEFLAG_SCRIPTMENU_ACTIVE;
}
bool FFScript::runActiveSubscreenScriptEngine()
{
	word activesubscript = DMaps[currdmap].active_sub_script;
	if(!activesubscript || !dmapscripts[activesubscript]->valid()) return false; //No script to run
	word passivesubscript = DMaps[currdmap].passive_sub_script;
	word dmapactivescript = DMaps[currdmap].script;
	clear_bitmap(script_menu_buf);
	blit(framebuf, script_menu_buf, 0, 0, 0, 0, 256, 224);
	initZScriptActiveSubscreenScript();
	GameFlags |= GAMEFLAG_SCRIPTMENU_ACTIVE;
	word script_dmap = currdmap;
	pause_all_sfx();
	while(active_subscreen_doscript && !Quit)
	{
		script_drawing_commands.Clear();
		load_control_state();
		if(get_bit(quest_rules, qr_DMAP_ACTIVE_RUNS_DURING_ACTIVE_SUBSCRIPT) && DMaps[script_dmap].script != 0 && dmap_doscript != 0)
		{
			ZScriptVersion::RunScript(SCRIPT_DMAP, dmapactivescript, script_dmap);
		}
		if(get_bit(quest_rules, qr_PASSIVE_SUBSCRIPT_RUNS_DURING_ACTIVE_SUBSCRIPT)!=0 && DMaps[script_dmap].passive_sub_script != 0 && passive_subscreen_doscript != 0)
		{
			ZScriptVersion::RunScript(SCRIPT_PASSIVESUBSCREEN, passivesubscript, script_dmap);
		}
		ZScriptVersion::RunScript(SCRIPT_ACTIVESUBSCREEN, activesubscript, script_dmap);
		if(dmap_waitdraw && (get_bit(quest_rules, qr_DMAP_ACTIVE_RUNS_DURING_ACTIVE_SUBSCRIPT) && DMaps[script_dmap].script != 0 && dmap_doscript != 0))
		{
			ZScriptVersion::RunScript(SCRIPT_DMAP, dmapactivescript, script_dmap);
			dmap_waitdraw = false;
		}
		if(passive_subscreen_waitdraw && (get_bit(quest_rules, qr_PASSIVE_SUBSCRIPT_RUNS_DURING_ACTIVE_SUBSCRIPT)!=0 && DMaps[script_dmap].passive_sub_script != 0 && passive_subscreen_doscript != 0))
		{
			ZScriptVersion::RunScript(SCRIPT_PASSIVESUBSCREEN, passivesubscript, script_dmap);
			passive_subscreen_waitdraw = false;
		}
		if(active_subscreen_waitdraw && active_subscreen_doscript != 0)
		{
			ZScriptVersion::RunScript(SCRIPT_ACTIVESUBSCREEN, activesubscript, script_dmap);
			active_subscreen_waitdraw = false;
		}
		//Draw
		clear_bitmap(framebuf);
		if(currdmap == script_dmap && ( !FFCore.system_suspend[susptCOMBOANIM] ) ) animate_combos();
		doScriptMenuDraws();
		//
		advanceframe(true);
		//Handle warps; run game_loop once!
		if(currdmap != script_dmap)
		{
			activesubscript = DMaps[currdmap].active_sub_script;
			if(!activesubscript || !dmapscripts[activesubscript]->valid()) return true; //No script to run
			passivesubscript = DMaps[currdmap].passive_sub_script;
			dmapactivescript = DMaps[currdmap].script;
			script_dmap = currdmap;
			//Reset the background image
			game_loop();
			clear_bitmap(script_menu_buf);
			blit(framebuf, script_menu_buf, 0, 0, 0, 0, 256, 224);
			//Now loop without advancing frame, so that the subscreen script can draw immediately.
		}
	}
	resume_all_sfx();
	GameFlags &= ~GAMEFLAG_SCRIPTMENU_ACTIVE;
	return true;
}

void FFScript::doScriptMenuDraws()
{
	BITMAP* menu_buf = ((GameFlags & GAMEFLAG_F6SCRIPT_ACTIVE) != 0) ? f6_menu_buf : script_menu_buf;
	blit(menu_buf, framebuf, 0, 0, 0, 0, 256, 224);
	//Script draws
	do_script_draws(framebuf, tmpscr, 0, playing_field_offset);
}

void FFScript::runOnSaveEngine()
{
	if(globalscripts[GLOBAL_SCRIPT_ONSAVE]->valid())
	{
		long tsarg1 = sarg1;
		long tsarg2 = sarg2;
		refInfo *tri = ri;
		script_data *tcurscript = curscript;
		//Prevent getting here via Quit from causing a forced-script-quit after 1000 commands!
		int tQuit = Quit;
		Quit = 0;
		//
		initZScriptGlobalScript(GLOBAL_SCRIPT_ONSAVE);
		ZScriptVersion::RunScript(SCRIPT_GLOBAL, GLOBAL_SCRIPT_ONSAVE, GLOBAL_SCRIPT_ONSAVE);
		//
		sarg1 = tsarg1;
		sarg2 = tsarg2;
		ri = tri;
		curscript = tcurscript;
		Quit = tQuit;
	}
}

void FFScript::lweaponScriptEngine()
{
	if ( FFCore.system_suspend[susptLWEAPONSCRIPTS] ) return;
	for ( int q = 0; q < Lwpns.Count(); q++ )
	{
		//ri->lwpn = Lwpns.spr(q)->getUID();
		//zprint("lweaponScriptEngine(): UID (%d) ri->lwpn (%d)\n", Lwpns.spr(q)->getUID(), ri->lwpn);
		//ri->lwpn = Lwpns.spr(q)->getUID();
		weapon *wp = (weapon*)Lwpns.spr(q);
		switch(Lwpns.spr(q)->id)
		{
			/* We can't have this, because the same script would run on the sword, and on the swordbeam!
			case wSword:
			{
				weapon *wa = (weapon*)Lwpns.spr(q);
				if ( wa->Dead() ) break;
				if ( Lwpns.spr(q)->doscript && Lwpns.spr(q)->weaponscript > 0 ) 
				{
					weapon *w = (weapon*)Lwpns.spr(q);
					if ( w->Dead() )
					{
						Lwpns.spr(q)->doscript = 0;
						Lwpns.spr(q)->weaponscript = 0;
						//memset(w->stack, 0xFFFF, sizeof(w->stack));
						break;
					}
					else
					{
						//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
						//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, index);		
						//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, Lwpns.spr(q)->getUID());		
						//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, ri->lwpn);		
						ri->lwpn = w->getUID();
						if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, w->getUID());		
					}
				}
				break;
			}
			*/
			case wBeam:
			case wRefBeam:
			{
				weapon *wa = (weapon*)Lwpns.spr(q);
				if ( wa->Dead() ) break;
				if ( Lwpns.spr(q)->doscript && Lwpns.spr(q)->weaponscript > 0 ) 
				{
					weapon *w = (weapon*)Lwpns.spr(q);
					if ( w->Dead() )
					{
						Lwpns.spr(q)->doscript = 0;
						Lwpns.spr(q)->weaponscript = 0;
						//memset(w->stack, 0xFFFF, sizeof(w->stack));
						break;
					}
					else
					{
						//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
						//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, index);		
						//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, Lwpns.spr(q)->getUID());		
						//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, ri->lwpn);		
						ri->lwpn = w->getUID();
						if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, w->getUID());		
					}
				}
				break;
			}
			
			case wWhistle:
			{
				weapon *wa = (weapon*)Lwpns.spr(q);
				if ( wa->Dead() ) break;
				if ( Lwpns.spr(q)->doscript && Lwpns.spr(q)->weaponscript > 0 ) 
				{
					weapon *w = (weapon*)Lwpns.spr(q);
					if ( w->Dead() )
					{
						Lwpns.spr(q)->doscript = 0;
						Lwpns.spr(q)->weaponscript = 0;
						break;
					}
					else
					{
						//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
						//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, index);		
						//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, Lwpns.spr(q)->getUID());	
						//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, ri->lwpn);
						ri->lwpn = w->getUID();
						if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, w->getUID());
					}
				}
				break;
			}
			
			case wWind:
			{
				break;
			}
			
			case wFire:
			{
				weapon *wa = (weapon*)Lwpns.spr(q);
				if ( wa->Dead() ) break;
				if ( Lwpns.spr(q)->doscript && Lwpns.spr(q)->weaponscript > 0 ) 
				{
					weapon *w = (weapon*)Lwpns.spr(q);
					if ( w->Dead() )
					{
						Lwpns.spr(q)->doscript = 0;
						Lwpns.spr(q)->weaponscript = 0;
						break;
					}
					else
					{
						//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
						//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, index);		
						//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, ri->lwpn);
						if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, w->getUID());
						ri->lwpn = w->getUID();
						//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, Lwpns.spr(q)->getUID());		
					}
				}
				break;
			}
			
			case wLitBomb:
			case wBomb:
			case ewLitBomb:
			case ewBomb:
			case ewLitSBomb:
			case ewSBomb:
			case wLitSBomb:
			case wSBomb:
			{
				break;
			}
			
			case wArrow:
			{
				weapon *wa = (weapon*)Lwpns.spr(q);
				if ( wa->Dead() ) break;
				if ( Lwpns.spr(q)->doscript && Lwpns.spr(q)->weaponscript > 0 ) 
				{
					weapon *w = (weapon*)Lwpns.spr(q);
					if ( w->Dead() )
					{
						Lwpns.spr(q)->doscript = 0;
						Lwpns.spr(q)->weaponscript = 0;
						break;
					}
					else
					{
						//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
						//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, index);		
						//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, Lwpns.spr(q)->getUID());		
						//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, ri->lwpn);	
						ri->lwpn = w->getUID();					
						if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, w->getUID());		
					}
				}
				break;
			}
			
			case wSSparkle:
			{
				break;
			}
			
			case wFSparkle:
			{
				break;
			}
			case wBait:
			{
				weapon *wa = (weapon*)Lwpns.spr(q);
				if ( wa->Dead() ) break;
				if ( Lwpns.spr(q)->doscript && Lwpns.spr(q)->weaponscript > 0 ) 
				{
					weapon *w = (weapon*)Lwpns.spr(q);
					if ( w->Dead() )
					{
						Lwpns.spr(q)->doscript = 0;
						Lwpns.spr(q)->weaponscript = 0;
						break;
					}
					else
					{
						//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
						//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, index);		
						//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, Lwpns.spr(q)->getUID());		
						//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, ri->lwpn);	
						ri->lwpn = w->getUID();
						if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, w->getUID());		
					}
				}
				break;
			}
			case wBrang:
			{
				weapon *wa = (weapon*)Lwpns.spr(q);
					
				if ( Lwpns.spr(q)->doscript ) 
				{
					weapon *w = (weapon*)Lwpns.spr(q);
					if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, w->getUID());		
				}
			
				
				break;
			}
			
			case wHookshot:
			{
				break;
			}
			case wHSHandle:
			{
				break;
			}
			case wPhantom:
			{
				break;
			}
			case wRefMagic:
			case wMagic:
			{
				//:Weapon Only
				if ( Lwpns.spr(q)->doscript && Lwpns.spr(q)->weaponscript > 0 ) 
				{
					weapon *w = (weapon*)Lwpns.spr(q);
					if ( w->Dead() )
					{
						Lwpns.spr(q)->doscript = 0;
						Lwpns.spr(q)->weaponscript = 0;
						break;
					}
					else
					{
						//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
						//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, index);		
						//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, Lwpns.spr(q)->getUID());		
						//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, ri->lwpn);	
						ri->lwpn = w->getUID();
						if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, w->getUID());		
					}
				}
				break;
			}
			
			case wRefFireball:
			{
				weapon *wa = (weapon*)Lwpns.spr(q);
				if ( wa->Dead() ) break;
				if ( Lwpns.spr(q)->doscript && Lwpns.spr(q)->weaponscript > 0 && wa->ScriptGenerated ) 
				{
					weapon *w = (weapon*)Lwpns.spr(q);
					if ( w->Dead() )
					{
						Lwpns.spr(q)->doscript = 0;
						Lwpns.spr(q)->weaponscript = 0;
						break;
					}
					else
					{
						//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
						//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, index);		
						//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, Lwpns.spr(q)->getUID());		
						//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, ri->lwpn);	
						ri->lwpn = w->getUID();
						if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, w->getUID());		
					}
				}
				break;
			}
			case wScript1:
			case wScript2:
			case wScript3:
			case wScript4:
			case wScript5:
			case wScript6:
			case wScript7:
			case wScript8:
			case wScript9:
			case wScript10:
			{
				weapon *wa = (weapon*)Lwpns.spr(q);
				//if ( wa->Dead() ) break;
				if ( Lwpns.spr(q)->doscript && Lwpns.spr(q)->weaponscript > 0 ) 
				{
					weapon *w = (weapon*)Lwpns.spr(q);
					if ( w->Dead() )
					{
						Lwpns.spr(q)->doscript = 0;
						Lwpns.spr(q)->weaponscript = 0;
						break;
					}
					else
					{
						//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
						//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, index);		
						//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, Lwpns.spr(q)->getUID());		
						//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, ri->lwpn);	
						ri->lwpn = w->getUID();
						if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, w->getUID());		
					}
				}
				break;
			}
			default: break;
		}
	}
}


bool FFScript::itemScriptEngine()
{
	if ( FFCore.system_suspend[susptITEMSCRIPTENGINE] ) return false;
	//zprint("Trying to check if an %s is running.\n","item script");
	for ( int q = 0; q < 256; q++ )
	{
		
		//zprint("Checking item ID: %d\n",q);
		if ( itemsbuf[q].script == 0 ) continue;
		if ( item_doscript[q] < 1 ) continue;
		//zprint("Running ItemScriptEngine() for item ID: %dn", q);
		/*! What happens here: When an item script is first run by the user using that utem, the script runs for one frame.
			After executing RunScript(), item_doscript is set to '1' in Link.cpp.
			If the quest allows the item to continue running, the itemScriptEngine() function ignores running the
			  same item script (again) that frame, and insteads increments item_doscript to '2'.
			If item_doscript == 2, then we know we are on the second frame, and we run it perpetually.
			If the QR to enable item scripts to run for more than one frame is not enabled, then item_doscript is set to '0'.
			If the item flag 'PERPETUAL SCRIPT' is enabled, then we ignore the lack of item_doscript==2.
			  This allows passive item scripts to function. 
		*/
		switch(item_doscript[q])
		{
			case 3:
			{
				if ( (get_bit(quest_rules, qr_ITEMSCRIPTSKEEPRUNNING)) ) 
				{
					item_doscript[q] = 2;
					continue;
				}
				else 
				{
					ZScriptVersion::RunScript(SCRIPT_ITEM, itemsbuf[q].script, q & 0xFFF);
					item_doscript[q] = 0;
				}
				break;
			}
			case 2:
			{
				break;
				
			}
			case 1:
			{
				
				if ( !get_bit(quest_rules, qr_ITEMSCRIPTSKEEPRUNNING) ) 
				{
					item_doscript[q] = 0;
					itemScriptData[q].Clear();
					FFScript::deallocateAllArrays(SCRIPT_ITEM, q);
					break;
				}
				//else 
				//{	
				//	item_doscript[q] = 2;
					//goto SKIPITEM; //the script ran one time this frame, from Link.cpp.
				//}
				break;
			}
			case 4: //Item set itself false, kill script and clear data here
			{
				item_doscript[q] = 0;
				itemScriptData[q].Clear();
				FFScript::deallocateAllArrays(SCRIPT_ITEM, q);
				//fall-through
			}
			case 0:
			{
				itemscriptInitialised[q] = 0;
				break;
			}
			
			
		}
		
		if ( (item_doscript[q] > 1) || ( (itemsbuf[q].flags&ITEM_FLAG16) && game->item[q] && (get_bit(quest_rules, qr_ITEMSCRIPTSKEEPRUNNING)) ) )
		{
			//zprint("ItemScriptEngine() reached a point to call RunScript for item id: %d\n",q);
			ZScriptVersion::RunScript(SCRIPT_ITEM, itemsbuf[q].script, q&0xFFF);
			continue;
			
		}
		else if ( item_doscript[q] == 1 )
		{
			if ( get_bit(quest_rules, qr_ITEMSCRIPTSKEEPRUNNING) )
			{
				item_doscript[q] = 2;
				//get ready for second frame
				
			}
		}
		
		if(item_doscript[q]==4)  //Item set itself false, kill script and clear data here
		{
			item_doscript[q] = 0;
			itemScriptData[q].Clear();
			itemscriptInitialised[q] = 0;
		}
		//SKIPITEM:
		//if ( ( item_doscript[q] == 3 ) )
		//{
		//	if ( (get_bit(quest_rules, qr_ITEMSCRIPTSKEEPRUNNING)) ) item_doscript[q] = 2;
		//	else 
		//	{
		//		ZScriptVersion::RunScript(SCRIPT_ITEM, itemsbuf[q].script, q & 0xFFF);
		//		item_doscript[q] = 0;
		//	}
		//}
		//if ( ( item_doscript[q] > 1)  || ( (itemsbuf[q].flags&ITEM_FLAG16) && game->item[q] && (get_bit(quest_rules, qr_ITEMSCRIPTSKEEPRUNNING)) ) )
		//Is this needed? If the user selects perpetual script, then should that not override the QR? Hmm. IDK. -Z 16th June, 2019 
		//{
		//	ZScriptVersion::RunScript(SCRIPT_ITEM, itemsbuf[q].script, q & 0xFFF);
		//}
		//else if ( item_doscript[q] == 1 )
		//{
		//	if ( !get_bit(quest_rules, qr_ITEMSCRIPTSKEEPRUNNING) ) 
		//	{
		//		item_doscript[q] = 0;
		//	}
		//	else item_doscript[q] = 2;
		//}
		//if ( runningItemScripts[i] == 1 )
		//{
			//zprint("Found a script running on item ID: %d\n",q);
			//ZScriptVersion::RunScript(SCRIPT_ITEM, itemsbuf[i].script);
			//ZScriptVersion::RunScript(SCRIPT_ITEM, itemsbuf[i].script, i);
			//zprint("Script Detected for that item is: %d\n",itemsbuf[q].script);
			
			////if ( runningItemScripts[q] == 1 || ( /*PASSIVE ITEM THAT ALWAYS RUNS*/ ((itemsbuf[q].flags&ITEM_FLAG16) && game->item[q])) )
			////{
			////	if ( get_bit(quest_rules,qr_ITEMSCRIPTSKEEPRUNNING) )
			////	{
			////		ZScriptVersion::RunScript(SCRIPT_ITEM, itemsbuf[q].script, q & 0xFFF);
			////	}
			////	else //if the QR isn't set, treat Waitframe as Quit()
			////	{
			////		runningItemScripts[q] = 0;
			////	}
			////}
		if ( runningItemScripts[q] == 3 ) //forced to run perpetually by itemdata->RunScript(int mode)
		{
			zprint("The item script is still running because it was forced by %s\n","itemdata->RunScript(true)");
			//ZScriptVersion::RunScript(SCRIPT_ITEM, itemsbuf[q].script, q & 0xFFF);
		}
		//}
			
	}
	
	return false;
}

void FFScript::npcScriptEngineOnWaitdraw()
{
	if ( FFCore.system_suspend[susptNPCSCRIPTS] ) return;
	for ( int q = 0; q < guys.Count(); q++ )
	{
		
		enemy *wp = (enemy*)guys.spr(q);
		//zprint("waitdraw is: %d\n", (wp->waitdraw));
		//zprint("wp->doscript is: %d\n", wp->waitdraw);
		//Lwpns.spr(LwpnH::getLWeaponIndex(i))->waitdraw = 1;
		if ( wp->doscript && wp->waitdraw ) 
		{
			//zprint("Running npc script on waitdraw.\n");
			if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_NPC, guys.spr(q)->script, wp->getUID());		
			wp->waitdraw = 0;
		}
		
	}
}

bool FFScript::itemScriptEngineOnWaitdraw()
{
	if ( FFCore.system_suspend[susptITEMSCRIPTENGINE] ) return false;
	//zprint("Trying to check if an %s is running.\n","item script");
	for ( int q = 0; q < 256; q++ )
	{
		//zprint("Checking item ID: %d\n",q);
		if ( itemsbuf[q].script == 0 ) continue;
		if ( item_doscript[q] < 1 ) continue;
		if ( !itemScriptsWaitdraw[q] ) continue;
		else itemScriptsWaitdraw[q] = 0;
		switch(item_doscript[q])
		{
			case 3:
			{
				if ( (get_bit(quest_rules, qr_ITEMSCRIPTSKEEPRUNNING)) ) 
				{
					item_doscript[q] = 2;
					continue;
				}
				else 
				{
					ZScriptVersion::RunScript(SCRIPT_ITEM, itemsbuf[q].script, q & 0xFFF);
					item_doscript[q] = 0;
				}
				break;
			}
			case 2:
			{
				break;
				
			}
			case 1:
			{
				
				if ( !get_bit(quest_rules, qr_ITEMSCRIPTSKEEPRUNNING) ) 
				{
					item_doscript[q] = 0;
					break;
				}
				//else 
				//{	
				//	item_doscript[q] = 2;
					//goto SKIPITEM; //the script ran one time this frame, from Link.cpp.
				//}
				break;
			}
			case 0:
			{
				itemscriptInitialised[q] = 0;
				break;
			}
			
			
		}
		
		if ( (item_doscript[q] > 1) || ( (itemsbuf[q].flags&ITEM_FLAG16) && game->item[q] && (get_bit(quest_rules, qr_ITEMSCRIPTSKEEPRUNNING)) ) )
		{
			//zprint("ItemScriptEngine() reached a point to call RunScript for item id: %d\n",q);
			ZScriptVersion::RunScript(SCRIPT_ITEM, itemsbuf[q].script, q&0xFFF);
			continue;
			
		}
		else if ( item_doscript[q] == 1 )
		{
			if ( get_bit(quest_rules, qr_ITEMSCRIPTSKEEPRUNNING) )
			{
				item_doscript[q] = 2;
				//get ready for second frame
				
			}
		}
			
		if ( runningItemScripts[q] == 3 ) //forced to run perpetually by itemdata->RunScript(int mode)
		{
			zprint("The item script is still running because it was forced by %s\n","itemdata->RunScript(true)");
			//ZScriptVersion::RunScript(SCRIPT_ITEM, itemsbuf[q].script, q & 0xFFF);
		}
		//itemScriptsWaitdraw[q] = 0; THis is the wrong place, so I moved it into an else stmt at the top of this function's body. -Z
		
	}
	
	return false;
}

void FFScript::eweaponScriptEngine()
{
	if ( FFCore.system_suspend[susptEWEAPONSCRIPTS] ) return;
	for ( int q = 0; q < Ewpns.Count(); q++ )
	{
		//ri->ewpn = Ewpns.spr(q)->getUID();
		//zprint("lweaponScriptEngine(): UID (%d) ri->ewpn (%d)\n", Ewpns.spr(q)->getUID(), ri->ewpn);
		//ri->ewpn = Ewpns.spr(q)->getUID();
		weapon *wp = (weapon*)Ewpns.spr(q);
		if ( wp->isLWeapon ) continue;
		//if ( wp->Dead() ) continue;
		//if ( Ewpns.spr(q)->weaponscript == 0 ) continue;
		//if ( Ewpns.spr(q)->doscript == 0 ) continue;
		if ( wp->doscript ) if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, wp->getUID());		
				
		/*
		switch(Ewpns.spr(q)->id)
		{
			case ewSword:
			{
			weapon *wa = (weapon*)Ewpns.spr(q);
			if ( wa->Dead() ) break;
			if ( Ewpns.spr(q)->doscript && Ewpns.spr(q)->weaponscript > 0 ) 
			{
				weapon *w = (weapon*)Ewpns.spr(q);
				if ( w->Dead() )
				{
					Ewpns.spr(q)->doscript = 0;
					Ewpns.spr(q)->weaponscript = 0;
					//memset(w->stack, 0xFFFF, sizeof(w->stack));
					break;
				}
				else
				{
					//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, index);		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, Ewpns.spr(q)->getUID());		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, ri->ewpn);		
					ri->ewpn = w->getUID();
					if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, w->getUID());		
				}
			}
			break;
			}
		
			
			case ewFlame:
			{
			weapon *wa = (weapon*)Ewpns.spr(q);
			if ( wa->Dead() ) break;
			if ( Ewpns.spr(q)->doscript && Ewpns.spr(q)->weaponscript > 0 ) 
			{
				weapon *w = (weapon*)Ewpns.spr(q);
				if ( w->Dead() )
				{
					Ewpns.spr(q)->doscript = 0;
					Ewpns.spr(q)->weaponscript = 0;
					break;
				}
				else
				{
					//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, index);		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, ri->ewpn);
					if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, w->getUID());
					ri->ewpn = w->getUID();
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, Ewpns.spr(q)->getUID());		
				}
			}
			break;
			}
			
			
			case ewSBomb:
			case ewBomb:
			{
			weapon *wa = (weapon*)Ewpns.spr(q);
			if ( wa->Dead() ) break;
			if ( Ewpns.spr(q)->doscript && Ewpns.spr(q)->weaponscript > 0 ) 
			{
				weapon *w = (weapon*)Ewpns.spr(q);
				if ( w->Dead() )
				{
					Ewpns.spr(q)->doscript = 0;
					Ewpns.spr(q)->weaponscript = 0;
					break;
				}
				else
				{
					//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, index);		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, ri->ewpn);
					if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, w->getUID());
					ri->ewpn = w->getUID();
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, Ewpns.spr(q)->getUID());		
				}
			}
			break;
			}
			
			case ewLitBomb:
			case ewLitSBomb:
			{
			weapon *wa = (weapon*)Ewpns.spr(q);
			if ( wa->Dead() ) break;
			if ( Ewpns.spr(q)->doscript && Ewpns.spr(q)->weaponscript > 0 ) 
			{
				weapon *w = (weapon*)Ewpns.spr(q);
				if ( w->Dead() )
				{
					Ewpns.spr(q)->doscript = 0;
					Ewpns.spr(q)->weaponscript = 0;
					break;
				}
				else
				{
					//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, index);		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, ri->ewpn);
					if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, w->getUID());
					ri->ewpn = w->getUID();
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, Ewpns.spr(q)->getUID());		
				}
			}
			break;
			}
			
			case ewArrow:
			{
			weapon *wa = (weapon*)Ewpns.spr(q);
			if ( wa->Dead() ) break;
			if ( Ewpns.spr(q)->doscript && Ewpns.spr(q)->weaponscript > 0 ) 
			{
				weapon *w = (weapon*)Ewpns.spr(q);
				if ( w->Dead() )
				{
					Ewpns.spr(q)->doscript = 0;
					Ewpns.spr(q)->weaponscript = 0;
					break;
				}
				else
				{
					//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, index);		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, Ewpns.spr(q)->getUID());		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, ri->ewpn);	
					ri->ewpn = w->getUID();					
					if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, w->getUID());		
				}
			}
			
			break;
			}
			
			case ewRock:
			{
			weapon *wa = (weapon*)Ewpns.spr(q);
			if ( wa->Dead() ) break;
			if ( Ewpns.spr(q)->doscript && Ewpns.spr(q)->weaponscript > 0 ) 
			{
				weapon *w = (weapon*)Ewpns.spr(q);
				if ( w->Dead() )
				{
					Ewpns.spr(q)->doscript = 0;
					Ewpns.spr(q)->weaponscript = 0;
					break;
				}
				else
				{
					//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, index);		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, Ewpns.spr(q)->getUID());		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, ri->ewpn);	
					ri->ewpn = w->getUID();
					if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, w->getUID());		
				}
			}
			break;
			}
			case ewBrang:
			{
			weapon *wa = (weapon*)Ewpns.spr(q);
			if ( wa->Dead() ) break;
			if ( Ewpns.spr(q)->doscript && Ewpns.spr(q)->weaponscript > 0 ) 
			{
				weapon *w = (weapon*)Ewpns.spr(q);
				if ( w->Dead() )
				{
					Ewpns.spr(q)->doscript = 0;
					Ewpns.spr(q)->weaponscript = 0;
					break;
				}
				else
				{
					//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, index);		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, Ewpns.spr(q)->getUID());		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, ri->ewpn);		
					ri->ewpn = w->getUID();
					if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, w->getUID());		
				}
			}
		
			
			break;
			}
			
			case ewMagic:
			{
			//:Weapon Only
			if ( Ewpns.spr(q)->doscript && Ewpns.spr(q)->weaponscript > 0 ) 
			{
				weapon *w = (weapon*)Ewpns.spr(q);
				if ( w->Dead() )
				{
					Ewpns.spr(q)->doscript = 0;
					Ewpns.spr(q)->weaponscript = 0;
					break;
				}
				else
				{
					//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, index);		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, Ewpns.spr(q)->getUID());		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, ri->ewpn);	
					ri->ewpn = w->getUID();
					if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, w->getUID());		
				}
			}
			break;
			}
			
			case ewFireball:
			case ewFireball2:
			{
			weapon *wa = (weapon*)Ewpns.spr(q);
			if ( wa->Dead() ) break;
			if ( Ewpns.spr(q)->doscript && Ewpns.spr(q)->weaponscript > 0 ) 
			{
				weapon *w = (weapon*)Ewpns.spr(q);
				if ( w->Dead() )
				{
					Ewpns.spr(q)->doscript = 0;
					Ewpns.spr(q)->weaponscript = 0;
					break;
				}
				else
				{
					//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, index);		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, Ewpns.spr(q)->getUID());		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, ri->ewpn);	
					ri->ewpn = w->getUID();
					if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, w->getUID());		
				}
			}
			break;
			}
			
			case ewFireTrail:
			{
			weapon *wa = (weapon*)Ewpns.spr(q);
			if ( wa->Dead() ) break;
			if ( Ewpns.spr(q)->doscript && Ewpns.spr(q)->weaponscript > 0 ) 
			{
				weapon *w = (weapon*)Ewpns.spr(q);
				if ( w->Dead() )
				{
					Ewpns.spr(q)->doscript = 0;
					Ewpns.spr(q)->weaponscript = 0;
					break;
				}
				else
				{
					//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, index);		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, Ewpns.spr(q)->getUID());		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, ri->ewpn);	
					ri->ewpn = w->getUID();
					if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, w->getUID());		
				}
			}
			break;
			}
			case ewWind:
			{
			weapon *wa = (weapon*)Ewpns.spr(q);
			if ( wa->Dead() ) break;
			if ( Ewpns.spr(q)->doscript && Ewpns.spr(q)->weaponscript > 0 ) 
			{
				weapon *w = (weapon*)Ewpns.spr(q);
				if ( w->Dead() )
				{
					Ewpns.spr(q)->doscript = 0;
					Ewpns.spr(q)->weaponscript = 0;
					break;
				}
				else
				{
					//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, index);		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, Ewpns.spr(q)->getUID());		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, ri->ewpn);	
					ri->ewpn = w->getUID();
					if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, w->getUID());		
				}
			}
			break;
			} 
			case ewFlame2:
			{
			weapon *wa = (weapon*)Ewpns.spr(q);
			if ( wa->Dead() ) break;
			if ( Ewpns.spr(q)->doscript && Ewpns.spr(q)->weaponscript > 0 ) 
			{
				weapon *w = (weapon*)Ewpns.spr(q);
				if ( w->Dead() )
				{
					Ewpns.spr(q)->doscript = 0;
					Ewpns.spr(q)->weaponscript = 0;
					break;
				}
				else
				{
					//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, index);		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, Ewpns.spr(q)->getUID());		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, ri->ewpn);	
					ri->ewpn = w->getUID();
					if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, w->getUID());		
				}
			}
			break;
			} 
			case ewFlame2Trail:
			{
			weapon *wa = (weapon*)Ewpns.spr(q);
			if ( wa->Dead() ) break;
			if ( Ewpns.spr(q)->doscript && Ewpns.spr(q)->weaponscript > 0 ) 
			{
				weapon *w = (weapon*)Ewpns.spr(q);
				if ( w->Dead() )
				{
					Ewpns.spr(q)->doscript = 0;
					Ewpns.spr(q)->weaponscript = 0;
					break;
				}
				else
				{
					//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, index);		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, Ewpns.spr(q)->getUID());		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, ri->ewpn);	
					ri->ewpn = w->getUID();
					if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, w->getUID());		
				}
			}
			break;
			}
			
			case ewIce:
			{
			weapon *wa = (weapon*)Ewpns.spr(q);
			if ( wa->Dead() ) break;
			if ( Ewpns.spr(q)->doscript && Ewpns.spr(q)->weaponscript > 0 ) 
			{
				weapon *w = (weapon*)Ewpns.spr(q);
				if ( w->Dead() )
				{
					Ewpns.spr(q)->doscript = 0;
					Ewpns.spr(q)->weaponscript = 0;
					break;
				}
				else
				{
					//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, index);		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, Ewpns.spr(q)->getUID());		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, ri->ewpn);	
					ri->ewpn = w->getUID();
					if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, w->getUID());		
				}
			}
			break;
			}
			case wScript1:
			case wScript2:
			case wScript3:
			case wScript4:
			case wScript5:
			case wScript6:
			case wScript7:
			case wScript8:
			case wScript9:
			case wScript10:
			{
			weapon *wa = (weapon*)Ewpns.spr(q);
			//if ( wa->Dead() ) break;
			if ( Ewpns.spr(q)->doscript && Ewpns.spr(q)->weaponscript > 0 ) 
			{
				weapon *w = (weapon*)Ewpns.spr(q);
				if ( w->Dead() )
				{
					Ewpns.spr(q)->doscript = 0;
					Ewpns.spr(q)->weaponscript = 0;
					break;
				}
				else
				{
					//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, index);		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, Ewpns.spr(q)->getUID());		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, ri->ewpn);	
					ri->ewpn = w->getUID();
					if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, w->getUID());		
				}
			}
			break;
			}
			default: break;
		}
		*/
	}
}

void FFScript::lweaponScriptEngineOnWaitdraw()
{
	if ( FFCore.system_suspend[susptLWEAPONSCRIPTS] ) return;
	for ( int q = 0; q < Lwpns.Count(); q++ )
	{
		//ri->ewpn = Ewpns.spr(q)->getUID();
		//zprint("lweaponScriptEngine(): UID (%d) ri->ewpn (%d)\n", Ewpns.spr(q)->getUID(), ri->ewpn);
		//ri->ewpn = Ewpns.spr(q)->getUID();
		weapon *wp = (weapon*)Lwpns.spr(q);
		if ( !wp->isLWeapon ) continue;
		//if ( wp->Dead() ) continue;
		//if ( Ewpns.spr(q)->weaponscript == 0 ) continue;
		//if ( Ewpns.spr(q)->doscript == 0 ) continue;
		if ( wp->doscript && wp->waitdraw ) 
		{
			if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_LWPN, Lwpns.spr(q)->weaponscript, wp->getUID());		
			wp->waitdraw = 0;
		}
		
	}
}

void FFScript::eweaponScriptEngineOnWaitdraw()
{
	if ( FFCore.system_suspend[susptEWEAPONSCRIPTS] ) return;
	for ( int q = 0; q < Ewpns.Count(); q++ )
	{
		//ri->ewpn = Ewpns.spr(q)->getUID();
		//zprint("lweaponScriptEngine(): UID (%d) ri->ewpn (%d)\n", Ewpns.spr(q)->getUID(), ri->ewpn);
		//ri->ewpn = Ewpns.spr(q)->getUID();
		weapon *wp = (weapon*)Ewpns.spr(q);
		if ( wp->isLWeapon ) continue;
		//if ( wp->Dead() ) continue;
		//if ( Ewpns.spr(q)->weaponscript == 0 ) continue;
		//if ( Ewpns.spr(q)->doscript == 0 ) continue;
		if ( wp->doscript && wp->waitdraw ) 
		{
			if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, wp->getUID());		
			wp->waitdraw = 0;
		}
		/*
		switch(Ewpns.spr(q)->id)
		{
			case ewSword:
			{
			weapon *wa = (weapon*)Ewpns.spr(q);
			if ( wa->Dead() ) break;
			if ( Ewpns.spr(q)->doscript && Ewpns.spr(q)->weaponscript > 0 ) 
			{
				weapon *w = (weapon*)Ewpns.spr(q);
				if ( w->Dead() )
				{
					Ewpns.spr(q)->doscript = 0;
					Ewpns.spr(q)->weaponscript = 0;
					//memset(w->stack, 0xFFFF, sizeof(w->stack));
					break;
				}
				else
				{
					//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, index);		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, Ewpns.spr(q)->getUID());		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, ri->ewpn);		
					ri->ewpn = w->getUID();
					if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, w->getUID());		
				}
			}
			break;
			}
		
			
			case ewFlame:
			{
			weapon *wa = (weapon*)Ewpns.spr(q);
			if ( wa->Dead() ) break;
			if ( Ewpns.spr(q)->doscript && Ewpns.spr(q)->weaponscript > 0 ) 
			{
				weapon *w = (weapon*)Ewpns.spr(q);
				if ( w->Dead() )
				{
					Ewpns.spr(q)->doscript = 0;
					Ewpns.spr(q)->weaponscript = 0;
					break;
				}
				else
				{
					//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, index);		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, ri->ewpn);
					if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, w->getUID());
					ri->ewpn = w->getUID();
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, Ewpns.spr(q)->getUID());		
				}
			}
			break;
			}
			
			
			case ewSBomb:
			case ewBomb:
			{
			weapon *wa = (weapon*)Ewpns.spr(q);
			if ( wa->Dead() ) break;
			if ( Ewpns.spr(q)->doscript && Ewpns.spr(q)->weaponscript > 0 ) 
			{
				weapon *w = (weapon*)Ewpns.spr(q);
				if ( w->Dead() )
				{
					Ewpns.spr(q)->doscript = 0;
					Ewpns.spr(q)->weaponscript = 0;
					break;
				}
				else
				{
					//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, index);		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, ri->ewpn);
					if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, w->getUID());
					ri->ewpn = w->getUID();
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, Ewpns.spr(q)->getUID());		
				}
			}
			break;
			}
			
			case ewLitBomb:
			case ewLitSBomb:
			{
			weapon *wa = (weapon*)Ewpns.spr(q);
			if ( wa->Dead() ) break;
			if ( Ewpns.spr(q)->doscript && Ewpns.spr(q)->weaponscript > 0 ) 
			{
				weapon *w = (weapon*)Ewpns.spr(q);
				if ( w->Dead() )
				{
					Ewpns.spr(q)->doscript = 0;
					Ewpns.spr(q)->weaponscript = 0;
					break;
				}
				else
				{
					//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, index);		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, ri->ewpn);
					if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, w->getUID());
					ri->ewpn = w->getUID();
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, Ewpns.spr(q)->getUID());		
				}
			}
			break;
			}
			
			case ewArrow:
			{
			weapon *wa = (weapon*)Ewpns.spr(q);
			if ( wa->Dead() ) break;
			if ( Ewpns.spr(q)->doscript && Ewpns.spr(q)->weaponscript > 0 ) 
			{
				weapon *w = (weapon*)Ewpns.spr(q);
				if ( w->Dead() )
				{
					Ewpns.spr(q)->doscript = 0;
					Ewpns.spr(q)->weaponscript = 0;
					break;
				}
				else
				{
					//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, index);		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, Ewpns.spr(q)->getUID());		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, ri->ewpn);	
					ri->ewpn = w->getUID();					
					if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, w->getUID());		
				}
			}
			
			break;
			}
			
			case ewRock:
			{
			weapon *wa = (weapon*)Ewpns.spr(q);
			if ( wa->Dead() ) break;
			if ( Ewpns.spr(q)->doscript && Ewpns.spr(q)->weaponscript > 0 ) 
			{
				weapon *w = (weapon*)Ewpns.spr(q);
				if ( w->Dead() )
				{
					Ewpns.spr(q)->doscript = 0;
					Ewpns.spr(q)->weaponscript = 0;
					break;
				}
				else
				{
					//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, index);		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, Ewpns.spr(q)->getUID());		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, ri->ewpn);	
					ri->ewpn = w->getUID();
					if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, w->getUID());		
				}
			}
			break;
			}
			case ewBrang:
			{
			weapon *wa = (weapon*)Ewpns.spr(q);
			if ( wa->Dead() ) break;
			if ( Ewpns.spr(q)->doscript && Ewpns.spr(q)->weaponscript > 0 ) 
			{
				weapon *w = (weapon*)Ewpns.spr(q);
				if ( w->Dead() )
				{
					Ewpns.spr(q)->doscript = 0;
					Ewpns.spr(q)->weaponscript = 0;
					break;
				}
				else
				{
					//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, index);		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, Ewpns.spr(q)->getUID());		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, ri->ewpn);		
					ri->ewpn = w->getUID();
					if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, w->getUID());		
				}
			}
		
			
			break;
			}
			
			case ewMagic:
			{
			//:Weapon Only
			if ( Ewpns.spr(q)->doscript && Ewpns.spr(q)->weaponscript > 0 ) 
			{
				weapon *w = (weapon*)Ewpns.spr(q);
				if ( w->Dead() )
				{
					Ewpns.spr(q)->doscript = 0;
					Ewpns.spr(q)->weaponscript = 0;
					break;
				}
				else
				{
					//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, index);		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, Ewpns.spr(q)->getUID());		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, ri->ewpn);	
					ri->ewpn = w->getUID();
					if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, w->getUID());		
				}
			}
			break;
			}
			
			case ewFireball:
			case ewFireball2:
			{
			weapon *wa = (weapon*)Ewpns.spr(q);
			if ( wa->Dead() ) break;
			if ( Ewpns.spr(q)->doscript && Ewpns.spr(q)->weaponscript > 0 ) 
			{
				weapon *w = (weapon*)Ewpns.spr(q);
				if ( w->Dead() )
				{
					Ewpns.spr(q)->doscript = 0;
					Ewpns.spr(q)->weaponscript = 0;
					break;
				}
				else
				{
					//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, index);		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, Ewpns.spr(q)->getUID());		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, ri->ewpn);	
					ri->ewpn = w->getUID();
					if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, w->getUID());		
				}
			}
			break;
			}
			
			case ewFireTrail:
			{
			weapon *wa = (weapon*)Ewpns.spr(q);
			if ( wa->Dead() ) break;
			if ( Ewpns.spr(q)->doscript && Ewpns.spr(q)->weaponscript > 0 ) 
			{
				weapon *w = (weapon*)Ewpns.spr(q);
				if ( w->Dead() )
				{
					Ewpns.spr(q)->doscript = 0;
					Ewpns.spr(q)->weaponscript = 0;
					break;
				}
				else
				{
					//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, index);		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, Ewpns.spr(q)->getUID());		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, ri->ewpn);	
					ri->ewpn = w->getUID();
					if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, w->getUID());		
				}
			}
			break;
			}
			case ewWind:
			{
			weapon *wa = (weapon*)Ewpns.spr(q);
			if ( wa->Dead() ) break;
			if ( Ewpns.spr(q)->doscript && Ewpns.spr(q)->weaponscript > 0 ) 
			{
				weapon *w = (weapon*)Ewpns.spr(q);
				if ( w->Dead() )
				{
					Ewpns.spr(q)->doscript = 0;
					Ewpns.spr(q)->weaponscript = 0;
					break;
				}
				else
				{
					//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, index);		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, Ewpns.spr(q)->getUID());		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, ri->ewpn);	
					ri->ewpn = w->getUID();
					if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, w->getUID());		
				}
			}
			break;
			} 
			case ewFlame2:
			{
			weapon *wa = (weapon*)Ewpns.spr(q);
			if ( wa->Dead() ) break;
			if ( Ewpns.spr(q)->doscript && Ewpns.spr(q)->weaponscript > 0 ) 
			{
				weapon *w = (weapon*)Ewpns.spr(q);
				if ( w->Dead() )
				{
					Ewpns.spr(q)->doscript = 0;
					Ewpns.spr(q)->weaponscript = 0;
					break;
				}
				else
				{
					//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, index);		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, Ewpns.spr(q)->getUID());		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, ri->ewpn);	
					ri->ewpn = w->getUID();
					if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, w->getUID());		
				}
			}
			break;
			} 
			case ewFlame2Trail:
			{
			weapon *wa = (weapon*)Ewpns.spr(q);
			if ( wa->Dead() ) break;
			if ( Ewpns.spr(q)->doscript && Ewpns.spr(q)->weaponscript > 0 ) 
			{
				weapon *w = (weapon*)Ewpns.spr(q);
				if ( w->Dead() )
				{
					Ewpns.spr(q)->doscript = 0;
					Ewpns.spr(q)->weaponscript = 0;
					break;
				}
				else
				{
					//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, index);		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, Ewpns.spr(q)->getUID());		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, ri->ewpn);	
					ri->ewpn = w->getUID();
					if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, w->getUID());		
				}
			}
			break;
			}
			
			case ewIce:
			{
			weapon *wa = (weapon*)Ewpns.spr(q);
			if ( wa->Dead() ) break;
			if ( Ewpns.spr(q)->doscript && Ewpns.spr(q)->weaponscript > 0 ) 
			{
				weapon *w = (weapon*)Ewpns.spr(q);
				if ( w->Dead() )
				{
					Ewpns.spr(q)->doscript = 0;
					Ewpns.spr(q)->weaponscript = 0;
					break;
				}
				else
				{
					//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, index);		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, Ewpns.spr(q)->getUID());		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, ri->ewpn);	
					ri->ewpn = w->getUID();
					if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, w->getUID());		
				}
			}
			break;
			}
			case wScript1:
			case wScript2:
			case wScript3:
			case wScript4:
			case wScript5:
			case wScript6:
			case wScript7:
			case wScript8:
			case wScript9:
			case wScript10:
			{
			weapon *wa = (weapon*)Ewpns.spr(q);
			//if ( wa->Dead() ) break;
			if ( Ewpns.spr(q)->doscript && Ewpns.spr(q)->weaponscript > 0 ) 
			{
				weapon *w = (weapon*)Ewpns.spr(q);
				if ( w->Dead() )
				{
					Ewpns.spr(q)->doscript = 0;
					Ewpns.spr(q)->weaponscript = 0;
					break;
				}
				else
				{
					//al_trace("Found an lweapon index of: %d, when trying to run an lweapon script.\n",w_index);
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, index);		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, Ewpns.spr(q)->getUID());		
					//if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, ri->ewpn);	
					ri->ewpn = w->getUID();
					if ( FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_EWPN, Ewpns.spr(q)->weaponscript, w->getUID());		
				}
			}
			break;
			}
			default: break;
		}
		*/
	}
}

void FFScript::itemSpriteScriptEngine()
{
	if ( FFCore.system_suspend[susptITEMSPRITESCRIPTS] ) return;
	for ( int q = 0; q < items.Count(); q++ )
	{
		item *wp = (item*)items.spr(q);
		if ( wp->script == 0 ) continue;
		if ( wp->doscript && FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) ZScriptVersion::RunScript(SCRIPT_ITEMSPRITE, items.spr(q)->script, wp->getUID());		
	}
}

void FFScript::itemSpriteScriptEngineOnWaitdraw()
{
	if ( FFCore.system_suspend[susptITEMSPRITESCRIPTS] ) return;
	for ( int q = 0; q < items.Count(); q++ )
	{
		
		item *wp = (item*)items.spr(q);

		if ( wp->waitdraw && wp->doscript && wp->script && FFCore.getQuestHeaderInfo(vZelda) >= 0x255 ) 
		{
			ZScriptVersion::RunScript(SCRIPT_ITEMSPRITE, items.spr(q)->script, wp->getUID());
			wp->waitdraw = 0;
		}			
	}
}


int FFScript::getTime(int type)
{
	//struct tm *tm_struct = localtime(time(NULL));
	struct tm * tm_struct;
	time_t sysRTC;
	time (&sysRTC);
	tm_struct = localtime (&sysRTC);
	int rval = -1;
	
	switch(type)
	{
		case curyear:
		{
			//Year format starts at 1900, yeat
			//A raw read of '2018' would be '118', so we add 1900 to it to derive the actual year. 
			rval = tm_struct->tm_year + 1900; break;
			
		}
		case curmonth:
		{
			//Months start at 0, but we want 1->12
			//al_trace("The current month is: %d\n",month);
			rval = tm_struct->tm_mon +1; break;
		}
		case curday_month:
		{
			rval = tm_struct->tm_mday; break;
		}
		case curday_week: 
		{
			//It seems that weekdays are a value range of 1 to 7.
			rval = tm_struct->tm_wday; break;
		}
		case curhour:
		{
			rval = tm_struct->tm_hour; break;
		}
		case curminute: 
		{
			rval = tm_struct->tm_min; break;
		}
		case cursecond:
		{
			rval = tm_struct->tm_sec; break;
		}
		case curdayyear:
		{
			//The day (n/365) out of the entire year. 
			rval = tm_struct->tm_yday; break;
		}
		case curDST:
		{
			//Returns if the user is in a Time Zone with Daylight TIme of some sort. 
			//View the time.h docs for the actual values of this struct element.
			rval = tm_struct->tm_isdst;; break;
		}
		default: 
		{
			al_trace("Invalid category passed to GetSystemTime(%d)\n",type);
			rval = -1;  break;
		}
		
	}
	return rval;
}

void FFScript::do_isdeadnpc()
{
	//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
	if(GuyH::loadNPC(ri->guyref, "npc->isDead") == SH::_NoError)
	{
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		//int dead = (int)e->Dead(GuyH::getNPCIndex(ri->guyref));
		//GuyH::getNPC()->Dead(GuyH::getNPCIndex(ri->guyref));
		set_register(sarg1, ((GuyH::getNPC()->Dead(GuyH::getNPCIndex(ri->guyref))) ? 10000 : 0));
	}
	else set_register(sarg1, -10000);
}


void FFScript::do_canslidenpc()
{
	
	if(GuyH::loadNPC(ri->guyref, "npc->CanSlide") == SH::_NoError)
	{
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		//bool candoit = e->can_slide();
		set_register(sarg1, ((GuyH::getNPC()->can_slide()) ? 10000 : 0));
	}
	else set_register(sarg1, -10000);
}

void FFScript::do_slidenpc()
{
	
	if(GuyH::loadNPC(ri->guyref, "npc->Slide()") == SH::_NoError)
	{
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		//bool candoit = e->slide();
		set_register(sarg1, ((GuyH::getNPC()->slide())*10000));
	}
	else set_register(sarg1, -10000);
}

void FFScript::do_npckickbucket()
{
	if(GuyH::loadNPC(ri->guyref, "npc->Remove()") == SH::_NoError)
	{
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		//e->kickbucket();
		//GuyH::getNPC()->kickbucket();
		guys.del(GuyH::getNPCIndex(ri->guyref));
	}
}

void FFScript::do_npc_stopbgsfx()
{
	//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
	if(GuyH::loadNPC(ri->guyref, "npc->StopBGSFX()") == SH::_NoError)
	{
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		//e->stop_bgsfx(GuyH::getNPCIndex(ri->guyref));
		GuyH::getNPC()->stop_bgsfx(GuyH::getNPCIndex(ri->guyref));
	}
}

void FFScript::updateIncludePaths()
{
	memset(includePaths,0,sizeof(includePaths));
	int pos = 0; int dest = 0; int pathnumber = 0;
	for ( int q = 0; q < MAX_INCLUDE_PATHS; q++ )
	{
		while(includePathString[pos] != ';' && includePathString[pos] != '\0' )
		{
			includePaths[q][dest] = includePathString[pos];
			pos++;
			dest++;
		}
		++pos;
		dest = 0;
	}
}

void FFScript::initRunString()
{
	memset(scriptRunString,0,sizeof(scriptRunString));
	strcpy(scriptRunString,get_config_string("Compiler","run_string","run"));
}

void FFScript::initIncludePaths()
{
	memset(includePaths,0,sizeof(includePaths));
	memset(includePathString,0,sizeof(includePathString));
	strcpy(includePathString,get_config_string("Compiler","include_path","include/"));
	includePathString[((MAX_INCLUDE_PATHS+1)*512)-1] = '\0';
	al_trace("Full path string is: %s\n",includePathString);
	int pos = 0; int dest = 0; int pathnumber = 0;
	for ( int q = 0; q < MAX_INCLUDE_PATHS; q++ )
	{
		while(includePathString[pos] != ';' && includePathString[pos] != '\0' )
		{
			includePaths[q][dest] = includePathString[pos];
			pos++;
			dest++;
		}
		++pos;
		dest = 0;
	}

	for ( int q = 0; q < MAX_INCLUDE_PATHS; q++ )
		al_trace("Include path %d: %s\n",q,includePaths[q]);
}

void FFScript::do_npcattack()
{
	
	if(GuyH::loadNPC(ri->guyref, "npc->Attack()") == SH::_NoError)
	{
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		//e->FireWeapon();
		//we could just do: 
		GuyH::getNPC()->FireWeapon();
	}
}
void FFScript::do_npc_newdir()
{
	long arrayptr = get_register(sarg2) / 10000;
	int sz = FFCore.getSize(arrayptr);
	 //(FFCore.getElement(sdci[2]/10000, q))/10000;
	
	if(GuyH::loadNPC(ri->guyref, "npc->NewDir()") == SH::_NoError)
	{
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		
		if ( sz != -1 ) 
		{
			if ( sz != 3 ) 
			{
				Z_scripterrlog("Invalid array size (%d) passed to npc->VariableWalk(int arr[])\n",sz);
				return;
			}
			GuyH::getNPC()->newdir((FFCore.getElement(arrayptr, 0)/10000), (FFCore.getElement(arrayptr, 1)/10000),
				(FFCore.getElement(arrayptr, 2)/10000));
			//e->newdir( (FFCore.getElement(arrayptr, 0)/10000), (FFCore.getElement(arrayptr, 1)/10000),
			//	(FFCore.getElement(arrayptr, 2)/10000) );
		}
		//else e->newdir();
		else GuyH::getNPC()->newdir();
		
		
	}
}

void FFScript::do_npc_constwalk()
{
	long arrayptr = get_register(sarg2) / 10000;
	int sz = FFCore.getSize(arrayptr);
	//zprint("Array size passed to do_npc_constwalk: %d\n", sz);
	 //(FFCore.getElement(sdci[2]/10000, q))/10000;
	
	if(GuyH::loadNPC(ri->guyref, "npc->ConstantWalk()") == SH::_NoError)
	{
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		
		if ( sz != -1 ) 
		{
			if ( sz != 3 ) 
			{
				Z_scripterrlog("Invalid array size (%d) passed to npc->VariableWalk(int arr[])\n",sz);
				return;
			}
			//zprint("Calling npc->ConstantWalk( %d, %d, %d ).\n", (getElement(arrayptr, 0)/10000), (getElement(arrayptr, 1)/10000),
			//	(getElement(arrayptr, 2)/10000));
			GuyH::getNPC()->constant_walk( (getElement(arrayptr, 0)/10000), (getElement(arrayptr, 1)/10000),
				(getElement(arrayptr, 2)/10000) );
		}
		else GuyH::getNPC()->constant_walk();//e->constant_walk();
		
		
	}
}

void FFScript::do_npc_varwalk()
{
	long arrayptr = get_register(sarg2) / 10000;
	int sz = FFCore.getSize(arrayptr);
	 //(FFCore.getElement(sdci[2]/10000, q))/10000;
	
	if(GuyH::loadNPC(ri->guyref, "npc->VariableWalk()") == SH::_NoError)
	{
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		
		if ( sz == 3 ) 
		{
			
			GuyH::getNPC()->variable_walk( (FFCore.getElement(arrayptr, 0)/10000), (FFCore.getElement(arrayptr, 1)/10000),
				(FFCore.getElement(arrayptr, 2)/10000) );
		}
		else Z_scripterrlog("Invalid array size (%d) passed to npc->VariableWalk(int arr[])\n",sz);
		
		
	}
}

void FFScript::do_npc_varwalk8()
{
	long arrayptr = get_register(sarg2) / 10000;
	int sz = FFCore.getSize(arrayptr);
	 //(FFCore.getElement(sdci[2]/10000, q))/10000;
	//void variable_walk_8(int rate,int homing,int newclk,int special);
	// same as above but with variable enemy size
	//void variable_walk_8(int rate,int homing,int newclk,int special,int dx1,int dy1,int dx2,int dy2);
	
	
	if(GuyH::loadNPC(ri->guyref, "npc->VariableWalk8()") == SH::_NoError)
	{
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		
		if ( sz == 4 ) 
		{
			GuyH::getNPC()->variable_walk_8( (FFCore.getElement(arrayptr, 0)/10000), (FFCore.getElement(arrayptr, 1)/10000),
				(FFCore.getElement(arrayptr, 2)/10000), (FFCore.getElement(arrayptr, 3)/10000) );
		}
		else if ( sz == 8 ) 
		{
			GuyH::getNPC()->variable_walk_8( (FFCore.getElement(arrayptr, 0)/10000), (FFCore.getElement(arrayptr, 1)/10000),
				(FFCore.getElement(arrayptr, 2)/10000), (FFCore.getElement(arrayptr, 3)/10000),
				(FFCore.getElement(arrayptr, 4)/10000), (FFCore.getElement(arrayptr, 5)/10000),
				(FFCore.getElement(arrayptr, 6)/10000), (FFCore.getElement(arrayptr, 7)/10000)
			);
		}
		else Z_scripterrlog("Invalid array size (%d) passed to npc->VariableWalk(int arr[])\n",sz);
	}
}

void FFScript::do_npc_constwalk8()
{
	long arrayptr = get_register(sarg2) / 10000;
	int sz = FFCore.getSize(arrayptr);
	 //(FFCore.getElement(sdci[2]/10000, q))/10000;
	//void variable_walk_8(int rate,int homing,int newclk,int special);
	// same as above but with variable enemy size
	//void variable_walk_8(int rate,int homing,int newclk,int special,int dx1,int dy1,int dx2,int dy2);
	
	
	if(GuyH::loadNPC(ri->guyref, "npc->ConstantWalk8()") == SH::_NoError)
	{
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		
		if ( sz == 3 ) 
		{
			GuyH::getNPC()->constant_walk_8( (FFCore.getElement(arrayptr, 0)/10000), (FFCore.getElement(arrayptr, 1)/10000),
				(FFCore.getElement(arrayptr, 2)/10000) );
		}
		
		else Z_scripterrlog("Invalid array size (%d) passed to npc->VariableWalk(int arr[])\n",sz);
	}
}


void FFScript::do_npc_haltwalk()
{
	long arrayptr = get_register(sarg2) / 10000;
	int sz = FFCore.getSize(arrayptr);
	 //(FFCore.getElement(sdci[2]/10000, q))/10000;
	
	if(GuyH::loadNPC(ri->guyref, "npc->HaltingWalk()") == SH::_NoError)
	{
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		
		if ( sz == 5 ) 
		{
			
			GuyH::getNPC()->halting_walk( (FFCore.getElement(arrayptr, 0)/10000), (FFCore.getElement(arrayptr, 1)/10000),
				(FFCore.getElement(arrayptr, 2)/10000), (FFCore.getElement(arrayptr, 3)/10000),
				(FFCore.getElement(arrayptr, 4)/10000));
		}
		else Z_scripterrlog("Invalid array size (%d) passed to npc->VariableWalk(int arr[])\n",sz);
		
		
	}
}

void FFScript::do_npc_haltwalk8()
{
	long arrayptr = get_register(sarg2) / 10000;
	int sz = FFCore.getSize(arrayptr);
	 //(FFCore.getElement(sdci[2]/10000, q))/10000;
	
	if(GuyH::loadNPC(ri->guyref, "npc->HaltingWalk8()") == SH::_NoError)
	{
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		
		if ( sz == 6 ) 
		{
			
			GuyH::getNPC()->halting_walk_8( (FFCore.getElement(arrayptr, 0)/10000), (FFCore.getElement(arrayptr, 1)/10000),
				(FFCore.getElement(arrayptr, 2)/10000), (FFCore.getElement(arrayptr, 3)/10000),
				(FFCore.getElement(arrayptr, 4)/10000),(FFCore.getElement(arrayptr, 5)/10000));
		}
		else Z_scripterrlog("Invalid array size (%d) passed to npc->VariableWalk(int arr[])\n",sz);
		
		
	}
}


void FFScript::do_npc_floatwalk()
{
	long arrayptr = get_register(sarg2) / 10000;
	int sz = FFCore.getSize(arrayptr);
	 //(FFCore.getElement(sdci[2]/10000, q))/10000;
	
	if(GuyH::loadNPC(ri->guyref, "npc->FloatingWalk()") == SH::_NoError)
	{
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		
		if ( sz == 3 ) 
		{
			
			GuyH::getNPC()->floater_walk( (FFCore.getElement(arrayptr, 0)/10000), (FFCore.getElement(arrayptr, 1)/10000),
				(zfix)(FFCore.getElement(arrayptr, 2)/10000));
		
		}
		else if ( sz == 7 ) 
		{
			
			GuyH::getNPC()->floater_walk( (FFCore.getElement(arrayptr, 0)/10000), (FFCore.getElement(arrayptr, 1)/10000),
				(zfix)(FFCore.getElement(arrayptr, 2)/10000), (zfix)(FFCore.getElement(arrayptr, 3)/10000),
				(FFCore.getElement(arrayptr, 4)/10000),(FFCore.getElement(arrayptr, 5)/10000),
				(FFCore.getElement(arrayptr, 6)/10000));
		}
		else Z_scripterrlog("Invalid array size (%d) passed to npc->VariableWalk(int arr[])\n",sz);
		
		
	}
}

void FFScript::do_npc_breathefire()
{
	bool seek = (get_register(sarg2));
	if(GuyH::loadNPC(ri->guyref, "npc->BreathAttack()") == SH::_NoError)
	{
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		GuyH::getNPC()->FireBreath(seek);
		
	}
}


void FFScript::do_npc_newdir8()
{
	long arrayptr = get_register(sarg2) / 10000;
	int sz = FFCore.getSize(arrayptr);
	 //(FFCore.getElement(sdci[2]/10000, q))/10000;
	
	if(GuyH::loadNPC(ri->guyref, "npc->NewDir8()") == SH::_NoError)
	{
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		
		if ( sz == 3 ) 
		{
			
			GuyH::getNPC()->newdir_8( (FFCore.getElement(arrayptr, 0)/10000), (FFCore.getElement(arrayptr, 1)/10000),
				(FFCore.getElement(arrayptr, 2)/10000));
		
		}
		else if ( sz == 7 ) 
		{
			
			GuyH::getNPC()->newdir_8( (FFCore.getElement(arrayptr, 0)/10000), (FFCore.getElement(arrayptr, 1)/10000),
				(FFCore.getElement(arrayptr, 2)/10000), (FFCore.getElement(arrayptr, 3)/10000),
				(FFCore.getElement(arrayptr, 4)/10000),(FFCore.getElement(arrayptr, 5)/10000),
				(FFCore.getElement(arrayptr, 6)/10000));
		}
		else Z_scripterrlog("Invalid array size (%d) passed to npc->VariableWalk(int arr[])\n",sz);
		
		
	}
}

	
long FFScript::npc_collision()
{
	long isColl = 0;
	if(GuyH::loadNPC(ri->guyref, "npc->Collision()") == SH::_NoError)
	{
		long _obj_type = (ri->d[0] / 10000);
		long _obj_ptr = (ri->d[1]);
		
		switch(_obj_type)
		{
			case obj_type_lweapon:
			{
				zprint("Checking collision on npc (%d) against lweapon (%d)\n", ri->guyref, _obj_ptr);
				isColl = 0;
				break;
			}
			case obj_type_eweapon:
			{
				zprint("Checking collision on npc (%d) against eweapon (%d)\n", ri->guyref, _obj_ptr);
				isColl = 0;
				break;
			}
			case obj_type_npc:
			{
				zprint("Checking collision on npc (%d) against npc (%d)\n", ri->guyref, _obj_ptr);
				isColl = 0;
				break;
			}
			case obj_type_link:
			{
				zprint("Checking collision on npc (%d) against Player\n", ri->guyref);
				isColl = 0;
				break;
			}
			case obj_type_ffc:
			{
				_obj_ptr *= 10000; _obj_ptr -= 1;
				zprint("Checking collision on npc (%d) against ffc (%d)\n", ri->guyref, _obj_ptr);
				isColl = 0;
				break;
			}
			case obj_type_combo_pos:
			{
				_obj_ptr *= 10000;
				zprint("Checking collision on npc (%d) against combo position (%d)\n", ri->guyref, _obj_ptr);
				isColl = 0;
				break;
			}
			case obj_type_item:
			{
				zprint("Checking collision on npc (%d) against item (%d)\n", ri->guyref, _obj_ptr);
				isColl = 0;
				break;
			}
			default: 
			{
				Z_scripterrlog("Invalid object type (%d) passed to npc->Collision(int type, int ptr)\n", _obj_type);
				isColl = 0;
				break;
			}
		}
	}
	
	return isColl;
}


long FFScript::npc_linedup()
{
	if(GuyH::loadNPC(ri->guyref, "npc->LinedUp()") == SH::_NoError)
	{
		long range = (ri->d[0] / 10000);
		//zprint("LinedUp distance is: %d\n", range);
		bool dir8 = (ri->d[1]);
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		return (long)(GuyH::getNPC()->lined_up(range,dir8)*10000);
	}
	
	return 0;
}


void FFScript::do_npc_link_in_range(const bool v)
{
	int dist = get_register(sarg1) / 10000;
	//zprint("LinkInrange dist is: %d\n", dist);
	//bool in_range = false;
	if(GuyH::loadNPC(ri->guyref, "npc->LinedUp()") == SH::_NoError)
	{
		//long range = (ri->d[0] / 10000);
		//bool dir8 = (ri->d[1]);
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		//in_range = (e->LinkInRange(dist));
		//zprint("LinkInRange returned: %s\n", (GuyH::getNPC()->LinkInRange(dist) ? "true" : "false"));
		bool in_range = GuyH::getNPC()->LinkInRange(dist);
		set_register(sarg1, (in_range ? 10000 : 0)); //This isn't setting the right value, it seems. 
		//set_register(sarg1, (in_range ? 10000 : 0));
		//set_register(sarg1, 0);
	}
	else set_register(sarg2, 0);
}






void FFScript::do_npc_simulate_hit(const bool v)
{
	long arrayptr = SH::get_arg(sarg1, v) / 10000;
	int sz = FFCore.getSize(arrayptr);
	bool ishit = false;
	
	if(GuyH::loadNPC(ri->guyref, "npc->SimulateHit()") == SH::_NoError)
	{
		zprint("Trying to simulate a hit on npc\n");
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		if ( sz == 2 ) //type and pointer
		{
			int type = FFCore.getElement(arrayptr, 0)/10000;
			
			//switch(type)
			//{
			//	case simulate_hit_type_weapon:
			//	{
			//		ishit = e->hit(*);
			//		break;
			//	}
			//	case simulate_hit_type_sprite:
			//	{
			//		ishit = e->hit(*);
			//		break;
			//	}
			//}
			ishit = false;
		}
		if ( sz == 6 ) //hit(int tx,int ty,int tz,int txsz,int tysz,int tzsz);
		{
			ishit = GuyH::getNPC()->hit( (FFCore.getElement(arrayptr, 0)/10000), (FFCore.getElement(arrayptr, 1)/10000),
				(FFCore.getElement(arrayptr, 2)/10000), (FFCore.getElement(arrayptr, 3)/10000), 
				(FFCore.getElement(arrayptr, 4)/10000), (FFCore.getElement(arrayptr, 5)/10000) );			
			
		}
		else 
		{
			Z_scripterrlog("Invalid array size (%d) passed to npc->SimulateHit(). The array size must be [1] or [3].\n", sz);
			ishit = false;
		}
	}
	set_register(sarg1, ( ishit ? 10000 : 0));
}

void FFScript::do_npc_knockback(const bool v)
{
	long time = SH::get_arg(sarg1, v) / 10000;
	long dir = SH::get_arg(sarg2, v) / 10000;
	long spd = vbound(ri->d[0] / 10000, 0, 255);
	//zprint("Knockback: time %d,dir %d,spd %d\n",time,dir,spd);
	bool ret = false;
	
	if(GuyH::loadNPC(ri->guyref, "npc->Knockback()") == SH::_NoError)
	{
		ret = GuyH::getNPC()->knockback(time, dir, spd);
	}
	set_register(sarg1, ( ret ? 10000 : 0));
}

void FFScript::do_npc_add(const bool v)
{
	
	long arrayptr = SH::get_arg(sarg1, v) / 10000;
	int sz = FFCore.getSize(arrayptr);
	
	int id = 0, nx = 0, ny = 0, clk = -10;
	
	if ( sz < 1 ) 
	{
		Z_scripterrlog("Invalid array size (%d) passed to npc->Create(). The array size must be [1] or [3].\n", sz);
		return;
	}
	else //size is valid
	{
		id = (FFCore.getElement(arrayptr, 0)/10000);
		
		if ( sz == 3 ) //x and y
		{
			nx = (FFCore.getElement(arrayptr, 1)/10000);
			ny = (FFCore.getElement(arrayptr, 2)/10000);
		}
	}
	
	
	if(BC::checkGuyID(id, "npc->Create()") != SH::_NoError)
		return;
		
	//If we make a segmented enemy there'll be more than one sprite created
	word numcreated = addenemy(nx, ny, id, -10);
	
	if(numcreated == 0)
	{
		ri->guyref = LONG_MAX;
		Z_scripterrlog("Couldn't create NPC \"%s\", screen NPC limit reached\n", guy_string[id]);
	}
	else
	{
		word index = guys.Count() - numcreated; //Get the main enemy, not a segment
		ri->guyref = guys.spr(index)->getUID();
		
		for(; index<guys.Count(); index++)
			((enemy*)guys.spr(index))->script_spawned=true;
		
		ri->d[2] = ri->guyref;
		ri->d[3] = ri->guyref;
		Z_eventlog("Script created NPC \"%s\" with UID = %ld\n", guy_string[id], ri->guyref);
	}
}

bool FFScript::checkExtension(std::string &filename, const std::string &extension)
//inline bool checkExtension(std::string filename, std::string extension)
{
	int dot = filename.find_last_of(".");
	std::string exten = (dot == std::string::npos ? "" : filename.substr(dot, filename.length() - dot));
	return exten == extension;
}


void FFScript::do_loadgamestructs(const bool v, const bool v2)
{
	long arrayptr = SH::get_arg(sarg1, v) / 10000;
	long section_id = SH::get_arg(sarg2, v2) / 10000;
	zprint("do_loadgamestructs selected section is: %d\n", section_id);
	//Bitwise OR sections together
	string strA;
	FFCore.getString(arrayptr, strA, 256);
	int temp_sram_flags = section_id; int sram_version = 0;

	if ( FFCore.checkExtension(strA, ".zcsram") )
	{
		PACKFILE *f = pack_fopen_password(strA.c_str(),F_READ, "");
		if (f)
		{
			p_igetl(&sram_version,f,true);
			p_igetl(&section_id,f,true);
			zprint("Reading ZCSRAM, Version: %d\n", sram_version);
			if ( sram_version > SRAM_VERSION ) //file version is greater than programme current version.
			{
				Z_scripterrlog("SRAM Version is from a version of ZC newer than the running version and cannot be loaded.\n");
				return;
			}
			if ( section_id != temp_sram_flags )
			{
				Z_scripterrlog("Reading an SRAM file with a section flag mismatch!\nThe file section flags are (%d) and the specified flagset is (%d).\nThis may cause errors!\n", section_id, temp_sram_flags);
			}
			
			if ( !section_id || section_id&svGUYS ) FFCore.read_enemies(f,sram_version);
			if ( !section_id || section_id&svITEMS )FFCore.read_items(f,sram_version);
			if ( !section_id || section_id&svWEAPONS ) FFCore.read_weaponsprtites(f,sram_version);
			if ( !section_id || section_id&svCOMBOS ) 
			{
				reset_combo_animations();
				reset_combo_animations2();
				FFCore.read_combos(f,sram_version);
			}
			if ( !section_id || section_id&svDMAPS ) FFCore.read_dmaps(f,sram_version);
			if ( !section_id || section_id&svMAPSCR ) FFCore.read_mapscreens(f,sram_version);
			pack_fclose(f);
			zprint("do_savegamestructs COMPLETED READINV %s, with section ID flags %d\n", "ALL", section_id);
			
			set_register(sarg1, 10000);
		}
		else 
		{
			Z_scripterrlog("FFCore.do_loadgamestructs could not read packfile!");
			set_register(sarg1, -10000);
		}
	}
	else
	{
		Z_scripterrlog("Tried to read a .zcsram file, but the file lacked the ..zcsram extension!\n");
		set_register(sarg1, -20000);
		
	}
}

void FFScript::do_savegamestructs(const bool v, const bool v2)
{
	long arrayptr = SH::get_arg(sarg1, v) / 10000;
	long section_id = SH::get_arg(sarg2, v2) / 10000;
	zprint("do_loadgamestructs selected section is: %d\n", section_id);
	//Bitwise OR sections together
	string strA;
	FFCore.getString(arrayptr, strA, 256);
	int cycles = 0;

	if ( FFCore.checkExtension(strA, ".zcsram") )
	{
		PACKFILE *f = pack_fopen_password(strA.c_str(),F_WRITE, "");
		if (f)
		{
			p_iputl(SRAM_VERSION,f);
			p_iputl(section_id,f);
			
			if ( !section_id || section_id&svGUYS ) FFCore.write_enemies(f,SRAM_VERSION);
			if ( !section_id || section_id&svITEMS ) FFCore.write_items(f,SRAM_VERSION);
			if ( !section_id || section_id&svWEAPONS ) FFCore.write_weaponsprtites(f,SRAM_VERSION);
			if ( !section_id || section_id&svCOMBOS ) 
			{
				reset_combo_animations();
				reset_combo_animations2();
				FFCore.write_combos(f,SRAM_VERSION);
			}
			if ( !section_id || section_id&svDMAPS ) FFCore.write_dmaps(f,SRAM_VERSION);
			if ( !section_id || section_id&svMAPSCR ) FFCore.write_mapscreens(f,SRAM_VERSION);
			pack_fclose(f);
			zprint("do_savegamestructs COMPLETED WRITING %s, with section ID flags %d\n", "ALL", section_id);
			set_register(sarg1, 10000);
		}
		else 
		{
			Z_scripterrlog("FFCore.do_loadgamestructs could not read packfile!");
			set_register(sarg1, -10000);
		}
	}
	else
	{
		Z_scripterrlog("Tried to write a .zcsram file, but the file lacked the ..zcsram extension!\n");
		set_register(sarg1, -20000);
	}
}

void FFScript::do_strcmp()
{
	long arrayptr_a = ri->d[0]/10000;
	long arrayptr_b = ri->d[1]/10000;
	string strA;
	string strB;
	FFCore.getString(arrayptr_a, strA);
	FFCore.getString(arrayptr_b, strB);
	set_register(sarg1, (strcmp(strA.c_str(), strB.c_str()) * 10000));
}

void FFScript::do_stricmp()
{
	long arrayptr_a = ri->d[0]/10000;
	long arrayptr_b = ri->d[1]/10000;
	string strA;
	string strB;
	FFCore.getString(arrayptr_a, strA);
	FFCore.getString(arrayptr_b, strB);
	set_register(sarg1, (stricmp(strA.c_str(), strB.c_str()) * 10000));
}

void FFScript::do_LowerToUpper(const bool v)
{
	
	long arrayptr_a = ri->d[0]/10000;
	string strA;
	FFCore.getString(arrayptr_a, strA);
	if ( strA.size() < 1 ) 
	{
		zprint("String passed to UpperToLower() is too small. Size is: %d \n", strA.size());
		set_register(sarg1, 0); return;
	}
	for ( unsigned int q = 0; q < strA.size(); ++q )
	{
		if(( strA[q] >= 'a' && strA[q] <= 'z' ) || ( strA[q] >= 'A' && strA[q] <= 'Z' ))
		{
			if ( strA[q] < 'a' ) { continue; }
			else strA[q] -= 32;
			continue;
		}
		//else if ( strA[q] >= 'A' || strA[q] <= 'Z' )
		//{
		//	strA[q] += 32;
		//	continue;
		//}
	}
	//zprint("Converted string is: %s \n", strA.c_str());
	if(ArrayH::setArray(arrayptr_a, strA) == SH::_Overflow)
	{
		Z_scripterrlog("Dest string supplied to 'LowerToUpper()' not large enough\n");
		set_register(sarg1, 0);
	}
	else set_register(sarg1, (10000));
}

void FFScript::do_UpperToLower(const bool v)
{
	
	long arrayptr_a = ri->d[0]/10000;
	string strA;
	FFCore.getString(arrayptr_a, strA);
	if ( strA.size() < 1 ) 
	{
		Z_scripterrlog("String passed to UpperToLower() is too small. Size is: %d \n", strA.size());
		set_register(sarg1, 0); return;
	}
	for ( unsigned int q = 0; q < strA.size(); ++q )
	{
		if(( strA[q] >= 'a' && strA[q] <= 'z' ) || ( strA[q] >= 'A' && strA[q] <= 'Z' ))
		{
			if ( strA[q] < 'a' ) { strA[q] += 32; }
			else continue;
			continue;
		}
		//else if ( strA[q] >= 'A' || strA[q] <= 'Z' )
		//{
		//	strA[q] += 32;
		//	continue;
		//}
	}
	//zprint("Converted string is: %s \n", strA.c_str());
	if(ArrayH::setArray(arrayptr_a, strA) == SH::_Overflow)
	{
		Z_scripterrlog("Dest string supplied to 'LowerToUpper()' not large enough\n");
		set_register(sarg1, 0);
	}
	else set_register(sarg1, (10000));
}

void FFScript::do_getnpcscript()
{
	long arrayptr = get_register(sarg1) / 10000;
	string the_string;
	int script_num = -1;
	FFCore.getString(arrayptr, the_string, 256); //What is the max length of a script identifier?
	
	for(int q = 0; q < NUMSCRIPTGUYS; q++)
	{
		if(!(strcmp(the_string.c_str(), npcmap[q].scriptname.c_str())))
		{
			script_num = q+1;
			break;
		}
	}
	set_register(sarg1, (script_num * 10000));
}
void FFScript::do_getlweaponscript()
{
	long arrayptr = get_register(sarg1) / 10000;
	string the_string;
	int script_num = -1;
	FFCore.getString(arrayptr, the_string, 256); //What is the max length of a script identifier?
	
	for(int q = 0; q < NUMSCRIPTWEAPONS; q++)
	{
		if(!(strcmp(the_string.c_str(), lwpnmap[q].scriptname.c_str())))
		{
			script_num = q+1;
			break;
		}
	}
	set_register(sarg1, (script_num * 10000));
}
void FFScript::do_geteweaponscript()
{
	long arrayptr = get_register(sarg1) / 10000;
	string the_string;
	int script_num = -1;
	FFCore.getString(arrayptr, the_string, 256); //What is the max length of a script identifier?
	
	for(int q = 0; q < NUMSCRIPTWEAPONS; q++)
	{
		if(!(strcmp(the_string.c_str(), ewpnmap[q].scriptname.c_str())))
		{
			script_num = q+1;
			break;
		}
	}
	set_register(sarg1, (script_num * 10000));
}
void FFScript::do_getheroscript()
{
	long arrayptr = get_register(sarg1) / 10000;
	string the_string;
	int script_num = -1;
	FFCore.getString(arrayptr, the_string, 256); //What is the max length of a script identifier?
	
	for(int q = 0; q < NUMSCRIPTLINK; q++)
	{
		if(!(strcmp(the_string.c_str(), linkmap[q].scriptname.c_str())))
		{
			script_num = q+1;
			break;
		}
	}
	set_register(sarg1, (script_num * 10000));
}
void FFScript::do_getglobalscript()
{
	long arrayptr = get_register(sarg1) / 10000;
	string the_string;
	int script_num = -1;
	FFCore.getString(arrayptr, the_string, 256); //What is the max length of a script identifier?
	
	for(int q = 0; q < NUMSCRIPTGLOBAL; q++)
	{
		if(!(strcmp(the_string.c_str(), globalmap[q].scriptname.c_str())))
		{
			script_num = q+1;
			break;
		}
	}
	set_register(sarg1, (script_num * 10000));
}
void FFScript::do_getdmapscript()
{
	long arrayptr = get_register(sarg1) / 10000;
	string the_string;
	int script_num = -1;
	FFCore.getString(arrayptr, the_string, 256); //What is the max length of a script identifier?
	
	for(int q = 0; q < NUMSCRIPTSDMAP; q++)
	{
		if(!(strcmp(the_string.c_str(), dmapmap[q].scriptname.c_str())))
		{
			script_num = q+1;
			break;
		}
	}
	set_register(sarg1, (script_num * 10000));
}
void FFScript::do_getscreenscript()
{
	long arrayptr = get_register(sarg1) / 10000;
	string the_string;
	int script_num = -1;
	FFCore.getString(arrayptr, the_string, 256); //What is the max length of a script identifier?
	
	for(int q = 0; q < NUMSCRIPTSCREEN; q++)
	{
		if(!(strcmp(the_string.c_str(), screenmap[q].scriptname.c_str())))
		{
			script_num = q+1;
			break;
		}
	}
	set_register(sarg1, (script_num * 10000));
}
void FFScript::do_getitemspritescript()
{
	long arrayptr = get_register(sarg1) / 10000;
	string the_string;
	int script_num = -1;
	FFCore.getString(arrayptr, the_string, 256); //What is the max length of a script identifier?
	
	for(int q = 0; q < NUMSCRIPTSITEMSPRITE; q++)
	{
		if(!(strcmp(the_string.c_str(), itemspritemap[q].scriptname.c_str())))
		{
			script_num = q+1;
			break;
		}
	}
	set_register(sarg1, (script_num * 10000));
}
//Not assigned to slots at present. If they ever are, then this would get the id of any script (any type) by name. -Z
void FFScript::do_getuntypedscript()
{
	set_register(sarg1, 0);
	//long arrayptr = ri->d[0]/10000;
	//string the_string;
	//int script_num = -1;
	//FFCore.getString(arrayptr, the_string, 256); //What is the max length of a script identifier?
	
	//for(int q = 0; q < NUMSCRIPTSITEMSPRITE; q++)
	//{
	//	if(!(strcmp(the_string.c_str(), itemspritemap[q].scriptname.c_str())))
	//	{
	//		script_num = q+1;
	//		break;
	//	}
	//}
	//set_register(sarg1, (script_num * 10000));
}
void FFScript::do_getsubscreenscript()
{
	//long arrayptr = ri->d[0]/10000;
	//string the_string;
	//int script_num = -1;
	//FFCore.getString(arrayptr, the_string, 256); //What is the max length of a script identifier?
	
	//for(int q = 0; q < NUMSCRIPTSUBSCREEN; q++)
	//{
	//	if(!(strcmp(the_string.c_str(), subscreenmap[q].scriptname.c_str())))
	//	{
	//		script_num = q+1;
	//		break;
	//	}
	//}
	//set_register(sarg1, (script_num * 10000));
	set_register(sarg1, 0); //Remove this line, when we add this script type, then un-comment the rest. -Z
}
void FFScript::do_getnpcbyname()
{
	long arrayptr = get_register(sarg1) / 10000;
	string the_string;
	int num = -1;
	FFCore.getString(arrayptr, the_string, 256); //What is the max length of a script identifier?
	
	for(int q = 0; q < MAXNPCS; q++)
	{
		if(!(strcmp(the_string.c_str(), guy_string[q])))
		{
			num = q;
			break;
		}
	}
	set_register(sarg1, (num * 10000));
}	
void FFScript::do_getitembyname()
{
	long arrayptr = get_register(sarg1) / 10000;
	string the_string;
	int num = -1;
	FFCore.getString(arrayptr, the_string, 256); //What is the max length of a script identifier?
	
	for(int q = 0; q < MAXNPCS; q++)
	{
		if(!(strcmp(the_string.c_str(), item_string[q])))
		{
			num = q;
			break;
		}
	}
	set_register(sarg1, (num * 10000));
}	
void FFScript::do_getcombobyname()
{
	long arrayptr = get_register(sarg1) / 10000;
	string the_string;
	int num = -1;
	FFCore.getString(arrayptr, the_string, 256); //What is the max length of a script identifier?
	
	for(int q = 0; q < MAXCOMBOS; q++)
	{
		if(!(strcmp(the_string.c_str(), combobuf[q].label)))
		{
			num = q;
			break;
		}
	}
	set_register(sarg1, (num * 10000));
}
void FFScript::do_getdmapbyname()
{
	long arrayptr = get_register(sarg1) / 10000;
	string the_string;
	int num = -1;
	FFCore.getString(arrayptr, the_string, 256); //What is the max length of a script identifier?
	
	for(int q = 0; q < MAXNPCS; q++)
	{
		if(!(strcmp(the_string.c_str(), DMaps[q].title)))
		{
			num = q;
			break;
		}
	}
	set_register(sarg1, (num * 10000));
}

void FFScript::do_ConvertCase(const bool v)
{
	
	long arrayptr_a = ri->d[0]/10000;
	string strA;
	FFCore.getString(arrayptr_a, strA);
	if ( strA.size() < 1 ) 
	{
		Z_scripterrlog("String passed to UpperToLower() is too small. Size is: %d \n", strA.size());
		set_register(sarg1, 0); return;
	}
	for ( unsigned int q = 0; q < strA.size(); ++q )
	{
		if(( strA[q] >= 'a' || strA[q] <= 'z' ) || ( strA[q] >= 'A' || strA[q] <= 'Z' ))
		{
			if ( strA[q] < 'a' ) { strA[q] += 32; }
			else strA[q] -= 32;
			continue;
		}
		//else if ( strA[q] >= 'A' || strA[q] <= 'Z' )
		//{
		//	strA[q] += 32;
		//	continue;
		//}
	}
	//zprint("Converted string is: %s \n", strA.c_str());
	if(ArrayH::setArray(arrayptr_a, strA) == SH::_Overflow)
	{
		Z_scripterrlog("Dest string supplied to 'LowerToUpper()' not large enough\n");
		set_register(sarg1, 0);
	}
	else set_register(sarg1, (10000));
}

void FFScript::do_xlen(const bool v)
{
	//not implemented, xlen not found
	//zprint("Running: %s\n","strlen()");
	long arrayptr = (SH::get_arg(sarg2, v) / 10000);
	string str;
	FFCore.getString(arrayptr, str);
	//zprint("strlen string size is: %d\n", str.length());
	//set_register(sarg1, (xlen(str.c_str()) * 10000));
}
void FFScript::do_xtoi(const bool v)
{
	//not implemented, xtoi not found
	//zprint("Running: %s\n","strlen()");
	long arrayptr = (SH::get_arg(sarg2, v) / 10000);
	string str;
	FFCore.getString(arrayptr, str);
	//zprint("strlen string size is: %d\n", str.length());
	//set_register(sarg1, (xtoi(str.c_str()) * 10000));
}
void FFScript::do_ilen(const bool v)
{
	long arrayptr = (SH::get_arg(sarg2, v) / 10000);
	string str;
	FFCore.getString(arrayptr, str);
	//zprint("strlen string size is: %d\n", str.length());
	set_register(sarg1, (FFCore.ilen((char*)str.c_str()) * 10000));
}
void FFScript::do_atoi(const bool v)
{
	long arrayptr = (SH::get_arg(sarg2, v) / 10000);
	string str;
	FFCore.getString(arrayptr, str);
	set_register(sarg1, (atoi(str.c_str()) * 10000));
}



void FFScript::do_strstr()
{
	
	long arrayptr_a = ri->d[0]/10000;
	long arrayptr_b = ri->d[1]/10000;
	string strA;
	string strB;
	FFCore.getString(arrayptr_a, strA);
	FFCore.getString(arrayptr_b, strB);
	if ( strA.size() < 1 ) 
	{
		Z_scripterrlog("String passed to strstr() is too small. Size is: %d \n", strA.size());
		set_register(sarg1,-10000);
		return;
	}
	set_register(sarg1, (strA.find(strB) * 10000));
}

void FFScript::do_strcat()
{
	
	long arrayptr_a = ri->d[0]/10000;
	long arrayptr_b = ri->d[1]/10000;
	string strA;
	string strB;
	FFCore.getString(arrayptr_a, strA);
	FFCore.getString(arrayptr_b, strB);
	//char str_c[2048];
	//strcpy(str_c, strA.c_str());
	string strC = strA + strB;
	//zprint("strcat string: %s\n", strC.c_str());
	if(ArrayH::setArray(arrayptr_a, strC) == SH::_Overflow)
	{
		Z_scripterrlog("Dest string supplied to 'strcat()' not large enough\n");
		set_register(sarg1, 0);
	}
	//set_register(sarg1, (strcat((char)strA.c_str(), strB.c_str()) * 10000));
	else set_register(sarg1, arrayptr_a); //returns the pointer to the dest
}
void FFScript::do_strspn()
{
	
	long arrayptr_a = ri->d[0]/10000;
	long arrayptr_b = ri->d[1]/10000;
	string strA;
	string strB;
	FFCore.getString(arrayptr_a, strA);
	FFCore.getString(arrayptr_b, strB);
	set_register(sarg1, (strspn(strA.c_str(), strB.c_str()) * 10000));
}

void FFScript::do_strcspn()
{
	
	long arrayptr_a = ri->d[0]/10000;
	long arrayptr_b = ri->d[1]/10000;
	string strA;
	string strB;
	FFCore.getString(arrayptr_a, strA);
	FFCore.getString(arrayptr_b, strB);
	set_register(sarg1, (strcspn(strA.c_str(), strB.c_str()) * 10000));
}

void FFScript::do_strchr()
{
	
	long arrayptr_a = ri->d[0]/10000;
	char chr_to_find = (ri->d[1]/10000);
	string strA; 
	FFCore.getString(arrayptr_a, strA);
	if ( strA.size() < 1 ) 
	{
		Z_scripterrlog("String passed to strchr() is too small. Size is: %d \n", strA.size());
		set_register(sarg1,-10000);
		return;
	}
	
	set_register(sarg1,strA.find_first_of(chr_to_find)*10000);
}
void FFScript::do_strrchr()
{
	long arrayptr_a = ri->d[0]/10000;
	char chr_to_find = (ri->d[1]/10000);
	string strA; 
	FFCore.getString(arrayptr_a, strA);
	if ( strA.size() < 1 ) 
	{
		Z_scripterrlog("String passed to strrchr() is too small. Size is: %d \n", strA.size());
		set_register(sarg1,-10000);
		return;
	}
	set_register(sarg1,strA.find_last_of(chr_to_find)*10000);
}
void FFScript::do_xtoi2()
{
	//Not implemented, xtoi not found
	long arrayptr_a = ri->d[0]/10000;
	string strA;
	FFCore.getString(arrayptr_a, strA);
	//set_register(sarg1, (xtoi(strA.c_str(), (ri->d[1]/10000)) * 10000));
}
void FFScript::do_remchr2()
{
	//Not implemented, remchr not found
	//not part of any standard library
	long arrayptr_a = ri->d[0]/10000;
	string strA;
	FFCore.getString(arrayptr_a, strA);
	//set_register(sarg1, (remchr(strA.c_str(), (ri->d[1]/10000)) * 10000));
}
void FFScript::do_atoi2()
{
	//not implemented; atoi does not take 2 params
	long arrayptr_a = ri->d[0]/10000;
	string strA;
	FFCore.getString(arrayptr_a, strA);
	//set_register(sarg1, (atoi(strA.c_str(), (ri->d[1]/10000)) * 10000));
}
void FFScript::do_ilen2()
{
	//not implemented, ilen not found
	long arrayptr_a = ri->d[0]/10000;
	string strA;
	FFCore.getString(arrayptr_a, strA);
	//set_register(sarg1, (ilen(strA.c_str(), (ri->d[1]/10000)) * 10000));
}
void FFScript::do_xlen2()
{
	//not implemented, xlen not found
	long arrayptr_a = ri->d[0]/10000;
	string strA;
	FFCore.getString(arrayptr_a, strA);
	//set_register(sarg1, (xlen(strA.c_str(), (ri->d[1]/10000)) * 10000));
}
void FFScript::do_itoa()
{
	
	long arrayptr_a = ri->d[1]/10000;
	int value = ri->d[0]/10000;
	char the_string[13];
	char* chrptr = NULL;
	chrptr = zc_itoa(value, the_string, 10);
	//Returns the number of characters used. 
	if(ArrayH::setArray(arrayptr_a, the_string) == SH::_Overflow)
		Z_scripterrlog("Dest string supplied to 'itoa()' not large enough\n");
	set_register(sarg1, (FFCore.zc_strlen(the_string)*10000));
}
void FFScript::do_xtoa()
{
	//not implemented, xtoa not found
	long arrayptr_a = ri->d[0]/10000;
	string strA;
	FFCore.getString(arrayptr_a, strA);
	//set_register(sarg1, (xtoa(strA.c_str(), (ri->d[1]/10000)) * 10000));
}

void FFScript::do_strcpy(const bool a, const bool b)
{
	long arrayptr_b = SH::get_arg(sarg1, a) / 10000;
	long arrayptr_a = SH::get_arg(sarg2, b) / 10000;
	
	string strA;

	FFCore.getString(arrayptr_a, strA);

	if(ArrayH::setArray(arrayptr_b, strA) == SH::_Overflow)
		Z_scripterrlog("Dest string supplied to 'strcpy()' not large enough\n");
}
void FFScript::do_arraycpy(const bool a, const bool b)
{
	long arrayptr_b = SH::get_arg(sarg1, a) / 10000;
	long arrayptr_a = SH::get_arg(sarg2, b) / 10000;
	long *P = NULL;
	FFCore.getValues(arrayptr_a,P, FFCore.getSize(arrayptr_a));
	//ZScriptArray& a = FFCore.getArray(arrayptr_a);
	FFCore.setArray(arrayptr_b, FFCore.getSize(arrayptr_a), P);

	//if(ArrayH::setArray(arrayptr_b, a.size(), a) == SH::_Overflow)
	//	Z_scripterrlog("Dest string supplied to 'ArrayCopy()' not large enough\n");
}
void FFScript::do_strlen(const bool v)
{
	//zprint("Running: %s\n","strlen()");
	long arrayptr = (SH::get_arg(sarg2, v) / 10000);
	string str;
	FFCore.getString(arrayptr, str);
	//zprint("strlen string size is: %d\n", str.length());
	set_register(sarg1, (str.length() * 10000));
}

void FFScript::do_strncmp()
{
	long arrayptr_a = ri->d[0]/10000;
	long arrayptr_b = ri->d[3]/10000;
	long len = ri->d[2]/10000;
	string strA;
	string strB;
	FFCore.getString(arrayptr_a, strA);
	FFCore.getString(arrayptr_b, strB);
	set_register(sarg1, (strncmp(strA.c_str(), strB.c_str(), len) * 10000));
}

void FFScript::do_strnicmp()
{
	long arrayptr_a = ri->d[0]/10000;
	long arrayptr_b = ri->d[3]/10000;
	long len = ri->d[2]/10000;
	string strA;
	string strB;
	FFCore.getString(arrayptr_a, strA);
	FFCore.getString(arrayptr_b, strB);
	set_register(sarg1, (strnicmp(strA.c_str(), strB.c_str(), len) * 10000));
}

void FFScript::do_npc_canmove(const bool v)
{
	long arrayptr = SH::get_arg(sarg1, v) / 10000;
	int sz = FFCore.getSize(arrayptr);
	//bool can_mv = false;
	if(GuyH::loadNPC(ri->guyref, "npc->CanMove()") == SH::_NoError)
	{
		//enemy *e = (enemy*)guys.spr(GuyH::getNPCIndex(ri->guyref));
		if ( sz == 1 ) //bool canmove(int ndir): dir only, uses 'step' IIRC
		{
			//zprint("npc->CanMove(%d)\n",getElement(arrayptr, 0)/10000);
			//can_mv = e->canmove(getElement(arrayptr, 0)/10000);
			set_register(sarg1, ( GuyH::getNPC()->canmove((getElement(arrayptr, 0)/10000),false)) ? 10000 : 0);
			//zprint("npc->CanMove(dir) returned: %s\n", (GuyH::getNPC()->canmove((getElement(arrayptr, 0)/10000))) ? "true" : "false");
			//return;
		}
		else if ( sz == 2 ) //bool canmove(int ndir, int special): I think that this also uses the default 'step'
		{
			//zprint("npc->CanMove(%d, %d)\n",(getElement(arrayptr, 0)/10000),(getElement(arrayptr, 1)/10000));
			set_register(sarg1, ( GuyH::getNPC()->canmove((getElement(arrayptr, 0)/10000),(zfix)(getElement(arrayptr, 1)/10000), false)) ? 10000 : 0);
			//can_mv = e->canmove((getElement(arrayptr, 0)/10000), (getElement(arrayptr, 1)/10000));
			//set_register(sarg1, ( can_mv ? 10000 : 0));
			//return;
		}
		else if ( sz == 3 ) //bool canmove(int ndir,zfix s,int special) : I'm pretty sure that 'zfix s' is 'step' here. 
		{
			//zprint("npc->CanMove(%d, %d, %d)\n",(getElement(arrayptr, 0)/10000),(getElement(arrayptr, 1)/10000),(getElement(arrayptr, 2)/10000));
			//can_mv = e->canmove((getElement(arrayptr, 0)/10000), (zfix)(getElement(arrayptr, 1)/10000), (getElement(arrayptr, 2)/10000));
			//set_register(sarg1, ( can_mv ? 10000 : 0));
			set_register(sarg1, ( GuyH::getNPC()->canmove((getElement(arrayptr, 0)/10000),(zfix)(getElement(arrayptr, 1)/10000),(getElement(arrayptr, 2)/10000),false)) ? 10000 : 0);
			//return;
		}
		else if ( sz == 7 ) //bool canmove(int ndir,zfix s,int special) : I'm pretty sure that 'zfix s' is 'step' here. 
		{
			zprint("npc->CanMove(%d, %d, %d, %d, %d, %d, %d)\n",(getElement(arrayptr, 0)/10000),(getElement(arrayptr, 1)/10000),(getElement(arrayptr, 2)/10000),(getElement(arrayptr, 3)/10000),(getElement(arrayptr, 4)/10000),(getElement(arrayptr, 5)/10000),(getElement(arrayptr, 6)/10000),false);
			//can_mv = e->canmove((getElement(arrayptr, 0)/10000), (zfix)(getElement(arrayptr, 1)/10000), (getElement(arrayptr, 2)/10000));
			//set_register(sarg1, ( can_mv ? 10000 : 0));
			set_register(sarg1, ( GuyH::getNPC()->canmove((getElement(arrayptr, 0)/10000),(zfix)(getElement(arrayptr, 1)/10000),(getElement(arrayptr, 2)/10000),(getElement(arrayptr, 3)/10000),(getElement(arrayptr, 4)/10000),(getElement(arrayptr, 5)/10000),(getElement(arrayptr, 6)/10000),false)) ? 10000 : 0);
			
			//can_mv = e->canmove((getElement(arrayptr, 0)/10000), 
			//(zfix)(getElement(arrayptr, 1)/10000), (getElement(arrayptr, 2)/10000),
			//(getElement(arrayptr, 3)/10000), (getElement(arrayptr, 4)/10000), 
			//(getElement(arrayptr, 5)/10000), (getElement(arrayptr, 5)/10000)	);
			//set_register(sarg1, ( can_mv ? 10000 : 0));
			//return;
		}
		else 
		{
			Z_scripterrlog("Invalid array size (%d) passed to npc->CanMove(). The array size must be [1], [2], [3], or [7].\n", sz);
			//can_mv = false;
			set_register(sarg1, 0);
		}
	}
	//set_register(sarg1, ( can_mv ? 10000 : 0));
}

//void do_get_enh_music_filename(const bool v)
void FFScript::get_npcdata_initd_label(const bool v)
{
	long init_d_index = SH::get_arg(sarg1, v) / 10000;
	long arrayptr = get_register(sarg2) / 10000;
	
	if((unsigned)init_d_index > 7)
	{
	Z_scripterrlog("Invalid InitD[] index (%d) passed to npcdata->GetInitDLabel().\n", init_d_index);
	return;
	}
		
	if(ArrayH::setArray(arrayptr, string(guysbuf[ri->npcdataref].initD_label[init_d_index])) == SH::_Overflow)
		Z_scripterrlog("Array supplied to 'npcdata->GetInitDLabel()' not large enough\n");
}

script_command ZASMcommands[NUMCOMMANDS+1]=
{
	//name                args arg1 arg2 more
	{ "SETV",                2,   0,   1,   0},
	{ "SETR",                2,   0,   0,   0},
	{ "ADDR",                2,   0,   0,   0},
	{ "ADDV",                2,   0,   1,   0},
	{ "SUBR",                2,   0,   0,   0},
	{ "SUBV",                2,   0,   1,   0},
	{ "MULTR",               2,   0,   0,   0},
	{ "MULTV",               2,   0,   1,   0},
	{ "DIVR",                2,   0,   0,   0},
	{ "DIVV",                2,   0,   1,   0},
	{ "WAITFRAME",           0,   0,   0,   0},
	{ "GOTO",                1,   1,   0,   0},
	{ "CHECKTRIG",           0,   0,   0,   0},
	{ "WARP",                2,   1,   1,   0},
	{ "COMPARER",            2,   0,   0,   0},
	{ "COMPAREV",            2,   0,   1,   0},
	{ "GOTOTRUE",            1,   1,   0,   0},
	{ "GOTOFALSE",           1,   1,   0,   0},
	{ "GOTOLESS",            1,   1,   0,   0},
	{ "GOTOMORE",            1,   1,   0,   0},
	{ "LOAD1",               2,   0,   0,   0},
	{ "LOAD2",               2,   0,   0,   0},
	{ "SETA1",               2,   0,   0,   0},
	{ "SETA2",               2,   0,   0,   0},
	{ "QUIT",                0,   0,   0,   0},
	{ "SINR",                2,   0,   0,   0},
	{ "SINV",                2,   0,   1,   0},
	{ "COSR",                2,   0,   0,   0},
	{ "COSV",                2,   0,   1,   0},
	{ "TANR",                2,   0,   0,   0},
	{ "TANV",                2,   0,   1,   0},
	{ "MODR",                2,   0,   0,   0},
	{ "MODV",                2,   0,   1,   0},
	{ "ABS",                 1,   0,   0,   0},
	{ "MINR",                2,   0,   0,   0},
	{ "MINV",                2,   0,   1,   0},
	{ "MAXR",                2,   0,   0,   0},
	{ "MAXV",                2,   0,   1,   0},
	{ "RNDR",                2,   0,   0,   0},
	{ "RNDV",                2,   0,   1,   0},
	{ "FACTORIAL",           1,   0,   0,   0},
	{ "POWERR",              2,   0,   0,   0},
	{ "POWERV",              2,   0,   1,   0},
	{ "IPOWERR",             2,   0,   0,   0},
	{ "IPOWERV",             2,   0,   1,   0},
	{ "ANDR",                2,   0,   0,   0},
	{ "ANDV",                2,   0,   1,   0},
	{ "ORR",                 2,   0,   0,   0},
	{ "ORV",                 2,   0,   1,   0},
	{ "XORR",                2,   0,   0,   0},
	{ "XORV",                2,   0,   1,   0},
	{ "NANDR",               2,   0,   0,   0},
	{ "NANDV",               2,   0,   1,   0},
	{ "NORR",                2,   0,   0,   0},
	{ "NORV",                2,   0,   1,   0},
	{ "XNORR",               2,   0,   0,   0},
	{ "XNORV",               2,   0,   1,   0},
	{ "NOT",                 1,   0,   0,   0},
	{ "LSHIFTR",             2,   0,   0,   0},
	{ "LSHIFTV",             2,   0,   1,   0},
	{ "RSHIFTR",             2,   0,   0,   0},
	{ "RSHIFTV",             2,   0,   1,   0},
	{ "TRACER",              1,   0,   0,   0},
	{ "TRACEV",              1,   1,   0,   0},
	{ "TRACE3",              0,   0,   0,   0},
	{ "LOOP",                2,   1,   0,   0},
	{ "PUSHR",               1,   0,   0,   0},
	{ "PUSHV",               1,   1,   0,   0},
	{ "POP",                 1,   0,   0,   0},
	{ "ENQUEUER",            2,   0,   0,   0},
	{ "ENQUEUEV",            2,   0,   1,   0},
	{ "DEQUEUE",             1,   0,   0,   0},
	{ "PLAYSOUNDR",          1,   0,   0,   0},
	{ "PLAYSOUNDV",          1,   1,   0,   0},
	{ "LOADLWEAPONR",        1,   0,   0,   0},
	{ "LOADLWEAPONV",        1,   1,   0,   0},
	{ "LOADITEMR",           1,   0,   0,   0},
	{ "LOADITEMV",           1,   1,   0,   0},
	{ "LOADNPCR",            1,   0,   0,   0},
	{ "LOADNPCV",            1,   1,   0,   0},
	{ "CREATELWEAPONR",      1,   0,   0,   0},
	{ "CREATELWEAPONV",      1,   1,   0,   0},
	{ "CREATEITEMR",         1,   0,   0,   0},
	{ "CREATEITEMV",         1,   1,   0,   0},
	{ "CREATENPCR",          1,   0,   0,   0},
	{ "CREATENPCV",          1,   1,   0,   0},
	{ "LOADI",               2,   0,   0,   0},
	{ "STOREI",              2,   0,   0,   0},
	{ "GOTOR",               1,   0,   0,   0},
	{ "SQROOTV",             2,   0,   1,   0},
	{ "SQROOTR",             2,   0,   0,   0},
	{ "CREATEEWEAPONR",      1,   0,   0,   0},
	{ "CREATEEWEAPONV",      1,   1,   0,   0},
	{ "PITWARP",             2,   1,   1,   0},
	{ "WARPR",               2,   0,   0,   0},
	{ "PITWARPR",            2,   0,   0,   0},
	{ "CLEARSPRITESR",       1,   0,   0,   0},
	{ "CLEARSPRITESV",       1,   1,   0,   0},
	{ "RECT",                0,   0,   0,   0},
	{ "CIRCLE",              0,   0,   0,   0},
	{ "ARC",                 0,   0,   0,   0},
	{ "ELLIPSE",             0,   0,   0,   0},
	{ "LINE",                0,   0,   0,   0},
	{ "PUTPIXEL",            0,   0,   0,   0},
	{ "DRAWTILE",            0,   0,   0,   0},
	{ "DRAWCOMBO",           0,   0,   0,   0},
	{ "ELLIPSE2",            0,   0,   0,   0},
	{ "SPLINE",              0,   0,   0,   0},
	{ "FLOODFILL",           0,   0,   0,   0},
	{ "COMPOUNDR",           1,   0,   0,   0},
	{ "COMPOUNDV",           1,   1,   0,   0},
	{ "MSGSTRR",             1,   0,   0,   0},
	{ "MSGSTRV",             1,   1,   0,   0},
	{ "ISVALIDITEM",         1,   0,   0,   0},
	{ "ISVALIDNPC",          1,   0,   0,   0},
	{ "PLAYMIDIR",           1,   0,   0,   0},
	{ "PLAYMIDIV",           1,   1,   0,   0},
	{ "COPYTILEVV",          2,   1,   1,   0},
	{ "COPYTILEVR",          2,   1,   0,   0},
	{ "COPYTILERV",          2,   0,   1,   0},
	{ "COPYTILERR",          2,   0,   0,   0},
	{ "SWAPTILEVV",          2,   1,   1,   0},
	{ "SWAPTILEVR",          2,   1,   0,   0},
	{ "SWAPTILERV",          2,   0,   1,   0},
	{ "SWAPTILERR",          2,   0,   0,   0},
	{ "CLEARTILEV",          1,   1,   0,   0},
	{ "CLEARTILER",          1,   0,   0,   0},
	{ "OVERLAYTILEVV",       2,   1,   1,   0},
	{ "OVERLAYTILEVR",       2,   1,   0,   0},
	{ "OVERLAYTILERV",       2,   0,   1,   0},
	{ "OVERLAYTILERR",       2,   0,   0,   0},
	{ "FLIPROTTILEVV",       2,   1,   1,   0},
	{ "FLIPROTTILEVR",       2,   1,   0,   0},
	{ "FLIPROTTILERV",       2,   0,   1,   0},
	{ "FLIPROTTILERR",       2,   0,   0,   0},
	{ "GETTILEPIXELV",       1,   1,   0,   0},
	{ "GETTILEPIXELR",       1,   0,   0,   0},
	{ "SETTILEPIXELV",       1,   1,   0,   0},
	{ "SETTILEPIXELR",       1,   0,   0,   0},
	{ "SHIFTTILEVV",         2,   1,   1,   0},
	{ "SHIFTTILEVR",         2,   1,   0,   0},
	{ "SHIFTTILERV",         2,   0,   1,   0},
	{ "SHIFTTILERR",         2,   0,   0,   0},
	{ "ISVALIDLWPN",         1,   0,   0,   0},
	{ "ISVALIDEWPN",         1,   0,   0,   0},
	{ "LOADEWEAPONR",        1,   0,   0,   0},
	{ "LOADEWEAPONV",        1,   1,   0,   0},
	{ "ALLOCATEMEMR",        2,   0,   0,   0},
	{ "ALLOCATEMEMV",        2,   0,   1,   0},
	{ "ALLOCATEGMEMV",       2,   0,   1,   0},
	{ "DEALLOCATEMEMR",      1,   0,   0,   0},
	{ "DEALLOCATEMEMV",      1,   1,   0,   0},
	{ "WAITDRAW",			   0,   0,   0,   0},
	{ "ARCTANR",		       1,   0,   0,   0},
	{ "LWPNUSESPRITER",      1,   0,   0,   0},
	{ "LWPNUSESPRITEV",      1,   1,   0,   0},
	{ "EWPNUSESPRITER",      1,   0,   0,   0},
	{ "EWPNUSESPRITEV",      1,   1,   0,   0},
	{ "LOADITEMDATAR",       1,   0,   0,   0},
	{ "LOADITEMDATAV",       1,   1,   0,   0},
	{ "BITNOT",              1,   0,   0,   0},
	{ "LOG10",               1,   0,   0,   0},
	{ "LOGE",                1,   0,   0,   0},
	{ "ISSOLID",             1,   0,   0,   0},
	{ "LAYERSCREEN",         2,   0,   0,   0},
	{ "LAYERMAP",            2,   0,   0,   0},
	{ "TRACE2R",             1,   0,   0,   0},
	{ "TRACE2V",             1,   1,   0,   0},
	{ "TRACE4",              0,   0,   0,   0},
	{ "TRACE5",              0,   0,   0,   0},
	{ "SECRETS",			   0,   0,   0,   0},
	{ "DRAWCHAR",            0,   0,   0,   0},
	{ "GETSCREENFLAGS",      1,   0,   0,   0},
	{ "QUAD",                0,   0,   0,   0},
	{ "TRIANGLE",            0,   0,   0,   0},
	{ "ARCSINR",             2,   0,   0,   0},
	{ "ARCSINV",             2,   1,   0,   0},
	{ "ARCCOSR",             2,   0,   0,   0},
	{ "ARCCOSV",             2,   1,   0,   0},
	{ "GAMEEND",             0,   0,   0,   0},
	{ "DRAWINT",             0,   0,   0,   0},
	{ "SETTRUE",             1,   0,   0,   0},
	{ "SETFALSE",            1,   0,   0,   0},
	{ "SETMORE",             1,   0,   0,   0},
	{ "SETLESS",             1,   0,   0,   0},
	{ "FASTTILE",            0,   0,   0,   0},
	{ "FASTCOMBO",           0,   0,   0,   0},
	{ "DRAWSTRING",          0,   0,   0,   0},
	{ "SETSIDEWARP",         0,   0,   0,   0},
	{ "SAVE",                0,   0,   0,   0},
	{ "TRACE6",              0,   0,   0,   0},
	{ "DEPRECATED",	       1,   0,   0,   0},
	{ "QUAD3D",              0,   0,   0,   0},
	{ "TRIANGLE3D",          0,   0,   0,   0},
	{ "SETCOLORB",           0,   0,   0,   0},
	{ "SETDEPTHB",           0,   0,   0,   0},
	{ "GETCOLORB",           0,   0,   0,   0},
	{ "GETDEPTHB",           0,   0,   0,   0},
	{ "COMBOTILE",           2,   0,   0,   0},
	{ "SETTILEWARP",         0,   0,   0,   0},
	{ "GETSCREENEFLAGS",     1,   0,   0,   0},
	{ "GETSAVENAME",         1,   0,   0,   0},
	{ "ARRAYSIZE",           1,   0,   0,   0},
	{ "ITEMNAME",            1,   0,   0,   0},
	{ "SETSAVENAME",         1,   0,   0,   0},
	{ "NPCNAME",             1,   0,   0,   0},
	{ "GETMESSAGE",          2,   0,   0,   0},
	{ "GETDMAPNAME",         2,   0,   0,   0},
	{ "GETDMAPTITLE",        2,   0,   0,   0},
	{ "GETDMAPINTRO",        2,   0,   0,   0},
	{ "ALLOCATEGMEMR",       2,   0,   0,   0},
	{ "DRAWBITMAP",          0,   0,   0,   0},
	{ "SETRENDERTARGET",     0,   0,   0,   0},
	{ "PLAYENHMUSIC",        2,   0,   0,   0},
	{ "GETMUSICFILE",        2,   0,   0,   0},
	{ "GETMUSICTRACK",       1,   0,   0,   0},
	{ "SETDMAPENHMUSIC",     0,   0,   0,   0},
	{ "DRAWLAYER",           0,   0,   0,   0},
	{ "DRAWSCREEN",          0,   0,   0,   0},
	{ "BREAKSHIELD",         1,   0,   0,   0},
	{ "SAVESCREEN",          1,   0,   0,   0},
	{ "SAVEQUITSCREEN",      0,   0,   0,   0},
	{ "SELECTAWPNR",         1,   0,   0,   0},
	{ "SELECTAWPNV",         1,   1,   0,   0},
	{ "SELECTBWPNR",         1,   0,   0,   0},
	{ "SELECTBWPNV",         1,   1,   0,   0},
	{ "GETSIDEWARPDMAP",     1,   0,   0,   0},
	{ "GETSIDEWARPSCR",      1,   0,   0,   0},
	{ "GETSIDEWARPTYPE",     1,   0,   0,   0},
	{ "GETTILEWARPDMAP",     1,   0,   0,   0},
	{ "GETTILEWARPSCR",      1,   0,   0,   0},
	{ "GETTILEWARPTYPE",     1,   0,   0,   0},
	{ "GETFFCSCRIPT",        1,   0,   0,   0},
	{ "BITMAPEXR",          0,   0,   0,   0},
	{ "__RESERVED_FOR_QUAD2R",                0,   0,   0,   0},
	{ "WAVYIN",			   0,   0,   0,   0},
	{ "WAVYOUT",			   0,   0,   0,   0},
	{ "ZAPIN",			   0,   0,   0,   0},
	{ "ZAPOUT",			   0,   0,   0,   0},
	{ "OPENWIPE",			   0,   0,   0,   0},
	{ "FREE0x00F1",			   0,   0,   0, 0  },
	{ "FREE0x00F2",			   0,   0,   0, 0},  
	{ "FREE0x00F3",			   0,   0,   0,0},  
	{ "SETMESSAGE",          2,   0,   0,   0},
	{ "SETDMAPNAME",          2,   0,   0,   0},
	{ "SETDMAPTITLE",          2,   0,   0,   0},
	{ "SETDMAPINTRO",          2,   0,   0,   0},
	{ "GREYSCALEON",			   0,   0,   0,   0},
	{ "GREYSCALEOFF",			   0,   0,   0,   0},
	{ "ENDSOUNDR",          1,   0,   0,   0},
	{ "ENDSOUNDV",          1,   1,   0,   0},
	{ "PAUSESOUNDR",          1,   0,   0,   0},
	{ "PAUSESOUNDV",          1,   1,   0,   0},
	{ "RESUMESOUNDR",          1,   0,   0,   0},
	{ "RESUMESOUNDV",          1,   1,   0,   0},
	{ "PAUSEMUSIC",			   0,   0,   0,   0},
	{ "RESUMEMUSIC",			   0,   0,   0,   0},
	{ "LWPNARRPTR",                1,   0,   0,   0},
	{ "EWPNARRPTR",                1,   0,   0,   0},
	{ "EWPNARRPTR",                1,   0,   0,   0},
	{ "IDATAARRPTR",                1,   0,   0,   0},
	{ "FFCARRPTR",                1,   0,   0,   0},
	{ "BOOLARRPTR",                1,   0,   0,   0},
	{ "BOOLARRPTR",                1,   0,   0,   0},
	{ "LWPNARRPTR2",                1,   0,   0,   0},
	{ "EWPNARRPTR2",                1,   0,   0,   0},
	{ "ITEMARRPTR2",                1,   0,   0,   0},
	{ "IDATAARRPTR2",                1,   0,   0,   0},
	{ "FFCARRPTR2",                1,   0,   0,   0},
	{ "BOOLARRPTR2",                1,   0,   0,   0},
	{ "NPCARRPTR2",                1,   0,   0,   0},
	{ "ARRAYSIZEB",                1,   0,   0,   0},
	{ "ARRAYSIZEF",                1,   0,   0,   0},
	{ "ARRAYSIZEN",                1,   0,   0,   0},
	{ "ARRAYSIZEL",                1,   0,   0,   0},
	{ "ARRAYSIZEE",                1,   0,   0,   0},
	{ "ARRAYSIZEI",                1,   0,   0,   0},
	{ "ARRAYSIZEID",                1,   0,   0,   0},
	{ "POLYGONR",                0,   0,   0,   0},
	{ "__RESERVED_FOR_POLYGON3DR",                0,   0,   0,   0},
	{ "__RESERVED_FOR_SETRENDERSOURCE",                0,   0,   0,   0},
	{ "LINESARRAY",                0,   0,   0,   0},
	{ "PIXELARRAYR",                0,   0,   0,   0},
	{ "TILEARRAYR",                0,   0,   0,   0},
	{ "COMBOARRAYR",                0,   0,   0,   0},
	{ "RES0000",			   0,   0,   0,   0},
	{ "RES0001",			   0,   0,   0,   0},
	{ "RES0002",			   0,   0,   0,   0},
	{ "RES0003",			   0,   0,   0,   0},
	{ "RES0004",			   0,   0,   0,   0},
	{ "RES0005",			   0,   0,   0,   0},
	{ "RES0006",			   0,   0,   0,   0},
	{ "RES0007",			   0,   0,   0,   0},
	{ "RES0008",			   0,   0,   0,   0},
	{ "RES0009",			   0,   0,   0,   0},
	{ "RES000A",			   0,   0,   0,   0},
	{ "RES000B",			   0,   0,   0,   0},
	{ "RES000C",			   0,   0,   0,   0},
	{ "RES000D",			   0,   0,   0,   0},
	{ "RES000E",			   0,   0,   0,   0},
	{ "RES000F",			   0,   0,   0,   0},
	{ "__RESERVED_FOR_CREATELWPN2VV",          2,   1,   1,   0},
	{ "__RESERVED_FOR_CREATELWPN2VR",          2,   1,   0,   0},
	{ "__RESERVED_FOR_CREATELWPN2RV",          2,   0,   1,   0},
	{ "__RESERVED_FOR_CREATELWPN2RR",          2,   0,   0,   0},
	{ "GETSCREENDOOR",      1,   0,   0,   0},
	{ "GETSCREENENEMY",      1,   0,   0,   0},
	{ "PAUSESFX",         1,   0,   0,   0},
	{ "RESUMESFX",         1,   0,   0,   0},
	{ "CONTINUESFX",         1,   0,   0,   0},
	{ "ADJUSTSFX",         3,   0,   0,   0},
	{ "GETITEMSCRIPT",        1,   0,   0,   0},
	{ "GETSCREENLAYOP",      1,   0,   0,   0},
	{ "GETSCREENSECCMB",      1,   0,   0,   0},
	{ "GETSCREENSECCST",      1,   0,   0,   0},
	{ "GETSCREENSECFLG",      1,   0,   0,   0},
	{ "GETSCREENLAYMAP",      1,   0,   0,   0},
	{ "GETSCREENLAYSCR",      1,   0,   0,   0},
	{ "GETSCREENPATH",      1,   0,   0,   0},
	{ "GETSCREENWARPRX",      1,   0,   0,   0},
	{ "GETSCREENWARPRY",      1,   0,   0,   0},
	{ "TRIGGERSECRETR",          1,   0,   0,   0},
	{ "TRIGGERSECRETV",          1,   1,   0,   0},
	{ "CHANGEFFSCRIPTR",          1,   0,   0,   0},
	{ "CHANGEFFSCRIPTV",          1,   1,   0,   0},
	//NPCData
	//one input, one return
	{ "GETNPCDATAFLAGS",           2,   0,   0,   0},
	{ "GETNPCDATAFLAGS2",           2,   0,   0,   0},
	{ "GETNPCDATAWIDTH",           2,   0,   0,   0},
	{ "GETNPCDATAHEIGHT",           2,   0,   0,   0},
	{ "GETNPCDATASTILE",           2,   0,   0,   0},
	{ "GETNPCDATASWIDTH",           2,   0,   0,   0},
	{ "GETNPCDATASHEIGHT",           2,   0,   0,   0},
	{ "GETNPCDATAETILE",           2,   0,   0,   0},
	{ "GETNPCDATAEWIDTH",           2,   0,   0,   0},
	{ "GETNPCDATAHP",           2,   0,   0,   0},
	{ "GETNPCDATAFAMILY",           2,   0,   0,   0},
	{ "GETNPCDATACSET",           2,   0,   0,   0},
	{ "GETNPCDATAANIM",           2,   0,   0,   0},
	{ "GETNPCDATAEANIM",           2,   0,   0,   0},
	{ "GETNPCDATAFRAMERATE",           2,   0,   0,   0},
	{ "GETNPCDATAEFRAMERATE",           2,   0,   0,   0},
	{ "GETNPCDATATOUCHDMG",           2,   0,   0,   0},
	{ "GETNPCDATAWPNDAMAGE",           2,   0,   0,   0},
	{ "GETNPCDATAWEAPON",           2,   0,   0,   0},
	{ "GETNPCDATARANDOM",           2,   0,   0,   0},
	{ "GETNPCDATAHALT",           2,   0,   0,   0},
	{ "GETNPCDATASTEP",           2,   0,   0,   0},
	{ "GETNPCDATAHOMING",           2,   0,   0,   0},
	{ "GETNPCDATAHUNGER",           2,   0,   0,   0},
	{ "GETNPCDATADROPSET",           2,   0,   0,   0},
	{ "GETNPCDATABGSFX",           2,   0,   0,   0},
	{ "GETNPCDATADEATHSFX",           2,   0,   0,   0},
	{ "GETNPCDATAXOFS",           2,   0,   0,   0},
	{ "GETNPCDATAYOFS",           2,   0,   0,   0},
	{ "GETNPCDATAZOFS",           2,   0,   0,   0},
	{ "GETNPCDATAHXOFS",           2,   0,   0,   0},
	{ "GETNPCDATAHYOFS",           2,   0,   0,   0},
	{ "GETNPCDATAHITWIDTH",           2,   0,   0,   0},
	{ "GETNPCDATAHITHEIGHT",           2,   0,   0,   0},
	{ "GETNPCDATAHITZ",           2,   0,   0,   0},
	{ "GETNPCDATATILEWIDTH",           2,   0,   0,   0},
	{ "GETNPCDATATILEHEIGHT",           2,   0,   0,   0},
	{ "GETNPCDATAWPNSPRITE",           2,   0,   0,   0},
	//two inputs one return
	{ "GETNPCDATASCRIPTDEF",             1,   0,   0,   0},
	{ "GETNPCDATADEFENSE",             1,   0,   0,   0},
	{ "GETNPCDATASIZEFLAG",             1,   0,   0,   0},
	{ "GETNPCDATAATTRIBUTE",             1,   0,   0,   0},
	//two inputs no return
	{ "SETNPCDATAFLAGS",        2,   0,   0,   0},
	{ "SETNPCDATAFLAGS2",        2,   0,   0,   0},
	{ "SETNPCDATAWIDTH",        2,   0,   0,   0},
	{ "SETNPCDATAHEIGHT",        2,   0,   0,   0},
	{ "SETNPCDATASTILE",        2,   0,   0,   0},
	{ "SETNPCDATASWIDTH",        2,   0,   0,   0},
	{ "SETNPCDATASHEIGHT",        2,   0,   0,   0},
	{ "SETNPCDATAETILE",        2,   0,   0,   0},
	{ "SETNPCDATAEWIDTH",        2,   0,   0,   0},
	{ "SETNPCDATAHP",        2,   0,   0,   0},
	{ "SETNPCDATAFAMILY",        2,   0,   0,   0},
	{ "SETNPCDATACSET",        2,   0,   0,   0},
	{ "SETNPCDATAANIM",        2,   0,   0,   0},
	{ "SETNPCDATAEANIM",        2,   0,   0,   0},
	{ "SETNPCDATAFRAMERATE",        2,   0,   0,   0},
	{ "SETNPCDATAEFRAMERATE",        2,   0,   0,   0},
	{ "SETNPCDATATOUCHDMG",        2,   0,   0,   0},
	{ "SETNPCDATAWPNDAMAGE",        2,   0,   0,   0},
	{ "SETNPCDATAWEAPON",        2,   0,   0,   0},
	{ "SETNPCDATARANDOM",        2,   0,   0,   0},
	{ "SETNPCDATAHALT",        2,   0,   0,   0},
	{ "SETNPCDATASTEP",        2,   0,   0,   0},
	{ "SETNPCDATAHOMING",        2,   0,   0,   0},
	{ "SETNPCDATAHUNGER",        2,   0,   0,   0},
	{ "SETNPCDATADROPSET",        2,   0,   0,   0},
	{ "SETNPCDATABGSFX",        2,   0,   0,   0},
	{ "SETNPCDATADEATHSFX",        2,   0,   0,   0},
	{ "SETNPCDATAXOFS",        2,   0,   0,   0},
	{ "SETNPCDATAYOFS",        2,   0,   0,   0},
	{ "SETNPCDATAZOFS",        2,   0,   0,   0},
	{ "SETNPCDATAHXOFS",        2,   0,   0,   0},
	{ "SETNPCDATAHYOFS",        2,   0,   0,   0},
	{ "SETNPCDATAHITWIDTH",        2,   0,   0,   0},
	{ "SETNPCDATAHITHEIGHT",        2,   0,   0,   0},
	{ "SETNPCDATAHITZ",        2,   0,   0,   0},
	{ "SETNPCDATATILEWIDTH",        2,   0,   0,   0},
	{ "SETNPCDATATILEHEIGHT",        2,   0,   0,   0},
	{ "SETNPCDATAWPNSPRITE",        2,   0,   0,   0},
	{ "SETNPCDATAHITSFX",        2,   0,   0,   0},
	{ "GETNPCDATAHITSFX",        2,   0,   0,   0},
	//Combodata, one input no return
	{ "GCDBLOCKENEM",           2,   0,   0,   0},
	{ "GCDBLOCKHOLE",           2,   0,   0,   0},
	{ "GCDBLOCKTRIG",           2,   0,   0,   0},
	{ "GCDCONVEYSPDX",           2,   0,   0,   0},
	{ "GCDCONVEYSPDY",           2,   0,   0,   0},
	{ "GCDCREATEENEM",           2,   0,   0,   0},  
	{ "GCDCREATEENEMWH",           2,   0,   0,   0},  
	{ "GCDCREATEENEMCH",           2,   0,   0,   0},  
	{ "GCDDIRCHTYPE",           2,   0,   0,   0},  
	{ "GCDDISTCHTILES",           2,   0,   0,   0},  
	{ "GCDDIVEITEM",           2,   0,   0,   0},  
	{ "GCDDOCK",           2,   0,   0,   0},  
	{ "GCDFAIRY",           2,   0,   0,   0},  
	{ "GCDFFCOMBOATTRIB",           2,   0,   0,   0},  
	{ "GCDFOOTDECOTILE",           2,   0,   0,   0},  
	{ "GCDFOOTDECOTYPE",           2,   0,   0,   0},  
	{ "GCDHOOKSHOTGRAB",           2,   0,   0,   0},  
	{ "GCDLADDERPASS",           2,   0,   0,   0},  
	{ "GCDLOCKBLOCKTYPE",           2,   0,   0,   0},  
	{ "GCDLOCKBLOCKCHANGE",           2,   0,   0,   0},  
	{ "GCDMAGICMIRRORTYPE",           2,   0,   0,   0},  
	{ "GCDMODIFYHPAMOUNT",           2,   0,   0,   0},  
	{ "GCDMODIFYHPDELAY",           2,   0,   0,   0},  
	{ "GCDMODIFYHPTYPE",           2,   0,   0,   0},  
	{ "GCDMODIFYMPAMOUNT",           2,   0,   0,   0},  
	{ "GCDMODIFYMPDELAY",           2,   0,   0,   0},  
	{ "GCDMODIFYMPTYPE",           2,   0,   0,   0},  
	{ "GCDNOPUSHBLOCKS",           2,   0,   0,   0},  
	{ "GCDOVERHEAD",           2,   0,   0,   0},  
	{ "GCDPLACEENEMY",           2,   0,   0,   0},  
	{ "GCDPUSHDIR",           2,   0,   0,   0},  
	{ "GCDPUSHWEIGHT",           2,   0,   0,   0},  
	{ "GCDPUSHWAIT",           2,   0,   0,   0},  
	{ "GCDPUSHED",           2,   0,   0,   0},  
	{ "GCDRAFT",           2,   0,   0,   0},  
	{ "GCDRESETROOM",           2,   0,   0,   0},  
	{ "GCDSAVEPOINT",           2,   0,   0,   0},  
	{ "GCDSCREENFREEZE",           2,   0,   0,   0},  
	{ "GCDSECRETCOMBO",           2,   0,   0,   0},  
	{ "GCDSINGULAR",           2,   0,   0,   0},  
	{ "GCDSLOWMOVE",           2,   0,   0,   0},  
	{ "GCDSTATUE",           2,   0,   0,   0},  
	{ "GCDSTEPTYPE",           2,   0,   0,   0},  
	{ "GCDSTEPCHANGETO",           2,   0,   0,   0},  
	{ "GCDSTRIKEREMNANTS",           2,   0,   0,   0},  
	{ "GCDSTRIKEREMNANTSTYPE",           2,   0,   0,   0},  
	{ "GCDSTRIKECHANGE",           2,   0,   0,   0},  
	{ "GCDSTRIKECHANGEITEM",           2,   0,   0,   0},  
	{ "GCDTOUCHITEM",           2,   0,   0,   0},  
	{ "GCDTOUCHSTAIRS",           2,   0,   0,   0},  
	{ "GCDTRIGGERTYPE",           2,   0,   0,   0},  
	{ "GCDTRIGGERSENS",           2,   0,   0,   0},  
	{ "GCDWARPTYPE",           2,   0,   0,   0},  
	{ "GCDWARPSENS",           2,   0,   0,   0},  
	{ "GCDWARPDIRECT",           2,   0,   0,   0},  
	{ "GCDWARPLOCATION",           2,   0,   0,   0},  
	{ "GCDWATER",           2,   0,   0,   0},  
	{ "GCDWHISTLE",           2,   0,   0,   0},  
	{ "GCDWINGAME",           2,   0,   0,   0},  
	{ "GCDBLOCKWEAPLVL",           2,   0,   0,   0},  
	{ "GCDTILE",           2,   0,   0,   0},  
	{ "GCDFLIP",           2,   0,   0,   0},  
	{ "GCDWALK",           2,   0,   0,   0},  
	{ "GCDTYPE",           2,   0,   0,   0},  
	{ "GCDCSETS",           2,   0,   0,   0},  
	{ "GCDFOO",           2,   0,   0,   0},  
	{ "GCDFRAMES",           2,   0,   0,   0},  
	{ "GCDSPEED",           2,   0,   0,   0},  
	{ "GCDNEXTCOMBO",           2,   0,   0,   0},  
	{ "GCDNEXTCSET",           2,   0,   0,   0},  
	{ "GCDFLAG",           2,   0,   0,   0},  
	{ "GCDSKIPANIM",           2,   0,   0,   0},  
	{ "GCDNEXTTIMER",           2,   0,   0,   0},  
	{ "GCDSKIPANIMY",           2,   0,   0,   0},  
	{ "GCDANIMFLAGS",           2,   0,   0,   0},  
	//combodata two input, one return
	{ "GCDBLOCKWEAPON",             1,   0,   0,   0},
	{ "GCDEXPANSION",             1,   0,   0,   0},
	{ "GCDSTRIKEWEAPONS",             1,   0,   0,   0},
	//combodata two input, one return
	{ "SCDBLOCKENEM",           2,   0,   0,   0},
	{ "SCDBLOCKHOLE",           2,   0,   0,   0},
	{ "SCDBLOCKTRIG",           2,   0,   0,   0},
	{ "SCDCONVEYSPDX",           2,   0,   0,   0},
	{ "SCDCONVEYSPDY",           2,   0,   0,   0},
	{ "SCDCREATEENEM",           2,   0,   0,   0},  
	{ "SCDCREATEENEMWH",           2,   0,   0,   0},  
	{ "SCDCREATEENEMCH",           2,   0,   0,   0},  
	{ "SCDDIRCHTYPE",           2,   0,   0,   0},  
	{ "SCDDISTCHTILES",           2,   0,   0,   0},  
	{ "SCDDIVEITEM",           2,   0,   0,   0},  
	{ "SCDDOCK",           2,   0,   0,   0},  
	{ "SCDFAIRY",           2,   0,   0,   0},  
	{ "SCDFFCOMBOATTRIB",           2,   0,   0,   0},  
	{ "SCDFOOTDECOTILE",           2,   0,   0,   0},  
	{ "SCDFOOTDECOTYPE",           2,   0,   0,   0},  
	{ "SCDHOOKSHOTGRAB",           2,   0,   0,   0},  
	{ "SCDLADDERPASS",           2,   0,   0,   0},  
	{ "SCDLOCKBLOCKTYPE",           2,   0,   0,   0},  
	{ "SCDLOCKBLOCKCHANGE",           2,   0,   0,   0},  
	{ "SCDMAGICMIRRORTYPE",           2,   0,   0,   0},  
	{ "SCDMODIFYHPAMOUNT",           2,   0,   0,   0},  
	{ "SCDMODIFYHPDELAY",           2,   0,   0,   0},  
	{ "SCDMODIFYHPTYPE",           2,   0,   0,   0},  
	{ "SCDMODIFYMPAMOUNT",           2,   0,   0,   0},  
	{ "SCDMODIFYMPDELAY",           2,   0,   0,   0},  
	{ "SCDMODIFYMPTYPE",           2,   0,   0,   0},  
	{ "SCDNOPUSHBLOCKS",           2,   0,   0,   0},  
	{ "SCDOVERHEAD",           2,   0,   0,   0},  
	{ "SCDPLACEENEMY",           2,   0,   0,   0},  
	{ "SCDPUSHDIR",           2,   0,   0,   0},  
	{ "SCDPUSHWEIGHT",           2,   0,   0,   0},  
	{ "SCDPUSHWAIT",           2,   0,   0,   0},  
	{ "SCDPUSHED",           2,   0,   0,   0},  
	{ "SCDRAFT",           2,   0,   0,   0},  
	{ "SCDRESETROOM",           2,   0,   0,   0},  
	{ "SCDSAVEPOINT",           2,   0,   0,   0},  
	{ "SCDSCREENFREEZE",           2,   0,   0,   0},  
	{ "SCDSECRETCOMBO",           2,   0,   0,   0},  
	{ "SCDSINGULAR",           2,   0,   0,   0},  
	{ "SCDSLOWMOVE",           2,   0,   0,   0},  
	{ "SCDSTATUE",           2,   0,   0,   0},  
	{ "SCDSTEPTYPE",           2,   0,   0,   0},  
	{ "SCDSTEPCHANGETO",           2,   0,   0,   0},  
	{ "SCDSTRIKEREMNANTS",           2,   0,   0,   0},  
	{ "SCDSTRIKEREMNANTSTYPE",           2,   0,   0,   0},  
	{ "SCDSTRIKECHANGE",           2,   0,   0,   0},  
	{ "SCDSTRIKECHANGEITEM",           2,   0,   0,   0},  
	{ "SCDTOUCHITEM",           2,   0,   0,   0},  
	{ "SCDTOUCHSTAIRS",           2,   0,   0,   0},  
	{ "SCDTRIGGERTYPE",           2,   0,   0,   0},  
	{ "SCDTRIGGERSENS",           2,   0,   0,   0},  
	{ "SCDWARPTYPE",           2,   0,   0,   0},  
	{ "SCDWARPSENS",           2,   0,   0,   0},  
	{ "SCDWARPDIRECT",           2,   0,   0,   0},  
	{ "SCDWARPLOCATION",           2,   0,   0,   0},  
	{ "SCDWATER",           2,   0,   0,   0},  
	{ "SCDWHISTLE",           2,   0,   0,   0},  
	{ "SCDWINGAME",           2,   0,   0,   0},  
	{ "SCDBLOCKWEAPLVL",           2,   0,   0,   0},  
	{ "SCDTILE",           2,   0,   0,   0},  
	{ "SCDFLIP",           2,   0,   0,   0},  
	{ "SCDWALK",           2,   0,   0,   0},  
	{ "SCDTYPE",           2,   0,   0,   0},  
	{ "SCDCSETS",           2,   0,   0,   0},  
	{ "SCDFOO",           2,   0,   0,   0},  
	{ "SCDFRAMES",           2,   0,   0,   0},  
	{ "SCDSPEED",           2,   0,   0,   0},  
	{ "SCDNEXTCOMBO",           2,   0,   0,   0},  
	{ "SCDNEXTCSET",           2,   0,   0,   0},  
	{ "SCDFLAG",           2,   0,   0,   0},  
	{ "SCDSKIPANIM",           2,   0,   0,   0},  
	{ "SCDNEXTTIMER",           2,   0,   0,   0},  
	{ "SCDSKIPANIMY",           2,   0,   0,   0},  
	{ "SCDANIMFLAGS",           2,   0,   0,   0},  
	{ "GETNPCDATATILE",           2,   0,   0,   0},
	{ "GETNPCDATAEHEIGHT",           2,   0,   0,   0},
	{ "SETNPCDATATILE",        2,   0,   0,   0},
	{ "SETNPCDATAEHEIGHT",        2,   0,   0,   0},
	{ "GETSPRITEDATASTRING",        2,   0,   0,   0},
	//SpriteData
	{ "GETSPRITEDATATILE",           2,   0,   0,   0},  
	{ "GETSPRITEDATAMISC",           2,   0,   0,   0},  
	{ "GETSPRITEDATACGETS",           2,   0,   0,   0},  
	{ "GETSPRITEDATAFRAMES",           2,   0,   0,   0},  
	{ "GETSPRITEDATASPEED",           2,   0,   0,   0},  
	{ "GETSPRITEDATATYPE",           2,   0,   0,   0},  
	{ "SETSPRITEDATASTRING",           2,   0,   0,   0},  
	{ "SETSPRITEDATATILE",           2,   0,   0,   0},  
	{ "SETSPRITEDATAMISC",           2,   0,   0,   0},  
	{ "SETSPRITEDATACSETS",           2,   0,   0,   0},  
	{ "SETSPRITEDATAFRAMES",           2,   0,   0,   0},  
	{ "SETSPRITEDATASPEED",           2,   0,   0,   0},  
	{ "SETSPRITEDATATYPE",           2,   0,   0,   0},  
	//Game->SetContinueScreenSetting
	{ "SETCONTINUESCREEN",           2,   0,   0,   0}, 
	//Game->SetContinueScreenString
	{ "SETCONTINUESTRING",           2,   0,   0,   0}, 
	
	{ "LOADNPCDATAR",       1,   0,   0,   0},
	{ "LOADNPCDATAV",       1,   1,   0,   0},
	
	{ "LOADCOMBODATAR",       1,   0,   0,   0},
	{ "LOADCOMBODATAV",       1,   1,   0,   0},
	
	{ "LOADMAPDATAR",       1,   0,   0,   0},
	{ "LOADMAPDATAV",       1,   1,   0,   0},
	
	{ "LOADSPRITEDATAR",       1,   0,   0,   0},
	{ "LOADSPRITEDATAV",       1,   1,   0,   0},
	
	{ "LOADSCREENDATAR",       1,   0,   0,   0},
	{ "LOADSCREENDATAV",       1,   1,   0,   0},

	{ "LOADBITMAPDATAR",       1,   0,   0,   0},
	{ "LOADBITMAPDATAV",       1,   1,   0,   0},
	
	{ "LOADSHOPR",       1,   0,   0,   0},
	{ "LOADSHOPV",       1,   1,   0,   0},

	{ "LOADINFOSHOPR",       1,   0,   0,   0},
	{ "LOADINFOSHOPV",       1,   1,   0,   0},
	
	{ "LOADMESSAGEDATAR",       1,   0,   0,   0},
	{ "LOADMESSAGEDATAV",       1,   1,   0,   0},
	{ "MESSAGEDATASETSTRINGR",       1,   0,   0,   0},
	{ "MESSAGEDATASETSTRINGV",       1,   1,   0,   0},
	{ "MESSAGEDATAGETSTRINGR",       1,   0,   0,   0},
	{ "MESSAGEDATAGETSTRINGV",       1,   1,   0,   0},
	
	{ "LOADDMAPDATAR",       1,   0,   0,   0},
	{ "LOADDMAPDATAV",       1,   1,   0,   0},
	{ "DMAPDATAGETNAMER",       1,   0,   0,   0},
	{ "DMAPDATAGETNAMEV",       1,   1,   0,   0},
	{ "DMAPDATASETNAMER",       1,   0,   0,   0},
	{ "DMAPDATASETNAMEV",       1,   1,   0,   0},
	{ "DMAPDATAGETTITLER",       1,   0,   0,   0},
	{ "DMAPDATAGETTITLEV",       1,   1,   0,   0},
	{ "DMAPDATASETTITLER",       1,   0,   0,   0},
	{ "DMAPDATASETTITLEV",       1,   1,   0,   0},
	
	{ "DMAPDATAGETINTROR",       1,   0,   0,   0},
	{ "DMAPDATAGETINTROV",       1,   1,   0,   0},
	{ "DMAPDATANSETITROR",       1,   0,   0,   0},
	{ "DMAPDATASETINTROV",       1,   1,   0,   0},
	{ "DMAPDATAGETMUSICR",       1,   0,   0,   0},
	{ "DMAPDATAGETMUSICV",       1,   1,   0,   0},
	{ "DMAPDATASETMUSICR",       1,   0,   0,   0},
	{ "DMAPDATASETMUSICV",       1,   1,   0,   0},
	
	{ "ADJUSTSFXVOLUMER",          1,   0,   0,   0},
	{ "ADJUSTSFXVOLUMEV",          1,   1,   0,   0},
	
	{ "ADJUSTVOLUMER",          1,   0,   0,   0},
	{ "ADJUSTVOLUMEV",          1,   1,   0,   0},
	
	{ "FXWAVYR",             1,   0,   0,   0},
	{ "FXWAVYV",             1,   1,   0,   0},
	
	{ "FXZAPR",             1,   0,   0,   0},
	{ "FXZAPV",             1,   1,   0,   0},
	
	{ "GREYSCALER",             1,   0,   0,   0},
	{ "GREYSCALEV",             1,   1,   0,   0},
	{ "RETURN",			0,	0,	0,	0},
	{ "MONOCHROMER",             1,   0,   0,   0},
	{ "MONOCHROMEV",             1,   1,   0,   0},
	{ "CLEARTINT",              0,   0,   0,   0},
	{ "TINT",         0,   0,   0,   0},
	{ "MONOHUE",         0,   0,   0,   0},
	
	{ "BMPRECTR",                0,   0,   0,   0},
	{ "BMPCIRCLER",                0,   0,   0,   0},
	{ "BMPARCR",                0,   0,   0,   0},
	{ "BMPELLIPSER",                0,   0,   0,   0},
	{ "BMPLINER",                0,   0,   0,   0},
	{ "BMPSPLINER",                0,   0,   0,   0},
	{ "BMPPUTPIXELR",                0,   0,   0,   0},
	{ "BMPDRAWTILER",                0,   0,   0,   0},
	{ "BMPDRAWCOMBOR",                0,   0,   0,   0},
	{ "BMPFASTTILER",                0,   0,   0,   0},
	{ "BMPFASTCOMBOR",                0,   0,   0,   0},
	{ "BMPDRAWCHARR",                0,   0,   0,   0},
	{ "BMPDRAWINTR",                0,   0,   0,   0},
	{ "BMPDRAWSTRINGR",                0,   0,   0,   0},
	{ "BMPQUADR",                0,   0,   0,   0},
	{ "BMPQUAD3DR",                0,   0,   0,   0},
	{ "BMPTRIANGLER",                0,   0,   0,   0},
	{ "BMPTRIANGLE3DR",                0,   0,   0,   0},
	{ "BMPPOLYGONR",                0,   0,   0,   0},
	{ "BMPDRAWLAYERR",                0,   0,   0,   0},
	{ "BMPDRAWSCREENR",                0,   0,   0,   0},
	{ "BMPBLIT",                0,   0,   0,   0},
	
	{ "LINKWARPEXR",             1,   0,   0,   0},
	{ "LINKWARPEXV",             1,   1,   0,   0},
	{ "LINKEXPLODER",             1,   0,   0,   0},
	{ "LINKEXPLODEV",             1,   1,   0,   0},
	{ "NPCEXPLODER",             1,   0,   0,   0},
	{ "NPCEXPLODEV",             1,   1,   0,   0},
	
	{ "ITEMEXPLODER",             1,   0,   0,   0},
	{ "ITEMEXPLODEV",             1,   1,   0,   0},
	{ "LWEAPONEXPLODER",             1,   0,   0,   0},
	{ "LWEAPONEXPLODEV",             1,   1,   0,   0},
	{ "EWEAPONEXPLODER",             1,   0,   0,   0},
	{ "EWEAPONEXPLODEV",             1,   1,   0,   0},
	{ "RUNITEMSCRIPT",			   0,   0,   0,   0},
	{ "GETRTCTIMER",             1,   0,   0,   0},
	{ "GETRTCTIMEV",             1,   1,   0,   0},
	
	//new npc functions for npc scripts
	{ "NPCDEAD",                1,   0,   0,   0},
	{ "NPCKICKBUCKET",                0,   0,   0,   0},
	{ "NPCSTOPBGSFX",                0,   0,   0,   0},
	{ "NPCCANMOVE",                1,   0,   0,   0},
	{ "NPCNEWDIR8",                0,   0,   0,   0},
	{ "NPCNEWDIR",                0,   0,   0,   0},
	{ "NPCCONSTWALK",                0,   0,   0,   0},
	{ "NPCCONSTWALK8",                0,   0,   0,   0},
	{ "NPCVARWALK",                0,   0,   0,   0},
	{ "NPCVARWALK8",                0,   0,   0,   0},
	{ "NPCHALTWALK",                0,   0,   0,   0},
	{ "NPCHALTWALK8",                0,   0,   0,   0},
	{ "NPCFLOATWALK",                0,   0,   0,   0},
	// moved to a var: { "NPCLINEDUP",                0,   0,   0,   0},
	{ "NPCLINKINRANGE",                1,   0,   0,   0},
	{ "NPCATTACK",                0,   0,   0,   0},
	{ "NPCPLACEONAXIS",                0,   0,   0,   0},
	{ "NPCADD",                1,   0,   0,   0},
	{ "NPCFIREBREATH",                0,   0,   0,   0},
	{ "NPCCANSLIDE",                1,   0,   0,   0},
	{ "NPCSLIDE",                1,   0,   0,   0},
	{ "NPCHITWITH",                1,   0,   0,   0},
	{ "NPCGETINITDLABEL",                0,   0,   0,   0},
	// moved to a var: { "NPCCOLLISION",                0,   0,   0,   0}, //how to implement this?
	{ "GAMECONTINUE",             0,   0,   0,   0},
	{ "MAPDATAISSOLID",             1,   0,   0,   0},
	{ "SHOWF6SCREEN",             0,   0,   0,   0},
	{ "NPCDATAGETNAME",             1,   0,   0,   0},
	{ "PLAYENHMUSICEX",        2,   0,   0,   0},
	{ "GETENHMUSICPOS",          1,   0,   0,   0},
	{ "SETENHMUSICPOS",        1,   0,   0,   0},
	{ "SETENHMUSICSPEED",        1,   0,   0,   0},
	{ "ISVALIDBITMAP",         1,   0,   0,   0},
	{ "READBITMAP",        0,   0,   0,   0},
	{ "WRITEBITMAP",        0,   0,   0,   0},
	{ "ALLOCATEBITMAP",        1,   0,   0,   0},
	{ "CLEARBITMAP",        0,   0,   0,   0},
	{ "REGENERATEBITMAP",        0,   0,   0,   0},
	{ "BMPBLITTO",                0,   0,   0,   0},
	
	{ "BMPDRAWSCREENSOLIDR",                0,   0,   0,   0},
	{ "BMPDRAWSCREENCOMBOFR",                0,   0,   0,   0},
	{ "BMPDRAWSCREENCOMBOIR",                0,   0,   0,   0},
	{ "BMPDRAWSCREENCOMBOTR",                0,   0,   0,   0},
	{ "BMPDRAWSCREENSOLID2R",                0,   0,   0,   0},
	{ "GRAPHICSGETPIXEL",     1,   0,   0,   0},
	
	{ "BMPDRAWLAYERSOLIDR",     0,   0,   0,   0},
	{ "BMPDRAWLAYERCFLAGR",     0,   0,   0,   0},
	{ "BMPDRAWLAYERCTYPER",     0,   0,   0,   0},
	{ "BMPDRAWLAYERCIFLAGR",     0,   0,   0,   0},
	{ "BMPDRAWLAYERSOLIDITYR",     0,   0,   0,   0},
	{ "BMPMODE7",     0,   0,   0,   0},
	{ "BITMAPGETPIXEL",     0,   0,   0,   0},
	{ "NOP",                 0,   0,   0,   0},
	{ "STRINGCOMPARE",		       1,   0,   0,   0},
	{ "STRINGNCOMPARE",		       1,   0,   0,   0},
	{ "STRINGLENGTH",                2,   0,   0,   0},
	{ "STRINGCOPY",          2,   0,   0,   0},
	{ "CASTBOOLI",          1,   0,   0,   0},
	{ "CASTBOOLF",          1,   0,   0,   0},
	{ "SETTRUEI",             1,   0,   0,   0},
	{ "SETFALSEI",            1,   0,   0,   0},
	{ "SETMOREI",             1,   0,   0,   0},
	{ "SETLESSI",             1,   0,   0,   0},
	
	{ "ARRAYCOPY",          2,   0,   0,   0},
	{ "ARRAYNCOPY",		       1,   0,   0,   0},
	
	//1 INPUT, NO RETURN 
	{ "REMCHR",                2,   0,   0,   0},
	{ "STRINGUPPERLOWER",                2,   0,   0,   0},
	{ "STRINGLOWERUPPER",                2,   0,   0,   0},
	{ "STRINGCONVERTCASE",                2,   0,   0,   0},
	
	//1 input, 1 ret
	{ "XLEN",                2,   0,   0,   0},
	{ "XTOI",                2,   0,   0,   0},
	{ "ILEN",                2,   0,   0,   0},
	{ "ATOI",                2,   0,   0,   0},
	
	//2 INPUT, 1 RET, based on strcmp
	{ "STRCSPN",                1,   0,   0,   0},
	{ "STRSTR",                1,   0,   0,   0},
	{ "XTOA",                1,   0,   0,   0},
	{ "ITOA",                1,   0,   0,   0},
	{ "STRCAT",                1,   0,   0,   0},
	{ "STRSPN",                1,   0,   0,   0},
	{ "STRCHR",                1,   0,   0,   0},
	{ "STRRCHR",                1,   0,   0,   0},
	//2 INP, 1 RET OVERLOADS
	{ "XLEN2",                1,   0,   0,   0},
	{ "XTOI2",                1,   0,   0,   0},
	{ "ILEN2",                1,   0,   0,   0},
	{ "ATOI2",                1,   0,   0,   0},
	{ "REMCHR2",                1,   0,   0,   0},
	
	//3 INPUT 1 RET 
	{ "XTOA3",		       1,   0,   0,   0},
	{ "STRCATF",		       1,   0,   0,   0},
	{ "ITOA3",		       1,   0,   0,   0},
	{ "STRSTR3",		       1,   0,   0,   0},
	{ "REMNCHR3",		       1,   0,   0,   0},
	{ "STRCAT3",		       1,   0,   0,   0},
	{ "STRNCAT3",		       1,   0,   0,   0},
	{ "STRCHR3",		       1,   0,   0,   0},
	{ "STRRCHR3",		       1,   0,   0,   0},
	{ "STRSPN3",		       1,   0,   0,   0},
	{ "STRCSPN3",		       1,   0,   0,   0},
	
	
	{ "UPPERTOLOWER",                2,   0,   0,   0},
	{ "LOWERTOUPPER",                2,   0,   0,   0},
	{ "CONVERTCASE",                2,   0,   0,   0},
	//Game->Get
	{ "GETNPCSCRIPT",                1,   0,   0,   0},
	{ "GETLWEAPONSCRIPT",                1,   0,   0,   0},
	{ "GETEWEAPONSCRIPT",                1,   0,   0,   0},
	{ "GETHEROSCRIPT",                1,   0,   0,   0},
	{ "GETGLOBALSCRIPT",                1,   0,   0,   0},
	{ "GETDMAPSCRIPT",                1,   0,   0,   0},
	{ "GETSCREENSCRIPT",                1,   0,   0,   0},
	{ "GETSPRITESCRIPT",                1,   0,   0,   0},
	{ "GETUNTYPEDSCRIPT",                1,   0,   0,   0},
	{ "GETSUBSCREENSCRIPT",                1,   0,   0,   0},
	{ "GETNPCBYNAME",                1,  0,   0,   0},
	{ "GETITEMBYNAME",                1,   0,   0,   0},
	{ "GETCOMBOBYNAME",                1,   0,   0,   0},
	{ "GETDMAPBYNAME",                1,   0,   0,   0},
	
	{ "SRNDR",                1,   0,   0,   0},
	{ "SRNDV",                1,   1,   0,   0},
	{ "SRNDRND",              1,   0,   0,   0},
	{ "SAVEGAMESTRUCTS",                2,   0,   0,   0},
	{ "READGAMESTRUCTS",                2,   0,   0,   0},
	{ "ANDR32",                2,   0,   0,   0},
	{ "ANDV32",                2,   0,   1,   0},
	{ "ORR32",                 2,   0,   0,   0},
	{ "ORV32",                 2,   0,   1,   0},
	{ "XORR32",                2,   0,   0,   0},
	{ "XORV32",                2,   0,   1,   0},
	{ "BITNOT32",                 1,   0,   0,   0},
	{ "LSHIFTR32",             2,   0,   0,   0},
	{ "LSHIFTV32",             2,   0,   1,   0},
	{ "RSHIFTR32",             2,   0,   0,   0},
	{ "RSHIFTV32",             2,   0,   1,   0},
	{ "ISALLOCATEDBITMAP",         1,   0,   0,   0},
	{ "FONTHEIGHTR",            1,   0,   0,   0},
	{ "STRINGWIDTHR",           2,   0,   0,   0},
	{ "CHARWIDTHR",             2,   0,   0,   0},
	{ "MESSAGEWIDTHR",          1,   0,   0,   0},
	{ "MESSAGEHEIGHTR",         1,   0,   0,   0},
	{ "ISVALIDARRAY",         1,   0,   0,   0},
	{ "DIREXISTS",         1,   0,   0,   0},
	{ "GAMESAVEQUIT",         0,   0,   0,   0},
	{ "GAMESAVECONTINUE",         0,   0,   0,   0},
	{ "DRAWTILECLOAKEDR",                0,   0,   0,   0},
	{ "BMPDRAWTILECLOAKEDR",                0,   0,   0,   0},
	{ "DRAWCOMBOCLOAKEDR",                0,   0,   0,   0},
	{ "BMPDRAWCOMBOCLOAKEDR",                0,   0,   0,   0},
	{ "NPCKNOCKBACK",                2,   0,   0,   0},
	{ "CLOSEWIPE",                0,   0,   0,   0},
	{ "OPENWIPESHAPE",                1,   0,   0,   0},
	{ "CLOSEWIPESHAPE",                1,   0,   0,   0},
	{ "FILEEXISTS",                1,   0,   0,   0},
	{ "BITMAPCLEARTOCOLOR",                0,   0,   0,   0},
	{ "LOADNPCBYSUID",        1,   0,   0,   0},
	{ "LOADLWEAPONBYSUID",        1,   0,   0,   0},
	{ "LOADWEAPONCBYSUID",        1,   0,   0,   0},
	{ "LOADDROPSETR",       1,   0,   0,   0},
	{ "LOADTMPSCR",             1,   0,   0,   0},
	{ "LOADSCROLLSCR",             1,   0,   0,   0},
	{ "MAPDATAISSOLIDLYR",             1,   0,   0,   0},
	{ "ISSOLIDLAYER",             1,   0,   0,   0},
	{ "BREAKPOINT",             1,   0,   0,   0},
	{ "TOBYTE",           1,   0,   0,   0},
	{ "TOWORD",           1,   0,   0,   0},
	{ "TOSHORT",           1,   0,   0,   0},
	{ "TOSIGNEDBYTE",           1,   0,   0,   0},
	{ "TOINTEGER",           1,   0,   0,   0},
	{ "FLOOR",           1,   0,   0,   0},
	{ "CEILING",           1,   0,   0,   0},
	
	{ "FILECLOSE",           0,   0,   0,   0},
	{ "FILEFREE",           0,   0,   0,   0},
	{ "FILEISALLOCATED",           0,   0,   0,   0},
	{ "FILEISVALID",           0,   0,   0,   0},
	{ "FILEALLOCATE",           0,   0,   0,   0},
	{ "FILEFLUSH",           0,   0,   0,   0},
	{ "FILEGETCHAR",           0,   0,   0,   0},
	{ "FILEREWIND",           0,   0,   0,   0},
	{ "FILECLEARERR",           0,   0,   0,   0},
	
	{ "FILEOPEN",           1,   0,   0,   0},
	{ "FILECREATE",           1,   0,   0,   0},
	{ "FILEREADSTR",           1,   0,   0,   0},
	{ "FILEWRITESTR",           1,   0,   0,   0},
	{ "FILEPUTCHAR",           1,   0,   0,   0},
	{ "FILEUNGETCHAR",           1,   0,   0,   0},
	
	{ "FILEREADCHARS",           2,   0,   0,   0},
	{ "FILEREADINTS",           2,   0,   0,   0},
	{ "FILEWRITECHARS",           2,   0,   0,   0},
	{ "FILEWRITEINTS",           2,   0,   0,   0},
	{ "FILESEEK",           2,   0,   0,   0},
	{ "FILEOPENMODE",           2,   0,   0,   0},
	{ "FILEGETERROR",           1,   0,   0,   0},
	
	{ "BITMAPFREE",           0,   0,   0,   0},
	
	{ "POPARGS",           2,   0,   1,   0},
	{ "GAMERELOAD",           0,   0,   0,   0},
	
	{ "READPODARRAYR",           2,   0,   0,   0},
	{ "READPODARRAYV",           2,   0,   1,   0},
	{ "WRITEPODARRAYRR",           2,   0,   0,   0},
	{ "WRITEPODARRAYRV",           2,   0,   1,   0},
	{ "WRITEPODARRAYVR",           2,   1,   0,   0},
	{ "WRITEPODARRAYVV",           2,   1,   1,   0},
	
	{ "PRINTFV",           1,   1,   0,   0},
	{ "SPRINTFV",           1,   1,   0,   0},
	
	{ "STRCMPR",           2,   0,   0,   0},
	{ "STRICMPR",           2,   0,   0,   0},
	{ "STRINGICOMPARE",		       1,   0,   0,   0},
	{ "STRINGNICOMPARE",		       1,   0,   0,   0},
	
	{ "FILEREMOVE",		       0,   0,   0,   0},
	{ "FILESYSREMOVE",		       1,   0,   0,   0},
	
	{ "DRAWSTRINGR2",		       0,   0,   0,   0},
	{ "BMPDRAWSTRINGR2",		       0,   0,   0,   0},
	
	{ "",                    0,   0,   0,   0}
};


script_variable ZASMVars[]=
{
	//name                id                maxcount       multiple
	{ "D",                 D(0),                 8,             0 },
	{ "A",                 A(0),                 2,             0 },
	{ "DATA",              DATA,                 0,             0 },
	{ "CSET",              FCSET,                0,             0 },
	{ "DELAY",             DELAY,                0,             0 },
	{ "X",                 FX,                   0,             0 },
	{ "Y",                 FY,                   0,             0 },
	{ "XD",                XD,                   0,             0 },
	{ "YD",                YD,                   0,             0 },
	{ "XD2",               XD2,                  0,             0 },
	{ "YD2",               YD2,                  0,             0 },
	{ "FLAG",              FLAG,                 0,             0 },
	{ "WIDTH",             WIDTH,                0,             0 },
	{ "HEIGHT",            HEIGHT,               0,             0 },
	{ "LINK",              LINK,                 0,             0 },
	{ "FFFLAGSD",          FFFLAGSD,             0,             0 },
	{ "FFCWIDTH",          FFCWIDTH,             0,             0 },
	{ "FFCHEIGHT",         FFCHEIGHT,            0,             0 },
	{ "FFTWIDTH",          FFTWIDTH,             0,             0 },
	{ "FFTHEIGHT",         FFTHEIGHT,            0,             0 },
	{ "FFLINK",            FFLINK,               0,             0 },
	//{ "COMBOD",            COMBOD(0),          176,             3 },
	//{ "COMBOC",            COMBOC(0),          176,             3 },
	//{ "COMBOF",            COMBOF(0),          176,             3 },
	{ "INPUTSTART",        INPUTSTART,           0,             0 },
	{ "INPUTUP",           INPUTUP,              0,             0 },
	{ "INPUTDOWN",         INPUTDOWN,            0,             0 },
	{ "INPUTLEFT",         INPUTLEFT,            0,             0 },
	{ "INPUTRIGHT",        INPUTRIGHT,           0,             0 },
	{ "INPUTA",            INPUTA,               0,             0 },
	{ "INPUTB",            INPUTB,               0,             0 },
	{ "INPUTL",            INPUTL,               0,             0 },
	{ "INPUTR",            INPUTR,               0,             0 },
	{ "INPUTMOUSEX",       INPUTMOUSEX,          0,             0 },
	{ "INPUTMOUSEY",       INPUTMOUSEY,          0,             0 },
	{ "LINKX",             LINKX,                0,             0 },
	{ "LINKY",             LINKY,                0,             0 },
	{ "LINKZ",             LINKZ,                0,             0 },
	{ "LINKJUMP",          LINKJUMP,             0,             0 },
	{ "LINKDIR",           LINKDIR,              0,             0 },
	{ "LINKHITDIR",        LINKHITDIR,           0,             0 },
	{ "LINKHP",            LINKHP,               0,             0 },
	{ "LINKMP",            LINKMP,               0,             0 },
	{ "LINKMAXHP",         LINKMAXHP,            0,             0 },
	{ "LINKMAXMP",         LINKMAXMP,            0,             0 },
	{ "LINKACTION",        LINKACTION,           0,             0 },
	{ "LINKHELD",          LINKHELD,             0,             0 },
	{ "LINKITEMD",         LINKITEMD,            0,             0 },
	{ "LINKSWORDJINX",     LINKSWORDJINX,        0,             0 },
	{ "LINKITEMJINX",      LINKITEMJINX,         0,             0 },
	{ "LINKDRUNK",         LINKDRUNK,            0,             0 },
	{ "ITEMX",             ITEMX,                0,             0 },
	{ "ITEMY",             ITEMY,                0,             0 },
	{ "ITEMZ",             ITEMZ,                0,             0 },
	{ "ITEMJUMP",          ITEMJUMP,             0,             0 },
	{ "ITEMDRAWTYPE",      ITEMDRAWTYPE,         0,             0 },
	{ "ITEMID",            ITEMID,               0,             0 },
	{ "ITEMTILE",          ITEMTILE,             0,             0 },
	{ "ITEMOTILE",         ITEMOTILE,            0,             0 },
	{ "ITEMCSET",          ITEMCSET,             0,             0 },
	{ "ITEMFLASHCSET",     ITEMFLASHCSET,        0,             0 },
	{ "ITEMFRAMES",        ITEMFRAMES,           0,             0 },
	{ "ITEMFRAME",         ITEMFRAME,            0,             0 },
	{ "ITEMASPEED",        ITEMASPEED,           0,             0 },
	{ "ITEMDELAY",         ITEMDELAY,            0,             0 },
	{ "ITEMFLASH",         ITEMFLASH,            0,             0 },
	{ "ITEMFLIP",          ITEMFLIP,             0,             0 },
	{ "ITEMCOUNT",         ITEMCOUNT,            0,             0 },
	{ "IDATAFAMILY",       IDATAFAMILY,          0,             0 },
	{ "IDATALEVEL",        IDATALEVEL,           0,             0 },
	{ "IDATAKEEP",         IDATAKEEP,            0,             0 },
	{ "IDATAAMOUNT",       IDATAAMOUNT,          0,             0 },
	{ "IDATASETMAX",       IDATASETMAX,          0,             0 },
	{ "IDATAMAX",          IDATAMAX,             0,             0 },
	{ "IDATACOUNTER",      IDATACOUNTER,         0,             0 },
	{ "ITEMEXTEND",        ITEMEXTEND,           0,             0 },
	{ "NPCX",              NPCX,                 0,             0 },
	{ "NPCY",              NPCY,                 0,             0 },
	{ "NPCZ",              NPCZ,                 0,             0 },
	{ "NPCJUMP",           NPCJUMP,              0,             0 },
	{ "NPCDIR",            NPCDIR,               0,             0 },
	{ "NPCRATE",           NPCRATE,              0,             0 },
	{ "NPCSTEP",           NPCSTEP,              0,             0 },
	{ "NPCFRAMERATE",      NPCFRAMERATE,         0,             0 },
	{ "NPCHALTRATE",       NPCHALTRATE,          0,             0 },
	{ "NPCDRAWTYPE",       NPCDRAWTYPE,          0,             0 },
	{ "NPCHP",             NPCHP,                0,             0 },
	{ "NPCID",             NPCID,                0,             0 },
	{ "NPCDP",             NPCDP,                0,             0 },
	{ "NPCWDP",            NPCWDP,               0,             0 },
	{ "NPCOTILE",          NPCOTILE,             0,             0 },
	{ "NPCENEMY",          NPCENEMY,             0,             0 },
	{ "NPCWEAPON",         NPCWEAPON,            0,             0 },
	{ "NPCITEMSET",        NPCITEMSET,           0,             0 },
	{ "NPCCSET",           NPCCSET,              0,             0 },
	{ "NPCBOSSPAL",        NPCBOSSPAL,           0,             0 },
	{ "NPCBGSFX",          NPCBGSFX,             0,             0 },
	{ "NPCCOUNT",          NPCCOUNT,             0,             0 },
	{ "GD",                GD(0),              1024,             0 },
	{ "SDD",               SDD,                  0,             0 },
	{ "GDD",               GDD,                  0,             0 },
	{ "SDDD",              SDDD,                 0,             0 },
	{ "SCRDOORD",          SCRDOORD,             0,             0 },
	{ "GAMEDEATHS",        GAMEDEATHS,           0,             0 },
	{ "GAMECHEAT",         GAMECHEAT,            0,             0 },
	{ "GAMETIME",          GAMETIME,             0,             0 },
	{ "GAMEHASPLAYED",     GAMEHASPLAYED,        0,             0 },
	{ "GAMETIMEVALID",     GAMETIMEVALID,        0,             0 },
	{ "GAMEGUYCOUNT",      GAMEGUYCOUNT,         0,             0 },
	{ "GAMECONTSCR",       GAMECONTSCR,          0,             0 },
	{ "GAMECONTDMAP",      GAMECONTDMAP,         0,             0 },
	{ "GAMECOUNTERD",      GAMECOUNTERD,         0,             0 },
	{ "GAMEMCOUNTERD",     GAMEMCOUNTERD,        0,             0 },
	{ "GAMEDCOUNTERD",     GAMEDCOUNTERD,        0,             0 },
	{ "GAMEGENERICD",      GAMEGENERICD,         0,             0 },
	{ "GAMEMISC",      GAMEMISC,         0,             0 },
	{ "GAMEITEMSD",        GAMEITEMSD,           0,             0 },
	{ "GAMELITEMSD",       GAMELITEMSD,          0,             0 },
	{ "GAMELKEYSD",        GAMELKEYSD,           0,             0 },
	{ "SCREENSTATED",      SCREENSTATED,         0,             0 },
	{ "SCREENSTATEDD",     SCREENSTATEDD,        0,             0 },
	{ "GAMEGUYCOUNTD",     GAMEGUYCOUNTD,        0,             0 },
	{ "CURMAP",            CURMAP,               0,             0 },
	{ "CURSCR",            CURSCR,               0,             0 },
	{ "CURDSCR",           CURDSCR,              0,             0 },
	{ "CURDMAP",           CURDMAP,              0,             0 },
	{ "COMBODD",           COMBODD,              0,             0 },
	{ "COMBOCD",           COMBOCD,              0,             0 },
	{ "COMBOFD",           COMBOFD,              0,             0 },
	{ "COMBOTD",           COMBOTD,              0,             0 },
	{ "COMBOID",           COMBOID,              0,             0 },
	{ "COMBOSD",           COMBOSD,              0,             0 },
	{ "REFITEMCLASS",      REFITEMCLASS,         0,             0 },
	{ "REFITEM",           REFITEM,              0,             0 },
	{ "REFFFC",            REFFFC,               0,             0 },
	{ "REFLWPN",           REFLWPN,              0,             0 },
	{ "REFEWPN",           REFEWPN,              0,             0 },
	{ "REFLWPNCLASS",      REFLWPNCLASS,         0,             0 },
	{ "REFEWPNCLASS",      REFEWPNCLASS,         0,             0 },
	{ "REFNPC",            REFNPC,               0,             0 },
	{ "REFNPCCLASS",       REFNPCCLASS,          0,             0 },
	{ "LWPNX",             LWPNX,                0,             0 },
	{ "LWPNY",             LWPNY,                0,             0 },
	{ "LWPNZ",             LWPNZ,                0,             0 },
	{ "LWPNJUMP",          LWPNJUMP,             0,             0 },
	{ "LWPNDIR",           LWPNDIR,              0,             0 },
	{ "LWPNSTEP",          LWPNSTEP,             0,             0 },
	{ "LWPNANGULAR",       LWPNANGULAR,          0,             0 },
	{ "LWPNANGLE",         LWPNANGLE,            0,             0 },
	{ "LWPNDRAWTYPE",      LWPNDRAWTYPE,         0,             0 },
	{ "LWPNPOWER",         LWPNPOWER,            0,             0 },
	{ "LWPNDEAD",          LWPNDEAD,             0,             0 },
	{ "LWPNID",            LWPNID,               0,             0 },
	{ "LWPNTILE",          LWPNTILE,             0,             0 },
	{ "LWPNCSET",          LWPNCSET,             0,             0 },
	{ "LWPNFLASHCSET",     LWPNFLASHCSET,        0,             0 },
	{ "LWPNFRAMES",        LWPNFRAMES,           0,             0 },
	{ "LWPNFRAME",         LWPNFRAME,            0,             0 },
	{ "LWPNASPEED",        LWPNASPEED,           0,             0 },
	{ "LWPNFLASH",         LWPNFLASH,            0,             0 },
	{ "LWPNFLIP",          LWPNFLIP,             0,             0 },
	{ "LWPNCOUNT",         LWPNCOUNT,            0,             0 },
	{ "LWPNEXTEND",        LWPNEXTEND,           0,             0 },
	{ "LWPNOTILE",         LWPNOTILE,            0,             0 },
	{ "LWPNOCSET",         LWPNOCSET,            0,             0 },
	{ "EWPNX",             EWPNX,                0,             0 },
	{ "EWPNY",             EWPNY,                0,             0 },
	{ "EWPNZ",             EWPNZ,                0,             0 },
	{ "EWPNJUMP",          EWPNJUMP,             0,             0 },
	{ "EWPNDIR",           EWPNDIR,              0,             0 },
	{ "EWPNSTEP",          EWPNSTEP,             0,             0 },
	{ "EWPNANGULAR",       EWPNANGULAR,          0,             0 },
	{ "EWPNANGLE",         EWPNANGLE,            0,             0 },
	{ "EWPNDRAWTYPE",      EWPNDRAWTYPE,         0,             0 },
	{ "EWPNPOWER",         EWPNPOWER,            0,             0 },
	{ "EWPNDEAD",          EWPNDEAD,             0,             0 },
	{ "EWPNID",            EWPNID,               0,             0 },
	{ "EWPNTILE",          EWPNTILE,             0,             0 },
	{ "EWPNCSET",          EWPNCSET,             0,             0 },
	{ "EWPNFLASHCSET",     EWPNFLASHCSET,        0,             0 },
	{ "EWPNFRAMES",        EWPNFRAMES,           0,             0 },
	{ "EWPNFRAME",         EWPNFRAME,            0,             0 },
	{ "EWPNASPEED",        EWPNASPEED,           0,             0 },
	{ "EWPNFLASH",         EWPNFLASH,            0,             0 },
	{ "EWPNFLIP",          EWPNFLIP,             0,             0 },
	{ "EWPNCOUNT",         EWPNCOUNT,            0,             0 },
	{ "EWPNEXTEND",        EWPNEXTEND,           0,             0 },
	{ "EWPNOTILE",         EWPNOTILE,            0,             0 },
	{ "EWPNOCSET",         EWPNOCSET,            0,             0 },
	{ "NPCEXTEND",         NPCEXTEND,            0,             0 },
	{ "SP",                SP,                   0,             0 },
	{ "SP",                SP,                   0,             0 },
	{ "WAVY",              WAVY,                 0,             0 },
	{ "QUAKE",             QUAKE,                0,             0 },
	{ "IDATAUSESOUND",     IDATAUSESOUND,        0,             0 },
	{ "INPUTMOUSEZ",       INPUTMOUSEZ,          0,             0 },
	{ "INPUTMOUSEB",       INPUTMOUSEB,          0,             0 },
	{ "COMBODDM",          COMBODDM,             0,             0 },
	{ "COMBOCDM",           COMBOCDM,            0,             0 },
	{ "COMBOFDM",           COMBOFDM,            0,             0 },
	{ "COMBOTDM",           COMBOTDM,            0,             0 },
	{ "COMBOIDM",           COMBOIDM,            0,             0 },
	{ "COMBOSDM",           COMBOSDM,            0,             0 },
	{ "SCRIPTRAM",          SCRIPTRAM,           0,             0 },
	{ "GLOBALRAM",          GLOBALRAM,           0,             0 },
	{ "SCRIPTRAMD",         SCRIPTRAMD,          0,             0 },
	{ "GLOBALRAMD",         GLOBALRAMD,          0,             0 },
	{ "LWPNHXOFS",          LWPNHXOFS,           0,             0 },
	{ "LWPNHYOFS",          LWPNHYOFS,           0,             0 },
	{ "LWPNXOFS",           LWPNXOFS,            0,             0 },
	{ "LWPNYOFS",           LWPNYOFS,            0,             0 },
	{ "LWPNZOFS",           LWPNZOFS,            0,             0 },
	{ "LWPNHXSZ",           LWPNHXSZ,            0,             0 },
	{ "LWPNHYSZ",           LWPNHYSZ,            0,             0 },
	{ "LWPNHZSZ",           LWPNHZSZ,            0,             0 },
	{ "EWPNHXOFS",          EWPNHXOFS,           0,             0 },
	{ "EWPNHYOFS",          EWPNHYOFS,           0,             0 },
	{ "EWPNXOFS",           EWPNXOFS,            0,             0 },
	{ "EWPNYOFS",           EWPNYOFS,            0,             0 },
	{ "EWPNZOFS",           EWPNZOFS,            0,             0 },
	{ "EWPNHXSZ",           EWPNHXSZ,            0,             0 },
	{ "EWPNHYSZ",           EWPNHYSZ,            0,             0 },
	{ "EWPNHZSZ",           EWPNHZSZ,            0,             0 },
	{ "NPCHXOFS",           NPCHXOFS,            0,             0 },
	{ "NPCHYOFS",           NPCHYOFS,            0,             0 },
	{ "NPCXOFS",            NPCXOFS,             0,             0 },
	{ "NPCYOFS",            NPCYOFS,             0,             0 },
	{ "NPCZOFS",            NPCZOFS,             0,             0 },
	{ "NPCHXSZ",            NPCHXSZ,             0,             0 },
	{ "NPCHYSZ",            NPCHYSZ,             0,             0 },
	{ "NPCHZSZ",            NPCHZSZ,             0,             0 },
	{ "ITEMHXOFS",          ITEMHXOFS,           0,             0 },
	{ "ITEMHYOFS",          ITEMHYOFS,           0,             0 },
	{ "ITEMXOFS",           ITEMXOFS,            0,             0 },
	{ "ITEMYOFS",           ITEMYOFS,            0,             0 },
	{ "ITEMZOFS",           ITEMZOFS,            0,             0 },
	{ "ITEMHXSZ",           ITEMHXSZ,            0,             0 },
	{ "ITEMHYSZ",           ITEMHYSZ,            0,             0 },
	{ "ITEMHZSZ",           ITEMHZSZ,            0,             0 },
	{ "LWPNTXSZ",           LWPNTXSZ,            0,             0 },
	{ "LWPNTYSZ",           LWPNTYSZ,            0,             0 },
	{ "EWPNTXSZ",           EWPNTXSZ,            0,             0 },
	{ "EWPNTYSZ",           EWPNTYSZ,            0,             0 },
	{ "NPCTXSZ",            NPCTXSZ,             0,             0 },
	{ "NPCTYSZ",            NPCTYSZ,             0,             0 },
	{ "ITEMTXSZ",           ITEMTXSZ,            0,             0 },
	{ "ITEMTYSZ",           ITEMTYSZ,            0,             0 },
	{ "LINKHXOFS",          LINKHXOFS,           0,             0 },
	{ "LINKHYOFS",          LINKHYOFS,           0,             0 },
	{ "LINKXOFS",           LINKXOFS,            0,             0 },
	{ "LINKYOFS",           LINKYOFS,            0,             0 },
	{ "LINKZOFS",           LINKZOFS,            0,             0 },
	{ "LINKHXSZ",           LINKHXSZ,            0,             0 },
	{ "LINKHYSZ",           LINKHYSZ,            0,             0 },
	{ "LINKHZSZ",           LINKHZSZ,            0,             0 },
	{ "LINKTXSZ",           LINKTXSZ,            0,             0 },
	{ "LINKTYSZ",           LINKTYSZ,            0,             0 },
	{ "NPCTILE",            NPCTILE,             0,             0 },
	{ "LWPNBEHIND",         LWPNBEHIND,          0,             0 },
	{ "EWPNBEHIND",         EWPNBEHIND,          0,             0 },
	{ "SDDDD",              SDDDD,               0,             0 },
	{ "CURLEVEL",           CURLEVEL,            0,             0 },
	{ "ITEMPICKUP",         ITEMPICKUP,          0,             0 },
	{ "INPUTMAP",           INPUTMAP,            0,             0 },
	{ "LIT",                LIT,                 0,             0 },
	{ "INPUTEX1",           INPUTEX1,            0,             0 },
	{ "INPUTEX2",           INPUTEX2,            0,             0 },
	{ "INPUTEX3",           INPUTEX3,            0,             0 },
	{ "INPUTEX4",           INPUTEX4,            0,             0 },
	{ "INPUTPRESSSTART",    INPUTPRESSSTART,     0,             0 },
	{ "INPUTPRESSUP",       INPUTPRESSUP,        0,             0 },
	{ "INPUTPRESSDOWN",     INPUTPRESSDOWN,      0,             0 },
	{ "INPUTPRESSLEFT",     INPUTPRESSLEFT,      0,             0 },
	{ "INPUTPRESSRIGHT",    INPUTPRESSRIGHT,     0,             0 },
	{ "INPUTPRESSA",        INPUTPRESSA,         0,             0 },
	{ "INPUTPRESSB",        INPUTPRESSB,         0,             0 },
	{ "INPUTPRESSL",        INPUTPRESSL,         0,             0 },
	{ "INPUTPRESSR",        INPUTPRESSR,         0,             0 },
	{ "INPUTPRESSEX1",      INPUTPRESSEX1,       0,             0 },
	{ "INPUTPRESSEX2",      INPUTPRESSEX2,       0,             0 },
	{ "INPUTPRESSEX3",      INPUTPRESSEX3,       0,             0 },
	{ "INPUTPRESSEX4",      INPUTPRESSEX4,       0,             0 },
	{ "LWPNMISCD",          LWPNMISCD,           0,             0 },
	{ "EWPNMISCD",          EWPNMISCD,           0,             0 },
	{ "NPCMISCD",           NPCMISCD,            0,             0 },
	{ "ITEMMISCD",          ITEMMISCD,           0,             0 },
	{ "FFMISCD",            FFMISCD,             0,             0 },
	{ "GETMIDI",            GETMIDI,             0,             0 },
	{ "NPCHOMING",          NPCHOMING,           0,             0 },
	{ "NPCDD",			  NPCDD,			   0,             0 },
	{ "LINKEQUIP",		  LINKEQUIP,		   0,             0 },
	{ "INPUTAXISUP",        INPUTAXISUP,         0,             0 },
	{ "INPUTAXISDOWN",      INPUTAXISDOWN,       0,             0 },
	{ "INPUTAXISLEFT",      INPUTAXISLEFT,       0,             0 },
	{ "INPUTAXISRIGHT",     INPUTAXISRIGHT,      0,             0 },
	{ "PRESSAXISUP",        INPUTPRESSAXISUP,    0,             0 },
	{ "PRESSAXISDOWN",      INPUTPRESSAXISDOWN,  0,             0 },
	{ "PRESSAXISLEFT",      INPUTPRESSAXISLEFT,  0,             0 },
	{ "PRESSAXISRIGHT",     INPUTPRESSAXISRIGHT, 0,             0 },
	{ "NPCTYPE",			  NPCTYPE,             0,             0 },
	{ "FFSCRIPT",			  FFSCRIPT,            0,             0 },
	{ "SCREENFLAGSD",       SCREENFLAGSD,        0,             0 },
	{ "LINKINVIS",          LINKINVIS,           0,             0 },
	{ "LINKINVINC",         LINKINVINC,          0,             0 },
	{ "SCREENEFLAGSD",      SCREENEFLAGSD,       0,             0 },
	{ "NPCMFLAGS",          NPCMFLAGS,           0,             0 },
	{ "FFINITDD",           FFINITDD,            0,             0 },
	{ "LINKMISCD",          LINKMISCD,           0,             0 },
	{ "DMAPFLAGSD",         DMAPFLAGSD,          0,             0 },
	{ "LWPNCOLLDET",        LWPNCOLLDET,         0,             0 },
	{ "EWPNCOLLDET",        EWPNCOLLDET,         0,             0 },
	{ "NPCCOLLDET",         NPCCOLLDET,          0,             0 },
	{ "LINKLADDERX",        LINKLADDERX,         0,             0 },
	{ "LINKLADDERY",        LINKLADDERY,         0,             0 },
	{ "NPCSTUN",            NPCSTUN,             0,             0 },
	{ "NPCDEFENSED",        NPCDEFENSED,         0,             0 },
	{ "IDATAPOWER",         IDATAPOWER,          0,             0 },
	{ "DMAPLEVELD",         DMAPLEVELD,          0,             0 },
	{ "DMAPCOMPASSD",       DMAPCOMPASSD,        0,             0 },
	{ "DMAPCONTINUED",      DMAPCONTINUED,       0,             0 },
	{ "DMAPMIDID",          DMAPMIDID,           0,             0 },
	{ "IDATAINITDD",        IDATAINITDD,         0,             0 },
	{ "ROOMTYPE",           ROOMTYPE,            0,             0 },
	{ "ROOMDATA",           ROOMDATA,            0,             0 },
	{ "LINKTILE",           LINKTILE,            0,             0 },
	{ "LINKFLIP",           LINKFLIP,            0,             0 },
	{ "INPUTPRESSMAP",      INPUTPRESSMAP,       0,             0 },
	{ "NPCHUNGER",          NPCHUNGER,           0,             0 },
	{ "GAMESTANDALONE",     GAMESTANDALONE,      0,             0 },
	{ "GAMEENTRSCR",        GAMEENTRSCR,         0,             0 },
	{ "GAMEENTRDMAP",       GAMEENTRDMAP,        0,             0 },
	{ "GAMECLICKFREEZE",    GAMECLICKFREEZE,     0,             0 },
	{ "PUSHBLOCKX",         PUSHBLOCKX,          0,             0 },
	{ "PUSHBLOCKY",         PUSHBLOCKY,          0,             0 },
	{ "PUSHBLOCKCOMBO",     PUSHBLOCKCOMBO,      0,             0 },
	{ "PUSHBLOCKCSET",      PUSHBLOCKCSET,       0,             0 },
	{ "UNDERCOMBO",         UNDERCOMBO,          0,             0 },
	{ "UNDERCSET",          UNDERCSET,           0,             0 },
	{ "DMAPOFFSET",         DMAPOFFSET,          0,             0 },
	{ "DMAPMAP",            DMAPMAP,             0,             0 },
	{ "__RESERVED_FOR_GAMETHROTTLE",         __RESERVED_FOR_GAMETHROTTLE,            0,             0 },
	{ "REFMAPDATA",       REFMAPDATA,          0,             0 },
	{ "REFSCREENDATA",       REFSCREENDATA,          0,             0 },
	{ "REFCOMBODATA",       REFCOMBODATA,          0,             0 },
	{ "REFSPRITEDATA",       REFSPRITEDATA,          0,             0 },
	{ "REFBITMAP",       REFBITMAP,          0,             0 },
	{ "REFDMAPDATA",         REFDMAPDATA,            0,             0 },
	{ "REFSHOPDATA",         REFSHOPDATA,            0,             0 },
	{ "REFMSGDATA",         REFMSGDATA,            0,             0 },
	{ "REFUNTYPED",         REFUNTYPED,            0,             0 },
	{ "REFDROPS",         REFDROPS,            0,             0 },
	{ "REFPONDS",         REFPONDS,            0,             0 },
	{ "REFWARPRINGS",         REFWARPRINGS,            0,             0 },
	{ "REFDOORS",         REFDOORS,            0,             0 },
	{ "REFUICOLOURS",         REFUICOLOURS,            0,             0 },
	{ "REFRGB",         REFRGB,            0,             0 },
	{ "REFPALETTE",         REFPALETTE,            0,             0 },
	{ "REFTUNES",         REFTUNES,            0,             0 },
	{ "REFPALCYCLE",         REFPALCYCLE,            0,             0 },
	{ "REFGAMEDATA",         REFGAMEDATA,            0,             0 },
	{ "REFCHEATS",         REFCHEATS,            0,             0 },
	{ "IDATAMAGICTIMER",         IDATAMAGICTIMER,            0,             0 },
	{ "IDATALTM",         IDATALTM,            0,             0 },
	{ "IDATASCRIPT",         IDATASCRIPT,            0,             0 },
	{ "IDATAPSCRIPT",         IDATAPSCRIPT,            0,             0 },
	{ "IDATAMAGCOST",         IDATAMAGCOST,            0,             0 },
	{ "IDATAMINHEARTS",         IDATAMINHEARTS,            0,             0 },
	{ "IDATATILE",         IDATATILE,            0,             0 },
	{ "IDATAMISC",         IDATAMISC,            0,             0 },
	{ "IDATACSET",         IDATACSET,            0,             0 },
	{ "IDATAFRAMES",         IDATAFRAMES,            0,             0 },
	{ "IDATAASPEED",         IDATAASPEED,            0,             0 },
	{ "IDATADELAY",         IDATADELAY,            0,             0 },
	{ "IDATACOMBINE",         IDATACOMBINE,            0,             0 },
	{ "IDATADOWNGRADE",         IDATADOWNGRADE,            0,             0 },
	{ "IDATAPSTRING",         IDATAPSTRING,            0,             0 },
	{ "RESVD0023",         RESVD023,            0,             0 },
	{ "IDATAKEEPOLD",         IDATAKEEPOLD,            0,             0 },
	{ "IDATARUPEECOST",         IDATARUPEECOST,            0,             0 },
	{ "IDATAEDIBLE",         IDATAEDIBLE,            0,             0 },
	{ "IDATAFLAGUNUSED",         IDATAFLAGUNUSED,            0,             0 },
	{ "IDATAGAINLOWER",         IDATAGAINLOWER,            0,             0 },
	{ "RESVD0024",         RESVD024,            0,             0 },
	{ "RESVD0025",         RESVD025,            0,             0 },
	{ "RESVD0026",         RESVD026,            0,             0 },
	{ "IDATAID",         IDATAID,            0,             0 },
	{ "__RESERVED_FOR_LINKEXTEND",         __RESERVED_FOR_LINKEXTEND,            0,             0 },
	{ "NPCSCRDEFENSED",        NPCSCRDEFENSED,         0,             0 },
	{ "__RESERVED_FOR_SETLINKTILE",              __RESERVED_FOR_SETLINKTILE,                 0,             0 },
	{ "__RESERVED_FOR_SETLINKEXTEND",           __RESERVED_FOR_SETLINKEXTEND,            0,             0 },
	{ "__RESERVED_FOR_SIDEWARPSFX",           __RESERVED_FOR_SIDEWARPSFX,            0,             0 },
	{ "__RESERVED_FOR_PITWARPSFX",           __RESERVED_FOR_PITWARPSFX,            0,             0 },
	{ "__RESERVED_FOR_SIDEWARPVISUAL",           __RESERVED_FOR_SIDEWARPVISUAL,            0,             0 },
	{ "__RESERVED_FOR_PITWARPVISUAL",           __RESERVED_FOR_PITWARPVISUAL,            0,             0 },
	{ "GAMESETA",           GAMESETA,            0,             0 },
	{ "GAMESETB",           GAMESETB,            0,             0 },
	{ "SETITEMSLOT",           SETITEMSLOT,            0,             0 },
	{ "LINKITEMB",           LINKITEMB,            0,             0 },
	{ "LINKITEMA",           LINKITEMA,            0,             0 },
	{ "__RESERVED_FOR_LINKWALKTILE",           __RESERVED_FOR_LINKWALKTILE,            0,             0 }, //Walk sprite
	{ "__RESERVED_FOR_LINKFLOATTILE",           __RESERVED_FOR_LINKFLOATTILE,            0,             0 }, //float sprite
	{ "__RESERVED_FOR_LINKSWIMTILE",           __RESERVED_FOR_LINKSWIMTILE,            0,             0 }, //swim sprite
	{ "__RESERVED_FOR_LINKDIVETILE",           __RESERVED_FOR_LINKDIVETILE,            0,             0 }, //dive sprite
	{ "__RESERVED_FOR_LINKSLASHTILE",           __RESERVED_FOR_LINKSLASHTILE,            0,             0 }, //slash sprite
	{ "__RESERVED_FOR_LINKJUMPTILE",           __RESERVED_FOR_LINKJUMPTILE,            0,             0 }, //jump sprite
	{ "__RESERVED_FOR_LINKCHARGETILE",           __RESERVED_FOR_LINKCHARGETILE,            0,             0 }, //charge sprite
	{ "__RESERVED_FOR_LINKSTABTILE",           __RESERVED_FOR_LINKSTABTILE,            0,             0 }, //stab sprite
	{ "__RESERVED_FOR_LINKCASTTILE",           __RESERVED_FOR_LINKCASTTILE,            0,             0 }, //casting sprite
	{ "__RESERVED_FOR_LINKHOLD1LTILE",           __RESERVED_FOR_LINKHOLD1LTILE,            0,             0 }, //hold1land sprite
	{ "__RESERVED_FOR_LINKHOLD2LTILE",           __RESERVED_FOR_LINKHOLD2LTILE,            0,             0 }, //hold2land sprite
	{ "__RESERVED_FOR_LINKHOLD1WTILE",           __RESERVED_FOR_LINKHOLD1WTILE,            0,             0 }, //hold1water sprite
	{ "__RESERVED_FOR_LINKHOLD2WTILE",           __RESERVED_FOR_LINKHOLD2WTILE,            0,             0 }, //hold2water sprite
	{ "__RESERVED_FOR_LINKPOUNDTILE",           __RESERVED_FOR_LINKPOUNDTILE,            0,             0 }, //hammer pound sprite
	{ "__RESERVED_FOR_LINKSWIMSPD",           __RESERVED_FOR_LINKSWIMSPD,            0,             0 },
	{ "__RESERVED_FOR_LINKWALKANMSPD",           __RESERVED_FOR_LINKWALKANMSPD,            0,             0 },
	{ "__RESERVED_FOR_LINKANIMTYPE",           __RESERVED_FOR_LINKANIMTYPE,            0,             0 },
	{ "LINKINVFRAME",           LINKINVFRAME,            0,             0 },
	{ "LINKCANFLICKER",           LINKCANFLICKER,            0,             0 },
	{ "LINKHURTSFX",           LINKHURTSFX,            0,             0 },
	{ "NOACTIVESUBSC",           NOACTIVESUBSC,            0,             0 },
	{ "LWPNRANGE",         LWPNRANGE,            0,             0 },
	{ "ZELDAVERSION",         ZELDAVERSION,            0,             0 },
	{ "ZELDABUILD",         ZELDABUILD,            0,             0 },
	{ "ZELDABETA",         ZELDABETA,            0,             0 },
	{ "NPCINVINC",         NPCINVINC,            0,             0 },
	{ "NPCSUPERMAN",         NPCSUPERMAN,            0,             0 },
	{ "NPCHASITEM",         NPCHASITEM,            0,             0 },
	{ "NPCRINGLEAD",         NPCRINGLEAD,            0,             0 },
	{ "IDATAFRAME",         IDATAFRAME,            0,             0 },
	{ "ITEMACLK",         ITEMACLK,            0,             0 },
	{ "FFCID",         FFCID,            0,             0 },
	{ "IDATAATTRIB",         IDATAATTRIB,            0,             0 },
	{ "IDATASPRITE",         IDATASPRITE,            0,             0 },
	{ "IDATAFLAGS",         IDATAFLAGS,            0,             0 },
	{ "DMAPLEVELPAL",	DMAPLEVELPAL,          0,             0 },
	{ "__RESERVED_FOR_ITEMPTR",         __RESERVED_FOR_ITEMPTR,          0,             0 },
	{ "__RESERVED_FOR_NPCPTR",         __RESERVED_FOR_NPCPTR,          0,             0 },
	{ "__RESERVED_FOR_LWPNPTR",         __RESERVED_FOR_LWPNPTR,          0,             0 },
	{ "__RESERVED_FOR_EWPNPTR",         __RESERVED_FOR_EWPNPTR,          0,             0 },
	{ "SETSCREENDOOR",           SETSCREENDOOR,            0,             0 },
	{ "SETSCREENENEMY",           SETSCREENENEMY,            0,             0 },
	{ "GAMEMAXMAPS",          GAMEMAXMAPS,              0,             0 },
	{ "CREATELWPNDX", CREATELWPNDX, 0, 0 },
	{ "__RESERVED_FOR_SCREENFLAG",     __RESERVED_FOR_SCREENFLAG,        0,             0 },
	{ "BUTTONPRESS",	BUTTONPRESS,        0,             0 },
	{ "BUTTONINPUT",	BUTTONINPUT,        0,             0 },
	{ "BUTTONHELD",		BUTTONHELD,        0,             0 },
	{ "RAWKEY",		RAWKEY,        0,             0 },
	{ "READKEY",		READKEY,        0,             0 },
	{ "JOYPADPRESS",	JOYPADPRESS,        0,             0 },
	{ "DISABLEDITEM",	DISABLEDITEM,            0,             0 },
	{ "LINKDIAG",           LINKDIAG,            0,             0 },
	{ "LINKBIGHITBOX",           LINKBIGHITBOX,            0,             0 },
	{ "LINKEATEN", LINKEATEN, 0, 0 },
	{ "__RESERVED_FOR_LINKRETSQUARE", __RESERVED_FOR_LINKRETSQUARE, 0, 0 },
	{ "__RESERVED_FOR_LINKWARPSOUND", __RESERVED_FOR_LINKWARPSOUND, 0, 0 },
	{ "__RESERVED_FOR_PLAYPITWARPSFX", __RESERVED_FOR_PLAYPITWARPSFX, 0, 0 },
	{ "__RESERVED_FOR_WARPEFFECT", __RESERVED_FOR_WARPEFFECT, 0, 0 },
	{ "__RESERVED_FOR_PLAYWARPSOUND", __RESERVED_FOR_PLAYWARPSOUND, 0, 0 },
	{ "LINKUSINGITEM", LINKUSINGITEM, 0, 0 },
	{ "LINKUSINGITEMA", LINKUSINGITEMA, 0, 0 },
	{ "LINKUSINGITEMB", LINKUSINGITEMB, 0, 0 },
	//    { "DMAPLEVELPAL",         DMAPLEVELPAL,          0,             0 },
	//{ "LINKZHEIGHT",           LINKZHEIGHT,            0,             0 },
		//{ "ITEMINDEX",         ITEMINDEX,          0,             0 },
		//{ "LWPNINDEX",         LWPNINDEX,          0,             0 },
		//{ "EWPNINDEX",         EWPNINDEX,          0,             0 },
		//{ "NPCINDEX",         NPCINDEX,          0,             0 },
		//TABLE END
	{ "IDATAUSEWPN", IDATAUSEWPN, 0, 0 }, //UseWeapon
	{ "IDATAUSEDEF", IDATAUSEDEF, 0, 0 }, //UseDefense
	{ "IDATAWRANGE", IDATAWRANGE, 0, 0 }, //Range
	{ "IDATAUSEMVT", IDATAUSEMVT, 0, 0 }, //Movement[]
	{ "IDATADURATION", IDATADURATION, 0, 0 }, //Duration
	
	{ "IDATADUPLICATES", IDATADUPLICATES, 0, 0 }, //Duplicates
	{ "IDATADRAWLAYER", IDATADRAWLAYER, 0, 0 }, //DrawLayer
	{ "IDATACOLLECTFLAGS", IDATACOLLECTFLAGS, 0, 0 }, //CollectFlags
	{ "IDATAWEAPONSCRIPT", IDATAWEAPONSCRIPT, 0, 0 }, //WeaponScript
	{ "IDATAMISCD", IDATAMISCD, 0, 0 }, //WeaponMisc[32]
	{ "IDATAWEAPHXOFS", IDATAWEAPHXOFS, 0, 0 }, //WeaponHitXOffset
	{ "IDATAWEAPHYOFS", IDATAWEAPHYOFS, 0, 0 }, //WeaponHitYOffset
	{ "IDATAWEAPHXSZ", IDATAWEAPHYSZ, 0, 0 }, //WeaponHitWidth
	{ "IDATAWEAPHYSZ", IDATAWEAPHYSZ, 0, 0 }, //WeaponHitHeight
	{ "IDATAWEAPHZSZ", IDATAWEAPHZSZ, 0, 0 }, //WeaponHitZHeight
	{ "IDATAWEAPXOFS", IDATAWEAPXOFS, 0, 0 }, //WeaponDrawXOffset
	{ "IDATAWEAPYOFS", IDATAWEAPYOFS, 0, 0 }, //WeaponDrawYOffset
	{ "IDATAWEAPZOFS", IDATAWEAPZOFS, 0, 0 }, //WeaponDrawZOffset
	{ "IDATAWPNINITD", IDATAWPNINITD, 0, 0 }, //WeaponD[8]
	
	{ "NPCWEAPSPRITE", NPCWEAPSPRITE, 0, 0 }, //WeaponSprite
	
	{ "DEBUGREFFFC", DEBUGREFFFC, 0, 0 }, //REFFFC
	{ "DEBUGREFITEM", DEBUGREFITEM, 0, 0 }, //REFITEM
	{ "DEBUGREFNPC", DEBUGREFNPC, 0, 0 }, //REFNPC
	{ "DEBUGREFITEMDATA", DEBUGREFITEMDATA, 0, 0 }, //REFITEMCLASS
		{ "DEBUGREFLWEAPON", DEBUGREFLWEAPON, 0, 0 }, //REFLWPN
		{ "DEBUGREFEWEAPON", DEBUGREFEWEAPON, 0, 0 }, //REFEWPN
		{ "DEBUGSP", DEBUGSP, 0, 0 }, //SP
		{ "DEBUGGDR", DEBUGGDR, 0, 0 }, //GDR[256]
	{ "SCREENWIDTH",              SCREENWIDTH,                 0,             0 },
	{ "SCREENHEIGHT",              SCREENHEIGHT,                 0,             0 },
	{ "SCREENVIEWX",              SCREENVIEWX,                 0,             0 },
	{ "SCREENVIEWY",              SCREENVIEWY,                 0,             0 },
	{ "SCREENGUY",              SCREENGUY,                 0,             0 },
	{ "SCREENSTRING",              SCREENSTRING,                 0,             0 },
	{ "SCREENROOM",              SCREENROOM,                 0,             0 },
	{ "SCREENENTX",              SCREENENTX,                 0,             0 },
	{ "SCREENENTY",              SCREENENTY,                 0,             0 },
	{ "SCREENITEM",              SCREENITEM,                 0,             0 },
	{ "SCREENUNDCMB",              SCREENUNDCMB,                 0,             0 },
	{ "SCREENUNDCST",              SCREENUNDCST,                 0,             0 },
	{ "SCREENCATCH",              SCREENCATCH,                 0,             0 },
	{ "SETSCREENLAYOP",              SETSCREENLAYOP,                 0,             0 },
	{ "SETSCREENSECCMB",              SETSCREENSECCMB,                 0,             0 },
	{ "SETSCREENSECCST",              SETSCREENSECCST,                 0,             0 },
	{ "SETSCREENSECFLG",              SETSCREENSECFLG,                 0,             0 },
	{ "SETSCREENLAYMAP",              SETSCREENLAYMAP,                 0,             0 },
	{ "SETSCREENLAYSCR",              SETSCREENLAYSCR,                 0,             0 },
	{ "SETSCREENPATH",              SETSCREENPATH,                 0,             0 },
	{ "SETSCREENWARPRX",              SETSCREENWARPRX,                 0,             0 },
	{ "SETSCREENWARPRY",              SETSCREENWARPRY,                 0,             0 },
	{"GAMENUMMESSAGES", GAMENUMMESSAGES, 0, 0 },
	{"GAMESUBSCHEIGHT", GAMESUBSCHEIGHT, 0, 0 },
	{"GAMEPLAYFIELDOFS", GAMEPLAYFIELDOFS, 0, 0 },
	{"PASSSUBOFS", PASSSUBOFS, 0, 0 },
	

	//NPCData
	{"SETNPCDATASCRIPTDEF", SETNPCDATASCRIPTDEF, 0, 0 },
	{"SETNPCDATADEFENSE", SETNPCDATADEFENSE, 0, 0 },
	{"SETNPCDATASIZEFLAG", SETNPCDATASIZEFLAG, 0, 0 },
	{"SETNPCDATAATTRIBUTE", SETNPCDATAATTRIBUTE, 0, 0 },
	
	{"SCDBLOCKWEAPON", SCDBLOCKWEAPON, 0, 0 },
	{"SCDSTRIKEWEAPONS", SCDSTRIKEWEAPONS, 0, 0 },
	{"SCDEXPANSION", SCDEXPANSION, 0, 0 },
	{"SETGAMEOVERELEMENT", SETGAMEOVERELEMENT, 0, 0 },
	{"SETGAMEOVERSTRING", SETGAMEOVERSTRING, 0, 0 },
	{"MOUSEARR", MOUSEARR, 0, 0 },
	
	{"IDATAOVERRIDEFLWEAP", IDATAOVERRIDEFLWEAP, 0, 0 },
	{"IDATATILEHWEAP", IDATATILEHWEAP, 0, 0 },
	{"IDATATILEWWEAP", IDATATILEWWEAP, 0, 0 },
	{"IDATAHZSZWEAP", IDATAHZSZWEAP, 0, 0 },
	{"IDATAHYSZWEAP", IDATAHYSZWEAP, 0, 0 },
	{"IDATAHXSZWEAP", IDATAHXSZWEAP, 0, 0 },
	{"IDATADYOFSWEAP", IDATADYOFSWEAP, 0, 0 },
	{"IDATADXOFSWEAP", IDATADXOFSWEAP, 0, 0 },
	{"IDATAHYOFSWEAP", IDATAHYOFSWEAP, 0, 0 },
	{"IDATAHXOFSWEAP", IDATAHXOFSWEAP, 0, 0 },
	{"IDATAOVERRIDEFL", IDATAOVERRIDEFL, 0, 0 },
	{"IDATAPICKUP", IDATAPICKUP, 0, 0 },
	{"IDATATILEH", IDATATILEH, 0, 0 },
	{"IDATATILEW", IDATATILEW, 0, 0 },
	{"IDATAHZSZ", IDATAHZSZ, 0, 0 },
	{"IDATAHYSZ", IDATAHYSZ, 0, 0 },
	{"IDATAHXSZ", IDATAHXSZ, 0, 0 },
	{"IDATADYOFS", IDATADYOFS, 0, 0 },
	{"IDATADXOFS", IDATADXOFS, 0, 0 },
	{"IDATAHYOFS", IDATAHYOFS, 0, 0 },
	{"IDATAHXOFS", IDATAHXOFS, 0, 0 },
	//spritedata sd->
	{"SPRITEDATATILE", SPRITEDATATILE, 0, 0 },
	{"SPRITEDATAMISC", SPRITEDATAMISC, 0, 0 },
	{"SPRITEDATACSETS", SPRITEDATACSETS, 0, 0 },
	{"SPRITEDATAFRAMES", SPRITEDATAFRAMES, 0, 0 },
	{"SPRITEDATASPEED", SPRITEDATASPEED, 0, 0 },
	{"SPRITEDATATYPE", SPRITEDATATYPE, 0, 0 },
	
	//npcdata nd->
	{"NPCDATATILE", NPCDATATILE, 0, 0 },
	{"NPCDATAHEIGHT", NPCDATAHEIGHT, 0, 0 },
	{"NPCDATAFLAGS", NPCDATAFLAGS, 0, 0 },
	{"NPCDATAFLAGS2", NPCDATAFLAGS2, 0, 0 },
	{"NPCDATAWIDTH", NPCDATAWIDTH, 0, 0 },
	{"NPCDATAHITSFX", NPCDATAHITSFX, 0, 0 },
	{"NPCDATASTILE", NPCDATASTILE, 0, 0 },
	{"NPCDATASWIDTH", NPCDATASWIDTH, 0, 0 },
	{"NPCDATASHEIGHT", NPCDATASHEIGHT, 0, 0 },
	{"NPCDATAETILE", NPCDATAETILE, 0, 0 },
	{"NPCDATAEWIDTH", NPCDATAEWIDTH, 0, 0 },
	{"NPCDATAEHEIGHT", NPCDATAEHEIGHT, 0, 0 },
	{"NPCDATAHP", NPCDATAHP, 0, 0 },
	{"NPCDATAFAMILY", NPCDATAFAMILY, 0, 0 },
	{"NPCDATACSET", NPCDATACSET, 0, 0 },
	{"NPCDATAANIM", NPCDATAANIM, 0, 0 },
	{"NPCDATAEANIM", NPCDATAEANIM, 0, 0 },
	{"NPCDATAFRAMERATE", NPCDATAFRAMERATE, 0, 0 },
	{"NPCDATAEFRAMERATE", NPCDATAEFRAMERATE, 0, 0 },
	{"NPCDATATOUCHDAMAGE", NPCDATATOUCHDAMAGE, 0, 0 },
	{"NPCDATAWEAPONDAMAGE", NPCDATAWEAPONDAMAGE, 0, 0 },
	{"NPCDATAWEAPON", NPCDATAWEAPON, 0, 0 },
	{"NPCDATARANDOM", NPCDATARANDOM, 0, 0 },
	{"NPCDATAHALT", NPCDATAHALT, 0, 0 },
	{"NPCDATASTEP", NPCDATASTEP, 0, 0 },
	{"NPCDATAHOMING", NPCDATAHOMING, 0, 0 },
	{"NPCDATAHUNGER", NPCDATAHUNGER, 0, 0 },
	{"NPCDATADROPSET", NPCDATADROPSET, 0, 0 },
	{"NPCDATABGSFX", NPCDATABGSFX, 0, 0 },
	{"NPCDATADEATHSFX", NPCDATADEATHSFX, 0, 0 },
	{"NPCDATAXOFS", NPCDATAXOFS, 0, 0 },
	{"NPCDATAYOFS", NPCDATAYOFS, 0, 0 },
	{"NPCDATAZOFS", NPCDATAZOFS, 0, 0 },
	{"NPCDATAHXOFS", NPCDATAHXOFS, 0, 0 },
	{"NPCDATAHYOFS", NPCDATAHYOFS, 0, 0 },
	{"NPCDATAHITWIDTH", NPCDATAHITWIDTH, 0, 0 },
	{"NPCDATAHITHEIGHT", NPCDATAHITHEIGHT, 0, 0 },
	{"NPCDATAHITZ", NPCDATAHITZ, 0, 0 },
	{"NPCDATATILEWIDTH", NPCDATATILEWIDTH, 0, 0 },
	{"NPCDATATILEHEIGHT", NPCDATATILEHEIGHT, 0, 0 },
	{"NPCDATAWPNSPRITE", NPCDATAWPNSPRITE, 0, 0 },
	{"NPCDATADEFENSE", NPCDATADEFENSE, 0, 0 },
	{"NPCDATASIZEFLAG", NPCDATASIZEFLAG, 0, 0 },
	{"NPCDATAATTRIBUTE", NPCDATAATTRIBUTE, 0, 0 },
	
	{"NPCDATAFROZENTILE", NPCDATAFROZENTILE, 0, 0 },
	{"NPCDATAFROZENCSET", NPCDATAFROZENCSET, 0, 0 },
	
	//mapdata md->
	{"MAPDATAVALID", MAPDATAVALID, 0, 0 },
	{"MAPDATAGUY", MAPDATAGUY, 0, 0 },
	{"MAPDATASTRING", MAPDATASTRING, 0, 0 },
	{"MAPDATAROOM", MAPDATAROOM, 0, 0 },
	{"MAPDATAITEM", MAPDATAITEM, 0, 0 },
	{"MAPDATAHASITEM", MAPDATAHASITEM, 0, 0 },
	{"MAPDATATILEWARPTYPE", MAPDATATILEWARPTYPE, 0, 0 },
	{"MAPDATATILEWARPOVFLAGS", MAPDATATILEWARPOVFLAGS, 0, 0 },
	{"MAPDATADOORCOMBOSET", MAPDATADOORCOMBOSET, 0, 0 },
	{"MAPDATAWARPRETX", MAPDATAWARPRETX, 0, 0 },
	{"MAPDATAWARPRETY", MAPDATAWARPRETY, 0, 0 },
	{"MAPDATAWARPRETURNC", MAPDATAWARPRETURNC, 0, 0 },
	{"MAPDATASTAIRX", MAPDATASTAIRX, 0, 0 },
	{"MAPDATASTAIRY", MAPDATASTAIRY, 0, 0 },
	{"MAPDATACOLOUR", MAPDATACOLOUR, 0, 0 },
	{"MAPDATAENEMYFLAGS", MAPDATAENEMYFLAGS, 0, 0 },
	{"MAPDATADOOR", MAPDATADOOR, 0, 0 },
	{"MAPDATATILEWARPDMAP", MAPDATATILEWARPDMAP, 0, 0 },
	{"MAPDATATILEWARPSCREEN", MAPDATATILEWARPSCREEN, 0, 0 },
	{"MAPDATAEXITDIR", MAPDATAEXITDIR, 0, 0 },
	{"MAPDATAENEMY", MAPDATAENEMY, 0, 0 },
	{"MAPDATAPATTERN", MAPDATAPATTERN, 0, 0 },
	{"MAPDATASIDEWARPTYPE", MAPDATASIDEWARPTYPE, 0, 0 },
	{"MAPDATASIDEWARPOVFLAGS", MAPDATASIDEWARPOVFLAGS, 0, 0 },
	{"MAPDATAWARPARRIVALX", MAPDATAWARPARRIVALX, 0, 0 },
	{"MAPDATAWARPARRIVALY", MAPDATAWARPARRIVALY, 0, 0 },
	{"MAPDATAPATH", MAPDATAPATH, 0, 0 },
	{"MAPDATASIDEWARPSC", MAPDATASIDEWARPSC, 0, 0 },
	{"MAPDATASIDEWARPDMAP", MAPDATASIDEWARPDMAP, 0, 0 },
	{"MAPDATASIDEWARPINDEX", MAPDATASIDEWARPINDEX, 0, 0 },
	{"MAPDATAUNDERCOMBO", MAPDATAUNDERCOMBO, 0, 0 },
	{"MAPDATAUNDERCSET", MAPDATAUNDERCSET, 0, 0 },
	{"MAPDATACATCHALL", MAPDATACATCHALL, 0, 0 },
	{"MAPDATAFLAGS", MAPDATAFLAGS, 0, 0 },
	{"MAPDATACSENSITIVE", MAPDATACSENSITIVE, 0, 0 },
	{"MAPDATANORESET", MAPDATANORESET, 0, 0 },
	{"MAPDATANOCARRY", MAPDATANOCARRY, 0, 0 },
	{"MAPDATALAYERMAP", MAPDATALAYERMAP, 0, 0 },
	{"MAPDATALAYERSCREEN", MAPDATALAYERSCREEN, 0, 0 },
	{"MAPDATALAYEROPACITY", MAPDATALAYEROPACITY, 0, 0 },
	{"MAPDATATIMEDWARPTICS", MAPDATATIMEDWARPTICS, 0, 0 },
	{"MAPDATANEXTMAP", MAPDATANEXTMAP, 0, 0 },
	{"MAPDATANEXTSCREEN", MAPDATANEXTSCREEN, 0, 0 },
	{"MAPDATASECRETCOMBO", MAPDATASECRETCOMBO, 0, 0 },
	{"MAPDATASECRETCSET", MAPDATASECRETCSET, 0, 0 },
	{"MAPDATASECRETFLAG", MAPDATASECRETFLAG, 0, 0 },
	{"MAPDATAVIEWX", MAPDATAVIEWX, 0, 0 },
	{"MAPDATAVIEWY", MAPDATAVIEWY, 0, 0 },
	{"MAPDATASCREENWIDTH", MAPDATASCREENWIDTH, 0, 0 },
	{"MAPDATASCREENHEIGHT", MAPDATASCREENHEIGHT, 0, 0 },
	{"MAPDATAENTRYX", MAPDATAENTRYX, 0, 0 },
	{"MAPDATAENTRYY", MAPDATAENTRYY, 0, 0 },
	{"MAPDATANUMFF", MAPDATANUMFF, 0, 0 },
	{"MAPDATAFFDATA", MAPDATAFFDATA, 0, 0 },
	{"MAPDATAFFCSET", MAPDATAFFCSET, 0, 0 },
	{"MAPDATAFFDELAY", MAPDATAFFDELAY, 0, 0 },
	{"MAPDATAFFX", MAPDATAFFX, 0, 0 },
	{"MAPDATAFFY", MAPDATAFFY, 0, 0 },
	{"MAPDATAFFXDELTA", MAPDATAFFXDELTA, 0, 0 },
	{"MAPDATAFFYDELTA", MAPDATAFFYDELTA, 0, 0 },
	{"MAPDATAFFXDELTA2", MAPDATAFFXDELTA2, 0, 0 },
	{"MAPDATAFFYDELTA2", MAPDATAFFYDELTA2, 0, 0 },
	{"MAPDATAFFFLAGS", MAPDATAFFFLAGS, 0, 0 },
	{"MAPDATAFFWIDTH", MAPDATAFFWIDTH, 0, 0 },
	{"MAPDATAFFHEIGHT", MAPDATAFFHEIGHT, 0, 0 },
	{"MAPDATAFFLINK", MAPDATAFFLINK, 0, 0 },
	{"MAPDATAFFSCRIPT", MAPDATAFFSCRIPT, 0, 0 },
	{"MAPDATAINTID", MAPDATAINTID, 0, 0 }, //Needs to be a function [32][10]
	{"MAPDATAINITA", MAPDATAINITA, 0, 0 }, //needs to be a function, [32][2]
	{"MAPDATAFFINITIALISED", MAPDATAFFINITIALISED, 0, 0 },
	{"MAPDATASCRIPTENTRY", MAPDATASCRIPTENTRY, 0, 0 },
	{"MAPDATASCRIPTOCCUPANCY", MAPDATASCRIPTOCCUPANCY, 0, 0 },
	{"MAPDATASCRIPTEXIT", MAPDATASCRIPTEXIT, 0, 0 },
	{"MAPDATAOCEANSFX", MAPDATAOCEANSFX, 0, 0 },
	{"MAPDATABOSSSFX", MAPDATABOSSSFX, 0, 0 },
	{"MAPDATASECRETSFX", MAPDATASECRETSFX, 0, 0 },
	{"MAPDATAHOLDUPSFX", MAPDATAHOLDUPSFX, 0, 0 },
	{"MAPDATASCREENMIDI", MAPDATASCREENMIDI, 0, 0 },
	{"MAPDATALENSLAYER", MAPDATALENSLAYER, 0, 0 },
	{"MAPDATAMISCD", MAPDATAMISCD, 0, 0},
	
	{"MAPDATASCREENSTATED", MAPDATASCREENSTATED, 0, 0},
	{"MAPDATASCREENFLAGSD", MAPDATASCREENFLAGSD, 0, 0},
	{"MAPDATASCREENEFLAGSD", MAPDATASCREENEFLAGSD, 0, 0},
	
	
	
	{"MAPDATACOMBODD", MAPDATACOMBODD, 0, 0},
	{"MAPDATACOMBOCD", MAPDATACOMBOCD, 0, 0},
	{"MAPDATACOMBOFD", MAPDATACOMBOFD, 0, 0},
	{"MAPDATACOMBOTD", MAPDATACOMBOTD, 0, 0},
	{"MAPDATACOMBOID", MAPDATACOMBOID, 0, 0},
	{"MAPDATACOMBOSD", MAPDATACOMBOSD, 0, 0},
	
		{"SCREENDATAVALID", SCREENDATAVALID, 0, 0 },
	{"SCREENDATAGUY", SCREENDATAGUY, 0, 0 },
	{"SCREENDATASTRING", SCREENDATASTRING, 0, 0 },
	{"SCREENDATAROOM", SCREENDATAROOM, 0, 0 },
	{"SCREENDATAITEM", SCREENDATAITEM, 0, 0 },
	{"SCREENDATAHASITEM", SCREENDATAHASITEM, 0, 0 },
	{"SCREENDATATILEWARPTYPE", SCREENDATATILEWARPTYPE, 0, 0 },
	{"SCREENDATATILEWARPOVFLAGS", SCREENDATATILEWARPOVFLAGS, 0, 0 },
	{"SCREENDATADOORCOMBOSET", SCREENDATADOORCOMBOSET, 0, 0 },
	{"SCREENDATAWARPRETX", SCREENDATAWARPRETX, 0, 0 },
	{"SCREENDATAWARPRETY", SCREENDATAWARPRETY, 0, 0 },
	{"SCREENDATAWARPRETURNC", SCREENDATAWARPRETURNC, 0, 0 },
	{"SCREENDATASTAIRX", SCREENDATASTAIRX, 0, 0 },
	{"SCREENDATASTAIRY", SCREENDATASTAIRY, 0, 0 },
	{"SCREENDATACOLOUR", SCREENDATACOLOUR, 0, 0 },
	{"SCREENDATAENEMYFLAGS", SCREENDATAENEMYFLAGS, 0, 0 },
	{"SCREENDATADOOR", SCREENDATADOOR, 0, 0 },
	{"SCREENDATATILEWARPDMAP", SCREENDATATILEWARPDMAP, 0, 0 },
	{"SCREENDATATILEWARPSCREEN", SCREENDATATILEWARPSCREEN, 0, 0 },
	{"SCREENDATAEXITDIR", SCREENDATAEXITDIR, 0, 0 },
	{"SCREENDATAENEMY", SCREENDATAENEMY, 0, 0 },
	{"SCREENDATAPATTERN", SCREENDATAPATTERN, 0, 0 },
	{"SCREENDATASIDEWARPTYPE", SCREENDATASIDEWARPTYPE, 0, 0 },
	{"SCREENDATASIDEWARPOVFLAGS", SCREENDATASIDEWARPOVFLAGS, 0, 0 },
	{"SCREENDATAWARPARRIVALX", SCREENDATAWARPARRIVALX, 0, 0 },
	{"SCREENDATAWARPARRIVALY", SCREENDATAWARPARRIVALY, 0, 0 },
	{"SCREENDATAPATH", SCREENDATAPATH, 0, 0 },
	{"SCREENDATASIDEWARPSC", SCREENDATASIDEWARPSC, 0, 0 },
	{"SCREENDATASIDEWARPDMAP", SCREENDATASIDEWARPDMAP, 0, 0 },
	{"SCREENDATASIDEWARPINDEX", SCREENDATASIDEWARPINDEX, 0, 0 },
	{"SCREENDATAUNDERCOMBO", SCREENDATAUNDERCOMBO, 0, 0 },
	{"SCREENDATAUNDERCSET", SCREENDATAUNDERCSET, 0, 0 },
	{"SCREENDATACATCHALL", SCREENDATACATCHALL, 0, 0 },
	{"SCREENDATAFLAGS", SCREENDATAFLAGS, 0, 0 },
	{"SCREENDATACSENSITIVE", SCREENDATACSENSITIVE, 0, 0 },
	{"SCREENDATANORESET", SCREENDATANORESET, 0, 0 },
	{"SCREENDATANOCARRY", SCREENDATANOCARRY, 0, 0 },
	{"SCREENDATALAYERMAP", SCREENDATALAYERMAP, 0, 0 },
	{"SCREENDATALAYERSCREEN", SCREENDATALAYERSCREEN, 0, 0 },
	{"SCREENDATALAYEROPACITY", SCREENDATALAYEROPACITY, 0, 0 },
	{"SCREENDATATIMEDWARPTICS", SCREENDATATIMEDWARPTICS, 0, 0 },
	{"SCREENDATANEXTMAP", SCREENDATANEXTMAP, 0, 0 },
	{"SCREENDATANEXTSCREEN", SCREENDATANEXTSCREEN, 0, 0 },
	{"SCREENDATASECRETCOMBO", SCREENDATASECRETCOMBO, 0, 0 },
	{"SCREENDATASECRETCSET", SCREENDATASECRETCSET, 0, 0 },
	{"SCREENDATASECRETFLAG", SCREENDATASECRETFLAG, 0, 0 },
	{"SCREENDATAVIEWX", SCREENDATAVIEWX, 0, 0 },
	{"SCREENDATAVIEWY", SCREENDATAVIEWY, 0, 0 },
	{"SCREENDATASCREENWIDTH", SCREENDATASCREENWIDTH, 0, 0 },
	{"SCREENDATASCREENHEIGHT", SCREENDATASCREENHEIGHT, 0, 0 },
	{"SCREENDATAENTRYX", SCREENDATAENTRYX, 0, 0 },
	{"SCREENDATAENTRYY", SCREENDATAENTRYY, 0, 0 },
	{"SCREENDATANUMFF", SCREENDATANUMFF, 0, 0 },
	{"SCREENDATAFFDATA", SCREENDATAFFDATA, 0, 0 },
	{"SCREENDATAFFCSET", SCREENDATAFFCSET, 0, 0 },
	{"SCREENDATAFFDELAY", SCREENDATAFFDELAY, 0, 0 },
	{"SCREENDATAFFX", SCREENDATAFFX, 0, 0 },
	{"SCREENDATAFFY", SCREENDATAFFY, 0, 0 },
	{"SCREENDATAFFXDELTA", SCREENDATAFFXDELTA, 0, 0 },
	{"SCREENDATAFFYDELTA", SCREENDATAFFYDELTA, 0, 0 },
	{"SCREENDATAFFXDELTA2", SCREENDATAFFXDELTA2, 0, 0 },
	{"SCREENDATAFFYDELTA2", SCREENDATAFFYDELTA2, 0, 0 },
	{"SCREENDATAFFFLAGS", SCREENDATAFFFLAGS, 0, 0 },
	{"SCREENDATAFFWIDTH", SCREENDATAFFWIDTH, 0, 0 },
	{"SCREENDATAFFHEIGHT", SCREENDATAFFHEIGHT, 0, 0 },
	{"SCREENDATAFFLINK", SCREENDATAFFLINK, 0, 0 },
	{"SCREENDATAFFSCRIPT", SCREENDATAFFSCRIPT, 0, 0 },
	{"SCREENDATAINTID", SCREENDATAINTID, 0, 0 }, //Needs to be a function [32][10]
	{"SCREENDATAINITA", SCREENDATAINITA, 0, 0 }, //needs to be a function, [32][2]
	{"SCREENDATAFFINITIALISED", SCREENDATAFFINITIALISED, 0, 0 },
	{"SCREENDATASCRIPTENTRY", SCREENDATASCRIPTENTRY, 0, 0 },
	{"SCREENDATASCRIPTOCCUPANCY", SCREENDATASCRIPTOCCUPANCY, 0, 0 },
	{"SCREENDATASCRIPTEXIT", SCREENDATASCRIPTEXIT, 0, 0 },
	{"SCREENDATAOCEANSFX", SCREENDATAOCEANSFX, 0, 0 },
	{"SCREENDATABOSSSFX", SCREENDATABOSSSFX, 0, 0 },
	{"SCREENDATASECRETSFX", SCREENDATASECRETSFX, 0, 0 },
	{"SCREENDATAHOLDUPSFX", SCREENDATAHOLDUPSFX, 0, 0 },
	{"SCREENDATASCREENMIDI", SCREENDATASCREENMIDI, 0, 0 },
	{"SCREENDATALENSLAYER", SCREENDATALENSLAYER, 0, 0 },
	
	{"LINKSCRIPTTILE", LINKSCRIPTTILE, 0, 0 },
	{"LINKSCRIPFLIP", LINKSCRIPFLIP, 0, 0 },
	{"MAPDATAITEMX", MAPDATAITEMX, 0, 0 },
	{"MAPDATAITEMY", MAPDATAITEMY, 0, 0 },
	{"SCREENDATAITEMX", SCREENDATAITEMX, 0, 0 },
	{"SCREENDATAITEMY", SCREENDATAITEMY, 0, 0 },
	
	{"MAPDATAFFEFFECTWIDTH", MAPDATAFFEFFECTWIDTH, 0, 0 },
	{"MAPDATAFFEFFECTHEIGHT", MAPDATAFFEFFECTHEIGHT, 0, 0 },
	{"SCREENDATAFFEFFECTWIDTH", SCREENDATAFFEFFECTWIDTH, 0, 0 },
	{"SCREENDATAFFEFFECTHEIGHT", SCREENDATAFFEFFECTHEIGHT, 0, 0 },
	
	{"LOADMAPDATA", LOADMAPDATA, 0, 0 },
	{"LWPNPARENT", LWPNPARENT, 0, 0 },
	{"LWPNLEVEL", LWPNLEVEL, 0, 0 },
	{"EWPNLEVEL", EWPNLEVEL, 0, 0 },
	{"EWPNPARENT", EWPNPARENT, 0, 0 },
	
	
	{"SHOPDATANAME", SHOPDATANAME, 0, 0 },
	{"SHOPDATAITEM", SHOPDATAITEM, 0, 0 },
	{"SHOPDATAHASITEM", SHOPDATAHASITEM, 0, 0 },
	{"SHOPDATAPRICE", SHOPDATAPRICE, 0, 0 },
	{"SHOPDATASTRING", SHOPDATASTRING, 0, 0 },
	
	{"NPCDATASHIELD", NPCDATASHIELD, 0, 0 },
	{"NPCSHIELD", NPCSHIELD, 0, 0 },
	{"AUDIOVOLUME", AUDIOVOLUME, 0, 0 },
	{"AUDIOPAN", AUDIOPAN, 0, 0 },
	
	{"MESSAGEDATANEXT", MESSAGEDATANEXT, 0, 0 },
	{"MESSAGEDATATILE", MESSAGEDATATILE, 0, 0 },
	{"MESSAGEDATACSET", MESSAGEDATACSET, 0, 0 },
	{"MESSAGEDATATRANS", MESSAGEDATATRANS, 0, 0 },
	{"MESSAGEDATAFONT", MESSAGEDATAFONT, 0, 0 },
	{"MESSAGEDATAX", MESSAGEDATAX, 0, 0 },
	{"MESSAGEDATAY", MESSAGEDATAY, 0, 0 },
	{"MESSAGEDATAW", MESSAGEDATAW, 0, 0 },
	{"MESSAGEDATAH", MESSAGEDATAH, 0, 0 },
	{"MESSAGEDATASFX", MESSAGEDATASFX, 0, 0 },
	{"MESSAGEDATALISTPOS", MESSAGEDATALISTPOS, 0, 0 },
	{"MESSAGEDATAVSPACE", MESSAGEDATAVSPACE, 0, 0 },
	{"MESSAGEDATAHSPACE", MESSAGEDATAHSPACE, 0, 0 },
	{"MESSAGEDATAFLAGS", MESSAGEDATAFLAGS, 0, 0 },
	
	{"DMAPDATAMAP", DMAPDATAMAP, 0, 0 },
	{"DMAPDATALEVEL", DMAPDATALEVEL, 0, 0 },
	{"DMAPDATAOFFSET", DMAPDATAOFFSET, 0, 0 },
	{"DMAPDATACOMPASS", DMAPDATACOMPASS, 0, 0 },
	{"DMAPDATAPALETTE", DMAPDATAPALETTE, 0, 0 },
	{"DMAPDATAMIDI", DMAPDATAMIDI, 0, 0 },
	{"DMAPDATACONTINUE", DMAPDATACONTINUE, 0, 0 },
	{"DMAPDATATYPE", DMAPDATATYPE, 0, 0 },
	{"DMAPDATAGRID", DMAPDATAGRID, 0, 0 },
	{"DMAPDATAMINIMAPTILE", DMAPDATAMINIMAPTILE, 0, 0 },
	{"DMAPDATAMINIMAPCSET", DMAPDATAMINIMAPCSET, 0, 0 },
	{"DMAPDATALARGEMAPTILE", DMAPDATALARGEMAPTILE, 0, 0 },
	{"DMAPDATALARGEMAPCSET", DMAPDATALARGEMAPCSET, 0, 0 },
	{"DMAPDATAMUISCTRACK", DMAPDATAMUISCTRACK, 0, 0 },
	{"DMAPDATASUBSCRA", DMAPDATASUBSCRA, 0, 0 },
	{"DMAPDATASUBSCRP", DMAPDATASUBSCRP, 0, 0 },
	{"DMAPDATADISABLEDITEMS", DMAPDATADISABLEDITEMS, 0, 0 },
	{"DMAPDATAFLAGS", DMAPDATAFLAGS, 0, 0 },
	
	{"NPCFROZEN", NPCFROZEN, 0, 0 },
	{"NPCFROZENTILE", NPCFROZENTILE, 0, 0 },
	{"NPCFROZENCSET", NPCFROZENCSET, 0, 0 },
	
	{"ITEMPSTRING", ITEMPSTRING, 0, 0 },
	{"ITEMPSTRINGFLAGS", ITEMPSTRINGFLAGS, 0, 0 },
	{"ITEMOVERRIDEFLAGS", ITEMOVERRIDEFLAGS, 0, 0 },
	{"LINKPUSH", LINKPUSH, 0, 0 },
	{"LINKSTUN", LINKSTUN, 0, 0 },
	{"IDATACOSTCOUNTER", IDATACOSTCOUNTER, 0, 0 },
	{"TYPINGMODE", TYPINGMODE, 0, 0 },
	//{"DMAPDATAGRAVITY", DMAPDATAGRAVITY, 0, 0 },
	//{"DMAPDATAJUMPLAYER", DMAPDATAJUMPLAYER, 0, 0 },
	//end ffscript vars
	//END VARS END OF BYTECODE
	
	//newcombo
	{"COMBODTILE", COMBODTILE, 0, 0 },
	{"COMBODFLIP", COMBODFLIP, 0, 0 },
	{"COMBODWALK", COMBODWALK, 0, 0 },
	{"COMBODTYPE", COMBODTYPE, 0, 0 },
	{"COMBODCSET", COMBODCSET, 0, 0 },
	{"COMBODFOO", COMBODFOO, 0, 0 },
	{"COMBODFRAMES", COMBODFRAMES, 0, 0 },
	{"COMBODNEXTD", COMBODNEXTD, 0, 0 },
	{"COMBODNEXTC", COMBODNEXTC, 0, 0 },
	{"COMBODFLAG", COMBODFLAG, 0, 0 },
	{"COMBODSKIPANIM", COMBODSKIPANIM, 0, 0 },
	{"COMBODNEXTTIMER", COMBODNEXTTIMER, 0, 0 },
	{"COMBODAKIMANIMY", COMBODAKIMANIMY, 0, 0 },
	{"COMBODANIMFLAGS", COMBODANIMFLAGS, 0, 0 },
	{"COMBODEXPANSION", COMBODEXPANSION, 0, 0 },
	{"COMBODATTRIBUTES", COMBODATTRIBUTES, 0, 0 },
	{"COMBODATTRIBYTES", COMBODATTRIBYTES, 0, 0 },
	{"COMBODUSRFLAGS", COMBODUSRFLAGS, 0, 0 },
	{"COMBODTRIGGERFLAGS", COMBODTRIGGERFLAGS, 0, 0 },
	{"COMBODTRIGGERLEVEL", COMBODTRIGGERLEVEL, 0, 0 },

	//comboclass
	{"COMBODNAME", COMBODNAME, 0, 0 },
	{"COMBODBLOCKNPC", COMBODBLOCKNPC, 0, 0 },
	{"COMBODBLOCKHOLE", COMBODBLOCKHOLE, 0, 0 },
	{"COMBODBLOCKTRIG", COMBODBLOCKTRIG, 0, 0 },
	{"COMBODBLOCKWEAPON", COMBODBLOCKWEAPON, 0, 0 },
	{"COMBODCONVXSPEED", COMBODCONVXSPEED, 0, 0 },
	{"COMBODCONVYSPEED", COMBODCONVYSPEED, 0, 0 },
	{"COMBODSPAWNNPC", COMBODSPAWNNPC, 0, 0 },
	{"COMBODSPAWNNPCWHEN", COMBODSPAWNNPCWHEN, 0, 0 },
	{"COMBODSPAWNNPCCHANGE", COMBODSPAWNNPCCHANGE, 0, 0 },
	{"COMBODDIRCHANGETYPE", COMBODDIRCHANGETYPE, 0, 0 },
	{"COMBODDISTANCECHANGETILES", COMBODDISTANCECHANGETILES, 0, 0 },
	{"COMBODDIVEITEM", COMBODDIVEITEM, 0, 0 },
	{"COMBODDOCK", COMBODDOCK, 0, 0 },
	{"COMBODFAIRY", COMBODFAIRY, 0, 0 },
	{"COMBODFFATTRCHANGE", COMBODFFATTRCHANGE, 0, 0 },
	{"COMBODFOORDECOTILE", COMBODFOORDECOTILE, 0, 0 },
	{"COMBODFOORDECOTYPE", COMBODFOORDECOTYPE, 0, 0 },
	{"COMBODHOOKSHOTPOINT", COMBODHOOKSHOTPOINT, 0, 0 },
	{"COMBODLADDERPASS", COMBODLADDERPASS, 0, 0 },
	{"COMBODLOCKBLOCK", COMBODLOCKBLOCK, 0, 0 },
	{"COMBODLOCKBLOCKCHANGE", COMBODLOCKBLOCKCHANGE, 0, 0 },
	{"COMBODMAGICMIRROR", COMBODMAGICMIRROR, 0, 0 },
	{"COMBODMODHPAMOUNT", COMBODMODHPAMOUNT, 0, 0 },
	{"COMBODMODHPDELAY", COMBODMODHPDELAY, 0, 0 },
	{"COMBODMODHPTYPE", COMBODMODHPTYPE, 0, 0 },
	{"COMBODNMODMPAMOUNT", COMBODNMODMPAMOUNT, 0, 0 },
	{"COMBODMODMPDELAY", COMBODMODMPDELAY, 0, 0 },
	{"COMBODMODMPTYPE", COMBODMODMPTYPE, 0, 0 },
	{"COMBODNOPUSHBLOCK", COMBODNOPUSHBLOCK, 0, 0 },
	{"COMBODOVERHEAD", COMBODOVERHEAD, 0, 0 },
	{"COMBODPLACENPC", COMBODPLACENPC, 0, 0 },
	{"COMBODPUSHDIR", COMBODPUSHDIR, 0, 0 },
	{"COMBODPUSHWAIT", COMBODPUSHWAIT, 0, 0 },
	{"COMBODPUSHHEAVY", COMBODPUSHHEAVY, 0, 0 },
	{"COMBODPUSHED", COMBODPUSHED, 0, 0 },
	{"COMBODRAFT", COMBODRAFT, 0, 0 },
	{"COMBODRESETROOM", COMBODRESETROOM, 0, 0 },
	{"COMBODSAVEPOINTTYPE", COMBODSAVEPOINTTYPE, 0, 0 },
	{"COMBODSCREENFREEZETYPE", COMBODSCREENFREEZETYPE, 0, 0 },
	{"COMBODSECRETCOMBO", COMBODSECRETCOMBO, 0, 0 },
	{"COMBODSINGULAR", COMBODSINGULAR, 0, 0 },
	{"COMBODSLOWWALK", COMBODSLOWWALK, 0, 0 },
	{"COMBODSTATUETYPEs", COMBODSTATUETYPE, 0, 0 },
	{"COMBODSTEPTYPE", COMBODSTEPTYPE, 0, 0 },
	{"COMBODSTEPCHANGEINTO", COMBODSTEPCHANGEINTO, 0, 0 },
	{"COMBODSTRIKEWEAPONS", COMBODSTRIKEWEAPONS, 0, 0 },
	{"COMBODSTRIKEREMNANTS", COMBODSTRIKEREMNANTS, 0, 0 },
	{"COMBODSTRIKEREMNANTSTYPE", COMBODSTRIKEREMNANTSTYPE, 0, 0 },
	{"COMBODSTRIKECHANGE", COMBODSTRIKECHANGE, 0, 0 },
	{"COMBODSTRIKEITEM", COMBODSTRIKEITEM, 0, 0 },
	{"COMBODTOUCHITEM", COMBODTOUCHITEM, 0, 0 },
	{"COMBODTOUCHSTAIRS", COMBODTOUCHSTAIRS, 0, 0 },
	{"COMBODTRIGGERTYPE", COMBODTRIGGERTYPE, 0, 0 },
	{"COMBODTRIGGERSENS", COMBODTRIGGERSENS, 0, 0 },
	{"COMBODWARPTYPE", COMBODWARPTYPE, 0, 0 },
	{"COMBODWARPSENS", COMBODWARPSENS, 0, 0 },
	{"COMBODWARPDIRECT", COMBODWARPDIRECT, 0, 0 },
	{"COMBODWARPLOCATION", COMBODWARPLOCATION, 0, 0 },
	{"COMBODWATER", COMBODWATER, 0, 0 },
	{"COMBODWHISTLE", COMBODWHISTLE, 0, 0 },
	{"COMBODWINGAME", COMBODWINGAME, 0, 0 },
	{"COMBODBLOCKWPNLEVEL", COMBODBLOCKWPNLEVEL, 0, 0 },

	{"TYPINGMODE", TYPINGMODE, 0, 0 },
	{"TYPINGMODE", TYPINGMODE, 0, 0 },
	{"LINKHITBY", LINKHITBY, 0, 0 },
	{"LINKDEFENCE", LINKDEFENCE, 0, 0 },
	{"NPCHITBY", NPCHITBY, 0, 0 },
	{"NPCISCORE", NPCISCORE, 0, 0 },
	{"NPCSCRIPTUID", NPCSCRIPTUID, 0, 0 },
	{"LWEAPONSCRIPTUID", LWEAPONSCRIPTUID, 0, 0 },
	{"EWEAPONSCRIPTUID", EWEAPONSCRIPTUID, 0, 0 },
	{"ITEMSCRIPTUID", ITEMSCRIPTUID, 0, 0 },
	
	{"DMAPDATASIDEVIEW", DMAPDATASIDEVIEW, 0, 0 },
	
	{"DONULL", DONULL, 0, 0 },
	{"DEBUGD", DEBUGD, 0, 0 },
	{"GETPIXEL", GETPIXEL, 0, 0 },
	{"DOUNTYPE", DOUNTYPE, 0, 0 },
	{"NPCBEHAVIOUR", NPCBEHAVIOUR, 0, 0 },
	{"NPCDATABEHAVIOUR", NPCDATABEHAVIOUR, 0, 0 },
	{"CREATEBITMAP", CREATEBITMAP, 0, 0 },
	{"LINKTILEMOD", LINKTILEMOD, 0, 0 },
	{"NPCINITD", NPCINITD, 0, 0 },
	{"NPCCOLLISION", NPCCOLLISION, 0, 0 },
	{"NPCLINEDUP", NPCLINEDUP, 0, 0 },
	
	{"NPCDATAINITD", NPCLINEDUP, 0, 0 },
	{"NPCDATASCRIPT", NPCDATASCRIPT, 0, 0 },
	{"NPCMATCHINITDLABEL", NPCMATCHINITDLABEL, 0, 0 },
	//lweapon scripts
	{"LWPNSCRIPT", LWPNSCRIPT, 0, 0 },
	{"LWPNINITD", LWPNINITD, 0, 0 },
	{"ITEMFAMILY", ITEMFAMILY, 0, 0 },
	{"ITEMLEVEL", ITEMLEVEL, 0, 0 },
	
	{"EWPNSCRIPT", EWPNSCRIPT, 0, 0 },
	{"EWPNINITD", EWPNINITD, 0, 0 },
	
	{"NPCSCRIPT", NPCSCRIPT, 0, 0 },
	
	{"DMAPSCRIPT", DMAPSCRIPT, 0, 0 },
	{"DMAPINITD", DMAPINITD, 0, 0 },
	
	{"SCREENSCRIPT", SCREENSCRIPT, 0, 0 },
	{"SCREENINITD", SCREENINITD, 0, 0 },
	
	{"LINKINITD", LINKINITD, 0, 0 },
	{"NPCDATAWEAPONINITD", NPCDATAWEAPONINITD, 0, 0 },
	{"NPCDATAWEAPONSCRIPT", NPCDATAWEAPONSCRIPT, 0, 0 },
	
	{"NPCSCRIPTTILE", NPCSCRIPTTILE, 0, 0 },
	{"NPCSCRIPTFLIP", NPCSCRIPTFLIP, 0, 0 },
	{"LWPNSCRIPTTILE", LWPNSCRIPTTILE, 0, 0 },
	{"LWPNSCRIPTFLIP", LWPNSCRIPTFLIP, 0, 0 },
	{"EWPNSCRIPTTILE", EWPNSCRIPTTILE, 0, 0 },
	{"EWPNSCRIPTFLIP", EWPNSCRIPTFLIP, 0, 0 },
	
	{"LINKENGINEANIMATE", LINKENGINEANIMATE, 0, 0 },
	{"NPCENGINEANIMATE", NPCENGINEANIMATE, 0, 0 },
	{"LWPNENGINEANIMATE", LWPNENGINEANIMATE, 0, 0 },
	{"EWPNENGINEANIMATE", EWPNENGINEANIMATE, 0, 0 },
	{"SKIPCREDITS", SKIPCREDITS, 0, 0 },
	{"SKIPF6", SKIPF6, 0, 0 },
	{"LWPNUSEWEAPON", LWPNUSEWEAPON, 0, 0 },
	{"LWPNUSEDEFENCE", LWPNUSEDEFENCE, 0, 0 },
	{"LWPNROTATION", LWPNROTATION, 0, 0 },	
	{"EWPNROTATION", EWPNROTATION, 0, 0 },	
	{"NPCROTATION", NPCROTATION, 0, 0 },	
	{"ITEMROTATION", ITEMROTATION, 0, 0 },	
	{"LINKROTATION", LINKROTATION, 0, 0 },
	{"LWPNSCALE", LWPNSCALE, 0, 0 },
	{"EWPNSCALE", EWPNSCALE, 0, 0 },
	{"NPCSCALE", NPCSCALE, 0, 0 },
	{"ITEMSCALE", ITEMSCALE, 0, 0 },
	{"LINKSCALE", LINKSCALE, 0, 0 },
	{"ITEMSPRITESCRIPT", ITEMSPRITESCRIPT, 0, 0 },
	{"FFRULE", FFRULE, 0, 0 },
	{"NUMDRAWS", NUMDRAWS, 0, 0 },
	{"MAXDRAWS", MAXDRAWS, 0, 0 },
	{"BITMAPWIDTH", BITMAPWIDTH, 0, 0 },
	{"BITMAPHEIGHT", BITMAPHEIGHT, 0, 0 },
	{"ALLOCATEBITMAPR", ALLOCATEBITMAPR, 0, 0 },
	{"KEYMODIFIERS", KEYMODIFIERS, 0, 0 },
	{"SIMULATEKEYPRESS", SIMULATEKEYPRESS, 0, 0 },
	{"KEYBINDINGS", KEYBINDINGS, 0, 0 },
	
	{"SCREENSCRIPT", SCREENSCRIPT, 0, 0 },
	{"SCREENINITD", SCREENINITD, 0, 0 },
	{"MAPDATASCRIPT", MAPDATASCRIPT, 0, 0 },
	{"MAPDATAINITDARRAY", MAPDATAINITDARRAY, 0, 0 },
	{"LWPNGRAVITY", LWPNGRAVITY, 0, 0 },
	{"EWPNGRAVITY", EWPNGRAVITY, 0, 0 },
	{"NPCGRAVITY", NPCGRAVITY, 0, 0 },
	{"ITEMGRAVITY", ITEMGRAVITY, 0, 0 },
	
	{"MAPDATASIDEWARPID", MAPDATASIDEWARPID, 0, 0 },
	{"SCREENSIDEWARPID", SCREENSIDEWARPID, 0, 0 },
	{"SCREENDATALAYERINVIS", SCREENDATALAYERINVIS, 0, 0 },
	{"SCREENDATASCRIPTDRAWS", SCREENDATASCRIPTDRAWS, 0, 0 },
	{"MAPDATALAYERINVIS", MAPDATALAYERINVIS, 0, 0 },
	{"MAPDATASCRIPTDRAWS", MAPDATASCRIPTDRAWS, 0, 0 },
	
	{"ITEMSCRIPTTILE", ITEMSCRIPTTILE, 0, 0 },
	{"ITEMSCRIPTFLIP", ITEMSCRIPTFLIP, 0, 0 },
	{"MAPDATAMAP", MAPDATAMAP, 0, 0 },
	{"MAPDATASCREEN", MAPDATASCREEN, 0, 0 },
	{"IDATAVALIDATE", IDATAVALIDATE, 0, 0 },
	{ "DISABLEKEY",		DISABLEKEY,        0,             0 },
	{ "DISABLEBUTTON",		DISABLEBUTTON,        0,             0 },
	{ "GAMESUSPEND",		GAMESUSPEND,        0,             0 },
	{ "LINKOTILE",		LINKOTILE,        0,             0 },
	{ "LINKOFLIP",		LINKOFLIP,        0,             0 },
	{ "ITEMSPRITEINITD",		ITEMSPRITEINITD,        0,             0 },
	
	{ "ZSCRIPTVERSION",		ZSCRIPTVERSION,        0,             0 },
	{ "REFFILE",		REFFILE,        0,             0 },
	{ "LINKCLIMBING",		LINKCLIMBING,        0,             0 },
	{ "NPCIMMORTAL",		NPCIMMORTAL,        0,             0 },
	{ "NPCNOSLIDE",		NPCNOSLIDE,        0,             0 },
	{ "NPCKNOCKBACKSPEED",		NPCKNOCKBACKSPEED,        0,             0 },
	{ "NPCNOSCRIPTKB",		NPCNOSCRIPTKB,        0,             0 },
	{ "GETRENDERTARGET",		GETRENDERTARGET,        0,             0 },
	{ "HERONOSTEPFORWARD",		HERONOSTEPFORWARD,        0,             0 },
	{ "SCREENDATATWARPRETSQR",		SCREENDATATWARPRETSQR,        0,             0 },
	{ "SCREENDATASWARPRETSQR",		SCREENDATASWARPRETSQR,        0,             0 },
	{ "MAPDATATWARPRETSQR",		MAPDATATWARPRETSQR,        0,             0 },
	{ "MAPDATASWARPRETSQR",		MAPDATASWARPRETSQR,        0,             0 },
	{ "NPCSUBMERGED",		NPCSUBMERGED,        0,             0 },
	{ "GAMEGRAVITY",		GAMEGRAVITY,        0,             0 },
	{ "COMBODASPEED",		COMBODASPEED,        0,             0 },
	{ "DROPSETITEMS",		DROPSETITEMS,        0,             0 },
	{ "DROPSETCHANCES",		DROPSETCHANCES,        0,             0 },
	{ "DROPSETNULLCHANCE",		DROPSETNULLCHANCE,        0,             0 },
	{ "DROPSETCHOOSE",		DROPSETCHOOSE,        0,             0 },
	{ "NPCPARENTUID",		NPCPARENTUID,        0,             0 },
	{ "KEYPRESS",		KEYPRESS,        0,             0 },
	{ "KEYINPUT",		KEYINPUT,        0,             0 },
	{ "SPRITEMAXNPC",		SPRITEMAXNPC,        0,             0 },
	{ "SPRITEMAXLWPN",		SPRITEMAXLWPN,        0,             0 },
	{ "SPRITEMAXEWPN",		SPRITEMAXEWPN,        0,             0 },
	{ "SPRITEMAXITEM",		SPRITEMAXITEM,        0,             0 },
	{ "SPRITEMAXPARTICLE",		SPRITEMAXPARTICLE,        0,             0 },
	{ "SPRITEMAXDECO",		SPRITEMAXDECO,        0,             0 },
	{ "HEROHEALTHBEEP",		HEROHEALTHBEEP,        0,             0 },
	{ "NPCRANDOM",		NPCRANDOM,        0,             0 },
	{ "COMBOXR",		COMBOXR,        0,             0 },
	{ "COMBOYR",		COMBOYR,        0,             0 },
	{ "COMBOPOSR",		COMBOPOSR,        0,             0 },
	{ "COMBODATASCRIPT",		COMBODATASCRIPT,        0,             0 },
	{ "COMBODATAINITD",		COMBODATAINITD,        0,             0 },
	{ "HEROSCRIPTCSET",		HEROSCRIPTCSET,        0,             0 },
	{ "SHOPDATATYPE",		SHOPDATATYPE,        0,             0 },
	{ "HEROSTEPS",		HEROSTEPS,        0,             0 },
	{ "HEROSTEPRATE",		HEROSTEPRATE,        0,             0 },
	{ "COMBODOTILE",		COMBODOTILE,        0,             0 },
	{ "COMBODFRAME",		COMBODFRAME,        0,             0 },
	{ "COMBODACLK",		COMBODACLK,        0,             0 },
	{ "PC",                PC,                   0,             0 },
	{ "GAMESCROLLING", GAMESCROLLING, 0, 0 },
	{ "MESSAGEDATAMARGINS", MESSAGEDATAMARGINS, 0, 0 },
	{ "MESSAGEDATAPORTTILE", MESSAGEDATAPORTTILE, 0, 0 },
	{ "MESSAGEDATAPORTCSET", MESSAGEDATAPORTCSET, 0, 0 },
	{ "MESSAGEDATAPORTX", MESSAGEDATAPORTX, 0, 0 },
	{ "MESSAGEDATAPORTY", MESSAGEDATAPORTY, 0, 0 },
	{ "MESSAGEDATAPORTWID", MESSAGEDATAPORTWID, 0, 0 },
	{ "MESSAGEDATAPORTHEI", MESSAGEDATAPORTHEI, 0, 0 },
	{ "MESSAGEDATAFLAGSARR", MESSAGEDATAFLAGSARR, 0, 0 },
	{ "FILEPOS", FILEPOS, 0, 0 },
	{ "FILEEOF", FILEEOF, 0, 0 },
	{ "FILEERR", FILEERR, 0, 0 },
	{ "MESSAGEDATATEXTWID", MESSAGEDATATEXTWID, 0, 0 },
	{ "MESSAGEDATATEXTHEI", MESSAGEDATATEXTHEI, 0, 0 },
	{ "SWITCHKEY", SWITCHKEY, 0, 0 },
	{ "INCQST", INCQST, 0, 0 },
	{ "HEROJUMPCOUNT", HEROJUMPCOUNT, 0, 0 },
	{ "HEROPULLDIR", HEROPULLDIR, 0, 0 },
	{ "HEROPULLCLK", HEROPULLCLK, 0, 0 },
	{ "HEROFALLCLK", HEROFALLCLK, 0, 0 },
	{ "HEROFALLCMB", HEROFALLCMB, 0, 0 },
	{ "HEROMOVEFLAGS", HEROMOVEFLAGS, 0, 0 },
	{ "ITEMFALLCLK", ITEMFALLCLK, 0, 0 },
	{ "ITEMFALLCMB", ITEMFALLCMB, 0, 0 },
	{ "ITEMMOVEFLAGS", ITEMMOVEFLAGS, 0, 0 },
	{ "LWPNFALLCLK", LWPNFALLCLK, 0, 0 },
	{ "LWPNFALLCMB", LWPNFALLCMB, 0, 0 },
	{ "LWPNMOVEFLAGS", LWPNMOVEFLAGS, 0, 0 },
	{ "EWPNFALLCLK", EWPNFALLCLK, 0, 0 },
	{ "EWPNFALLCMB", EWPNFALLCMB, 0, 0 },
	{ "EWPNMOVEFLAGS", EWPNMOVEFLAGS, 0, 0 },
	{ "NPCFALLCLK", NPCFALLCLK, 0, 0 },
	{ "NPCFALLCMB", NPCFALLCMB, 0, 0 },
	{ "NPCMOVEFLAGS", NPCMOVEFLAGS, 0, 0 },
	{ "ISBLANKTILE", ISBLANKTILE, 0, 0 },
	{ "LWPNSPECIAL", LWPNSPECIAL, 0, 0 },
	{ "DMAPDATAASUBSCRIPT", DMAPDATAASUBSCRIPT, 0, 0 },
	{ "DMAPDATAPSUBSCRIPT", DMAPDATAPSUBSCRIPT, 0, 0 },
	{ "DMAPDATASUBINITD", DMAPDATASUBINITD, 0, 0 },
	{ "MODULEGETINT", MODULEGETINT, 0, 0 },
	{ "MODULEGETSTR", MODULEGETSTR, 0, 0 },
	{ " ",                       -1,             0,             0 }
};



///----------------------------------------------------------------------------------------------------//
//Debugger and Logging Consoles

void FFScript::ZScriptConsole(int attributes,const char *format,...)
{
	#ifdef _WIN32
	//if ( open )
	{
		zscript_coloured_console.Create("ZQuest Creator Logging Console", 600, 200);
		zscript_coloured_console.cls(CConsoleLoggerEx::COLOR_BACKGROUND_BLACK);
		zscript_coloured_console.gotoxy(0,0);
		zscript_coloured_console.cprintf( CConsoleLoggerEx::COLOR_BLUE | CConsoleLoggerEx::COLOR_INTENSITY |
		CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"ZQuest Creator Logging Console\n");
	
		zscript_coloured_console.cprintf( attributes, format );
	}
	//else
	//{
		//close
	//	zscript_coloured_console.Close();
	//}
	#endif	
}

void FFScript::ZScriptConsole(bool open)
{
	al_trace("Opening ZScript Console");
	#ifdef _WIN32
	if ( open )
	{
		zscript_coloured_console.Create("ZScript Debug Console", 600, 200);
		zscript_coloured_console.cls(CConsoleLoggerEx::COLOR_BACKGROUND_BLACK);
		zscript_coloured_console.gotoxy(0,0);
	
		zscript_coloured_console.cprintf( CConsoleLoggerEx::COLOR_RED | CConsoleLoggerEx::COLOR_BLUE | CConsoleLoggerEx::COLOR_INTENSITY |
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"\n       _____   ____                  __ \n");
		zscript_coloured_console.cprintf( CConsoleLoggerEx::COLOR_RED | CConsoleLoggerEx::COLOR_BLUE | CConsoleLoggerEx::COLOR_INTENSITY |
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"      /__  /  / __ \\__  _____  _____/ /_\n");
		zscript_coloured_console.cprintf( CConsoleLoggerEx::COLOR_RED | CConsoleLoggerEx::COLOR_BLUE | CConsoleLoggerEx::COLOR_INTENSITY |
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"        / /  / / / / / / / _ \\/ ___/ __/\n");
		zscript_coloured_console.cprintf( CConsoleLoggerEx::COLOR_RED | CConsoleLoggerEx::COLOR_BLUE | CConsoleLoggerEx::COLOR_INTENSITY |
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"       / /__/ /_/ / /_/ /  __(__  ) /_ \n");
		zscript_coloured_console.cprintf( CConsoleLoggerEx::COLOR_RED | CConsoleLoggerEx::COLOR_BLUE | CConsoleLoggerEx::COLOR_INTENSITY |
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"      /____/\\___\\_\\__,_/\\___/____/\\__/\n\n");
	
		zscript_coloured_console.cprintf( CConsoleLoggerEx::COLOR_BLUE | CConsoleLoggerEx::COLOR_INTENSITY |
		CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"Quest Data Logging & ZScript Debug Console\n");
		
		if ( FFCore.getQuestHeaderInfo(vZelda) > 0 )
		{
			zscript_coloured_console.cprintf( CConsoleLoggerEx::COLOR_BLUE |CConsoleLoggerEx::COLOR_GREEN | CConsoleLoggerEx::COLOR_INTENSITY |
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"Quest Made in ZC Version %x, Build %d\n", FFCore.getQuestHeaderInfo(vZelda), FFCore.getQuestHeaderInfo(vBuild));
		}
		else
		{
			zscript_coloured_console.cprintf( CConsoleLoggerEx::COLOR_BLUE |CConsoleLoggerEx::COLOR_GREEN | CConsoleLoggerEx::COLOR_INTENSITY |
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"%s, Version %s\n", ZC_PLAYER_NAME, ZC_PLAYER_V);
		}
	
		//coloured_console.SetAsDefaultOutput();
		zscript_debugger = 1;
	}
	else
	{
		//close
		zscript_coloured_console.Close();
		zscript_debugger = 0;
	}
	#endif	
}


void FFScript::ZScriptConsolePrint(int attributes,const char *format,...)
{
	#ifdef _WIN32
	
	coloured_console.cprintf( attributes,format);
	//coloured_console.print();
	#endif	
}

void FFScript::ZASMPrint(bool open)
{
	if(SKIPZASMPRINT()) return;
	zprint("%s ZASM Console\n", open ? "Opening" : "Closing");
	#ifdef _WIN32
	if ( open )
	{
		coloured_console.Create("ZASM Debugger", 600, 200);
		coloured_console.cls(CConsoleLoggerEx::COLOR_BACKGROUND_BLACK);
		coloured_console.gotoxy(0,0);
		coloured_console.cprintf( CConsoleLoggerEx::COLOR_GREEN | CConsoleLoggerEx::COLOR_INTENSITY |
		CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"ZASM Stack Trace:\n");
		//coloured_console.SetAsDefaultOutput();
		zasm_debugger = 1;
		zasm_break_mode = ZASM_BREAK_HALT;
	}
	else
	{
		//close
		coloured_console.Close();
		zasm_debugger = 0;
	}
	#endif	
}

std::string ZASMVarToString(long arg)
{
	for(int q = 0; ZASMVars[q].id != -1; ++q)
	{
		if(ZASMVars[q].maxcount>0)
		{
			long start = ZASMVars[q].id;
			int mult = zc_max(1,ZASMVars[q].multiple);
			if(arg >= start && arg < start+(ZASMVars[q].maxcount*mult))
			{
				for(int w = 0; w < ZASMVars[q].maxcount; ++w)
				{
					if(arg!=start+(w*mult)) continue;
					
					char buf[64];
					if(strcmp(ZASMVars[q].name, "A")==0)
						sprintf(buf, "%s%d", ZASMVars[q].name, w+1);
					else sprintf(buf, "%s%d", ZASMVars[q].name, w);
					return string(buf);
				}
			}
		}
		else if(ZASMVars[q].id == arg) return string(ZASMVars[q].name);
	}
	return "(null)";
}

void FFScript::ZASMPrintCommand(const word scommand)
{
	if(SKIPZASMPRINT()) return;
	#ifdef _WIN32
	//if ( !zasm_debugger ) return;
	
	script_command s_c = ZASMcommands[scommand];
	
	if(s_c.args == 2)
	{
		coloured_console.cprintf( CConsoleLoggerEx::COLOR_BLUE | CConsoleLoggerEx::COLOR_INTENSITY | 
		CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"%14s: ", s_c.name);
		
		if(s_c.arg1_type == 0)
		{
			coloured_console.cprintf( CConsoleLoggerEx::COLOR_WHITE | 
			//CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"%10s (val = %9d), ", s_v.name, get_register(sarg1));
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"\t %s (val = %2d), ", ZASMVarToString(sarg1).c_str(), get_register(sarg1));
		}
		else
		{
			coloured_console.cprintf( CConsoleLoggerEx::COLOR_RED |CConsoleLoggerEx::COLOR_INTENSITY | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"%10s (val = %2d), ", "immediate", sarg1);
		}
		if(s_c.arg2_type == 0)
		{
			coloured_console.cprintf( CConsoleLoggerEx::COLOR_RED | CConsoleLoggerEx::COLOR_INTENSITY | 
			//CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"%10s (val = %9d)\n", s_v.name, get_register(sarg2));
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK, "\t %s (val = %2d)\n", ZASMVarToString(sarg2).c_str(), get_register(sarg2));
		}
		else
		{
			coloured_console.cprintf( CConsoleLoggerEx::COLOR_RED | CConsoleLoggerEx::COLOR_INTENSITY | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"%10s (val = %2d)\n", "immediate", sarg2);
		}
	}
	else if(s_c.args == 1)
	{
		coloured_console.cprintf( CConsoleLoggerEx::COLOR_BLUE | CConsoleLoggerEx::COLOR_INTENSITY | 
		CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"%14s: ", s_c.name);
		
		if(s_c.arg1_type == 0)
		{
			coloured_console.cprintf( CConsoleLoggerEx::COLOR_RED | CConsoleLoggerEx::COLOR_INTENSITY | 
			//CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"%10s (val = %9d)\n", s_v.name, get_register(sarg1));
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"\t %w (val = %2d)\n", ZASMVarToString(sarg1).c_str(), get_register(sarg1));
		}
		else
		{
			coloured_console.cprintf( CConsoleLoggerEx::COLOR_RED | CConsoleLoggerEx::COLOR_INTENSITY |  
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"%10s (val = %2d)\n", "immediate", sarg1);
		}
	}
	else
	{
		coloured_console.cprintf( CConsoleLoggerEx::COLOR_BLUE | CConsoleLoggerEx::COLOR_INTENSITY | 
		CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"%14s\n",s_c.name);
	}
	//s_c.name is the string with the instruction
	
	//coloured_console.print();
	#endif	
}

void FFScript::ZASMPrintVarSet(const long arg, long argval)
{
	if(SKIPZASMPRINT()) return;
	#ifdef _WIN32
	//if ( !zasm_debugger ) return;
	// script_variable s_v = ZASMVars[arg];
	//s_v.name is the string with the instruction
	coloured_console.cprintf( CConsoleLoggerEx::COLOR_WHITE | 
	CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"Set: %s\t",ZASMVarToString(arg).c_str());
	coloured_console.cprintf( CConsoleLoggerEx::COLOR_GREEN | CConsoleLoggerEx::COLOR_INTENSITY | 
	CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"%d\n",argval);
	//coloured_console.print();
	#endif	
}

void FFScript::ZASMPrintVarGet(const long arg, long argval)
{
	if(SKIPZASMPRINT()) return;
	#ifdef _WIN32
	//if ( !zasm_debugger ) return;
	// script_variable s_v = ZASMVars[arg];
	//s_v.name is the string with the instruction
	coloured_console.cprintf( CConsoleLoggerEx::COLOR_WHITE | 
	CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"Get: %s\t",ZASMVarToString(arg).c_str());
	coloured_console.cprintf( CConsoleLoggerEx::COLOR_GREEN | CConsoleLoggerEx::COLOR_INTENSITY | 
	CConsoleLoggerEx::COLOR_BACKGROUND_BLACK,"%d\n",argval);
	//coloured_console.print();
	#endif	
}



///----------------------------------------------------------------------------------------------------//
//Tracing

void FFScript::do_trace(bool v)
{
	long temp = SH::get_arg(sarg1, v);
	
	char tmp[100];
	sprintf(tmp, (temp < 0 ? "%06ld" : "%05ld"), temp);
	string s2(tmp);
	s2 = s2.substr(0, s2.size() - 4) + "." + s2.substr(s2.size() - 4, 4);
	TraceScriptIDs();
	al_trace("%s\n", s2.c_str());
	
	if(zconsole)
		printf("%s\n", s2.c_str());
	if ( zscript_debugger ) 
	{
		#ifdef _WIN32
		zscript_coloured_console.cprintf((CConsoleLoggerEx::COLOR_WHITE | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK),"%s\n", s2.c_str());
		#else //Unix
			std::cout << "Z_scripterrlog Test\n" << std::endl;
			printf("%s\n", s2.c_str());	
		#endif
	}
}

void FFScript::do_tracebool(const bool v)
{
	long temp = SH::get_arg(sarg1, v);
	TraceScriptIDs();
	al_trace("%s\n", temp ? "true": "false");
	
	if(zconsole)
		printf("%s\n", temp ? "true": "false");
	
	if ( zscript_debugger ) 
	{
		#ifdef _WIN32
		zscript_coloured_console.cprintf((CConsoleLoggerEx::COLOR_WHITE | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK),"%s\n", temp ? "true": "false");
		#else //Unix
			std::cout << "Z_scripterrlog Test\n" << std::endl;
			printf("%s\n", temp ? "true": "false");	
		#endif
	}
}

void traceStr(string const& str)
{
	FFCore.TraceScriptIDs();
	safe_al_trace(str.c_str());
	
	if(zconsole)
		printf("%s", str.c_str());
	
	if ( zscript_debugger ) 
	{
		#ifdef _WIN32
		zscript_coloured_console.cprintf((CConsoleLoggerEx::COLOR_WHITE | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK),"%s", str.c_str());

		#else //Unix
			std::cout << "Z_scripterrlog Test\n" << std::endl;
			printf("%s", str.c_str());	
		#endif
	}
}

void FFScript::do_tracestring()
{
	long arrayptr = get_register(sarg1) / 10000;
	string str;
	ArrayH::getString(arrayptr, str, 512);
	traceStr(str);
}

string zs_sprintf(char const* format, int num_args)
{
	int arg_offset = ((ri->sp + num_args) - 1);
	int next_arg = 0;
	bool is_old_args = get_bit(quest_rules, qr_OLD_PRINTF_ARGS);
	ostringstream oss;
	while(format[0] != '\0')
	{
		long arg_val = ( (next_arg >= num_args) ? 0 : (SH::read_stack(arg_offset - next_arg)) );
		char buf[256] = {0};
		for ( int q = 0; q < 256; ++q )
		{
			if(format[0] == '\0') //done
			{
				oss << buf;
				return oss.str();
			}
			else if(format[0] == '%')
			{
				++format;
				bool hex_upper = true;
				int min_digits = 0;
				if(format[0] == '0' && !is_old_args)
				{
					char argbuf[4] = {0};
					int q = 0;
					while(q < 4)
					{
						++format;
						char c = format[0];
						if(c == '\0')
						{
							Z_scripterrlog("Cannot use minimum digits flag with no argument\n");
							oss << buf;
							return oss.str();
						}
						if(c >= '0' && c <= '9')
							argbuf[q++] = c;
						else
						{
							--format;
							break;
						}
					}
					++format;
					min_digits = atoi(argbuf);
					if(min_digits > 10)
					{
						Z_scripterrlog("Min digits argument cannot be larger than 10! Value will be truncated to 10.");
						min_digits = 10;
					}
					if(!min_digits)
					{
						Z_scripterrlog("Error formatting string: Invalid number '%s'\n", argbuf);
					}
				}
				char mindigbuf[8] = {0};
				sprintf(mindigbuf, "%%0%d%c", min_digits, (format[0]=='x' || format[0]=='X') ? 'x' : 'd');
				switch( format[0] )
				{
					case 'd':
					{
						if( (arg_val % 10000) )
						{
							goto zsprintf_float;
						}
						else
						{
							goto zsprintf_int;
						}
					}
					case 'i':
					case 'p':
					{
						zsprintf_int:
						{
							char argbuf[32] = {0};
							if(min_digits)
								sprintf(argbuf,mindigbuf,arg_val / 10000);
							else zc_itoa(arg_val / 10000, argbuf);
							++next_arg;
							oss << buf << argbuf;
							q = 300; //break main loop
							break;
						}
					}
					case 'f':
					{
						zsprintf_float:
						{
							char argbuf[32] = {0};
							if(min_digits)
								sprintf(argbuf,mindigbuf,arg_val / 10000);
							else zc_itoa(arg_val / 10000, argbuf);
							int inx = 0; for( ; argbuf[inx]; ++inx );
							argbuf[inx++] = '.';
							argbuf[inx++] = '0' + abs( ( (arg_val / 1000) % 10 ) );
							argbuf[inx++] = '0' + abs( ( (arg_val / 100) % 10 ) );
							argbuf[inx++] = '0' + abs( ( (arg_val / 10) % 10 ) );
							argbuf[inx] = '0' + abs( (arg_val % 10) );
							for ( int i = 0; i < 3; ++i )
							{
								if( argbuf[inx-i] == '0') argbuf[inx-i] = 0; //Trim trailing 0s
								else break;
							}
							++next_arg;
							oss << buf << argbuf;
							q = 300; //break main loop
							break;
						}
					}
					case 's':
					{
						if(min_digits)
							Z_scripterrlog("Cannot use minimum digits flag for '%%s'\n");
						long strptr = (arg_val / 10000);
						string str;
						ArrayH::getString(strptr, str, MAX_ZC_ARRAY_SIZE);
						oss << buf << str.c_str();
						++next_arg;
						q = 300; //break main loop
						break;
					}
					case 'c':
					{
						if(min_digits)
							Z_scripterrlog("Cannot use minimum digits flag for '%%c'\n");
						int c = (arg_val / 10000);
						++next_arg;
						if ( (char(c)) != c )
						{
							Z_scripterrlog("Illegal char value (%d) passed to sprintf as '%%c' arg\n", c);
							Z_scripterrlog("Value of invalid char will overflow.\n");
						}
						buf[q] = (char(c));
						oss << buf;
						q = 300; //break main loop
						break;
					}
					case 'x':
						hex_upper = false;
						//Fallthrough
					case 'X':
					{
						char argbuf[32] = {0};
						if(min_digits)
							sprintf(argbuf,mindigbuf,arg_val / 10000);
						else zc_itoa( (arg_val/10000), argbuf, 16 ); //base 16; hex
						
						for ( int inx = 0; inx < 16; ++inx ) //set chosen caps
						{
							argbuf[inx] = ( hex_upper ? toupper(argbuf[inx]) : tolower(argbuf[inx]) );
						}
						++next_arg;
						oss << buf << "0x" << argbuf;
						q = 300; //break main loop
						break;
					}
					case '%':
					{
						if(min_digits)
							Z_scripterrlog("Cannot use minimum digits flag for '%%%%'\n");
						buf[q] = '%';
						break;
					}
					default:
					{
						if(is_old_args)
							buf[q] = format[0];
						else
						{
							Z_scripterrlog("Error: '%%%c' is not a valid printf argument.\n",format[0]);
						}
						break;
					}
				}
				++format;
			}
			else
			{
				buf[q] = format[0];
				++format;
			}
			if(q == 255)
			{
				oss << buf;
				break;
			}
		}
	}
	return oss.str();
}

void FFScript::do_printf(const bool v)
{
	int num_args = SH::get_arg(sarg1, v) / 10000;
	long format_arrayptr = SH::read_stack(ri->sp + num_args) / 10000;
	string formatstr;
	ArrayH::getString(format_arrayptr, formatstr, MAX_ZC_ARRAY_SIZE);
	
	traceStr(zs_sprintf(formatstr.c_str(), num_args));
}
void FFScript::do_sprintf(const bool v)
{
	int num_args = SH::get_arg(sarg1, v) / 10000;
	long dest_arrayptr = SH::read_stack(ri->sp + num_args + 1) / 10000;
	long format_arrayptr = SH::read_stack(ri->sp + num_args) / 10000;
	string formatstr;
	ArrayH::getString(format_arrayptr, formatstr, MAX_ZC_ARRAY_SIZE);
	
	string output = zs_sprintf(formatstr.c_str(), num_args);
	if(ArrayH::setArray(dest_arrayptr, output) == SH::_Overflow)
	{
		Z_scripterrlog("Dest string supplied to 'sprintf()' not large enough\n");
		ri->d[2] = ArrayH::strlen(dest_arrayptr);
	}
	else ri->d[2] = output.size();
}

void FFScript::do_breakpoint()
{
	long arrayptr = get_register(sarg1) / 10000;
	string str;
	if(arrayptr && sarg1 != NUL)
	{
		ArrayH::getString(arrayptr, str, 512);
		str = "Breakpoint: " + str;
	}
	else str = "Breakpoint";
	TraceScriptIDs();
	al_trace("%s\n", str.c_str());
	
	if(zconsole)
		printf("%s\n", str.c_str());
	
	if ( zscript_debugger ) 
	{
		#ifdef _WIN32
		zscript_coloured_console.cprintf((CConsoleLoggerEx::COLOR_RED | 
				CConsoleLoggerEx::COLOR_BACKGROUND_BLACK),"%s\n", str.c_str());

		#else //Unix
			std::cout << "Z_scripterrlog Test\n" << std::endl;
			printf("%s", str.c_str());	
		#endif
	}
	if( zasm_debugger )
	{
		FFCore.zasm_break_mode = ZASM_BREAK_HALT; //Halt ZASM debugger; break execution
		#ifdef _WIN32
		coloured_console.cprintf((CConsoleLoggerEx::COLOR_RED | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK),"%s\n", str.c_str());
		#else //Unix
			std::cout << "Z_scripterrlog Test\n" << std::endl;
			printf("%s", str.c_str());	
		#endif
	}
}

void FFScript::do_tracenl()
{
	al_trace("\n");
	
	if(zconsole)
		printf("\n");
		if ( zscript_debugger ) 
	{
		#ifdef _WIN32
		zscript_coloured_console.cprintf((CConsoleLoggerEx::COLOR_WHITE | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK),"\n");
		#else //Unix
			std::cout << "Z_scripterrlog Test\n" << std::endl;
			printf("\n");	
		#endif
	}
}


void FFScript::TraceScriptIDs(bool zasm_console)
{
	if(get_bit(quest_rules,qr_TRACESCRIPTIDS) || DEVLOGGING )
	{
		if(!zasm_debugger && zasm_console) return;
		#ifdef _WIN32
		CConsoleLoggerEx console = (zasm_console ? coloured_console : zscript_coloured_console);
		#endif
		bool cond = (zasm_console ? zasm_debugger : zscript_debugger);
		switch(curScriptType)
		{
			case SCRIPT_GLOBAL:
				al_trace("Global script %u (%s): ", curScriptNum+1, globalmap[curScriptNum].scriptname.c_str());
				#ifdef _WIN32
				if ( cond ) {console.cprintf((CConsoleLoggerEx::COLOR_GREEN | CConsoleLoggerEx::COLOR_INTENSITY | 
					CConsoleLoggerEx::COLOR_BACKGROUND_BLACK),"Global script %u (%s): ", 
					curScriptNum+1, globalmap[curScriptNum].scriptname.c_str()); }
				#else //Unix
					std::cout << "Z_scripterrlog Test\n" << std::endl;
					printf("Global script %u (%s): ", curScriptNum+1, globalmap[curScriptNum].scriptname.c_str());	
				#endif
				break;
			
			case SCRIPT_LINK:
				al_trace("Link script %u (%s): ", curScriptNum, linkmap[curScriptNum-1].scriptname.c_str());
				#ifdef _WIN32
				if ( cond ) { console.cprintf((CConsoleLoggerEx::COLOR_GREEN | CConsoleLoggerEx::COLOR_INTENSITY | 
					CConsoleLoggerEx::COLOR_BACKGROUND_BLACK),"Link script %u (%s): ", curScriptNum, linkmap[curScriptNum-1].scriptname.c_str()); }
				#else //Unix
					std::cout << "Z_scripterrlog Test\n" << std::endl;
					printf("Link script %u (%s): ", curScriptNum, linkmap[curScriptNum-1].scriptname.c_str());	
				#endif    
			break;
			
			case SCRIPT_LWPN:
				al_trace("LWeapon script %u (%s): ", curScriptNum, lwpnmap[curScriptNum-1].scriptname.c_str());
				#ifdef _WIN32
				if ( cond ) {console.cprintf((CConsoleLoggerEx::COLOR_GREEN | CConsoleLoggerEx::COLOR_INTENSITY | 
					CConsoleLoggerEx::COLOR_BACKGROUND_BLACK),"LWeapon script %u (%s): ", curScriptNum, lwpnmap[curScriptNum-1].scriptname.c_str());}
				#else //Unix
					std::cout << "Z_scripterrlog Test\n" << std::endl;
					printf("LWeapon script %u (%s): ", curScriptNum, lwpnmap[curScriptNum-1].scriptname.c_str());	
				#endif      
			break;
			
			case SCRIPT_EWPN:
				al_trace("EWeapon script %u (%s): ", curScriptNum, ewpnmap[curScriptNum-1].scriptname.c_str());
				#ifdef _WIN32
				if ( cond ) { console.cprintf((CConsoleLoggerEx::COLOR_GREEN | CConsoleLoggerEx::COLOR_INTENSITY | 
					CConsoleLoggerEx::COLOR_BACKGROUND_BLACK),"EWeapon script %u (%s): ", curScriptNum, ewpnmap[curScriptNum-1].scriptname.c_str());}
				#else //Unix
					std::cout << "Z_scripterrlog Test\n" << std::endl;
					printf("EWeapon script %u (%s): ", curScriptNum, ewpnmap[curScriptNum-1].scriptname.c_str());	
				#endif      
			break;
			
			case SCRIPT_NPC:
				al_trace("NPC script %u (%s): ", curScriptNum, npcmap[curScriptNum-1].scriptname.c_str());
				#ifdef _WIN32
				if ( cond ) {console.cprintf((CConsoleLoggerEx::COLOR_GREEN | CConsoleLoggerEx::COLOR_INTENSITY | 
					CConsoleLoggerEx::COLOR_BACKGROUND_BLACK),"NPC script %u (%s): ", curScriptNum, npcmap[curScriptNum-1].scriptname.c_str());}
				#else //Unix
					std::cout << "Z_scripterrlog Test\n" << std::endl;
					printf("NPC script %u (%s): ", curScriptNum, npcmap[curScriptNum-1].scriptname.c_str());
				#endif         
			break;
				
			case SCRIPT_FFC:
				al_trace("FFC script %u (%s): ", curScriptNum, ffcmap[curScriptNum-1].scriptname.c_str());
				
				#ifdef _WIN32
				if ( cond ) {console.cprintf((CConsoleLoggerEx::COLOR_GREEN | CConsoleLoggerEx::COLOR_INTENSITY | 
					CConsoleLoggerEx::COLOR_BACKGROUND_BLACK),"FFC script %u (%s): ", curScriptNum, ffcmap[curScriptNum-1].scriptname.c_str());}
				#else //Unix
					std::cout << "Z_scripterrlog Test\n" << std::endl;
					printf("FFC script %u (%s): ", curScriptNum, ffcmap[curScriptNum-1].scriptname.c_str());
				#endif   
			break;
				
			case SCRIPT_ITEM:
				al_trace("Itemdata script %u (%s): ", curScriptNum, itemmap[curScriptNum-1].scriptname.c_str());
				#ifdef _WIN32
				if ( cond ) {console.cprintf((CConsoleLoggerEx::COLOR_GREEN | CConsoleLoggerEx::COLOR_INTENSITY | 
					CConsoleLoggerEx::COLOR_BACKGROUND_BLACK),"Itemdata script %u (%s): ", curScriptNum, itemmap[curScriptNum-1].scriptname.c_str());}
				#else //Unix
					std::cout << "Z_scripterrlog Test\n" << std::endl;
					printf("Itemdata script %u (%s): ", curScriptNum, itemmap[curScriptNum-1].scriptname.c_str());
				#endif   
			break;
			
			case SCRIPT_ACTIVESUBSCREEN:
			case SCRIPT_PASSIVESUBSCREEN:
			case SCRIPT_DMAP:
				al_trace("DMap script %u (%s): ", curScriptNum, dmapmap[curScriptNum-1].scriptname.c_str());
				
				#ifdef _WIN32
				if ( cond ) {console.cprintf((CConsoleLoggerEx::COLOR_GREEN | CConsoleLoggerEx::COLOR_INTENSITY | 
					CConsoleLoggerEx::COLOR_BACKGROUND_BLACK),"DMap script %u (%s): ", curScriptNum, dmapmap[curScriptNum-1].scriptname.c_str());}
				#else //Unix
					std::cout << "Z_scripterrlog Test\n" << std::endl;
					printf("DMap script %u (%s): ", curScriptNum, dmapmap[curScriptNum-1].scriptname.c_str());
				#endif   
			break;
			
			case SCRIPT_ITEMSPRITE:
				al_trace("itemsprite script %u (%s): ", curScriptNum, itemspritemap[curScriptNum-1].scriptname.c_str());
				#ifdef _WIN32
				if ( cond ) {console.cprintf((CConsoleLoggerEx::COLOR_GREEN | CConsoleLoggerEx::COLOR_INTENSITY | 
					CConsoleLoggerEx::COLOR_BACKGROUND_BLACK),"itemsprite script %u (%s): ", curScriptNum, itemspritemap[curScriptNum-1].scriptname.c_str());}
				#else //Unix
					std::cout << "Z_scripterrlog Test\n" << std::endl;
					printf("itemsprite script %u (%s): ", curScriptNum, itemspritemap[curScriptNum-1].scriptname.c_str());
				#endif   
			break;
			
			case SCRIPT_SCREEN:
				al_trace("Screen script %u (%s): ", curScriptNum, screenmap[curScriptNum-1].scriptname.c_str());
				#ifdef _WIN32
				if ( cond ) {console.cprintf((CConsoleLoggerEx::COLOR_GREEN | CConsoleLoggerEx::COLOR_INTENSITY | 
					CConsoleLoggerEx::COLOR_BACKGROUND_BLACK),"Screen script %u (%s): ", curScriptNum, screenmap[curScriptNum-1].scriptname.c_str());}
				#else //Unix
					std::cout << "Z_scripterrlog Test\n" << std::endl;
					printf("Screen script %u (%s): ", curScriptNum, screenmap[curScriptNum-1].scriptname.c_str());
				#endif   
			break;
			
			//case SCRIPT_SUBSCREEN:
			//	al_trace("Subscreen script %u (%s): ", curScriptNum, itemmap[curScriptNum-1].scriptname.c_str());
			//	#ifdef _WIN32
			//	if ( cond ) {console.cprintf((CConsoleLoggerEx::COLOR_GREEN | CConsoleLoggerEx::COLOR_INTENSITY | 
			//		CConsoleLoggerEx::COLOR_BACKGROUND_BLACK),"Subscreen script %u (%s): ", curScriptNum, itemmap[curScriptNum-1].scriptname.c_str());}
			//	#endif
			//break;
			
			case SCRIPT_COMBO:
				al_trace("combodata script %u (%s): ", curScriptNum, comboscriptmap[curScriptNum-1].scriptname.c_str());
				#ifdef _WIN32
				if ( cond ) {console.cprintf((CConsoleLoggerEx::COLOR_GREEN | CConsoleLoggerEx::COLOR_INTENSITY | 
					CConsoleLoggerEx::COLOR_BACKGROUND_BLACK),"combodata script %u (%s): ", curScriptNum, comboscriptmap[curScriptNum-1].scriptname.c_str());}
				#else //Unix
					std::cout << "Z_scripterrlog Test\n" << std::endl;
					printf("combodata script %u (%s): ", curScriptNum, comboscriptmap[curScriptNum-1].scriptname.c_str());
				#endif  
			break;
		}
	}
}

void FFScript::do_cleartrace()
{
	zc_trace_clear();
}

string inttobase(word base, long x, word mindigits)
{
	static const char coeff[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	
	string s2;
	word digits = zc_max(mindigits - 1, word(floor(log(double(x)) / log(double(base)))));
	
	for(int i = digits; i >= 0; i--)
	{
		s2 += coeff[word(floor(x / pow(double(base), i))) % base];
	}
	
	return s2;
}

void FFScript::do_tracetobase()
{
	long x = SH::read_stack(ri->sp + 2) / 10000;
	unsigned long base = vbound(SH::read_stack(ri->sp + 1) / 10000, 2, 36);
	unsigned long mindigits = zc_max(1, SH::read_stack(ri->sp) / 10000);
	
	string s2 = x < 0 ? "-": "";
	
	switch(base)
	{
	case 8:
		s2 += '0';
		break;
		
	case 16:
		s2 += "0x";
		break;
	}
	
	s2 += inttobase(base, int(fabs(double(x))), mindigits);
	
	switch(base)
	{
	case 8:
	case 10:
	case 16:
		break;
		
	case 2:
		s2 += 'b';
		break;
		
	default:
		std::stringstream ss;
		ss << " (Base " << base << ')';
		s2 += ss.str();
		break;
	}
	TraceScriptIDs();
	al_trace("%s\n", s2.c_str());
	
	if(zconsole)
		printf("%s\n", s2.c_str());
	
	if ( zscript_debugger ) 
	{
		#ifdef _WIN32
		zscript_coloured_console.cprintf((CConsoleLoggerEx::COLOR_WHITE | 
			CConsoleLoggerEx::COLOR_BACKGROUND_BLACK),"%s\n", s2.c_str());
		#else //Unix
			std::cout << "Z_scripterrlog Test\n" << std::endl;
			printf("%s\n", s2.c_str());
		#endif 
	}
}

//SRAM Functions
void FFScript::write_dmaps(PACKFILE *f, int vers_id)
{
	word dmap_count=count_dmaps();
  
		dmap_count=zc_min(dmap_count, 512);
		dmap_count=zc_min(dmap_count, MAXDMAPS-0);
		
		//finally...  section data
		if(!p_iputw(dmap_count,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",5);
		}
		
		
		for(int i=0; i<dmap_count; i++)
		{
			if(!p_putc(DMaps[i].map,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",6);
			}
			
			if(!p_iputw(DMaps[i].level,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",7);
			}
			
			if(!p_putc(DMaps[i].xoff,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",8);
			}
			
			if(!p_putc(DMaps[i].compass,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",9);
			}
			
			if(!p_iputw(DMaps[i].color,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",10);
			}
			
			if(!p_putc(DMaps[i].midi,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",11);
			}
			
			if(!p_putc(DMaps[i].cont,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",12);
			}
			
			if(!p_putc(DMaps[i].type,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",13);
			}
			
			for(int j=0; j<8; j++)
			{
				if(!p_putc(DMaps[i].grid[j],f))
				{
					Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",14);
				}
			}
			
			//16
			if(!pfwrite(&DMaps[i].name,sizeof(DMaps[0].name),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",15);
			}
			
			if(!pfwrite(&DMaps[i].title,sizeof(DMaps[0].title),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",16);
			}
			
			if(!pfwrite(&DMaps[i].intro,sizeof(DMaps[0].intro),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",17);
			}
			
			if(!p_iputl(DMaps[i].minimap_1_tile,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",18);
			}
			
			if(!p_putc(DMaps[i].minimap_1_cset,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",19);
			}
			
			if(!p_iputl(DMaps[i].minimap_2_tile,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",20);
			}
			
			if(!p_putc(DMaps[i].minimap_2_cset,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",21);
			}
			
			if(!p_iputl(DMaps[i].largemap_1_tile,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",22);
			}
			
			if(!p_putc(DMaps[i].largemap_1_cset,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",23);
			}
			
			if(!p_iputl(DMaps[i].largemap_2_tile,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",24);
			}
			
			if(!p_putc(DMaps[i].largemap_2_cset,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",25);
			}
			
			if(!pfwrite(&DMaps[i].tmusic,sizeof(DMaps[0].tmusic),f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",26);
			}
			
			if(!p_putc(DMaps[i].tmusictrack,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",25);
			}
			
			if(!p_putc(DMaps[i].active_subscreen,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",26);
			}
			
			if(!p_putc(DMaps[i].passive_subscreen,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",27);
			}
			
			byte disabled[32];
			memset(disabled,0,32);
			
			for(int j=0; j<MAXITEMS; j++)
			{
				if(DMaps[i].disableditems[j])
				{
					disabled[j/8] |= (1 << (j%8));
				}
			}
			
			if(!pfwrite(disabled,32,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",28);
			}
			
			if(!p_iputl(DMaps[i].flags,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",29);
			}
		if(!p_putc(DMaps[i].sideview,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",30);
			}
		if(!p_iputw(DMaps[i].script,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",31);
			}
		for ( int q = 0; q < 8; q++ )
		{
		if(!p_iputl(DMaps[i].initD[q],f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",32);
		}
			
		}
		for ( int q = 0; q < 8; q++ )
		{
			for ( int w = 0; w < 65; w++ )
			{
			if (!p_putc(DMaps[i].initD_label[q][w],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",33);
			}
		}
		}
		}
}
void FFScript::read_dmaps(PACKFILE *f, int vers_id)
{
	word dmap_count=count_dmaps();
  
		dmap_count=zc_min(dmap_count, 512);
		dmap_count=zc_min(dmap_count, MAXDMAPS-0);
		
		//finally...  section data
		if(!p_igetw(&dmap_count,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",5);
		}
		
		
		for(int i=0; i<dmap_count; i++)
		{
			if(!p_getc(&DMaps[i].map,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",6);
			}
			
			if(!p_igetw(&DMaps[i].level,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",7);
			}
			
			if(!p_getc(&DMaps[i].xoff,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",8);
			}
			
			if(!p_getc(&DMaps[i].compass,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",9);
			}
			
			if(!p_igetw(&DMaps[i].color,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",10);
			}
			
			if(!p_getc(&DMaps[i].midi,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",11);
			}
			
			if(!p_getc(&DMaps[i].cont,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",12);
			}
			
			if(!p_getc(&DMaps[i].type,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",13);
			}
			
			for(int j=0; j<8; j++)
			{
				if(!p_getc(&DMaps[i].grid[j],f,true))
				{
					Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",14);
				}
			}
			
			//16
			if(!pfread((&DMaps[i].name),sizeof(DMaps[0].name),f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",15);
			}
			
			if(!pfread((&DMaps[i].title),sizeof(DMaps[0].title),f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",16);
			}
			
			if(!pfread((&DMaps[i].intro),sizeof(DMaps[0].intro),f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",17);
			}
			
			if(!p_igetl(&DMaps[i].minimap_1_tile,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",18);
			}
			
			if(!p_getc(&DMaps[i].minimap_1_cset,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",19);
			}
			
			if(!p_igetl(&DMaps[i].minimap_2_tile,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",20);
			}
			
			if(!p_getc(&DMaps[i].minimap_2_cset,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",21);
			}
			
			if(!p_igetl(&DMaps[i].largemap_1_tile,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",22);
			}
			
			if(!p_getc(&DMaps[i].largemap_1_cset,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",23);
			}
			
			if(!p_igetl(&DMaps[i].largemap_2_tile,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",24);
			}
			
			if(!p_getc(&DMaps[i].largemap_2_cset,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",25);
			}
			
			if(!pfread((&DMaps[i].tmusic),sizeof(DMaps[0].tmusic),f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",26);
			}
			
			if(!p_getc(&DMaps[i].tmusictrack,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",25);
			}
			
			if(!p_getc(&DMaps[i].active_subscreen,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",26);
			}
			
			if(!p_getc(&DMaps[i].passive_subscreen,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",27);
			}
			
			byte disabled[32];
			memset(disabled,0,32);
			
			for(int j=0; j<MAXITEMS; j++)
			{
				if(&DMaps[i].disableditems[j])
				{
					disabled[j/8] |= (1 << (j%8));
				}
			}
			
			if(!pfread(disabled,32,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",28);
			}
			
			if(!p_igetl(&DMaps[i].flags,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",29);
			}
		if(!p_getc(&DMaps[i].sideview,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",30);
			}
		if(!p_igetw(&DMaps[i].script,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",31);
			}
		for ( int q = 0; q < 8; q++ )
		{
		if(!p_igetl(&DMaps[i].initD[q],f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",32);
		}
			
		}
		for ( int q = 0; q < 8; q++ )
		{
			for ( int w = 0; w < 65; w++ )
			{
			if (!p_getc(&DMaps[i].initD_label[q][w],f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read DMAP NODE: %d",33);
			}
		}
		}
		}
}



void FFScript::read_combos(PACKFILE *f, int version_id)
{
	
	word combos_used = 0;
	
		if(!p_igetw(&combos_used,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",5);
		}
		
		for(int i=0; i<combos_used; i++)
		{
			if(!p_igetl(&combobuf[i].tile,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",6);
			}
			
			if(!p_getc(&combobuf[i].flip,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",7);
			}
			
			if(!p_getc(&combobuf[i].walk,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",8);
			}
			
			if(!p_getc(&combobuf[i].type,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",9);
			}
			
			if(!p_getc(&combobuf[i].csets,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",10);
			}
			
			if(!p_getc(&combobuf[i].frames,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",11);
			}
			
			if(!p_getc(&combobuf[i].speed,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",12);
			}
			
			if(!p_igetw(&combobuf[i].nextcombo,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",13);
			}
			
			if(!p_getc(&combobuf[i].nextcset,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",14);
			}
			
			if(!p_getc(&combobuf[i].flag,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",15);
			}
			
			if(!p_getc(&combobuf[i].skipanim,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",16);
			}
			
			if(!p_igetw(&combobuf[i].nexttimer,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",17);
			}
			
			if(!p_getc(&combobuf[i].skipanimy,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",18);
			}
			
			if(!p_getc(&combobuf[i].animflags,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",19);
			}
		
		for ( int q = 0; q < NUM_COMBO_ATTRIBUTES; q++ )
		{
		if(!p_igetl(&combobuf[i].attributes[q],f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",20);
		}
		}
		if(!p_igetl(&combobuf[i].usrflags,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",21);
		}	 
		for ( int q = 0; q < 3; q++ ) 
		{
			if(!p_igetl(&combobuf[i].triggerflags[q],f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",22);
			}
		}
		
		if(!p_igetl(&combobuf[i].triggerlevel,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",23);
		}	
		for ( int q = 0; q < 11; q++ ) 
		{
			if(!p_getc(&combobuf[i].label[q],f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",24);
			}
		}
		for ( int q = 0; q < NUM_COMBO_ATTRIBUTES; q++ )
		{
			if(!p_getc(&combobuf[i].attribytes[q],f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",25);
			}
		}
		if(!p_igetw(&combobuf[i].script,f,true))
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",26);
		for ( int q = 0; q < 2; q++ )
		{
			if(!p_igetl(&combobuf[i].initd[q],f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",27);
			}
		}
		if(!p_igetl(&combobuf[i].o_tile,f,true))
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",28);
		if(!p_getc(&combobuf[i].cur_frame,f,true))
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",29);
		if(!p_getc(&combobuf[i].aclk,f,true))
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",30);
		}
}

void FFScript::write_combos(PACKFILE *f, int version_id)
{
	
	word combos_used = 0;
	
		//finally...  section data
		combos_used=count_combos()-0;
		combos_used=zc_min(combos_used, MAXCOMBOS);
		
		if(!p_iputw(combos_used,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",5);
		}
		
		for(int i=0; i<combos_used; i++)
		{
			if(!p_iputl(combobuf[i].tile,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",6);
			}
			
			if(!p_putc(combobuf[i].flip,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",7);
			}
			
			if(!p_putc(combobuf[i].walk,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",8);
			}
			
			if(!p_putc(combobuf[i].type,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",9);
			}
			
			if(!p_putc(combobuf[i].csets,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",10);
			}
			
			if(!p_putc(combobuf[i].frames,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",11);
			}
			
			if(!p_putc(combobuf[i].speed,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",12);
			}
			
			if(!p_iputw(combobuf[i].nextcombo,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",13);
			}
			
			if(!p_putc(combobuf[i].nextcset,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",14);
			}
			
			if(!p_putc(combobuf[i].flag,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",15);
			}
			
			if(!p_putc(combobuf[i].skipanim,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",16);
			}
			
			if(!p_iputw(combobuf[i].nexttimer,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",17);
			}
			
			if(!p_putc(combobuf[i].skipanimy,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",18);
			}
			
			if(!p_putc(combobuf[i].animflags,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",19);
			}
		
		for ( int q = 0; q < NUM_COMBO_ATTRIBUTES; q++ )
		{
		if(!p_iputl(combobuf[i].attributes[q],f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",20);
		}
		}
		if(!p_iputl(combobuf[i].usrflags,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",21);
		}	 
		for ( int q = 0; q < 3; q++ ) 
		{
			if(!p_iputl(combobuf[i].triggerflags[q],f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",22);
			}
		}
		
		if(!p_iputl(combobuf[i].triggerlevel,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",23);
		}	
		for ( int q = 0; q < 11; q++ ) 
		{
			if(!p_putc(combobuf[i].label[q],f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",24);
			}
		}
		for ( int q = 0; q < NUM_COMBO_ATTRIBUTES; q++ )
		{
			if(!p_putc(combobuf[i].attribytes[q],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",25);
			}
		}
		if(!p_iputw(combobuf[i].script,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",26);
		}
		for ( int q = 0; q < 2; q++ )
		{
			if(!p_iputl(combobuf[i].initd[q],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",27);
			}
		}
		if(!p_iputl(combobuf[i].o_tile,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",28);
		}
		if(!p_putc(combobuf[i].cur_frame,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",29);
		}
		if(!p_putc(combobuf[i].aclk,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read COMBO NODE: %d",30);
		}
			
		}
}
void FFScript::read_weaponsprtites(PACKFILE *f, int vers_id)
{   
		for(int i=0; i<wMAX; i++)
		{
			if(!p_igetw(&wpnsbuf[i].tile,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read WPNSPRITE NODE: %d",6);
			}
			
			if(!p_getc(&wpnsbuf[i].misc,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read WPNSPRITE NODE: %d",7);
			}
			
			if(!p_getc(&wpnsbuf[i].csets,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read WPNSPRITE NODE: %d",8);
			}
			
			if(!p_getc(&wpnsbuf[i].frames,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read WPNSPRITE NODE: %d",9);
			}
			
			if(!p_getc(&wpnsbuf[i].speed,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read WPNSPRITE NODE: %d",10);
			}
			
			if(!p_getc(&wpnsbuf[i].type,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read WPNSPRITE NODE: %d",11);
			}
		
		if(!p_igetw(&wpnsbuf[i].script,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read WPNSPRITE NODE: %d",12);
			}
		
		if(!p_igetl(&wpnsbuf[i].newtile,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read WPNSPRITE NODE: %d",12);
			}
		}
}
void FFScript::write_weaponsprtites(PACKFILE *f, int vers_id)
{   
		for(int i=0; i<wMAX; i++)
		{
			if(!p_iputw(wpnsbuf[i].tile,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read WPNSPRITE NODE: %d",6);
			}
			
			if(!p_putc(wpnsbuf[i].misc,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read WPNSPRITE NODE: %d",7);
			}
			
			if(!p_putc(wpnsbuf[i].csets,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read WPNSPRITE NODE: %d",8);
			}
			
			if(!p_putc(wpnsbuf[i].frames,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read WPNSPRITE NODE: %d",9);
			}
			
			if(!p_putc(wpnsbuf[i].speed,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read WPNSPRITE NODE: %d",10);
			}
			
			if(!p_putc(wpnsbuf[i].type,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read WPNSPRITE NODE: %d",11);
			}
		
		if(!p_iputw(wpnsbuf[i].script,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read WPNSPRITE NODE: %d",12);
			}
		
		if(!p_iputl(wpnsbuf[i].newtile,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read WPNSPRITE NODE: %d",12);
			}
		}
}


void FFScript::read_enemies(PACKFILE *f, int vers_id)
{
	if ( !f ) return;
	for(int i=0; i<MAXGUYS; i++)
	{
			if(!p_igetl(&guysbuf[i].flags,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",6);
			}
			
			if(!p_igetl(&guysbuf[i].flags2,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",7);
			}
			
			if(!p_igetl(&guysbuf[i].tile,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",8);
			}
			
			if(!p_getc(&guysbuf[i].width,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",9);
			}
			
			if(!p_getc(&guysbuf[i].height,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",10);
			}
			
			if(!p_igetl(&guysbuf[i].s_tile,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",11);
			}
			
			if(!p_getc(&guysbuf[i].s_width,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",12);
			}
			
			if(!p_getc(&guysbuf[i].s_height,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",13);
			}
			
			if(!p_igetl(&guysbuf[i].e_tile,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",14);
			}
			
			if(!p_getc(&guysbuf[i].e_width,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",15);
			}
			
			if(!p_getc(&guysbuf[i].e_height,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",16);
			}
			
			if(!p_igetw(&guysbuf[i].hp,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",17);
			}
			
			if(!p_igetw(&guysbuf[i].family,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",18);
			}
			
			if(!p_igetw(&guysbuf[i].cset,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",19);
			}
			
			if(!p_igetw(&guysbuf[i].anim,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",20);
			}
			
			if(!p_igetw(&guysbuf[i].e_anim,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",21);
			}
			
			if(!p_igetw(&guysbuf[i].frate,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",22);
			}
			
			if(!p_igetw(&guysbuf[i].e_frate,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",23);
			}
			
			if(!p_igetw(&guysbuf[i].dp,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",24);
			}
			
			if(!p_igetw(&guysbuf[i].wdp,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",25);
			}
			
			if(!p_igetw(&guysbuf[i].weapon,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",26);
			}
			
			if(!p_igetw(&guysbuf[i].rate,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",27);
			}
			
			if(!p_igetw(&guysbuf[i].hrate,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",28);
			}
			
			if(!p_igetw(&guysbuf[i].step,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",29);
			}
			
			if(!p_igetw(&guysbuf[i].homing,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",30);
			}
			
			if(!p_igetw(&guysbuf[i].grumble,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",31);
			}
			
			if(!p_igetw(&guysbuf[i].item_set,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",32);
			}
			
			if(!p_igetl(&guysbuf[i].misc1,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",33);
			}
			
			if(!p_igetl(&guysbuf[i].misc2,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",34);
			}
			
			if(!p_igetl(&guysbuf[i].misc3,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",35);
			}
			
			if(!p_igetl(&guysbuf[i].misc4,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",36);
			}
			
			if(!p_igetl(&guysbuf[i].misc5,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",37);
			}
			
			if(!p_igetl(&guysbuf[i].misc6,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",38);
			}
			
			if(!p_igetl(&guysbuf[i].misc7,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",39);
			}
			
			if(!p_igetl(&guysbuf[i].misc8,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",40);
			}
			
			if(!p_igetl(&guysbuf[i].misc9,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",41);
			}
			
			if(!p_igetl(&guysbuf[i].misc10,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",42);
			}
			
			if(!p_igetw(&guysbuf[i].bgsfx,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",43);
			}
			
			if(!p_igetw(&guysbuf[i].bosspal,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",44);
			}
			
			if(!p_igetw(&guysbuf[i].extend,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",45);
			}
			
			for(int j=0; j < edefLAST; j++)
			{
			if(!p_getc(&guysbuf[i].defense[j],f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",46);
			}
			}
			
			if(!p_getc(&guysbuf[i].hitsfx,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",47);
			}
			
			if(!p_getc(&guysbuf[i].deadsfx,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",48);
			}
			
			if(!p_igetl(&guysbuf[i].misc11,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",49);
			}
			
			if(!p_igetl(&guysbuf[i].misc12,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",50);
			}
			
			//New 2.6 defences
			for(int j=edefLAST; j < edefLAST255; j++)
			{
			if(!p_getc(&guysbuf[i].defense[j],f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",51);
			}
			}
			
			//tilewidth, tileheight, hitwidth, hitheight, hitzheight, hitxofs, hityofs, hitzofs
			if(!p_igetl(&guysbuf[i].txsz,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",52);
			}
			if(!p_igetl(&guysbuf[i].tysz,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",53);
			}
			if(!p_igetl(&guysbuf[i].hxsz,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",54);
			}
			if(!p_igetl(&guysbuf[i].hysz,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",55);
			}
			if(!p_igetl(&guysbuf[i].hzsz,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",56);
			}
			// These are not fixed types, but ints, so they are safe to use here. 
			if(!p_igetl(&guysbuf[i].hxofs,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",57);
			}
			if(!p_igetl(&guysbuf[i].hyofs,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",58);
			}
			if(!p_igetl(&guysbuf[i].xofs,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",59);
			}
			if(!p_igetl(&guysbuf[i].yofs,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",60);
			}
			if(!p_igetl(&guysbuf[i].zofs,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",61);
			}
			if(!p_igetl(&guysbuf[i].wpnsprite,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",62);
			}
			if(!p_igetl(&guysbuf[i].SIZEflags,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",63);
			}
			if(!p_igetl(&guysbuf[i].frozentile,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",64);
			}
			if(!p_igetl(&guysbuf[i].frozencset,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",65);
			}
			if(!p_igetl(&guysbuf[i].frozenclock,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",66);
			}
			
			for ( int q = 0; q < 10; q++ ) 
			{
			if(!p_igetw(&guysbuf[i].frozenmisc[q],f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",67);
			}
			}
			if(!p_igetw(&guysbuf[i].firesfx,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",68);
			}
			//misc 16->31
			if(!p_igetl(&guysbuf[i].misc16,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",69);
			}
			if(!p_igetl(&guysbuf[i].misc17,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",70);
			}
			if(!p_igetl(&guysbuf[i].misc18,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",71);
			}
			if(!p_igetl(&guysbuf[i].misc19,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",72);
			}
			if(!p_igetl(&guysbuf[i].misc20,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",73);
			}
			if(!p_igetl(&guysbuf[i].misc21,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",74);
			}
			if(!p_igetl(&guysbuf[i].misc22,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",75);
			}
			if(!p_igetl(&guysbuf[i].misc23,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",76);
			}
			if(!p_igetl(&guysbuf[i].misc24,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",77);
			}
			if(!p_igetl(&guysbuf[i].misc25,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",78);
			}
			if(!p_igetl(&guysbuf[i].misc26,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",79);
			}
			if(!p_igetl(&guysbuf[i].misc27,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",80);
			}
			if(!p_igetl(&guysbuf[i].misc28,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",81);
			}
			if(!p_igetl(&guysbuf[i].misc29,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",82);
			}
			if(!p_igetl(&guysbuf[i].misc30,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",83);
			}
			if(!p_igetl(&guysbuf[i].misc31,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",84);
			}
			if(!p_igetl(&guysbuf[i].misc32,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",85);
			}
			for ( int q = 0; q < 32; q++ )
			{
				if(!p_igetl(&guysbuf[i].movement[q],f,true))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",86);
				}
			}
			for ( int q = 0; q < 32; q++ )
			{
				if(!p_igetl(&guysbuf[i].new_weapon[q],f,true))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",87);
				}
			}
			if(!p_igetw(&guysbuf[i].script,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",88);
			}
			for ( int q = 0; q < 8; q++ )
			{
			if(!p_igetl(&guysbuf[i].initD[q],f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",89);
			}
			}
			for ( int q = 0; q < 2; q++ )
			{
			if(!p_igetl(&guysbuf[i].initA[q],f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",90);
			}
			}
			if(!p_igetl(&guysbuf[i].editorflags,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",91);
			}
			//somehow forgot these in the older builds -Z
			if(!p_igetl(&guysbuf[i].misc13,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",92);
			}
			if(!p_igetl(&guysbuf[i].misc14,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",93);
			}
			if(!p_igetl(&guysbuf[i].misc15,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",94);
			}
			
			//Enemy Editor InitD[] labels
			for ( int q = 0; q < 8; q++ )
			{
				for ( int w = 0; w < 65; w++ )
				{
					if(!p_getc(&guysbuf[i].initD_label[q][w],f,true))
					{
						Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",95);
					} 
				}
				for ( int w = 0; w < 65; w++ )
				{
					if(!p_getc(&guysbuf[i].weapon_initD_label[q][w],f,true))
					{
						Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",96);
					} 
				}
			}
			if(!p_igetw(&guysbuf[i].weaponscript,f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",97);
			}
			//eweapon initD
			for ( int q = 0; q < 8; q++ )
			{
			if(!p_igetl(&guysbuf[i].weap_initiald[q],f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read GUY NODE: %d",98);
			}
			}
			
	}
}

void FFScript::write_enemies(PACKFILE *f, int vers_id)
{
	if ( !f ) return;
	for(int i=0; i<MAXGUYS; i++)
	{
		if(!p_iputl(guysbuf[i].flags,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",6);
		}
		
		if(!p_iputl(guysbuf[i].flags2,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",7);
		}
		
		if(!p_iputl(guysbuf[i].tile,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",8);
		}
		
		if(!p_putc(guysbuf[i].width,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",9);
		}
		
		if(!p_putc(guysbuf[i].height,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",10);
		}
		
		if(!p_iputl(guysbuf[i].s_tile,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",11);
		}
		
		if(!p_putc(guysbuf[i].s_width,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",12);
		}
		
		if(!p_putc(guysbuf[i].s_height,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",13);
		}
		
		if(!p_iputl(guysbuf[i].e_tile,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",14);
		}
		
		if(!p_putc(guysbuf[i].e_width,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",15);
		}
		
		if(!p_putc(guysbuf[i].e_height,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",16);
		}
		
		if(!p_iputw(guysbuf[i].hp,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",17);
		}
		
		if(!p_iputw(guysbuf[i].family,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",18);
		}
		
		if(!p_iputw(guysbuf[i].cset,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",19);
		}
		
		if(!p_iputw(guysbuf[i].anim,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",20);
		}
		
		if(!p_iputw(guysbuf[i].e_anim,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",21);
		}
		
		if(!p_iputw(guysbuf[i].frate,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",22);
		}
		
		if(!p_iputw(guysbuf[i].e_frate,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",23);
		}
		
		if(!p_iputw(guysbuf[i].dp,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",24);
		}
		
		if(!p_iputw(guysbuf[i].wdp,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",25);
		}
		
		if(!p_iputw(guysbuf[i].weapon,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",26);
		}
		
		if(!p_iputw(guysbuf[i].rate,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",27);
		}
		
		if(!p_iputw(guysbuf[i].hrate,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",28);
		}
		
		if(!p_iputw(guysbuf[i].step,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",29);
		}
		
		if(!p_iputw(guysbuf[i].homing,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",30);
		}
		
		if(!p_iputw(guysbuf[i].grumble,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",31);
		}
		
		if(!p_iputw(guysbuf[i].item_set,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",32);
		}
		
		if(!p_iputl(guysbuf[i].misc1,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",33);
		}
		
		if(!p_iputl(guysbuf[i].misc2,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",34);
		}
		
		if(!p_iputl(guysbuf[i].misc3,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",35);
		}
		
		if(!p_iputl(guysbuf[i].misc4,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",36);
		}
		
		if(!p_iputl(guysbuf[i].misc5,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",37);
		}
		
		if(!p_iputl(guysbuf[i].misc6,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",38);
		}
		
		if(!p_iputl(guysbuf[i].misc7,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",39);
		}
		
		if(!p_iputl(guysbuf[i].misc8,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",40);
		}
		
		if(!p_iputl(guysbuf[i].misc9,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",41);
		}
		
		if(!p_iputl(guysbuf[i].misc10,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",42);
		}
		
		if(!p_iputw(guysbuf[i].bgsfx,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",43);
		}
		
		if(!p_iputw(guysbuf[i].bosspal,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",44);
		}
		
		if(!p_iputw(guysbuf[i].extend,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",45);
		}
		
		for(int j=0; j < edefLAST; j++)
		{
		if(!p_putc(guysbuf[i].defense[j],f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",46);
		}
		}
		
		if(!p_putc(guysbuf[i].hitsfx,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",47);
		}
		
		if(!p_putc(guysbuf[i].deadsfx,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",48);
		}
		
		if(!p_iputl(guysbuf[i].misc11,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",49);
		}
		
		if(!p_iputl(guysbuf[i].misc12,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",50);
		}
		
		//New 2.6 defences
		for(int j=edefLAST; j < edefLAST255; j++)
		{
		if(!p_putc(guysbuf[i].defense[j],f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",51);
		}
		}
		
		//tilewidth, tileheight, hitwidth, hitheight, hitzheight, hitxofs, hityofs, hitzofs
		if(!p_iputl(guysbuf[i].txsz,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",52);
		}
		if(!p_iputl(guysbuf[i].tysz,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",53);
		}
		if(!p_iputl(guysbuf[i].hxsz,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",54);
		}
		if(!p_iputl(guysbuf[i].hysz,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",55);
		}
		if(!p_iputl(guysbuf[i].hzsz,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",56);
		}
		// These are not fixed types, but ints, so they are safe to use here. 
		if(!p_iputl(guysbuf[i].hxofs,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",57);
		}
		if(!p_iputl(guysbuf[i].hyofs,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",58);
		}
		if(!p_iputl(guysbuf[i].xofs,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",59);
		}
		if(!p_iputl(guysbuf[i].yofs,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",60);
		}
		if(!p_iputl(guysbuf[i].zofs,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",61);
		}
		if(!p_iputl(guysbuf[i].wpnsprite,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",62);
		}
		if(!p_iputl(guysbuf[i].SIZEflags,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",63);
		}
		if(!p_iputl(guysbuf[i].frozentile,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",64);
		}
		if(!p_iputl(guysbuf[i].frozencset,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",65);
		}
		if(!p_iputl(guysbuf[i].frozenclock,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",66);
		}
		
		for ( int q = 0; q < 10; q++ ) 
		{
		if(!p_iputw(guysbuf[i].frozenmisc[q],f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",67);
		}
		}
		if(!p_iputw(guysbuf[i].firesfx,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",68);
		}
		//misc 16->31
		if(!p_iputl(guysbuf[i].misc16,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",69);
		}
		if(!p_iputl(guysbuf[i].misc17,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",70);
		}
		if(!p_iputl(guysbuf[i].misc18,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",71);
		}
		if(!p_iputl(guysbuf[i].misc19,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",72);
		}
		if(!p_iputl(guysbuf[i].misc20,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",73);
		}
		if(!p_iputl(guysbuf[i].misc21,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",74);
		}
		if(!p_iputl(guysbuf[i].misc22,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",75);
		}
		if(!p_iputl(guysbuf[i].misc23,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",76);
		}
		if(!p_iputl(guysbuf[i].misc24,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",77);
		}
		if(!p_iputl(guysbuf[i].misc25,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",78);
		}
		if(!p_iputl(guysbuf[i].misc26,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",79);
		}
		if(!p_iputl(guysbuf[i].misc27,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",80);
		}
		if(!p_iputl(guysbuf[i].misc28,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",81);
		}
		if(!p_iputl(guysbuf[i].misc29,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",82);
		}
		if(!p_iputl(guysbuf[i].misc30,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",83);
		}
		if(!p_iputl(guysbuf[i].misc31,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",84);
		}
		if(!p_iputl(guysbuf[i].misc32,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",85);
		}
		for ( int q = 0; q < 32; q++ )
		{
			if(!p_iputl(guysbuf[i].movement[q],f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",86);
			}
		}
		for ( int q = 0; q < 32; q++ )
		{
			if(!p_iputl(guysbuf[i].new_weapon[q],f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",87);
			}
		}
		if(!p_iputw(guysbuf[i].script,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",88);
		}
		for ( int q = 0; q < 8; q++ )
		{
		if(!p_iputl(guysbuf[i].initD[q],f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",89);
		}
		}
		for ( int q = 0; q < 2; q++ )
		{
		if(!p_iputl(guysbuf[i].initA[q],f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",90);
		}
		}
		if(!p_iputl(guysbuf[i].editorflags,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",91);
		}
		//somehow forgot these in the older builds -Z
		if(!p_iputl(guysbuf[i].misc13,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",92);
		}
		if(!p_iputl(guysbuf[i].misc14,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",93);
		}
		if(!p_iputl(guysbuf[i].misc15,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",94);
		}
		
		//Enemy Editor InitD[] labels
		for ( int q = 0; q < 8; q++ )
		{
			for ( int w = 0; w < 65; w++ )
			{
				if(!p_putc(guysbuf[i].initD_label[q][w],f))
				{
					Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",95);
				} 
			}
			for ( int w = 0; w < 65; w++ )
			{
				if(!p_putc(guysbuf[i].weapon_initD_label[q][w],f))
				{
					Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",96);
				} 
			}
		}
		if(!p_iputw(guysbuf[i].weaponscript,f))
		{
		Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",97);
		}
		//eweapon initD
		for ( int q = 0; q < 8; q++ )
		{
		if(!p_iputl(guysbuf[i].weap_initiald[q],f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write GUY NODE: %d",98);
		}
		}
		
	}
}


void FFScript::write_items(PACKFILE *f, int vers_id)
{
		for(int i=0; i<iMax; i++)
		{
			if(!p_iputl(itemsbuf[i].tile,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",6);
			}
			
			if(!p_putc(itemsbuf[i].misc,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",7);
			}
			
			if(!p_putc(itemsbuf[i].csets,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",8);
			}
			
			if(!p_putc(itemsbuf[i].frames,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",9);
			}
			
			if(!p_putc(itemsbuf[i].speed,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",10);
			}
			
			if(!p_putc(itemsbuf[i].delay,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",11);
			}
			
			if(!p_iputl(itemsbuf[i].ltm,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",12);
			}
			
			if(!p_iputl(itemsbuf[i].family,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",13);
			}
			
			if(!p_putc(itemsbuf[i].fam_type,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",14);
			}
			
			if(!p_iputl(itemsbuf[i].power,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",14);
			}
			
			if(!p_iputl(itemsbuf[i].flags,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",15);
			}
			
			if(!p_iputw(itemsbuf[i].script,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",16);
			}
			
			if(!p_putc(itemsbuf[i].count,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",17);
			}
			
			if(!p_iputw(itemsbuf[i].amount,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",18);
			}
			
			if(!p_iputw(itemsbuf[i].collect_script,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",19);
			}
			
			if(!p_iputw(itemsbuf[i].setmax,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",21);
			}
			
			if(!p_iputw(itemsbuf[i].max,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",22);
			}
			
			if(!p_putc(itemsbuf[i].playsound,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",23);
			}
			
			for(int j=0; j<8; j++)
			{
				if(!p_iputl(itemsbuf[i].initiald[j],f))
				{
					Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",24);
				}
			}
			
			for(int j=0; j<2; j++)
			{
				if(!p_putc(itemsbuf[i].initiala[j],f))
				{
					Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",25);
				}
			}
			
			if(!p_putc(itemsbuf[i].wpn,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",26);
			}
			
			if(!p_putc(itemsbuf[i].wpn2,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",27);
			}
			
			if(!p_putc(itemsbuf[i].wpn3,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",28);
			}
			
			if(!p_putc(itemsbuf[i].wpn4,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",29);
			}
			
			if(!p_putc(itemsbuf[i].wpn5,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",30);
			}
			
			if(!p_putc(itemsbuf[i].wpn6,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",31);
			}
			
			if(!p_putc(itemsbuf[i].wpn7,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",32);
			}
			
			if(!p_putc(itemsbuf[i].wpn8,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",33);
			}
			
			if(!p_putc(itemsbuf[i].wpn9,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",34);
			}
			
			if(!p_putc(itemsbuf[i].wpn10,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",35);
			}
			
			if(!p_putc(itemsbuf[i].pickup_hearts,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",36);
			}
			
			if(!p_iputl(itemsbuf[i].misc1,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",37);
			}
			
			if(!p_iputl(itemsbuf[i].misc2,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",38);
			}
			
			if(!p_putc(itemsbuf[i].magic,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",39);
			}
			
			if(!p_iputl(itemsbuf[i].misc3,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",40);
			}
			
			if(!p_iputl(itemsbuf[i].misc4,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",41);
			}
			
			if(!p_iputl(itemsbuf[i].misc5,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",42);
			}
			
			if(!p_iputl(itemsbuf[i].misc6,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",43);
			}
			
			if(!p_iputl(itemsbuf[i].misc7,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",44);
			}
			
			if(!p_iputl(itemsbuf[i].misc8,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",45);
			}
			
			if(!p_iputl(itemsbuf[i].misc9,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",46);
			}
			
			if(!p_iputl(itemsbuf[i].misc10,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",47);
			}
			
			if(!p_putc(itemsbuf[i].usesound,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",48);
			}
		
		//New itemdata vars -Z
		//! version 27
		
		if(!p_putc(itemsbuf[i].useweapon,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",49);
			}
		if(!p_putc(itemsbuf[i].usedefence,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",50);
			}
		if(!p_iputl(itemsbuf[i].weaprange,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",51);
			}
		if(!p_iputl(itemsbuf[i].weapduration,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",52);
			}
		for ( int q = 0; q < ITEM_MOVEMENT_PATTERNS; q++ ) {
			if(!p_iputl(itemsbuf[i].weap_pattern[q],f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",53);
			}
		}
		//version 28
		if(!p_iputl(itemsbuf[i].duplicates,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",54);
		}
		for ( int q = 0; q < INITIAL_D; q++ )
		{
			if(!p_iputl(itemsbuf[i].weap_initiald[q],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",55);
			}
		}
		for ( int q = 0; q < INITIAL_A; q++ )
		{
			if(!p_putc(itemsbuf[i].weap_initiala[q],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",56);
			}
		}

		if(!p_putc(itemsbuf[i].drawlayer,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",57);
		}


		if(!p_iputl(itemsbuf[i].hxofs,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",58);
		}
		if(!p_iputl(itemsbuf[i].hyofs,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",59);
		}
		if(!p_iputl(itemsbuf[i].hxsz,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",60);
		}
		if(!p_iputl(itemsbuf[i].hysz,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",61);
		}
		if(!p_iputl(itemsbuf[i].hzsz,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",62);
		}
		if(!p_iputl(itemsbuf[i].xofs,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",63);
		}
		if(!p_iputl(itemsbuf[i].yofs,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",64);
		}
		if(!p_iputl(itemsbuf[i].weap_hxofs,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",65);
		}
		if(!p_iputl(itemsbuf[i].weap_hyofs,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",66);
		}
		if(!p_iputl(itemsbuf[i].weap_hxsz,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",67);
		}
		if(!p_iputl(itemsbuf[i].weap_hysz,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",68);
		}
		if(!p_iputl(itemsbuf[i].weap_hzsz,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",69);
		}
		if(!p_iputl(itemsbuf[i].weap_xofs,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",70);
		}
		if(!p_iputl(itemsbuf[i].weap_yofs,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",71);
		}
		if(!p_iputw(itemsbuf[i].weaponscript,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",72);
		}
		if(!p_iputl(itemsbuf[i].wpnsprite,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",73);
		}
		if(!p_iputl(itemsbuf[i].magiccosttimer,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",74);
		}
		if(!p_iputl(itemsbuf[i].overrideFLAGS,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",75);
		}
		if(!p_iputl(itemsbuf[i].tilew,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",76);
		}
		if(!p_iputl(itemsbuf[i].tileh,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",77);
		}
		if(!p_iputl(itemsbuf[i].weapoverrideFLAGS,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",78);
		}
		if(!p_iputl(itemsbuf[i].weap_tilew,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",79);
		}
		if(!p_iputl(itemsbuf[i].weap_tileh,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",80);
		}
		if(!p_iputl(itemsbuf[i].pickup,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",81);
		}
		if(!p_iputw(itemsbuf[i].pstring,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",82);
		}
		if(!p_iputw(itemsbuf[i].pickup_string_flags,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",83);
		}
		
		if(!p_putc(itemsbuf[i].cost_counter,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",84);
		}
		
		//InitD[] labels
		for ( int q = 0; q < 8; q++ )
		{
			for ( int w = 0; w < 65; w++ )
			{
				if(!p_putc(itemsbuf[i].initD_label[q][w],f))
				{
					Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",85);
				} 
			}
			for ( int w = 0; w < 65; w++ )
			{
				if(!p_putc(itemsbuf[i].weapon_initD_label[q][w],f))
				{
					Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",86);
				} 
			}
			for ( int w = 0; w < 65; w++ )
			{
				if(!p_putc(itemsbuf[i].sprite_initD_label[q][w],f))
				{
					Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",87);
				} 
			}
			if(!p_iputl(itemsbuf[i].sprite_initiald[q],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",88);
			} 
		}
		for ( int q = 0; q < 2; q++ )
		{
			if(!p_putc(itemsbuf[i].sprite_initiala[q],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",89);
			} 
			
		}
		if(!p_iputw(itemsbuf[i].sprite_script,f))
		{
			Z_scripterrlog("do_savegamestructs FAILED to read ITEM NODE: %d",90);
		} 
		
		
		}
}

void FFScript::read_items(PACKFILE *f, int vers_id)
{
		for(int i=0; i<iMax; i++)
		{
			if(!p_igetl(&itemsbuf[i].tile,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",6);
			}
			
			if(!p_getc(&itemsbuf[i].misc,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",7);
			}
			
			if(!p_getc(&itemsbuf[i].csets,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",8);
			}
			
			if(!p_getc(&itemsbuf[i].frames,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",9);
			}
			
			if(!p_getc(&itemsbuf[i].speed,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",10);
			}
			
			if(!p_getc(&itemsbuf[i].delay,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",11);
			}
			
			if(!p_igetl(&itemsbuf[i].ltm,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",12);
			}
			
			if(!p_igetl(&itemsbuf[i].family,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",13);
			}
			
			if(!p_getc(&itemsbuf[i].fam_type,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",14);
			}
			
			if(!p_igetl(&itemsbuf[i].power,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",14);
			}
			
			if(!p_igetl(&itemsbuf[i].flags,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",15);
			}
			
			if(!p_igetw(&itemsbuf[i].script,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",16);
			}
			
			if(!p_getc(&itemsbuf[i].count,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",17);
			}
			
			if(!p_igetw(&itemsbuf[i].amount,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",18);
			}
			
			if(!p_igetw(&itemsbuf[i].collect_script,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",19);
			}
			
			if(!p_igetw(&itemsbuf[i].setmax,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",21);
			}
			
			if(!p_igetw(&itemsbuf[i].max,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",22);
			}
			
			if(!p_getc(&itemsbuf[i].playsound,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",23);
			}
			
			for(int j=0; j<8; j++)
			{
				if(!p_igetl(&itemsbuf[i].initiald[j],f,true))
				{
					Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",24);
				}
			}
			
			for(int j=0; j<2; j++)
			{
				if(!p_getc(&itemsbuf[i].initiala[j],f,true))
				{
					Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",25);
				}
			}
			
			if(!p_getc(&itemsbuf[i].wpn,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",26);
			}
			
			if(!p_getc(&itemsbuf[i].wpn2,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",27);
			}
			
			if(!p_getc(&itemsbuf[i].wpn3,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",28);
			}
			
			if(!p_getc(&itemsbuf[i].wpn4,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",29);
			}
			
			if(!p_getc(&itemsbuf[i].wpn5,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",30);
			}
			
			if(!p_getc(&itemsbuf[i].wpn6,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",31);
			}
			
			if(!p_getc(&itemsbuf[i].wpn7,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",32);
			}
			
			if(!p_getc(&itemsbuf[i].wpn8,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",33);
			}
			
			if(!p_getc(&itemsbuf[i].wpn9,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",34);
			}
			
			if(!p_getc(&itemsbuf[i].wpn10,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",35);
			}
			
			if(!p_getc(&itemsbuf[i].pickup_hearts,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",36);
			}
			
			if(!p_igetl(&itemsbuf[i].misc1,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",37);
			}
			
			if(!p_igetl(&itemsbuf[i].misc2,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",38);
			}
			
			if(!p_getc(&itemsbuf[i].magic,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",39);
			}
			
			if(!p_igetl(&itemsbuf[i].misc3,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",40);
			}
			
			if(!p_igetl(&itemsbuf[i].misc4,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",41);
			}
			
			if(!p_igetl(&itemsbuf[i].misc5,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",42);
			}
			
			if(!p_igetl(&itemsbuf[i].misc6,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",43);
			}
			
			if(!p_igetl(&itemsbuf[i].misc7,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",44);
			}
			
			if(!p_igetl(&itemsbuf[i].misc8,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",45);
			}
			
			if(!p_igetl(&itemsbuf[i].misc9,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",46);
			}
			
			if(!p_igetl(&itemsbuf[i].misc10,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",47);
			}
			
			if(!p_getc(&itemsbuf[i].usesound,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",48);
			}
		
		//New itemdata vars -Z
		//! version 27
		
		if(!p_getc(&itemsbuf[i].useweapon,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",49);
			}
		if(!p_getc(&itemsbuf[i].usedefence,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",50);
			}
		if(!p_igetl(&itemsbuf[i].weaprange,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",51);
			}
		if(!p_igetl(&itemsbuf[i].weapduration,f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",52);
			}
		for ( int q = 0; q < ITEM_MOVEMENT_PATTERNS; q++ ) {
			if(!p_igetl(&itemsbuf[i].weap_pattern[q],f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",53);
			}
		}
		//version 28
		if(!p_igetl(&itemsbuf[i].duplicates,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",54);
		}
		for ( int q = 0; q < INITIAL_D; q++ )
		{
			if(!p_igetl(&itemsbuf[i].weap_initiald[q],f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",55);
			}
		}
		for ( int q = 0; q < INITIAL_A; q++ )
		{
			if(!p_getc(&itemsbuf[i].weap_initiala[q],f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",56);
			}
		}

		if(!p_getc(&itemsbuf[i].drawlayer,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",57);
		}


		if(!p_igetl(&itemsbuf[i].hxofs,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",58);
		}
		if(!p_igetl(&itemsbuf[i].hyofs,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",59);
		}
		if(!p_igetl(&itemsbuf[i].hxsz,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",60);
		}
		if(!p_igetl(&itemsbuf[i].hysz,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",61);
		}
		if(!p_igetl(&itemsbuf[i].hzsz,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",62);
		}
		if(!p_igetl(&itemsbuf[i].xofs,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",63);
		}
		if(!p_igetl(&itemsbuf[i].yofs,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",64);
		}
		if(!p_igetl(&itemsbuf[i].weap_hxofs,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",65);
		}
		if(!p_igetl(&itemsbuf[i].weap_hyofs,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",66);
		}
		if(!p_igetl(&itemsbuf[i].weap_hxsz,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",67);
		}
		if(!p_igetl(&itemsbuf[i].weap_hysz,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",68);
		}
		if(!p_igetl(&itemsbuf[i].weap_hzsz,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",69);
		}
		if(!p_igetl(&itemsbuf[i].weap_xofs,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",70);
		}
		if(!p_igetl(&itemsbuf[i].weap_yofs,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",71);
		}
		if(!p_igetw(&itemsbuf[i].weaponscript,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",72);
		}
		if(!p_igetl(&itemsbuf[i].wpnsprite,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",73);
		}
		if(!p_igetl(&itemsbuf[i].magiccosttimer,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",74);
		}
		if(!p_igetl(&itemsbuf[i].overrideFLAGS,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",75);
		}
		if(!p_igetl(&itemsbuf[i].tilew,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",76);
		}
		if(!p_igetl(&itemsbuf[i].tileh,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",77);
		}
		if(!p_igetl(&itemsbuf[i].weapoverrideFLAGS,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",78);
		}
		if(!p_igetl(&itemsbuf[i].weap_tilew,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",79);
		}
		if(!p_igetl(&itemsbuf[i].weap_tileh,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",80);
		}
		if(!p_igetl(&itemsbuf[i].pickup,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",81);
		}
		if(!p_igetw(&itemsbuf[i].pstring,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",82);
		}
		if(!p_igetw(&itemsbuf[i].pickup_string_flags,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",83);
		}
		
		if(!p_getc(&itemsbuf[i].cost_counter,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",84);
		}
		
		//InitD[] labels
		for ( int q = 0; q < 8; q++ )
		{
			for ( int w = 0; w < 65; w++ )
			{
				if(!p_getc(&itemsbuf[i].initD_label[q][w],f,true))
				{
					Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",85);
				} 
			}
			for ( int w = 0; w < 65; w++ )
			{
				if(!p_getc(&itemsbuf[i].weapon_initD_label[q][w],f,true))
				{
					Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",86);
				} 
			}
			for ( int w = 0; w < 65; w++ )
			{
				if(!p_getc(&itemsbuf[i].sprite_initD_label[q][w],f,true))
				{
					Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",87);
				} 
			}
			if(!p_igetl(&itemsbuf[i].sprite_initiald[q],f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",88);
			} 
		}
		for ( int q = 0; q < 2; q++ )
		{
			if(!p_getc(&itemsbuf[i].sprite_initiala[q],f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",89);
			} 
			
		}
		if(!p_igetw(&itemsbuf[i].sprite_script,f,true))
		{
			Z_scripterrlog("do_savegamestructs FAILED to write ITEM NODE: %d",90);
		} 
		
		
		}
}
	
void FFScript::write_mapscreens(PACKFILE *f,int vers_id)
{
	for(int i=0; i<map_count && i<MAXMAPS2; i++)
		{
		for(int j=0; j<MAPSCRS; j++)
		{
			mapscr *m = &TheMaps[i*MAPSCRS+j];
			
			if(!p_putc(m->valid,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->guy,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			{
			if(!p_iputw(m->str,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			if(!p_putc(m->room,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->item,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->hasitem, f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			for(int k=0; k<4; k++)
			{
			if(!p_putc(m->tilewarptype[k],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			if(!p_iputw(m->door_combo_set,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			for(int k=0; k<4; k++)
			{
			if(!p_putc(m->warpreturnx[k],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			for(int k=0; k<4; k++)
			{
			if(!p_putc(m->warpreturny[k],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			if(!p_iputw(m->warpreturnc,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->stairx,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->stairy,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->itemx,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->itemy,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_iputw(m->color,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->enemyflags,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			for(int k=0; k<4; k++)
			{
			if(!p_putc(m->door[k],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			for(int k=0; k<4; k++)
			{
			if(!p_iputw(m->tilewarpdmap[k],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			for(int k=0; k<4; k++)
			{
			if(!p_putc(m->tilewarpscr[k],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			if(!p_putc(m->tilewarpoverlayflags,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->exitdir,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			for(int k=0; k<10; k++)
			{
			{
				if(!p_iputw(m->enemy[k],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
			}
			}
			
			if(!p_putc(m->pattern,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			for(int k=0; k<4; k++)
			{
			if(!p_putc(m->sidewarptype[k],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			if(!p_putc(m->sidewarpoverlayflags,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->warparrivalx,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->warparrivaly,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			for(int k=0; k<4; k++)
			{
			if(!p_putc(m->path[k],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			for(int k=0; k<4; k++)
			{
			if(!p_putc(m->sidewarpscr[k],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			for(int k=0; k<4; k++)
			{
			if(!p_iputw(m->sidewarpdmap[k],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			if(!p_putc(m->sidewarpindex,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_iputw(m->undercombo,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->undercset,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_iputw(m->catchall,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->flags,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->flags2,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->flags3,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->flags4,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->flags5,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_iputw(m->noreset,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_iputw(m->nocarry,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->flags6,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->flags7,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->flags8,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->flags9,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->flags10,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->csensitive,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->oceansfx,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->bosssfx,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->secretsfx,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->holdupsfx,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			for(int k=0; k<6; k++)
			{
			if(!p_putc(m->layermap[k],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			for(int k=0; k<6; k++)
			{
			if(!p_putc(m->layerscreen[k],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			for(int k=0; k<6; k++)
			{
			if(!p_putc(m->layeropacity[k],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			if(!p_iputw(m->timedwarptics,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->nextmap,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->nextscr,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			for(int k=0; k<128; k++)
			{
			if(!p_iputw(m->secretcombo[k],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			for(int k=0; k<128; k++)
			{
			if(!p_putc(m->secretcset[k],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			for(int k=0; k<128; k++)
			{
			if(!p_putc(m->secretflag[k],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			for(int k=0; k<(ZCMaps[i].tileWidth)*(ZCMaps[i].tileHeight); k++)
			{
			try
			{
				if(!p_iputw(m->data.at(k),f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
			}
			catch(std::out_of_range& )
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			for(int k=0; k<(ZCMaps[i].tileWidth)*(ZCMaps[i].tileHeight); k++)
			{
			try
			{
				if(!p_putc(m->sflag.at(k),f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
			}
			catch(std::out_of_range& )
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			for(int k=0; k<(ZCMaps[i].tileWidth)*(ZCMaps[i].tileHeight); k++)
			{
			try
			{
				if(!p_putc(m->cset.at(k),f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
			}
			catch(std::out_of_range& )
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			}
			
			if(!p_iputw(m->screen_midi,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->lens_layer,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_iputl(m->numff,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			for(int k=0; k<32; k++)
			{
			
				if(!p_iputw(m->ffdata[k],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_putc(m->ffcset[k],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputw(m->ffdelay[k],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputl(m->ffx[k],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputl(m->ffy[k],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputl(m->ffxdelta[k],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputl(m->ffydelta[k],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputl(m->ffxdelta2[k],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputl(m->ffydelta2[k],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_putc(m->fflink[k],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_putc(m->ffwidth[k],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_putc(m->ffheight[k],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputl(m->ffflags[k],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputw(m->ffscript[k],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputl(m->initd[k][0],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputl(m->initd[k][1],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputl(m->initd[k][2],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputl(m->initd[k][3],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputl(m->initd[k][4],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputl(m->initd[k][5],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputl(m->initd[k][6],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
				
				if(!p_iputl(m->initd[k][7],f))
				{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
				}
			
			}
			
			for ( int q = 0; q < 10; q++ ) 
			{
			if(!p_iputl(m->npcstrings[q],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			} 
			}
			for ( int q = 0; q < 10; q++ ) 
			{
			if(!p_iputw(m->new_items[q],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			} 
			}
			for ( int q = 0; q < 10; q++ ) 
			{
			if(!p_iputw(m->new_item_x[q],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			} 
			}
			for ( int q = 0; q < 10; q++ ) 
			{
			if(!p_iputw(m->new_item_y[q],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			} 
			}
			if(!p_iputw(m->script,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			} 
			for ( int q = 0; q < 8; q++ )
			{
			if(!p_iputl(m->screeninitd[q],f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			} 
				
			}
			if(!p_putc(m->preloadscript,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}
			
			if(!p_putc(m->hidelayers,f))
			{
			Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}  
			if(!p_putc(m->hidescriptlayers,f))
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODEz\n"); return;
			}    
				
			
		} //end mapscr for loop
	}
}
void FFScript::read_mapscreens(PACKFILE *f,int vers_id)
{
	for(int i=0; i<map_count && i<MAXMAPS2; i++)
		{
		for(int j=0; j<MAPSCRS; j++)
		{
			mapscr *m = &TheMaps[i*MAPSCRS+j];
			
			if(!p_getc(&(m->valid),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->guy),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			{
			if(!p_igetw(&(m->str),f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			if(!p_getc(&(m->room),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->item),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->hasitem), f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			for(int k=0; k<4; k++)
			{
			if(!p_getc(&(m->tilewarptype[k]),f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			if(!p_igetw(&(m->door_combo_set),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			for(int k=0; k<4; k++)
			{
			if(!p_getc(&(m->warpreturnx[k]),f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			for(int k=0; k<4; k++)
			{
			if(!p_getc(&(m->warpreturny[k]),f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			if(!p_igetw(&(m->warpreturnc),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->stairx),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->stairy),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->itemx),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->itemy),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_igetw(&(m->color),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->enemyflags),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			for(int k=0; k<4; k++)
			{
			if(!p_getc(&(m->door[k]),f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			for(int k=0; k<4; k++)
			{
			if(!p_igetw(&(m->tilewarpdmap[k]),f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			for(int k=0; k<4; k++)
			{
			if(!p_getc(&(m->tilewarpscr[k]),f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			if(!p_getc(&(m->tilewarpoverlayflags),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->exitdir),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			for(int k=0; k<10; k++)
			{
			{
				if(!p_igetw(&(m->enemy[k]),f,true))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
			}
			}
			
			if(!p_getc(&(m->pattern),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			for(int k=0; k<4; k++)
			{
			if(!p_getc(&(m->sidewarptype[k]),f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			if(!p_getc(&(m->sidewarpoverlayflags),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->warparrivalx),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->warparrivaly),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			for(int k=0; k<4; k++)
			{
			if(!p_getc(&(m->path[k]),f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			for(int k=0; k<4; k++)
			{
			if(!p_getc(&(m->sidewarpscr[k]),f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			for(int k=0; k<4; k++)
			{
			if(!p_igetw(&(m->sidewarpdmap[k]),f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			if(!p_getc(&(m->sidewarpindex),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_igetw(&(m->undercombo),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->undercset),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_igetw(&(m->catchall),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->flags),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->flags2),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->flags3),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->flags4),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->flags5),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_igetw(&(m->noreset),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_igetw(&(m->nocarry),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->flags6),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->flags7),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->flags8),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->flags9),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->flags10),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->csensitive),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->oceansfx),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->bosssfx),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->secretsfx),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->holdupsfx),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			for(int k=0; k<6; k++)
			{
			if(!p_getc(&(m->layermap[k]),f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			for(int k=0; k<6; k++)
			{
			if(!p_getc(&(m->layerscreen[k]),f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			for(int k=0; k<6; k++)
			{
			if(!p_getc(&(m->layeropacity[k]),f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			if(!p_igetw(&(m->timedwarptics),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->nextmap),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->nextscr),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			for(int k=0; k<128; k++)
			{
			if(!p_igetw(&(m->secretcombo[k]),f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			for(int k=0; k<128; k++)
			{
			if(!p_getc(&(m->secretcset[k]),f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			for(int k=0; k<128; k++)
			{
			if(!p_getc(&(m->secretflag[k]),f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			for(int k=0; k<(ZCMaps[i].tileWidth)*(ZCMaps[i].tileHeight); k++)
			{
			try
			{
				if(!p_igetw(&(m->data.at(k)),f,true))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
			}
			catch(std::out_of_range& )
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			for(int k=0; k<(ZCMaps[i].tileWidth)*(ZCMaps[i].tileHeight); k++)
			{
			try
			{
				if(!p_getc(&(m->sflag.at(k)),f,true))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
			}
			catch(std::out_of_range& )
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			for(int k=0; k<(ZCMaps[i].tileWidth)*(ZCMaps[i].tileHeight); k++)
			{
			try
			{
				if(!p_getc(&(m->cset.at(k)),f,true))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
			}
			catch(std::out_of_range& )
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			}
			
			if(!p_igetw(&(m->screen_midi),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_getc(&(m->lens_layer),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if(!p_igetl(&(m->numff),f,true))
			{
			Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			for(int k=0; k<32; k++)
			{
			
				if(!p_igetw(&(m->ffdata[k]),f,true))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_getc(&(m->ffcset[k]),f,true))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetw(&(m->ffdelay[k]),f,true))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetl(&(m->ffx[k]),f,true))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetl(&(m->ffy[k]),f,true))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetl(&(m->ffxdelta[k]),f,true))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetl(&(m->ffydelta[k]),f,true))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetl(&(m->ffxdelta2[k]),f,true))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetl(&(m->ffydelta2[k]),f,true))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_getc(&(m->fflink[k]),f,true))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_getc(&(m->ffwidth[k]),f,true))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_getc(&(m->ffheight[k]),f,true))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetl(&(m->ffflags[k]),f,true))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetw(&(m->ffscript[k]),f,true))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetl(&(m->initd[k][0]),f,true))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetl(&(m->initd[k][1]),f,true))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetl(&(m->initd[k][2]),f,true))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetl(&(m->initd[k][3]),f,true))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetl(&(m->initd[k][4]),f,true))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetl(&(m->initd[k][5]),f,true))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetl(&(m->initd[k][6]),f,true))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
				
				if(!p_igetl(&(m->initd[k][7]),f,true))
				{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
				}
			
			}
			
			for ( int q = 0; q < 10; q++ ) 
			{
			if(!p_igetl(&(m->npcstrings[q]),f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			} 
			}
			for ( int q = 0; q < 10; q++ ) 
			{
			if(!p_igetw(&(m->new_items[q]),f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			} 
			}
			for ( int q = 0; q < 10; q++ ) 
			{
			if(!p_igetw(&(m->new_item_x[q]),f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			} 
			}
			for ( int q = 0; q < 10; q++ ) 
			{
			if(!p_igetw(&(m->new_item_y[q]),f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			} 
			}
			if(!p_igetw(&(m->script),f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			} 
			for ( int q = 0; q < 8; q++ )
			{
			if(!p_igetl(&(m->screeninitd[q]),f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			} 
				
			}
			if(!p_getc(&(m->preloadscript),f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}
			
			if ( vers_id >= 2 )
			{
			if(!p_getc(&(m->hidelayers),f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}  
			if(!p_getc(&(m->hidescriptlayers),f,true))
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE\n"); return;
			}    
				
			}
			
			
		}//end mapscr all for loop
		
	}
}
/*
void FFScript::write_maps(PACKFILE *f, int vers_id)
{
		for(int i=0; i<map_count && i<MAXMAPS2; i++)
		{
		for(int j=0; j<MAPSCRS; j++)
		{
			if ( !(FFCore.write_mapscreen(f,i,j,vers_id)) )
			{
				Z_scripterrlog("do_savegamestructs FAILED to write MAPSCR NODE: %d",i*j);
			}
		}
		}
}

void FFScript::read_maps(PACKFILE *f, int vers_id)
{
		for(int i=0; i<map_count && i<MAXMAPS2; i++)
		{
		for(int j=0; j<MAPSCRS; j++)
		{
			if ( !(FFCore.read_mapscreen(f,i,j,vers_id)) )
			{
				Z_scripterrlog("do_savegamestructs FAILED to read MAPSCR NODE: %d",i*j);
			}
		}
		}
}
*/


int FFScript::getLinkOTile(long index1, long index2)
{
	{
		linkspritetype lst = (linkspritetype)index1;
		int dir = index2;
		int the_ret = 0;
		switch(lst)
		{
			case LSprwalkspr: the_ret = walkspr[dir][0];
			case LSprstabspr: the_ret = stabspr[dir][0];
			case LSprslashspr: the_ret = slashspr[dir][0];
			case LSprfloatspr: the_ret = floatspr[dir][0];
			case LSprswimspr: the_ret = swimspr[dir][0];
			case LSprdivespr: the_ret = divespr[dir][0];
			case LSprdrownspr: the_ret = drowningspr[dir][0];
			case LSprpoundspr: the_ret = poundspr[dir][0];
			case LSprjumpspr: the_ret = jumpspr[dir][0];
			case LSprchargespr: the_ret = chargespr[dir][0];
			case LSprcastingspr: the_ret = castingspr[0];
			case LSprholdspr1: the_ret = holdspr[0][0][0];
			case LSprholdspr2:  the_ret = holdspr[0][1][0];
			case LSprholdsprw1: the_ret = holdspr[1][0][0];
			case LSprholdsprw2: the_ret = holdspr[1][1][0];
			default: the_ret = 0;
		}
	
	return the_ret*10000;
	}
}

defWpnSprite FFScript::getDefWeaponSprite(int wpnid)
{
	switch(wpnid)
	{
		case wNone: return ws_0;
		case wSword: return ws_0;
		case wBeam: return wsBeam;
		case wBrang : return wsBrang;
		case wBomb: return wsBomb;
		case wSBomb: return wsSBomb;
		case wLitBomb: return wsBombblast;
		case wLitSBomb: return wsBombblast;
		case wArrow: return wsArrow;
		case wFire: return wsFire;
		case wWhistle: return wsUnused45;
		case wBait: return wsBait;
		case wWand: return wsWandHandle;
		case wMagic: return wsMagic;
		case wCatching: return wsUnused45;
		case wWind: return wsWind;
		case wRefMagic: return wsRefMagic;
		case wRefFireball: return wsRefFireball;
		case wRefRock: return wsRock;
		case wHammer: return wsHammer;
		case wHookshot: return wsHookshotHead;
		case wHSHandle: return wsHookshotHandle;
		case wHSChain: return wsHookshotChainH;
		case wSSparkle: return wsSilverSparkle;
		case wFSparkle: return wsGoldSparkle;
		case wSmack: return wsHammerSmack;
		case wPhantom: return wsUnused45;
		case wCByrna: return wsByrnaCane;
		case wRefBeam: return wsRefBeam;
		case wStomp: return wsUnused45;
		case lwMax: return wsUnused45;
		case wScript1: 
		case wScript2:
		case wScript3:
		case wScript4:
		case wScript5:
		case wScript6:
		case wScript7:
		case wScript8:
		case wScript9:
		case wScript10: return ws_0;
		case wIce: return wsIce; //new
		case wFlame: return wsEFire2; //new
		//not implemented; t/b/a
		case wSound:
		case wThrowRock: 
		case wPot:
		case wLit:
		case wBombos:
		case wEther:
		case wQuake:
		case wSword180:
		case wSwordLA:  return wsUnused45;
	
		case ewFireball: return wsFireball2;
		case ewArrow: return wsEArrow;
		case ewBrang: return wsBrang;
		case ewSword: return wsEBeam;
		case ewRock: return wsRock;
		case ewMagic: return wsEMagic;
		case ewBomb: return wsEBomb;
		case ewSBomb: return wsESbomb;
		case ewLitBomb: return wsEBombblast;
		case ewLitSBomb: return wsESbombblast;
		case ewFireTrail: return wsEFiretrail;
		case ewFlame: return wsEFire;
		case ewWind: return wsEWind;
		case ewFlame2: return wsEFire2;
		case ewFlame2Trail: return wsEFiretrail2;
		case ewIce: return wsIce;
		case ewFireball2: return wsFireball2;
		default: return wsUnused45;
	}
};


int FFScript::getEnemyByScriptUID(int sUID)
{
	
	for(word i = 0; i < guys.Count(); i++)
		{
			enemy *w = (enemy*)guys.spr(i);
			if ( w ->script_UID == sUID ) return i;
		}
	return -1;
}

int FFScript::getLWeaponByScriptUID(int sUID)
{
	
	for(word i = 0; i < Lwpns.Count(); i++)
		{
			weapon *w = (weapon*)Lwpns.spr(i);
			if ( w ->script_UID == sUID ) return i;
		}
	return -1;
}

int FFScript::getEWeaponByScriptUID(int sUID)
{
	
	for(word i = 0; i < Ewpns.Count(); i++)
		{
			weapon *w = (weapon*)Ewpns.spr(i);
			if ( w ->script_UID == sUID ) return i;
		}
	return -1;
}


void FFScript::do_loadlweapon_by_script_uid(const bool v)
{
	long sUID = SH::get_arg(sarg1, v); //literal, not div by 10000

	int indx = FFCore.getLWeaponByScriptUID(sUID);
	if ( indx > -1 ) 
		ri->lwpn = Lwpns.spr(indx)->getUID();
	else
		Z_scripterrlog("There is no valid LWeapon associated with UID (%) at this time.\nThe UID is stale, or invalid.\n", sUID);
}

void FFScript::do_loadeweapon_by_script_uid(const bool v)
{
	
	long sUID = SH::get_arg(sarg1, v); //literal, not div by 10000

	int indx = FFCore.getEWeaponByScriptUID(sUID);
	if ( indx > -1 ) 
		ri->ewpn = Lwpns.spr(indx)->getUID();
	else
		Z_scripterrlog("There is no valid EWeapon associated with UID (%) at this time.\nThe UID is stale, or invalid.\n", sUID);
}


void FFScript::do_loadnpc_by_script_uid(const bool v)
{
	
	long sUID = SH::get_arg(sarg1, v); //literal, not div by 10000

	int indx = FFCore.getEnemyByScriptUID(sUID);
	if ( indx > -1 ) 
		ri->guyref = guys.spr(indx)->getUID();
	else
		Z_scripterrlog("There is no valid NPC associated with UID (%) at this time.\nThe UID is stale, or invalid.\n", sUID);
}

//Combo Scripts

void FFScript::init_combo_doscript()
{
	clear_combo_refinfo();
	for(int q = 0; q < 7*176; ++q )
	{
		combo_doscript[q] = 1;
	}
}
void FFScript::clear_combo_refinfo()
{
	for ( int q = 0; q < 1232; q++ )
		comboScriptData[q].Clear();
}

void FFScript::clear_combo_refinfo(int pos)
{
	comboScriptData[pos].Clear();
}

void FFScript::clear_combo_stacks()
{
	for ( int q = 0; q < 1232; q++ )
		memset(combo_stack[q], 0, sizeof(combo_stack[q]));
}
void FFScript::clear_combo_stack(int q)
{
	memset(combo_stack[q], 0, sizeof(combo_stack[q]));
}

void FFScript::clear_combo_initialised()
{
	memset(combo_initialised, 0, sizeof(combo_initialised));
}

int FFScript::getComboDataLayer(int c, int scripttype)
{
	if ( scripttype != SCRIPT_COMBO )
	{
		Z_scripterrlog("combodata->Layer() only runs from combo scripts, not from script type &s\n", scripttypenames[scripttype]);
		return -1;
	}
	else
	{
		int l = 0;
		for (int q = 176; q < 1232; q+= 176 )
		{
			if ( c < q )
			{
				return l;
			}
			++l;
		}
		return -1;
	}
}

int FFScript::getCombodataPos(int c, int scripttype)
{
	if ( scripttype != SCRIPT_COMBO )
	{
		Z_scripterrlog("combodata->YPos() only runs from combo scripts, not from script type &s\n", scripttypenames[scripttype]);
		return -1;
	}
	else return ((c%176));
}

int FFScript::getCombodataX(int c, int scripttype)
{
	if ( scripttype != SCRIPT_COMBO )
	{
		Z_scripterrlog("combodata->X() only runs from combo scripts, not from script type &s\n", scripttypenames[scripttype]);
		return -1;
	}
	else
	{
		int pos = getCombodataPos(c, scripttype);
		return COMBOX(pos);
	}
}

int FFScript::getCombodataY(int c, int scripttype)
{
	if ( scripttype != SCRIPT_COMBO )
	{
		Z_scripterrlog("combodata->Y() only runs from combo scripts, not from script type &s\n", scripttypenames[scripttype]);
		return -1;
	}
	else
	{
		int pos = getCombodataPos(c, scripttype);
		return COMBOY(pos);
	}
}

//Clear stacks and refinfo in LOADSCR
void FFScript::ClearComboScripts()
{
	for ( int c = 0; c < 176; c++ )
	{
		combo_doscript[c] = 0;
		combo_waitdraw[c] = 0;
		combo_initialised[c] = 0;
		for ( int l = 0; l < 7; l++)
		{
			if ( get_bit(quest_rules, qr_COMBOSCRIPTS_LAYER_0+l) )
			{
				comboscript_combo_ids[c+(176*l)] = 0;
				comboScriptData[c+(176*l)].Clear();
				for ( int r = 0; r < MAX_SCRIPT_REGISTERS; ++r )
				{
					combo_stack[c+(176*l)][r] = 0; //clear the stacks
				}
			}
		}
	}
}

int FFScript::combo_script_engine(const bool preload)
{
	
	///non-scripted effects
	
	for ( int q = 0; q < 7; ++q )
	{
		for ( int c = 0; c < 176; ++c )
		{
			int ls = (q ? tmpscr->layerscreen[q-1] : 0);
			int lm = (q ? tmpscr->layermap[q-1] : 0);
			if(q && !lm) continue; //No layer for this screen
			mapscr* m = FFCore.tempScreens[q]; //get templayer mapscr for any layer (including 0)
			int cid = m->data[c];
			int type = combobuf[cid].type;
			if ( type == cTRIGGERGENERIC )
			{
				//run local trigger effects
				if ( combobuf[cid].usrflags&cflag13 ) //spawn an item on room entry
				{
					//need a way to set a bit as to not do this again, similar to screengrid
				}
				if ( combobuf[cid].usrflags&cflag14 ) //spawn an item on room entry
				{
					//need a way to set a bit as to not do this again, similar to screengrid
				}
			}
			
			if (!get_bit(quest_rules, qr_COMBOSCRIPTS_LAYER_0+q)) { continue;}
			if ( combobuf[cid].script )
			{
				if ( (combo_doscript[c]) )
				{
					comboscript_combo_ids[c+(176*q)] = cid;
					ZScriptVersion::RunScript(SCRIPT_COMBO, combobuf[m->data[c]].script, c+176*q);
				}
			}
		}
	}

	
	return 1;
}


//Config for file->

/*         ______   ___    ___
 *        /\  _  \ /\_ \  /\_ \ 
 *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
 *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
 *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
 *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
 *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
 *                                           /\____/
 *                                           \_/__/
 *
 *      Ported from Allegro 4.4.3.1 Configuration routines.
 *
 *      By Shawn Hargreaves; C++ Port by ZoriaRPG
 *
 *      Hook functions added by Martijn Versteegh.
 *
 *      Annie Testes lifted several hardcoded length limitations.
 *
 *      See readme.txt for copyright information.
 */


#include "allegro.h"
#include "allegro/internal/aintern.h"





/* zscript_flush_config:
 *  Writes out a config structure to disk if the contents
 *  have changed.
 */
void zscript_flush_config(ZSCRIPT_CONFIG *cfg)
{
	ZSCRIPT_CONFIG_ENTRY *pos;
	PACKFILE *f;
	char cr[16];

	usetc(cr+usetc(cr, '\n'), 0);

	if (cfg && cfg->filename && cfg->dirty) 
	{
		/* write changed data to disk */
		f = pack_fopen(cfg->filename, F_WRITE);
	
		if (f) 
		{
			pos = cfg->head;

			while (pos) 
			{
				if (pos->name) 
				{
					pack_fputs(pos->name, f);

					if (ugetc(pos->name) != '[') 
					{
						pack_putc(' ', f);
						pack_putc('=', f);
						pack_putc(' ', f);
					}
				}

				if (pos->data)
					pack_fputs(pos->data, f);

				pack_fputs(cr, f);

				pos = pos->next;
			}

			pack_fclose(f);
			cfg->dirty = FALSE;
		}
	}
}



/* zscript_flush_config_file:
 *  Writes out the config file to disk if the contents
 *  have changed.
 */
void zscript_flush_config_file(void)
{
	zscript_flush_config(config[0]);
}



/* zscript_destroy_config:
 *  Destroys a config structure, writing it out to disk if the contents
 *  have changed.
 */
void zscript_destroy_config(ZSCRIPT_CONFIG *cfg)
{
	ZSCRIPT_CONFIG_ENTRY *pos, *prev;
	
	if (cfg) 
	{
		zscript_flush_config(cfg);

		if (cfg->filename)
			_AL_FREE(cfg->filename);

		/* destroy the variable list */
		pos = cfg->head;

		while (pos) 
		{
			prev = pos;
			pos = pos->next;

			if (prev->name)
				_AL_FREE(prev->name);

			if (prev->data)
				_AL_FREE(prev->data);

			_AL_FREE(prev);
		}

		_AL_FREE(cfg);
	}
}



/* zscript_config_cleanup:
 *  Called at shutdown time to free memory being used by the config routines,
 *  and write any changed data out to disk.
 */
void zscript_config_cleanup(void)
{
	ZSCRIPT_CONFIG_HOOK *hook, *nexthook;
	int i;

	for (i=0; i<MAX_CONFIGS; i++) 
	{
		if (config[i]) 
		{
			zscript_destroy_config(config[i]);
			config[i] = NULL;
		}
	}

	if (config_override) 
	{
		zscript_destroy_config(config_override);
		config_override = NULL;
	}

	if (config_language) 
	{
		zscript_destroy_config(config_language);
		config_language = NULL;
	}

	if (system_config) 
	{
		zscript_destroy_config(system_config);
		system_config = NULL;
	}

	if (config_hook) 
	{
		hook = config_hook;

		while (hook) 
		{
			if (hook->section)
				_AL_FREE(hook->section);

			nexthook = hook->next; 
			_AL_FREE(hook);
			hook = nexthook;
		}

		config_hook = NULL;
	}

	_AL_FREE(config_argv);
	config_argv = NULL;
   
	_AL_FREE(argv_buf);
	argv_buf = NULL;
   
	argv_buf_size = 0;

	_remove_exit_func(zscript_config_cleanup);
	config_installed = FALSE;
}



/* zscript_init_config:
 *  Sets up the configuration routines ready for use, also loading the
 *  default config file if the loaddata flag is set and no other config
 *  file is in memory.
 */
void zscript_init_config(int loaddata)
{
	char filename[1024], tmp[128], *cfg_name;

	if (!config_installed) 
	{
		_add_exit_func(zscript_config_cleanup, "zscript_config_cleanup");
		config_installed = TRUE;
	}

	if ((loaddata) && (!config[0])) 
	{
		cfg_name = uconvert_ascii("allegro.cfg", tmp);

		if (find_allegro_resource(filename, cfg_name, NULL, NULL, NULL, NULL, NULL, sizeof(filename)) != 0) 
		{
			get_executable_name(filename, sizeof(filename));
			usetc(get_filename(filename), 0);
			ustrzcat(filename, sizeof(filename), cfg_name);
		}

		zscript_set_config_file(filename);
	}

	if (!system_config) 
	{
		system_config = (struct ZSCRIPT_CONFIG*)malloc(sizeof(ZSCRIPT_CONFIG));
		if (system_config) 
		{
			system_config->head = NULL;
			system_config->filename = NULL;
			system_config->dirty = FALSE;
		}
	}
}



/* zscript_get_config_line:
 *  Helper for splitting files up into individual lines. Returns the length
 *  in bytes of the sequence of characters delimited by the first EOL marker
 *  in the array DATA of length LENGTH, and allocates NAME and VAL to record
 *  the name and the value of the config entry respectively; otherwise set
 *  NAME to NULL and returns a copy of the line through VAL if the line was
 *  blank or a comment. Returns -1 and set allegro_errno on failure.
 */
int zscript_get_config_line(const char *data, int length, char **name, char **val)
{
	char *buf;
	int buf_size=256;
	int inpos, outpos, i, j;
	int c, c2, w0;

	inpos = 0;
	outpos = 0;
	w0 = ucwidth(0);

	buf = (char*)_AL_MALLOC_ATOMIC(buf_size);
	if (!buf) 
	{
		*allegro_errno = ENOMEM;
		return -1;
	}

	/* search for an EOL marker */
	while (inpos<length) 
	{
		c = ugetc(data+inpos);
		if ((c == '\r') || (c == '\n')) 
		{
			inpos += uwidth(data+inpos);
			if (inpos < length) 
			{
				c2 = ugetc(data+inpos);
				if (((c == '\r') && (c2 == '\n')) || ((c == '\n') && (c2 == '\r')))
					inpos += uwidth(data+inpos);
			}
			break;
		}

		/* increase the buffer size if needed */
		if (outpos>=(int)buf_size-w0) 
		{
			buf_size *= 2;
			buf = (char*)_al_sane_realloc(buf, buf_size);
			if (!buf) 
			{
				*allegro_errno = ENOMEM;
				return -1;
			}
		}

		outpos += usetc(buf+outpos, c);
		inpos += uwidth(data+inpos);
	}

	usetc(buf+outpos, 0);

	/* skip leading spaces */
	i = 0;
	c = ugetc(buf);

	while ((c) && (uisspace(c))) 
	{
		i += uwidth(buf+i);
		c = ugetc(buf+i);
	}

	/* read name string */
	j = 0;

	/* compute name length */
	while ((c) && (!uisspace(c)) && (c != '=') && (c != '#')) 
	{
		j += ucwidth(c);
		i += uwidth(buf+i);
		c = ugetc(buf+i);
	}

	if (j) 
	{
		/* got a variable */
		*name = (char*)_AL_MALLOC_ATOMIC(j+w0);
		if (!(*name)) 
		{
			*allegro_errno = ENOMEM;
			_AL_FREE(buf);
			return -1;
		}

		ustrzcpy(*name, j+w0, buf+i-j);

		while ((c) && ((uisspace(c)) || (c == '='))) 
		{
			i += uwidth(buf+i);
			c = ugetc(buf+i);
		}

		*val = _al_ustrdup(buf+i);
		if (!(*val)) 
		{
			_AL_FREE(name);
			_AL_FREE(buf);
			return -1;
		}

		/* strip trailing spaces */
		i = ustrlen(*val) - 1;
		while ((i >= 0) && (uisspace(ugetat(*val, i))))
			usetat(*val, i--, 0);
	}
	else 
	{
		/* blank line or comment */
		*name = NULL;
		*val = _al_ustrdup(buf);
		if (!(*val)) 
		{
			_AL_FREE(buf);
			return -1;
		}
	}

	_AL_FREE(buf);

	return inpos;
}



/* zscript_set_config:
 *  Does the work of setting up a config structure.
 */
void zscript_set_config(ZSCRIPT_CONFIG **config, const char *data, int length, const char *filename)
{
	ZSCRIPT_CONFIG_ENTRY **prev, *p;
	char *name, *val;
	int ret, pos;

	zscript_init_config(FALSE);

	if (*config) 
	{
		zscript_destroy_config(*config);
		*config = NULL;
	}

	*config = (struct ZSCRIPT_CONFIG*)_AL_MALLOC(sizeof(ZSCRIPT_CONFIG));
	if (!(*config)) 
	{
		*allegro_errno = ENOMEM;
		return;
	}

	(*config)->head = NULL;
	(*config)->dirty = FALSE;

	if (filename) 
	{
		(*config)->filename = _al_ustrdup(filename);
		if (!(*config)->filename) 
		{
			_AL_FREE(*config);
			*config = NULL;
			return;
		}
	}
	else
		(*config)->filename = NULL;

	prev = &(*config)->head;
	pos = 0;

	while (pos < length) 
	{
		ret = zscript_get_config_line(data+pos, length-pos, &name, &val);
		if (ret<0) 
		{
			_AL_FREE(*config);
			*config = NULL;
			return;
		}

		pos += ret;

		p = (struct ZSCRIPT_CONFIG_ENTRY*)_AL_MALLOC(sizeof(ZSCRIPT_CONFIG_ENTRY));
		if (!p) 
		{
			*allegro_errno = ENOMEM;
			_AL_FREE(*config);
			*config = NULL;
			return;
		}

		p->name = name;
		p->data = val;

		p->next = NULL;
		*prev = p;
		prev = &p->next;
	}
}



/* zscript_load_config_file:
 *  Does the work of loading a config file.
 */
void zscript_load_config_file(ZSCRIPT_CONFIG **config, const char *filename, const char *savefile)
{
	char *tmp, *tmp2;
	uint64_t length;

	if (*config) 
	{
		zscript_destroy_config(*config);
		*config = NULL;
	}

	/* Special case when allegro_init has not been called yet. */
	if (!system_driver) 
	{
		zscript_set_config(config, NULL, 0, savefile);
		return;
	}

	length = file_size_ex(filename);

	if (length > 0) 
	{
		PACKFILE *f = pack_fopen(filename, F_READ);

		if (f) 
		{
			tmp = (char*)_AL_MALLOC_ATOMIC(length+1);

			if (tmp) 
			{
				pack_fread(tmp, length, f);
				tmp[length] = 0;

				if (need_uconvert(tmp, U_UTF8, U_CURRENT)) 
				{
					length = uconvert_size(tmp, U_UTF8, U_CURRENT);
					tmp2 = (char*)_AL_MALLOC_ATOMIC(length);

					if (tmp2)
						do_uconvert(tmp, U_UTF8, tmp2, U_CURRENT, length);

					length -= ucwidth(0);
				}
				else
					tmp2 = tmp;

				if (tmp2) 
				{
					zscript_set_config(config, tmp2, length, savefile);

					if (tmp2 != tmp)
					_AL_FREE(tmp2);
				}

				_AL_FREE(tmp);
			}
			else
				zscript_set_config(config, NULL, 0, savefile);

			pack_fclose(f);
		}
		else
			zscript_set_config(config, NULL, 0, savefile);
	}
	else
		zscript_set_config(config, NULL, 0, savefile);
}



/* zscript_set_config_file:
 *  Sets the file to be used for all future configuration operations.
 */
void zscript_set_config_file(const char *filename)
{
	ASSERT(filename);
	zscript_load_config_file(&config[0], filename, filename);
}



/* zscript_set_config_data:
 *  Sets the block of data to be used for all future configuration 
 *  operations.
 */
void zscript_set_config_data(const char *data, int length)
{
	ASSERT(data);
	zscript_set_config(&config[0], data, length, NULL);
}



/* zscript_override_config_file:
 *  Sets the file that will override all future configuration operations.
 */
void zscript_override_config_file(const char *filename)
{
	/* load other configuration file to override settings */
	if (filename)
		zscript_load_config_file(&config_override, filename, filename);
	/* destroy the current one */
	else if (config_override) 
	{
		zscript_destroy_config(config_override);
		config_override = NULL;
	}
}



/* zscript_override_config_data:
 *  Sets the block of data that will override all future configuration 
 *  operations.
 */
void zscript_override_config_data(const char *data, int length)
{
	ASSERT(data);
	zscript_set_config(&config_override, data, length, NULL);
}



/* zscript_push_config_state:
 *  Pushes the current config state onto the stack.
 */
void zscript_push_config_state(void)
{
	int i;

	if (config[MAX_CONFIGS-1])
		zscript_destroy_config(config[MAX_CONFIGS-1]);

	for (i=MAX_CONFIGS-1; i>0; i--)
		config[i] = config[i-1];

	config[0] = NULL;
}



/* zscript_pop_config_state:
 *  Pops the current config state off the stack.
 */
void zscript_pop_config_state(void)
{
	int i;

	if (config[0])
		zscript_destroy_config(config[0]);

	for (i=0; i<MAX_CONFIGS-1; i++)
		config[i] = config[i+1];

	config[MAX_CONFIGS-1] = NULL;
}



/* zscript_prettify_config_section_name:
 *  Helper for ensuring that a section name is enclosed by [ ] braces.
 */
void zscript_prettify_config_section_name(const char *in, char *out, int out_size)
{
	int p;

	if ((in) && (ustrlen(in))) 
	{
		if (ugetc(in) != '[') 
		{
			p = usetc(out, '[');
			usetc(out+p, 0);
		}
		else
			usetc(out, 0);

		ustrzcat(out, out_size - ucwidth(']'), in);

		out += uoffset(out, -1);

		if (ugetc(out) != ']') 
		{
			out += uwidth(out);
			out += usetc(out, ']');
			usetc(out, 0);
		}
	}
	else
		usetc(out, 0);
}



/* zscript_hook_config_section:
 *  Hooks a config section to a set of getter/setter functions. This will 
 *  override the normal table of values, and give the provider of the hooks 
 *  complete control over that section.
 */
void zscript_hook_config_section(const char *section, int (*intgetter)(const char *, int), const char *(*stringgetter)(const char *, const char *), void (*stringsetter)(const char *, const char *))
{
	ZSCRIPT_CONFIG_HOOK *hook, **prev;
	char section_name[256];

	zscript_init_config(FALSE);
	
	zscript_prettify_config_section_name(section, section_name, sizeof(section_name));

	hook = config_hook;
	prev = &config_hook;

	while (hook) 
	{
		if (ustricmp(section_name, hook->section) == 0) 
		{
			if ((intgetter) || (stringgetter) || (stringsetter)) 
			{
				/* modify existing hook */
				hook->intgetter = intgetter;
				hook->stringgetter = stringgetter;
				hook->stringsetter = stringsetter;
			}
			else 
			{
				/* remove a hook */
				*prev = hook->next;
				_AL_FREE(hook->section);
			}

			return;
		}

		prev = &hook->next;
		hook = hook->next;
	}

	/* add a new hook */
	hook = (struct ZSCRIPT_CONFIG_HOOK*)_AL_MALLOC(sizeof(ZSCRIPT_CONFIG_HOOK));
	if (!hook)
	return;

	hook->section = _al_ustrdup(section_name);
	if (!(hook->section)) 
	{
		_AL_FREE(hook);
		return;
	}

	hook->intgetter = intgetter;
	hook->stringgetter = stringgetter;
	hook->stringsetter = stringsetter;

	hook->next = config_hook;
	config_hook = hook;
}



/* is_config_hooked:
 *  Checks whether a specific section is hooked in any way.
 */
int zscript_config_is_hooked(const char *section)
{
	ZSCRIPT_CONFIG_HOOK *hook = config_hook;
	char section_name[256];

	zscript_prettify_config_section_name(section, section_name, sizeof(section_name));

	while (hook) 
	{
		if (ustricmp(section_name, hook->section) == 0)
			return TRUE;

		hook = hook->next;
	}

	return FALSE;
}



/* zscript_find_config_string:
 *  Helper for finding an entry in the configuration file.
 */
ZSCRIPT_CONFIG_ENTRY *zscript_find_config_string(ZSCRIPT_CONFIG *config, const char *section, const char *name, ZSCRIPT_CONFIG_ENTRY **prev)
{
	ZSCRIPT_CONFIG_ENTRY *p;
	int in_section;

	if (config) 
	{
		p = config->head;

		if (prev)
			*prev = NULL;

		if (section && ugetc(section))
			in_section = FALSE;
		else
			in_section = TRUE;

		while (p) 
		{
			if (p->name) 
			{
				if ((section) && (ugetc(p->name) == '[') && (ugetat(p->name, -1) == ']')) 
				{
					/* change section */
					in_section = (ustricmp(section, p->name) == 0);
				}
				if ((in_section) || (ugetc(name) == '[')) 
				{
					/* is this the one? */
					if (ustricmp(p->name, name) == 0)
						return p;
				}
			}

			if (prev)
				*prev = p;

			p = p->next;
		}
	}

	return NULL;
}



/* zscript_get_config_string:
 *  Reads a string from the configuration file.
 */
const char *zscript_get_config_string(const char *section, const char *name, const char *def)
{
	char section_name[256];
	ZSCRIPT_CONFIG_HOOK *hook;
	ZSCRIPT_CONFIG_ENTRY *p;

	zscript_init_config(TRUE);

	zscript_prettify_config_section_name(section, section_name, sizeof(section_name));

	/* check for hooked sections */
	hook = config_hook;

	while (hook) 
	{
		if (ustricmp(section_name, hook->section) == 0) 
		{
			if (hook->stringgetter)
				return hook->stringgetter(name, def);
			else
				return def;
		}
		hook = hook->next;
	}

	/* find the string */
	p = zscript_find_config_string(config_override, section_name, name, NULL);

	if (!p) 
	{
		if ((ugetc(name) == '#') || ((ugetc(section_name) == '[') && (ugetat(section_name, 1) == '#')))
			p = zscript_find_config_string(system_config, section_name, name, NULL);
		else
			p = zscript_find_config_string(config[0], section_name, name, NULL);
	}

	if (p && p->data && (ustrlen(p->data) != 0))
		return p->data;
	else
		return def;
}



/* zscript_get_config_int:
 *  Reads an integer from the configuration file.
 */
int zscript_get_config_int(const char *section, const char *name, int def)
{
	ZSCRIPT_CONFIG_HOOK *hook;
	char section_name[256];
	const char *s;

	zscript_prettify_config_section_name(section, section_name, sizeof(section_name));

	/* check for hooked sections */
	hook = config_hook;

	while (hook) 
	{
		if (ustricmp(section_name, hook->section) == 0) 
		{
			if (hook->intgetter) 
			{
				return hook->intgetter(name, def);
			}
			else if (hook->stringgetter) 
			{
				s = hook->stringgetter(name, NULL);
				if ((s) && (ugetc(s)))
					return ustrtol(s, NULL, 0);
				else
					return def;
			}
			else
				return def;
		}
		hook = hook->next;
	}

	/* read normal data */
	s = zscript_get_config_string(section_name, name, NULL);

	if ((s) && (ugetc(s)))
		return ustrtol(s, NULL, 0);

	return def;
}



/* zscript_get_config_hex:
 *  Reads a hexadecimal integer from the configuration file.
 */
int zscript_get_config_hex(const char *section, const char *name, int def)
{
	const char *s = zscript_get_config_string(section, name, NULL);
	char tmp[64];
	int i;

	if ((s) && (ugetc(s))) 
	{
		i = ustrtol(s, NULL, 16);
		if ((i == 0x7FFFFFFF) && (ustricmp(s, uconvert_ascii("7FFFFFFF", tmp)) != 0))
			i = -1;
		return i;
	}

	return def;
}



/* zscript_get_config_float:
 *  Reads a float from the configuration file.
 */
float zscript_get_config_float(const char *section, const char *name, float def)
{
	const char* s = zscript_get_config_string(section, name, NULL);

	if ((s) && (ugetc(s)))
		return uatof(s);

	return def;
}



/* zscript_get_config_id:
 *  Reads a driver ID number from the configuration file.
 */
int zscript_get_config_id(const char *section, const char *name, int def)
{
	const char *s = zscript_get_config_string(section, name, NULL);
	char tmp[4];
	char* endp;
	int val, i;

	if ((s) && (ugetc(s))) 
	{
		val = ustrtol(s, &endp, 0);
		if (!ugetc(endp))
			return val;

		tmp[0] = tmp[1] = tmp[2] = tmp[3] = ' ';

		for (i=0; i<4; i++) 
		{
			if (ugetat(s, i))
				tmp[i] = utoupper(ugetat(s ,i));
			else
				break;
		}

		return AL_ID(tmp[0], tmp[1], tmp[2], tmp[3]);
	}

	return def;
}



/* zscript_get_config_argv:
 *  Reads an argc/argv style token list from the configuration file.
 */
char **zscript_get_config_argv(const char *section, const char *name, int *argc)
{
	int pos, ac, q, c;
	int s_size;
	int i;

	const char *s = zscript_get_config_string(section, name, NULL);

	if (!s) 
	{
		*argc = 0;
		return NULL;
	}

	/* clean up the old argv that was allocated the last time this function was
	* called.
	*/
	_AL_FREE(config_argv);
	config_argv = NULL;

	/* increase the buffer size if needed */
	s_size = ustrsizez(s);
	if (s_size>argv_buf_size) 
	{
		argv_buf_size = s_size;
		argv_buf = (char*)_al_sane_realloc(argv_buf, argv_buf_size);
		if (!argv_buf) 
		{
			*allegro_errno = ENOMEM;
			*argc = 0;
			return NULL;
		}
	}

	ustrzcpy(argv_buf, argv_buf_size, s);
	pos = 0;
	ac = 0;

	/* tokenize the buffer and count the number of words; every space character
	* as well as single and double quotes are replaced with zeros; comments * that start with # are also cut off with a 0
	*/
	c = ugetc(argv_buf);
	while ((c) && (c != '#')) 
	{
		/* replace all spaces up to the next word with 0 */
		while ((c) && (uisspace(c))) 
		{
			usetat(argv_buf+pos, 0, 0);
			pos += ucwidth(0);
			c = ugetc(argv_buf+pos);
		}

		/* quit if we reached the end of the buffer or a comment */
		if ((c) && (c != '#')) 
		{
			/* found another word! */
			ac++;

			/* cut away quotes by replacing them with 0 */
			if ((c == '\'') || (c == '"')) 
			{
				q = c;
				usetat(argv_buf+pos, 0, 0);
				pos += ucwidth(0);
				c = ugetc(argv_buf+pos);
			}
			else 
			{
				q = 0;
			}
	
			/* search for the end of the word */
			while ((c) && ((q) ? (c != q) : (!uisspace(c)))) 
			{
				pos += ucwidth(c);
				c = ugetc(argv_buf+pos);
			}
		}
	}

	/* now that we know how many words there are in the buffer, allocate enough
	* space for a list of pointers to them, or return 0 if there are no words
	*/
	if (ac > 0) 
	{
		config_argv = (char**)_AL_MALLOC(ac*sizeof *config_argv);
	}
	else 
	{
		*argc = 0;
		return NULL;
	}

	/* go through the tokenized buffer and assign pointers in argv to point to
	* the beginning of each individual word
	*/
	for (i=0,pos=0,c=ugetc(argv_buf); i<ac; i++) 
	{
		/* find next word */
		while (!c) 
		{
			pos += ucwidth(c);
			c = ugetc(argv_buf+pos);
		}

		/* assign pointer */
		config_argv[i] = argv_buf+pos;

		/* find end of the word */
		while (c) 
		{
			pos += ucwidth(c);
			c = ugetc(argv_buf+pos);
		}
	}

	*argc = ac;
	return config_argv;
}



/* zscript_insert_config_variable:
 *  Helper for inserting a new variable into a configuration file.
 */
ZSCRIPT_CONFIG_ENTRY *zscript_insert_config_variable(ZSCRIPT_CONFIG *the_config, ZSCRIPT_CONFIG_ENTRY *p, const char *name, const char *data)
{
	ZSCRIPT_CONFIG_ENTRY *n = (struct ZSCRIPT_CONFIG_ENTRY*)_AL_MALLOC(sizeof(ZSCRIPT_CONFIG_ENTRY));

	if (!n)
		return NULL;

	if (name)
		n->name = _al_ustrdup(name);
	else
		n->name = NULL;

	if (data)
		n->data = _al_ustrdup(data);
	else
		n->data = NULL;

	if (p) 
	{
		n->next = p->next;
		p->next = n; 
	}
	else 
	{
		n->next = NULL;
		the_config->head = n;
	}

	return n;
}



/* zscript_set_config_string:
 *  Writes a string to the configuration file.
 */
void zscript_set_config_string(const char *section, const char *name, const char *val)
{
	ZSCRIPT_CONFIG *the_config;
	ZSCRIPT_CONFIG_HOOK *hook;
	ZSCRIPT_CONFIG_ENTRY *p, *prev;
	char section_name[256];

	zscript_init_config(TRUE);

	zscript_prettify_config_section_name(section, section_name, sizeof(section_name));

	/* check for hooked sections */
	hook = config_hook;

	while (hook) 
	{
		if (ustricmp(section_name, hook->section) == 0) 
		{
			if (hook->stringsetter)
			hook->stringsetter(name, val);
			return;
		}
		hook = hook->next;
	}

	/* decide which config file to use */
	if ((ugetc(name) == '#') || ((ugetc(section_name) == '[') && (ugetat(section_name, 1) == '#')))
		the_config = system_config;
	else if (config_override)
		the_config = config_override;
	else
		the_config = config[0];

	if (the_config) 
	{
		p = zscript_find_config_string(the_config, section_name, name, &prev);

		if (p) 
		{
			if ((val) && (ugetc(val))) 
			{
				/* modify existing variable */
				if (p->data)
				_AL_FREE(p->data);

				p->data = _al_ustrdup(val);
			}
			else 
			{
				/* delete variable */
				if (p->name)
					_AL_FREE(p->name);
		
				if (p->data)
					_AL_FREE(p->data);

				if (prev)
					prev->next = p->next;
				else
					the_config->head = p->next;

				_AL_FREE(p);
			}
		}
		else 
		{
			if ((val) && (ugetc(val))) 
			{
				/* add a new variable */
				if (ugetc(section_name)) 
				{
					p = zscript_find_config_string(the_config, NULL, section_name, &prev);

					if (!p) 
					{
						/* create a new section */
						p = the_config->head;
						while ((p) && (p->next))
							p = p->next;

						if ((p) && (p->data) && (ugetc(p->data)))
							p = zscript_insert_config_variable(the_config, p, NULL, NULL);

						p = zscript_insert_config_variable(the_config, p, section_name, NULL);
					}

					/* append to the end of the section */
					while ((p) && (p->next) && 
						(((p->next->name) && (ugetc(p->next->name))) || 
						((p->next->data) && (ugetc(p->next->data)))))
					{
						p = p->next;
					}

					p = zscript_insert_config_variable(the_config, p, name, val);
				}
				else 
				{
					/* global variable */
					p = the_config->head;
					zscript_insert_config_variable(the_config, NULL, name, val);
					the_config->head->next = p;
				}
			} 
		}

		the_config->dirty = TRUE;
	}
}



/* zscript_set_config_int:
 *  Writes an integer to the configuration file.
 */
void zscript_set_config_int(const char *section, const char *name, int val)
{
	char buf[32], tmp[32];
	uszprintf(buf, sizeof(buf), uconvert_ascii("%d", tmp), val);
	zscript_set_config_string(section, name, buf);
}



/* zscript_set_config_hex:
 *  Writes a hexadecimal integer to the configuration file.
 */
void zscript_set_config_hex(const char *section, const char *name, int val)
{
	char buf[32], tmp[32];

	if (val >= 0) 
	{
		uszprintf(buf, sizeof(buf), uconvert_ascii("%X", tmp), val);
		zscript_set_config_string(section, name, buf);
	}
	else
		zscript_set_config_string(section, name, uconvert_ascii("-1", buf));
}



/* zscript_set_config_float:
 *  Writes a float to the configuration file.
 */
void zscript_set_config_float(const char *section, const char *name, float val)
{
	char buf[32], tmp[32];
	uszprintf(buf, sizeof(buf), uconvert_ascii("%f", tmp), val);
	zscript_set_config_string(section, name, buf);
}



/* zscript_set_config_id:
 *  Writes a driver ID to the configuration file.
 */
void zscript_set_config_id(const char *section, const char *name, int val)
{
	char buf[32], tmp[32];
	int v[4];
	int pos = 0;
	int i;

	if (val < 256) 
	{
		uszprintf(buf, sizeof(buf), uconvert_ascii("%d", tmp), val);
	}
	else 
	{
		v[0] = (val>>24)&0xFF;
		v[1] = (val>>16)&0xFF;
		v[2] = (val>>8)&0xFF;
		v[3] = val&0xFF;
	
		for (i=0; (i<4) && (v[i]) && (v[i] != ' '); i++)
			pos += usetc(buf+pos, v[i]);

		usetc(buf+pos, 0);
	}

	zscript_set_config_string(section, name, buf);
}



/* _zscript_reload_config:
 *  Internal helper to reload the configuration from allegro_init, in case
 *  zscript_set_config_file was called before allegro_init.
 */
void _zscript_reload_config(void)
{
	if (config[0]) 
	{
		char *name = _al_ustrdup(config[0]->filename);
		zscript_set_config_file(name);
		_AL_FREE(name);
	}
}



/* zscript_reload_config_texts:
 *  Reads in a block of translated system text, looking for either a
 *  user-specified file, a ??text.cfg file, or a language.dat#??TEXT_CFG 
 *  datafile object. If new_language is not NULL, the language config
 *  variable will be set to new_language before reloading the
 *  configuration files.
 */
void zscript_reload_config_texts(const char *new_language)
{
	char filename[1024], tmp1[128], tmp2[128];
	const char *name, *ext, *datafile;
	char *namecpy;

	if (config_language) 
	{
		zscript_destroy_config(config_language);
		config_language = NULL;
	}

	if (new_language)
		zscript_set_config_string("system", "language", new_language);

	name = zscript_get_config_string(uconvert_ascii("system", tmp1), uconvert_ascii("language", tmp2), NULL);

	if ((name) && (ugetc(name))) 
	{
		namecpy = _al_ustrdup(name);
		ustrlwr (namecpy);
		if ((ustrlen(namecpy)<4) || (ustricmp(namecpy+uoffset(namecpy, -4), uconvert_ascii("text", tmp1)) != 0))
			ext = uconvert_ascii("text.cfg", tmp1);
		else
			ext = uconvert_ascii(".cfg", tmp1);

		datafile = uconvert_ascii("language.dat", tmp2);

		if (find_allegro_resource(filename, namecpy, ext, datafile, NULL, NULL, NULL, sizeof(filename)) == 0) 
		{
			_AL_FREE(namecpy);
			zscript_load_config_file(&config_language, filename, NULL);
			return;
		}

		_AL_FREE(namecpy);
	}

	config_language = (struct ZSCRIPT_CONFIG*)_AL_MALLOC(sizeof(ZSCRIPT_CONFIG));
	if (config_language ) 
	{
		config_language ->head = NULL;
		config_language ->filename = NULL;
		config_language ->dirty = FALSE;
	}
}



/* zscript_get_config_text:
 *  Looks up a translated version of the specified English string,
 *  returning a suitable message in the current language if one is
 *  available, or a copy of the parameter if no translation can be found.
 */
const char *zscript_get_config_text(const char *msg)
{
	char tmp1[256];
	const char *section;
	const char *umsg;
	const char *s;
	const char *ret = NULL;
	char *name;
	ZSCRIPT_CONFIG_HOOK *hook;
	ZSCRIPT_CONFIG_ENTRY *p;
	int c, pos, size;
	ASSERT(msg);

	/* Hack: the inline definition of install_allegro() from 4.2.0 calls
	* zscript_get_config_text() even before Allegro has been initialised, leading
	* to a crash in get_executable_name().  To retain binary compatibility
	* we check for this case.
	*/
	if (_allegro_count == 0) 
	{
		return msg;
	}

	zscript_init_config(TRUE);

	section = uconvert_ascii("[language]", tmp1);

	/* allocate memory and convert message to current encoding format */
	if (need_uconvert(msg, U_ASCII, U_CURRENT)) 
	{
		size = uconvert_size(msg, U_ASCII, U_CURRENT);
		umsg = (char*)_AL_MALLOC_ATOMIC(size);
		if (!umsg) 
		{
			*allegro_errno = ENOMEM;
			return empty_string;
		}

		name = (char*)_AL_MALLOC_ATOMIC(size);
		if (!name) 
		{
			_AL_FREE((char *)umsg);  /* remove constness */
			*allegro_errno = ENOMEM;
			return empty_string;
		}

		do_uconvert(msg, U_ASCII, (char*)umsg, U_CURRENT, size);
	}
	else 
	{
		umsg = msg;
		name = (char*)_AL_MALLOC_ATOMIC(ustrsizez(msg));
		if (!name) 
		{
			*allegro_errno = ENOMEM;
			return empty_string;
		}
	}

	s = umsg;
	pos = 0;

	while ((c = ugetxc(&s)) != 0) 
	{
		if ((uisspace(c)) || (c == '=') || (c == '#'))
			pos += usetc(name+pos, '_');
		else
			pos += usetc(name+pos, c);
	}

	usetc(name+pos, 0);

	/* check for hooked sections */
	hook = config_hook;

	while (hook) 
	{
		if (ustricmp(section, hook->section) == 0) 
		{
			if (hook->stringgetter) 
			{
				ret = hook->stringgetter(name, umsg);
				break;
			}
		}

		hook = hook->next;
	}

	if (!ret) 
	{
		/* find the string */
		p = zscript_find_config_string(config_override, section, name, NULL);

		if (!p) 
		{
			p = zscript_find_config_string(config[0], section, name, NULL);

			if (!p)
				p = zscript_find_config_string(config_language, section, name, NULL);
		}

		if (p) 
		{
			ret = (p->data ? p->data : empty_string);
		}
		else 
		{
			/* no translation, so store off this value in the file */
			p = config_language->head;
			zscript_insert_config_variable(config_language, NULL, name, umsg);
			config_language->head->next = p;
			ret = config_language->head->data;
		}
	}

	/* free memory */
	if (umsg!=msg)
		_AL_FREE((char*) umsg);  /* remove constness */

	_AL_FREE(name);

	return ret;
}



/* zscript_add_unique_config_name
 *  Helper to add a name to a list of names.
 */
int zscript_add_unique_config_name(const char ***names, int n, char const *name)
{
	int i;
	/* FIXME: use better search algorithm */
	for (i = 0; i < n; i++)
		if (!ustrcmp((*names)[i], name))
	return n;

	*names = (const char**)_al_sane_realloc((void *)*names, (n + 1) * sizeof **names);
	(*names)[n] = name;
	return n + 1;
}



/* zscript_attach_config_entries
 *  Helper function to attach key or section names to a list of strings.
 */
int zscript_attach_config_entries(ZSCRIPT_CONFIG *conf, const char *section, int n, const char ***names, int list_sections)
{
	ZSCRIPT_CONFIG_ENTRY *p;
	char section_name[256];
	int in_section;

	zscript_prettify_config_section_name(section, section_name, sizeof(section_name));

	if (conf) 
	{
		p = conf->head;
	
		/* If section is NULL, only initial, section-less entries are used. */
		if (ugetc(section_name))
			in_section = FALSE;
		else
			in_section = TRUE;

		while (p) 
		{
			if (p->name) 
			{
				/* a section start is just a list entry enclosed in [] */
				if (ugetc(p->name) == '[' && ugetat(p->name, -1) == ']') 
				{
					if (list_sections) 
					{
						n = zscript_add_unique_config_name(names, n, p->name);
					}
					in_section = (ustricmp(section_name, p->name) == 0);
				}
				else if (in_section && !list_sections) 
				{
					n = zscript_add_unique_config_name(names, n, p->name);
				}
			}
			p = p->next;
		}
	}
	return n;
}



/* list_config_entires:
 *  Returns the names of all config entries in a section. The names parameter is
 *  a pointer to a strings array that will contain the config keys. If it points to
 *  a NULL pointer, it will be allocated, or else re-allocated accordingly. The
 *  return value tells how many valid string pointers it contains after the
 *  function returns.
 */
int zscript_list_config_entries(const char *section, const char ***names)
{
	int n = 0;
	n = zscript_attach_config_entries(config_override, section, n, names, 0);
	n = zscript_attach_config_entries(config[0], section, n, names, 0);
	return n;
}



/* zscript_list_config_sections:
 *  Returns the names of all current config sections, enclodes in []. The names
 *  parameter and return value is like in list_config_entires above.
 */
int zscript_list_config_sections(const char ***names)
{
	int n = 0;
	n = zscript_attach_config_entries(config_override, NULL, n, names, 1);
	n = zscript_attach_config_entries(config[0], NULL, n, names, 1);
	return n;
}



/* zscript_free_config_entries:
 *  Frees the entries list returned by list_config_entires or
 *  zscript_list_config_sections again.
 */
void zscript_free_config_entries(const char ***names)
{
	_AL_FREE(*names);
	*names = NULL;
}
